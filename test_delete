-- DROP SCHEMA transactions;

CREATE SCHEMA transactions AUTHORIZATION cmotswrite;

-- DROP SEQUENCE transactions.arn_logentry_logid_seq;

CREATE SEQUENCE transactions.arn_logentry_logid_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.arn_logentry_logid_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.arn_logentry_logid_seq TO cmotswrite;

-- DROP SEQUENCE transactions.auto_leadstatus_reject_id_seq;

CREATE SEQUENCE transactions.auto_leadstatus_reject_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.auto_leadstatus_reject_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.auto_leadstatus_reject_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.bank_id_seq;

CREATE SEQUENCE transactions.bank_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.bank_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.bank_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.communication_log_details_srno_seq;

CREATE SEQUENCE transactions.communication_log_details_srno_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.communication_log_details_srno_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.communication_log_details_srno_seq TO cmotswrite;

-- DROP SEQUENCE transactions.communication_mailer_mapper_id_seq;

CREATE SEQUENCE transactions.communication_mailer_mapper_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.communication_mailer_mapper_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.communication_mailer_mapper_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.communication_mailer_mst_comid_seq;

CREATE SEQUENCE transactions.communication_mailer_mst_comid_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.communication_mailer_mst_comid_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.communication_mailer_mst_comid_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_bookmark_history_bookmark_id_seq;

CREATE SEQUENCE transactions.mf_bookmark_history_bookmark_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_bookmark_history_bookmark_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_bookmark_history_bookmark_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_client_holdings_external_id_seq;

CREATE SEQUENCE transactions.mf_client_holdings_external_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_client_holdings_external_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_client_holdings_external_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_due_dates_id_seq;

CREATE SEQUENCE transactions.mf_due_dates_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_due_dates_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_due_dates_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_mandate_error_id_seq;

CREATE SEQUENCE transactions.mf_mandate_error_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_mandate_error_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_mandate_error_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_mandate_history_hist_id_seq;

CREATE SEQUENCE transactions.mf_mandate_history_hist_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_mandate_history_hist_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_mandate_history_hist_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_mandate_id_seq;

CREATE SEQUENCE transactions.mf_mandate_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_mandate_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_mandate_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_order_detail_history_trx_history_id_seq;

CREATE SEQUENCE transactions.mf_order_detail_history_trx_history_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_order_detail_history_trx_history_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_order_detail_history_trx_history_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_order_detail_modification_trx_id_seq;

CREATE SEQUENCE transactions.mf_order_detail_modification_trx_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_order_detail_modification_trx_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_order_detail_modification_trx_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_order_detail_trx_id_seq;

CREATE SEQUENCE transactions.mf_order_detail_trx_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_order_detail_trx_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_order_detail_trx_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_order_summary_history_history_id_seq;

CREATE SEQUENCE transactions.mf_order_summary_history_history_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_order_summary_history_history_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_order_summary_history_history_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_order_summary_id_seq;

CREATE SEQUENCE transactions.mf_order_summary_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_order_summary_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_order_summary_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_subsequent_order_error_id_seq;

CREATE SEQUENCE transactions.mf_subsequent_order_error_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_subsequent_order_error_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_subsequent_order_error_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_subsequent_order_id_seq;

CREATE SEQUENCE transactions.mf_subsequent_order_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_subsequent_order_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_subsequent_order_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_sync_history_id_seq;

CREATE SEQUENCE transactions.mf_sync_history_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_sync_history_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_sync_history_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_sync_history_log_id_seq;

CREATE SEQUENCE transactions.mf_sync_history_log_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_sync_history_log_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_sync_history_log_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.mf_viewed_history_viewed_id_seq;

CREATE SEQUENCE transactions.mf_viewed_history_viewed_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.mf_viewed_history_viewed_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.mf_viewed_history_viewed_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.order_consent_id_seq;

CREATE SEQUENCE transactions.order_consent_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.order_consent_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.order_consent_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.otp_otp_id_seq;

CREATE SEQUENCE transactions.otp_otp_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.otp_otp_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.otp_otp_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.otp_verification_otp_id_seq;

CREATE SEQUENCE transactions.otp_verification_otp_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.otp_verification_otp_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.otp_verification_otp_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.stg_mf_mandate_id_seq;

CREATE SEQUENCE transactions.stg_mf_mandate_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.stg_mf_mandate_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.stg_mf_mandate_id_seq TO cmotswrite;

-- DROP SEQUENCE transactions.stg_mf_order_detail_id_seq;

CREATE SEQUENCE transactions.stg_mf_order_detail_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE transactions.stg_mf_order_detail_id_seq OWNER TO cmotswrite;
GRANT ALL ON SEQUENCE transactions.stg_mf_order_detail_id_seq TO cmotswrite;
-- transactions.arn_logentry definition

-- Drop table

-- DROP TABLE transactions.arn_logentry;

CREATE TABLE transactions.arn_logentry ( logid serial4 NOT NULL, methodname varchar NULL, errormsg varchar NULL, paylod json NULL, CONSTRAINT arn_logentry_pkey PRIMARY KEY (logid));

-- Permissions

ALTER TABLE transactions.arn_logentry OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.arn_logentry TO cmotswrite;


-- transactions.auto_leadstatus_reject definition

-- Drop table

-- DROP TABLE transactions.auto_leadstatus_reject;

CREATE TABLE transactions.auto_leadstatus_reject ( id bigserial NOT NULL, trx_id int8 NULL, insertdtm timestamp DEFAULT CURRENT_TIMESTAMP NULL, is_picked bool DEFAULT false NULL, CONSTRAINT id_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE transactions.auto_leadstatus_reject OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.auto_leadstatus_reject TO cmotswrite;
GRANT SELECT ON TABLE transactions.auto_leadstatus_reject TO cmotsread;


-- transactions.bank definition

-- Drop table

-- DROP TABLE transactions.bank;

CREATE TABLE transactions.bank ( id serial4 NOT NULL, bankcode varchar NOT NULL, bankname varchar NOT NULL, payinurl varchar NOT NULL, payouturl varchar NULL, active bool NULL, createddate timestamp DEFAULT now() NULL, banknamevariation varchar NULL, atombankcode varchar NULL, atombankname varchar NULL, upi bool DEFAULT false NULL, pgallowed bool DEFAULT false NOT NULL, modifiedby varchar NULL, verifyurl varchar NULL, pgallowedmode int4 NULL, razorpaybankcode varchar NULL, defaultpgallowedmode int4 NULL, upiintent bool NULL, upiqr bool DEFAULT false NULL, app varchar NULL, reqtype varchar NULL, seg varchar NULL, mfbankcode varchar NULL, settlementbanktype varchar NULL, jpbankcode varchar NULL, logo_url varchar NULL, icon_url varchar NULL, CONSTRAINT bank_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE transactions.bank OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.bank TO cmotswrite;
GRANT SELECT ON TABLE transactions.bank TO cmotsread;


-- transactions.bank_mf definition

-- Drop table

-- DROP TABLE transactions.bank_mf;

CREATE TABLE transactions.bank_mf ( bankcode varchar NULL, bankname varchar NULL, seg varchar NULL);

-- Permissions

ALTER TABLE transactions.bank_mf OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.bank_mf TO cmotswrite;


-- transactions.bank_pmr definition

-- Drop table

-- DROP TABLE transactions.bank_pmr;

CREATE TABLE transactions.bank_pmr ( id int4 NULL, bankcode varchar NULL, bankname varchar NULL, payinurl varchar NULL, payouturl varchar NULL, active bool NULL, createddate timestamp NULL, banknamevariation varchar NULL, atombankcode varchar NULL, atombankname varchar NULL, upi bool NULL, pgallowed bool NULL, modifiedby varchar NULL, verifyurl varchar NULL, pgallowedmode int4 NULL, razorpaybankcode varchar NULL, defaultpgallowedmode int4 NULL, upiintent bool NULL, upiqr bool NULL, app varchar NULL, reqtype varchar NULL, seg varchar NULL, mfbankcode varchar NULL, settlementbanktype varchar NULL, jpbankcode varchar NULL, logo_url varchar NULL, icon_url varchar NULL);

-- Permissions

ALTER TABLE transactions.bank_pmr OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.bank_pmr TO cmotswrite;


-- transactions.client_exception definition

-- Drop table

-- DROP TABLE transactions.client_exception;

CREATE TABLE transactions.client_exception ( client_code varchar NOT NULL, product varchar NULL, CONSTRAINT client_pkey PRIMARY KEY (client_code));

-- Permissions

ALTER TABLE transactions.client_exception OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.client_exception TO cmotswrite;
GRANT SELECT ON TABLE transactions.client_exception TO cmotsread;


-- transactions.client_exception_physical_flag definition

-- Drop table

-- DROP TABLE transactions.client_exception_physical_flag;

CREATE TABLE transactions.client_exception_physical_flag ( client_code varchar NOT NULL, CONSTRAINT client_physical_pkey PRIMARY KEY (client_code));

-- Permissions

ALTER TABLE transactions.client_exception_physical_flag OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.client_exception_physical_flag TO cmotswrite;
GRANT SELECT ON TABLE transactions.client_exception_physical_flag TO cmotsread;


-- transactions.communication_log_details definition

-- Drop table

-- DROP TABLE transactions.communication_log_details;

CREATE TABLE transactions.communication_log_details ( srno serial4 NOT NULL, templateid int4 NULL, txn_type varchar NULL, trigger_point varchar NULL, trx_id int8 NULL, ac_code varchar NULL, is_sent int4 NULL, whatsappid varchar NULL, template_placeholders varchar NULL, values_placeholder varchar NULL, insert_date timestamp NULL, modified_date timestamp NULL, is_picked bool DEFAULT false NULL, comm_mode varchar NULL, categoryid int4 NULL, sent_communication varchar NULL);

-- Permissions

ALTER TABLE transactions.communication_log_details OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.communication_log_details TO cmotswrite;


-- transactions.communication_mailer_mapper definition

-- Drop table

-- DROP TABLE transactions.communication_mailer_mapper;

CREATE TABLE transactions.communication_mailer_mapper ( id bigserial NOT NULL, subcategory_id int4 NULL, template_placeholder varchar NULL, mapping_field_name varchar NULL, is_active int4 NULL, insertdtm timestamp DEFAULT CURRENT_TIMESTAMP NULL);

-- Permissions

ALTER TABLE transactions.communication_mailer_mapper OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.communication_mailer_mapper TO cmotswrite;


-- transactions.communication_mailer_mst definition

-- Drop table

-- DROP TABLE transactions.communication_mailer_mst;

CREATE TABLE transactions.communication_mailer_mst ( comid bigserial NOT NULL, producttype varchar NULL, ordertype varchar NULL, inv_type varchar NULL, trx_id int8 NULL, vendor_trx_id varchar NULL, orderid varchar NULL, clientcode varchar NULL, clientname varchar NULL, orderdate varchar NULL, transaction_mode varchar NULL, fundname varchar NULL, amount varchar NULL, units varchar NULL, rejection_reason varchar NULL, next_due_date varchar NULL, sip_start_date varchar NULL, sip_end_date varchar NULL, frequency varchar NULL, installment_number varchar NULL, bankname varchar NULL, bankacno varchar NULL, sourceid varchar NULL, subcategoryid varchar NULL, subcategory varchar NULL, insertdtm timestamp DEFAULT CURRENT_TIMESTAMP NULL, is_picked bool NULL, mandateid varchar NULL, mandate_mode varchar NULL, tot_inv_amt varchar NULL, no_of_installment varchar NULL, count_installment_pause varchar NULL, fundname_switch varchar NULL, rm_email varchar NULL, rm_mobile varchar NULL, modify_order_type varchar NULL, rm_name varchar NULL, reflink varchar NULL, emp_code varchar NULL, partner_code varchar NULL);

-- Permissions

ALTER TABLE transactions.communication_mailer_mst OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.communication_mailer_mst TO cmotswrite;


-- transactions.communication_mailer_mst_bkp definition

-- Drop table

-- DROP TABLE transactions.communication_mailer_mst_bkp;

CREATE TABLE transactions.communication_mailer_mst_bkp ( comid int8 NULL, producttype varchar NULL, ordertype varchar NULL, inv_type varchar NULL, trx_id int8 NULL, vendor_trx_id varchar NULL, orderid varchar NULL, clientcode varchar NULL, clientname varchar NULL, orderdate varchar NULL, transaction_mode varchar NULL, fundname varchar NULL, amount varchar NULL, units varchar NULL, rejection_reason varchar NULL, next_due_date varchar NULL, sip_start_date varchar NULL, sip_end_date varchar NULL, frequency varchar NULL, installment_number varchar NULL, bankname varchar NULL, bankacno varchar NULL, sourceid varchar NULL, subcategoryid varchar NULL, subcategory varchar NULL, insertdtm timestamp NULL, is_picked bool NULL, mandateid varchar NULL, mandate_mode varchar NULL, tot_inv_amt varchar NULL, no_of_installment varchar NULL, count_installment_pause varchar NULL, fundname_switch varchar NULL, rm_email varchar NULL, rm_mobile varchar NULL, modify_order_type varchar NULL, rm_name varchar NULL);

-- Permissions

ALTER TABLE transactions.communication_mailer_mst_bkp OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.communication_mailer_mst_bkp TO cmotswrite;


-- transactions.communication_mailer_mst_bkp_02june2025 definition

-- Drop table

-- DROP TABLE transactions.communication_mailer_mst_bkp_02june2025;

CREATE TABLE transactions.communication_mailer_mst_bkp_02june2025 ( comid int8 NULL, producttype varchar NULL, ordertype varchar NULL, inv_type varchar NULL, trx_id int8 NULL, vendor_trx_id varchar NULL, orderid varchar NULL, clientcode varchar NULL, clientname varchar NULL, orderdate varchar NULL, transaction_mode varchar NULL, fundname varchar NULL, amount varchar NULL, units varchar NULL, rejection_reason varchar NULL, next_due_date varchar NULL, sip_start_date varchar NULL, sip_end_date varchar NULL, frequency varchar NULL, installment_number varchar NULL, bankname varchar NULL, bankacno varchar NULL, sourceid varchar NULL, subcategoryid varchar NULL, subcategory varchar NULL, insertdtm timestamp NULL, is_picked bool NULL, mandateid varchar NULL, mandate_mode varchar NULL, tot_inv_amt varchar NULL, no_of_installment varchar NULL, count_installment_pause varchar NULL, fundname_switch varchar NULL, rm_email varchar NULL, rm_mobile varchar NULL, modify_order_type varchar NULL, rm_name varchar NULL, reflink varchar NULL);

-- Permissions

ALTER TABLE transactions.communication_mailer_mst_bkp_02june2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.communication_mailer_mst_bkp_02june2025 TO cmotswrite;


-- transactions.mf_bank_transaction_paymentstatus definition

-- Drop table

-- DROP TABLE transactions.mf_bank_transaction_paymentstatus;

CREATE TABLE transactions.mf_bank_transaction_paymentstatus ( nuvama_refno varchar NULL, mforderid int8 NULL, createddate timestamp NOT NULL, mfcallbackreq varchar NULL, paymenttrxid varchar NULL, clientcode varchar NULL, bankstatus varchar NULL, amount float8 NULL, refreshdate timestamp NULL);

-- Permissions

ALTER TABLE transactions.mf_bank_transaction_paymentstatus OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_bank_transaction_paymentstatus TO cmotswrite;


-- transactions.mf_bookmark_history definition

-- Drop table

-- DROP TABLE transactions.mf_bookmark_history;

CREATE TABLE transactions.mf_bookmark_history ( bookmark_id bigserial NOT NULL, login_code varchar NULL, mf_schcode int8 NULL, created_date timestamp DEFAULT CURRENT_TIMESTAMP NULL, CONSTRAINT mf_bookmark_history_pkey PRIMARY KEY (bookmark_id));

-- Permissions

ALTER TABLE transactions.mf_bookmark_history OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_bookmark_history TO cmotswrite;
GRANT SELECT ON TABLE transactions.mf_bookmark_history TO cmotsread;


-- transactions.mf_client_holdings_external definition

-- Drop table

-- DROP TABLE transactions.mf_client_holdings_external;

CREATE TABLE transactions.mf_client_holdings_external ( id serial4 NOT NULL, sync_history_id int4 NULL, pan varchar NULL, ucccode varchar NULL, mobileno varchar NULL, amcname varchar NULL, folio varchar NULL, schemecode varchar NULL, schemename varchar NULL, schemeoption varchar NULL, assetype varchar NULL, schemetype varchar NULL, nav numeric(18, 4) NULL, navdate date NULL, closingbalance numeric(18, 4) NULL, avlunits numeric(18, 4) NULL, avlamt numeric(18, 2) NULL, currentmarketvalue numeric(18, 2) NULL, costvalue numeric(18, 2) NULL, gainloss numeric(18, 2) NULL, gainlosspercentage int4 NULL, isin varchar NULL, decimalunits int4 NULL, decimalamt int4 NULL, decimalnav int4 NULL, isdemat varchar NULL, planmode varchar NULL, nomineestatus varchar NULL, brokercode varchar NULL, brokername varchar NULL, rtaname varchar NULL, isexternal bool NULL, created_date timestamp NULL, sync_status varchar NULL, arn_transfer_status varchar NULL, updated_date timestamp NULL, modified_date timestamp NULL);

-- Permissions

ALTER TABLE transactions.mf_client_holdings_external OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_client_holdings_external TO cmotswrite;
GRANT SELECT ON TABLE transactions.mf_client_holdings_external TO cmotsread;


-- transactions.mf_clientholding_bsemforder definition

-- Drop table

-- DROP TABLE transactions.mf_clientholding_bsemforder;

CREATE TABLE transactions.mf_clientholding_bsemforder ( holdingdate date NULL, accountcode varchar(12) NULL, dpid varchar(8000) NULL, isincode varchar(15) NULL, schemename varchar(15) NULL, totalqty numeric(20, 3) NULL, freeqty numeric(20, 3) NULL, defaultdp varchar(8000) NULL, refresh_date timestamp DEFAULT now() NULL);
CREATE INDEX idx_mf_bsemforder_accountcode ON transactions.mf_clientholding_bsemforder USING btree (accountcode);
CREATE INDEX idx_mf_bsemforder_isincode ON transactions.mf_clientholding_bsemforder USING btree (isincode);

-- Permissions

ALTER TABLE transactions.mf_clientholding_bsemforder OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_clientholding_bsemforder TO cmotswrite;


-- transactions.mf_due_dates definition

-- Drop table

-- DROP TABLE transactions.mf_due_dates;

CREATE TABLE transactions.mf_due_dates ( id bigserial NOT NULL, ac_code varchar NULL, vendor_trx_id int8 NOT NULL, reg_no int8 NULL, reg_date date NULL, upcoming_due_date date NULL, previous_paid_date date NULL, totalinstallmentamt_paid numeric(24, 6) NULL, mandate_id varchar NULL, created_date timestamp NULL, totalinstallment_paid int4 NULL, modified_date timestamp NULL, CONSTRAINT mf_due_dates_pk PRIMARY KEY (vendor_trx_id));

-- Permissions

ALTER TABLE transactions.mf_due_dates OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_due_dates TO cmotswrite WITH GRANT OPTION;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_due_dates TO appadmin;
GRANT SELECT ON TABLE transactions.mf_due_dates TO cmotsread WITH GRANT OPTION;


-- transactions.mf_due_dates_error definition

-- Drop table

-- DROP TABLE transactions.mf_due_dates_error;

CREATE TABLE transactions.mf_due_dates_error ( ac_code varchar NULL, vendor_trx_id int8 NOT NULL, reg_no int8 NULL, reg_date date NULL, upcoming_due_date date NULL, previous_paid_date date NULL, totalinstallmentamt_paid numeric(24, 6) NULL, mandate_id varchar NULL, created_date timestamp NULL, totalinstallment_paid int4 NULL, error_message varchar NULL, error_date timestamp DEFAULT now() NULL, CONSTRAINT mf_due_dates_error_pkey PRIMARY KEY (vendor_trx_id));

-- Permissions

ALTER TABLE transactions.mf_due_dates_error OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_due_dates_error TO cmotswrite WITH GRANT OPTION;
GRANT SELECT ON TABLE transactions.mf_due_dates_error TO cmotsread WITH GRANT OPTION;


-- transactions.mf_holding definition

-- Drop table

-- DROP TABLE transactions.mf_holding;

CREATE TABLE transactions.mf_holding ( folionumber varchar(50) NULL, holdingdate date NULL, schemename varchar(500) NULL, isin varchar(50) NULL, investorname varchar(200) NULL, accountcode varchar(200) NULL, ucc varchar(50) NULL, quantity float8 NULL, longtermquantity float8 NULL, shorttermquantity float8 NULL, foliotype varchar(50) NULL, folioemail varchar(100) NULL, foliomobile varchar(50) NULL, investorpan varchar(500) NULL, jointholder1pan varchar(500) NULL, jointholder2pan varchar(500) NULL, guardianpan varchar(500) NULL, ucccode varchar NULL);
CREATE INDEX idx_accode_isin ON transactions.mf_holding USING btree (accountcode, isin);

-- Permissions

ALTER TABLE transactions.mf_holding OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_holding TO cmotswrite;


-- transactions.mf_holdings definition

-- Drop table

-- DROP TABLE transactions.mf_holdings;

CREATE TABLE transactions.mf_holdings ( holdingdate timestamp NULL, ucccode varchar(20) NULL, isincode varchar(20) NULL, holding_qty numeric(15, 4) NULL, holding_amt numeric(15, 4) NULL, unrealisedpl numeric(15, 4) NULL, longtermquantity numeric(15, 4) NULL, shorttermquantity numeric(15, 4) NULL, refresh_date timestamp DEFAULT CURRENT_TIMESTAMP NULL);

-- Permissions

ALTER TABLE transactions.mf_holdings OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_holdings TO cmotswrite;
GRANT SELECT ON TABLE transactions.mf_holdings TO cmotsread;


-- transactions.mf_mandate definition

-- Drop table

-- DROP TABLE transactions.mf_mandate;

CREATE TABLE transactions.mf_mandate ( id serial4 NOT NULL, mandateid varchar NOT NULL, ac_code varchar(20) NULL, amount numeric(18, 2) NULL, bankname varchar(100) NULL, mandate_type bpchar(1) NULL, status varchar(50) NULL, created_date timestamp NULL, modified_date timestamp NULL, bank_ac_number varchar(50) NULL, ifsc_code varchar(11) NULL, start_date date NULL, end_date date NULL, trx_source varchar NULL, ucccode varchar NULL, acname varchar NULL, client_owner varchar(200) NULL, upccode varchar(200) NULL, partner_code varchar(200) NULL, remarks varchar NULL, CONSTRAINT mandateid_pk PRIMARY KEY (mandateid), CONSTRAINT unique_mandateid_bankno UNIQUE (mandateid, bank_ac_number));
CREATE INDEX idx_mandate_ucccode ON transactions.mf_mandate USING btree (ucccode);

-- Permissions

ALTER TABLE transactions.mf_mandate OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_mandate TO cmotswrite;


-- transactions.mf_mandate_error definition

-- Drop table

-- DROP TABLE transactions.mf_mandate_error;

CREATE TABLE transactions.mf_mandate_error ( id serial4 NOT NULL, mandateid varchar NOT NULL, ac_code varchar(20) NULL, amount numeric(18, 2) NULL, bankname varchar(100) NULL, mandate_type bpchar(1) NULL, status varchar(50) NULL, created_date timestamp NULL, modified_date timestamp NULL, bank_ac_number varchar(50) NULL, ifsc_code varchar(11) NULL, start_date date NULL, end_date date NULL, trx_source varchar NULL, ucccode varchar NULL, error_message varchar NULL, acname varchar NULL, client_owner varchar NULL, partner_code varchar NULL, upccode varchar NULL, inserted_dt timestamp DEFAULT now() NULL, CONSTRAINT pk_mandateid PRIMARY KEY (mandateid));

-- Permissions

ALTER TABLE transactions.mf_mandate_error OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_mandate_error TO cmotswrite;


-- transactions.mf_mandate_history definition

-- Drop table

-- DROP TABLE transactions.mf_mandate_history;

CREATE TABLE transactions.mf_mandate_history ( hist_id serial4 NOT NULL, mandateid varchar NOT NULL, ucccode varchar NULL, ac_code varchar(20) NULL, mandate_type bpchar(1) NULL, status varchar(50) NULL, remarks varchar NULL, start_date date NULL, end_date date NULL, created_date timestamp NULL, modified_date timestamp NULL, insertdtm timestamp DEFAULT CURRENT_TIMESTAMP NULL);

-- Permissions

ALTER TABLE transactions.mf_mandate_history OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_mandate_history TO cmotswrite WITH GRANT OPTION;
GRANT SELECT ON TABLE transactions.mf_mandate_history TO cmotsread WITH GRANT OPTION;


-- transactions.mf_mandate_optimum definition

-- Drop table

-- DROP TABLE transactions.mf_mandate_optimum;

CREATE TABLE transactions.mf_mandate_optimum ( id int4 NULL, mandateid varchar NULL, ac_code varchar(20) NULL, amount numeric(18, 2) NULL, bankname varchar(100) NULL, mandate_type bpchar(1) NULL, status varchar(50) NULL, created_date timestamp NULL, modified_date timestamp NULL, bank_ac_number varchar(50) NULL, ifsc_code varchar(11) NULL, start_date date NULL, end_date date NULL, trx_source varchar NULL, ucccode varchar NULL, acname varchar NULL, client_owner varchar(200) NULL, upccode varchar(200) NULL, partner_code varchar(200) NULL, remarks varchar NULL);

-- Permissions

ALTER TABLE transactions.mf_mandate_optimum OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_mandate_optimum TO cmotswrite;


-- transactions.mf_missingid definition

-- Drop table

-- DROP TABLE transactions.mf_missingid;

CREATE TABLE transactions.mf_missingid ( txnid int8 NULL);

-- Permissions

ALTER TABLE transactions.mf_missingid OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_missingid TO cmotswrite;


-- transactions.mf_order_detail definition

-- Drop table

-- DROP TABLE transactions.mf_order_detail;

CREATE TABLE transactions.mf_order_detail ( trx_id bigserial NOT NULL, display_trx_id varchar NULL, vendor_trx_id int8 NULL, ucccode varchar(20) NULL, ac_code varchar(20) NULL, user_id varchar NULL, isincode varchar(20) NULL, isinname varchar NULL, trx_datetime timestamp NULL, mf_schcode int8 NULL, schemegroup varchar NULL, return_type varchar NULL, trx_type_code int4 NULL, trx_type varchar(20) NULL, consent_status_code int4 NULL, consent_status varchar NULL, trx_status_code int4 NULL, trx_status varchar(20) NULL, vendor_trx_status varchar NULL, payment_status_code int4 NULL, payment_status varchar(20) NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, inv_type_code int4 NULL, inv_type varchar NULL, inv_action_code int4 NULL, inv_action varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, rejection_reason_code int4 NULL, consent_approval_reject_datetime timestamp NULL, trx_amt numeric(15, 4) NULL, trx_qty numeric(15, 4) NULL, delivery_mode varchar(10) NULL, physicalflag varchar(5) NULL, mandate_id varchar NULL, trx_source varchar(20) NULL, nav numeric(15, 4) NULL, navdate date NULL, order_nav numeric(15, 4) NULL, order_navdate date NULL, folio_no varchar(20) NULL, order_type varchar(50) NULL, order_remarks varchar NULL, tokenno int8 NULL, vendor_exchg_refno varchar(30) NULL, euinnumber varchar(30) NULL, orderby varchar NULL, rm_partner_code varchar NULL, qty_or_amt_order varchar(1) NULL, payment_trxid varchar(20) NULL, payment_method varchar NULL, bank_code varchar NULL, bank_name varchar NULL, bank_ac_number varchar NULL, payment_remarks varchar NULL, pan varchar NULL, vendor_req varchar NULL, vendor_res varchar NULL, order_placed_by varchar NULL, trx_retry_count int4 DEFAULT 0 NULL, lead_id varchar NULL, is_generatetoday bool NULL, switch_mf_schcode int8 NULL, switchtokenno int8 NULL, switch_isin varchar(20) NULL, switch_grpcode varchar NULL, internal_flag int4 DEFAULT 0 NULL, sent_to_vendor_datetime timestamp NULL, created_date timestamp NULL, modified_date timestamp NULL, modified_by varchar NULL, datasource varchar NULL, mobileno varchar NULL, email varchar NULL, natureoforder varchar NULL, created_for varchar NULL, sub_broker_code varchar NULL, sub_broker_name varchar NULL, arn_code varchar NULL, sub_broker_pass_pct numeric NULL, vendor_paymentstatus varchar NULL, cheque_number varchar NULL, cheque_date date NULL, created_for_name varchar NULL, created_for_type varchar NULL, bank_ifsc varchar(20) NULL, bank_branch varchar(100) NULL, cheque_amt numeric(15, 4) NULL, exchange_bank varchar(100) NULL, collectionentry_groupid varchar(50) NULL, collectionentry_remarks varchar(500) NULL, deposit_challanno varchar(50) NULL, deposit_challanremarks varchar(500) NULL, CONSTRAINT mf_transactions_pkey PRIMARY KEY (trx_id));
CREATE INDEX idx_created_date ON transactions.mf_order_detail USING btree (created_date);
CREATE INDEX idx_isincode ON transactions.mf_order_detail USING btree (isincode);
CREATE INDEX idx_mf_schcode ON transactions.mf_order_detail USING btree (mf_schcode);
CREATE INDEX idx_natureoforder ON transactions.mf_order_detail USING btree (natureoforder);
CREATE INDEX idx_order_placed_by ON transactions.mf_order_detail USING btree (order_placed_by);
CREATE INDEX idx_remarks ON transactions.mf_order_detail USING btree (order_remarks);
CREATE INDEX idx_rm_partner_code ON transactions.mf_order_detail USING btree (rm_partner_code);
CREATE INDEX idx_trx_id ON transactions.mf_order_detail USING btree (trx_id);
CREATE INDEX idx_vendor_trx_id ON transactions.mf_order_detail USING btree (vendor_trx_id);

-- Permissions

ALTER TABLE transactions.mf_order_detail OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_detail TO cmotswrite;


-- transactions.mf_order_detail_bkp_19july2025 definition

-- Drop table

-- DROP TABLE transactions.mf_order_detail_bkp_19july2025;

CREATE TABLE transactions.mf_order_detail_bkp_19july2025 ( trx_id int8 NULL, display_trx_id varchar NULL, vendor_trx_id int8 NULL, ucccode varchar(20) NULL, ac_code varchar(20) NULL, user_id varchar NULL, isincode varchar(20) NULL, isinname varchar NULL, trx_datetime timestamp NULL, mf_schcode int8 NULL, schemegroup varchar NULL, return_type varchar NULL, trx_type_code int4 NULL, trx_type varchar(20) NULL, consent_status_code int4 NULL, consent_status varchar NULL, trx_status_code int4 NULL, trx_status varchar(20) NULL, vendor_trx_status varchar NULL, payment_status_code int4 NULL, payment_status varchar(20) NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, inv_type_code int4 NULL, inv_type varchar NULL, inv_action_code int4 NULL, inv_action varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, rejection_reason_code int4 NULL, consent_approval_reject_datetime timestamp NULL, trx_amt numeric(15, 4) NULL, trx_qty numeric(15, 4) NULL, delivery_mode varchar(10) NULL, physicalflag varchar(5) NULL, mandate_id varchar NULL, trx_source varchar(20) NULL, nav numeric(15, 4) NULL, navdate date NULL, order_nav numeric(15, 4) NULL, order_navdate date NULL, folio_no varchar(20) NULL, order_type varchar(50) NULL, order_remarks varchar NULL, tokenno int8 NULL, vendor_exchg_refno varchar(30) NULL, euinnumber varchar(30) NULL, orderby varchar NULL, rm_partner_code varchar NULL, qty_or_amt_order varchar(1) NULL, payment_trxid varchar(20) NULL, payment_method varchar NULL, bank_code varchar NULL, bank_name varchar NULL, bank_ac_number varchar NULL, payment_remarks varchar NULL, pan varchar NULL, vendor_req varchar NULL, vendor_res varchar NULL, order_placed_by varchar NULL, trx_retry_count int4 NULL, lead_id varchar NULL, is_generatetoday bool NULL, switch_mf_schcode int8 NULL, switchtokenno int8 NULL, switch_isin varchar(20) NULL, switch_grpcode varchar NULL, internal_flag int4 NULL, sent_to_vendor_datetime timestamp NULL, created_date timestamp NULL, modified_date timestamp NULL, modified_by varchar NULL, datasource varchar NULL, mobileno varchar NULL, email varchar NULL, natureoforder varchar NULL, created_for varchar NULL, sub_broker_code varchar NULL, sub_broker_name varchar NULL, arn_code varchar NULL, sub_broker_pass_pct numeric NULL, vendor_paymentstatus varchar NULL, cheque_number varchar NULL, cheque_date date NULL);

-- Permissions

ALTER TABLE transactions.mf_order_detail_bkp_19july2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_detail_bkp_19july2025 TO cmotswrite;


-- transactions.mf_order_detail_error definition

-- Drop table

-- DROP TABLE transactions.mf_order_detail_error;

CREATE TABLE transactions.mf_order_detail_error ( trx_id int4 NULL, display_trx_id varchar NULL, vendor_trx_id int8 NOT NULL, ucccode varchar(20) NULL, ac_code varchar(20) NULL, user_id varchar NULL, isincode varchar(20) NULL, isinname varchar NULL, trx_datetime timestamp NULL, mf_schcode int8 NULL, schemegroup varchar NULL, return_type varchar NULL, trx_type_code int4 NULL, trx_type varchar(20) NULL, consent_status_code int4 NULL, consent_status varchar NULL, trx_status_code int4 NULL, trx_status varchar(20) NULL, vendor_trx_status varchar NULL, payment_status_code int4 NULL, payment_status varchar(20) NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, inv_type_code int4 NULL, inv_type varchar NULL, inv_action_code int4 NULL, inv_action varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, rejection_reason_code int4 NULL, consent_approval_reject_datetime timestamp NULL, trx_amt numeric(15, 4) NULL, trx_qty numeric(15, 4) NULL, delivery_mode varchar(10) NULL, physicalflag varchar(5) NULL, mandate_id varchar NULL, trx_source varchar(20) NULL, nav numeric(15, 4) NULL, navdate date NULL, order_nav numeric(15, 4) NULL, order_navdate date NULL, folio_no varchar(20) NULL, order_type varchar(50) NULL, order_remarks varchar NULL, tokenno int8 NULL, vendor_exchg_refno varchar(30) NULL, euinnumber varchar(30) NULL, orderby varchar NULL, rm_partner_code varchar NULL, qty_or_amt_order varchar(1) NULL, payment_trxid varchar(20) NULL, payment_method varchar NULL, bank_code varchar NULL, bank_name varchar NULL, bank_ac_number varchar NULL, payment_remarks varchar NULL, pan varchar NULL, vendor_req varchar NULL, vendor_res varchar NULL, order_placed_by varchar NULL, trx_retry_count int4 DEFAULT 0 NULL, lead_id varchar NULL, is_generatetoday bool NULL, switch_mf_schcode int8 NULL, switchtokenno int8 NULL, switch_isin varchar(20) NULL, switch_grpcode varchar NULL, internal_flag int4 DEFAULT 0 NULL, sent_to_vendor_datetime timestamp NULL, created_date timestamp NULL, modified_date timestamp NULL, modified_by varchar NULL, datasource varchar NULL, error_date timestamp DEFAULT now() NULL, error_message varchar NULL, CONSTRAINT pk_vendor_trx_id PRIMARY KEY (vendor_trx_id));

-- Permissions

ALTER TABLE transactions.mf_order_detail_error OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_detail_error TO cmotswrite;


-- transactions.mf_order_detail_history definition

-- Drop table

-- DROP TABLE transactions.mf_order_detail_history;

CREATE TABLE transactions.mf_order_detail_history ( trx_history_id bigserial NOT NULL, trx_id int8 NOT NULL, vendor_trx_id int8 NULL, ucccode varchar(20) NULL, ac_code varchar(20) NULL, trx_datetime timestamp NULL, valid_from timestamp NOT NULL, valid_to timestamp NULL, is_active bool NULL, trx_type_code int4 NULL, trx_type varchar(20) NULL, consent_status_code int4 NULL, consent_status varchar NULL, trx_status_code int4 NULL, trx_status varchar(20) NULL, vendor_trx_status varchar NULL, payment_status_code int4 NULL, payment_status varchar(20) NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, mandate_id varchar NULL, order_remarks varchar NULL, trx_source varchar(20) NULL, inserted_dt timestamp DEFAULT now()::timestamp without time zone NULL, CONSTRAINT mf_order_detail_history_pk PRIMARY KEY (trx_id, valid_from));

-- Permissions

ALTER TABLE transactions.mf_order_detail_history OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_detail_history TO cmotswrite;


-- transactions.mf_order_detail_history_bkp_19july2025 definition

-- Drop table

-- DROP TABLE transactions.mf_order_detail_history_bkp_19july2025;

CREATE TABLE transactions.mf_order_detail_history_bkp_19july2025 ( trx_history_id int8 NULL, trx_id int8 NULL, vendor_trx_id int8 NULL, ucccode varchar(20) NULL, ac_code varchar(20) NULL, trx_datetime timestamp NULL, valid_from timestamp NULL, valid_to timestamp NULL, is_active bool NULL, trx_type_code int4 NULL, trx_type varchar(20) NULL, consent_status_code int4 NULL, consent_status varchar NULL, trx_status_code int4 NULL, trx_status varchar(20) NULL, vendor_trx_status varchar NULL, payment_status_code int4 NULL, payment_status varchar(20) NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, mandate_id varchar NULL, order_remarks varchar NULL, trx_source varchar(20) NULL, inserted_dt timestamp NULL);

-- Permissions

ALTER TABLE transactions.mf_order_detail_history_bkp_19july2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_detail_history_bkp_19july2025 TO cmotswrite;


-- transactions.mf_order_detail_modification definition

-- Drop table

-- DROP TABLE transactions.mf_order_detail_modification;

CREATE TABLE transactions.mf_order_detail_modification ( trx_id bigserial NOT NULL, orderby varchar NULL, vc_remarks varchar NULL, org_trx_id int8 NOT NULL, vendor_trx_id int8 NOT NULL, display_trx_id varchar NULL, ucccode varchar(20) NULL, ac_code varchar(20) NULL, isincode varchar(20) NULL, isinname varchar NULL, trx_datetime timestamp NULL, mf_schcode int8 NULL, trx_type_code int4 NULL, trx_type varchar(20) NULL, consent_status_code int4 NULL, consent_status varchar NULL, trx_status_code int4 NULL, trx_status varchar(20) NULL, vendor_trx_status varchar NULL, payment_status_code int4 NULL, payment_status varchar NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, inv_type_code int4 NULL, inv_type varchar NULL, inv_action_code int4 NOT NULL, inv_action varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, consent_approval_reject_datetime timestamp NULL, trx_amt numeric(15, 4) NULL, physicalflag varchar(5) NULL, mandate_id varchar NULL, trx_source varchar(20) NULL, order_remarks varchar NULL, rm_partner_code varchar(20) NULL, payment_trxid varchar NULL, payment_method varchar NULL, bank_code varchar NULL, bank_name varchar NULL, bank_ac_number varchar NULL, payment_remarks varchar NULL, vendor_req varchar NULL, vendor_res varchar NULL, order_placed_by varchar NULL, internal_flag int4 DEFAULT 0 NULL, sent_to_vendor_datetime timestamp NULL, created_date timestamp NOT NULL, modified_date timestamp NULL, datasource varchar NULL, no_of_inst_paused int4 DEFAULT 0 NOT NULL, frequency varchar NULL, start_day varchar NULL, modifytype varchar NULL, modifycount int4 DEFAULT 0 NULL, sip_frequency varchar NULL, sip_date date NULL, installment_date_post_pause_resume date NULL, mobileno varchar NULL, email varchar NULL, natureoforder varchar NULL, created_for varchar NULL, created_for_name varchar NULL, created_for_type varchar NULL, CONSTRAINT mf_order_detail_modification_pkey PRIMARY KEY (org_trx_id, inv_action_code, created_date));
CREATE INDEX idx_mod_created_date ON transactions.mf_order_detail_modification USING btree (created_date);
CREATE INDEX idx_org_trx_id ON transactions.mf_order_detail_modification USING btree (org_trx_id);
CREATE INDEX idx_ucc_ucccode ON transactions.mf_order_detail_modification USING btree (ucccode);

-- Permissions

ALTER TABLE transactions.mf_order_detail_modification OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_order_detail_modification TO cmotswrite WITH GRANT OPTION;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_order_detail_modification TO appadmin;
GRANT SELECT ON TABLE transactions.mf_order_detail_modification TO cmotsread WITH GRANT OPTION;


-- transactions.mf_order_history definition

-- Drop table

-- DROP TABLE transactions.mf_order_history;

CREATE TABLE transactions.mf_order_history ( count int8 NULL);

-- Permissions

ALTER TABLE transactions.mf_order_history OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_history TO cmotswrite;


-- transactions.mf_order_summary definition

-- Drop table

-- DROP TABLE transactions.mf_order_summary;

CREATE TABLE transactions.mf_order_summary ( id bigserial NOT NULL, order_no int8 NULL, trx_id int8 NULL, vendor_trx_id int8 NULL, display_trx_id varchar NULL, trx_datetime timestamp NULL, reg_no int8 NULL, ac_code varchar NULL, pan varchar NULL, mf_schcode int8 NULL, isincode varchar NULL, firstordertoday varchar(1) NULL, is_generatetoday bool NULL, trx_type_code int4 NULL, trx_type varchar NULL, trx_status_code int4 NULL, trx_status varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, trx_amt numeric(24, 6) NULL, trx_qty numeric(24, 6) NULL, nav numeric(24, 6) NULL, order_nav numeric(24, 6) NULL, order_navdate date NULL, no_of_installment int4 NULL, installment_paid int4 NULL, installment_pending int4 NULL, start_date date NULL, end_date date NULL, folio_no varchar NULL, orderby varchar NULL, frequency varchar NULL, reinvestmentflag varchar NULL, mfimfdflag varchar NULL, order_remarks varchar NULL, euinnumber varchar NULL, rm_partner_code varchar NULL, dpc varchar(1) NULL, delivery_mode varchar NULL, user_id varchar NULL, trx_source varchar NULL, childordernumber varchar NULL, tokenno int4 NULL, mandate_id varchar NULL, mandate_amt numeric(24, 6) NULL, vendor_exchg_refno varchar NULL, mainsipregno varchar NULL, start_day varchar NULL, installment_type varchar DEFAULT '1'::character varying NULL, upcoming_due_date date NULL, previous_paid_date date NULL, totalinstallmentamt_paid int4 NULL, totalinstallment_paid int4 NULL, switch_isin varchar(20) NULL, modifytype varchar NULL, modifycount int4 NULL, stepup_type varchar NULL, stepup_amount numeric(24, 6) NULL, stepup_percent varchar NULL, stepup_start_date date NULL, ispaused int4 NULL, paused_date date NULL, no_of_installment_paused varchar NULL, pausemodificationcount int4 NULL, pausecount int4 NULL, isresumed bool NULL, resumed_date date NULL, isskip bool NULL, skip_date date NULL, istopup int4 NULL, topupdate date NULL, topupcount int4 NULL, iscancel bool NULL, cancellation_date date NULL, datasource varchar NULL, modified_date timestamp NULL, created_date timestamp NULL, remarks varchar NULL);
CREATE INDEX idx_vendor_trxid ON transactions.mf_order_summary USING btree (vendor_trx_id);

-- Permissions

ALTER TABLE transactions.mf_order_summary OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_summary TO cmotswrite;


-- transactions.mf_order_summary_bkp_19july2025 definition

-- Drop table

-- DROP TABLE transactions.mf_order_summary_bkp_19july2025;

CREATE TABLE transactions.mf_order_summary_bkp_19july2025 ( id int8 NULL, order_no int8 NULL, trx_id int8 NULL, vendor_trx_id int8 NULL, display_trx_id varchar NULL, trx_datetime timestamp NULL, reg_no int8 NULL, ac_code varchar NULL, pan varchar NULL, mf_schcode int8 NULL, isincode varchar NULL, firstordertoday varchar(1) NULL, is_generatetoday bool NULL, trx_type_code int4 NULL, trx_type varchar NULL, trx_status_code int4 NULL, trx_status varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, trx_amt numeric(24, 6) NULL, trx_qty numeric(24, 6) NULL, nav numeric(24, 6) NULL, order_nav numeric(24, 6) NULL, order_navdate date NULL, no_of_installment int4 NULL, installment_paid int4 NULL, installment_pending int4 NULL, start_date date NULL, end_date date NULL, folio_no varchar NULL, orderby varchar NULL, frequency varchar NULL, reinvestmentflag varchar NULL, mfimfdflag varchar NULL, order_remarks varchar NULL, euinnumber varchar NULL, rm_partner_code varchar NULL, dpc varchar(1) NULL, delivery_mode varchar NULL, user_id varchar NULL, trx_source varchar NULL, childordernumber varchar NULL, tokenno int4 NULL, mandate_id varchar NULL, mandate_amt numeric(24, 6) NULL, vendor_exchg_refno varchar NULL, mainsipregno varchar NULL, start_day varchar NULL, installment_type varchar NULL, upcoming_due_date date NULL, previous_paid_date date NULL, totalinstallmentamt_paid int4 NULL, totalinstallment_paid int4 NULL, switch_isin varchar(20) NULL, modifytype varchar NULL, modifycount int4 NULL, stepup_type varchar NULL, stepup_amount numeric(24, 6) NULL, stepup_percent varchar NULL, stepup_start_date date NULL, ispaused int4 NULL, paused_date date NULL, no_of_installment_paused varchar NULL, pausemodificationcount int4 NULL, pausecount int4 NULL, isresumed bool NULL, resumed_date date NULL, isskip bool NULL, skip_date date NULL, istopup int4 NULL, topupdate date NULL, topupcount int4 NULL, iscancel bool NULL, cancellation_date date NULL, datasource varchar NULL, modified_date timestamp NULL, created_date timestamp NULL, remarks varchar NULL);

-- Permissions

ALTER TABLE transactions.mf_order_summary_bkp_19july2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_summary_bkp_19july2025 TO cmotswrite;


-- transactions.mf_order_summary_error definition

-- Drop table

-- DROP TABLE transactions.mf_order_summary_error;

CREATE TABLE transactions.mf_order_summary_error ( id int8 NULL, order_no int8 NULL, trx_id int8 NULL, vendor_trx_id int8 NOT NULL, display_trx_id varchar NULL, trx_datetime timestamp NULL, reg_no int8 NULL, ac_code varchar NULL, pan varchar NULL, mf_schcode int8 NULL, isincode varchar NULL, firstordertoday varchar(1) NULL, is_generatetoday bool NULL, trx_type_code int4 NULL, trx_type varchar NULL, trx_status_code int4 NULL, trx_status varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, trx_amt numeric(24, 6) NULL, trx_qty numeric(24, 6) NULL, nav numeric(24, 6) NULL, order_nav numeric(24, 6) NULL, order_navdate date NULL, no_of_installment int4 NULL, installment_paid int4 NULL, installment_pending int4 NULL, start_date date NULL, end_date date NULL, folio_no varchar NULL, orderby varchar NULL, frequency varchar NULL, reinvestmentflag varchar NULL, mfimfdflag varchar NULL, order_remarks varchar NULL, euinnumber varchar NULL, rm_partner_code varchar NULL, dpc varchar(1) NULL, delivery_mode varchar NULL, user_id varchar NULL, trx_source varchar NULL, childordernumber varchar NULL, tokenno int4 NULL, mandate_id varchar NULL, mandate_amt numeric(24, 6) NULL, vendor_exchg_refno varchar NULL, mainsipregno varchar NULL, start_day varchar NULL, installment_type varchar NULL, upcoming_due_date date NULL, previous_paid_date date NULL, totalinstallmentamt_paid int4 NULL, totalinstallment_paid int4 NULL, switch_isin varchar(20) NULL, modifytype varchar NULL, modifycount int4 NULL, stepup_type varchar NULL, stepup_amount numeric(24, 6) NULL, stepup_percent varchar NULL, stepup_start_date date NULL, ispaused int4 NULL, paused_date date NULL, no_of_installment_paused varchar NULL, pausemodificationcount int4 NULL, pausecount int4 NULL, isresumed bool NULL, resumed_date date NULL, isskip bool NULL, skip_date date NULL, istopup int4 NULL, topupdate date NULL, topupcount int4 NULL, iscancel bool NULL, cancellation_date date NULL, datasource varchar NULL, modified_date timestamp NULL, created_date timestamp NULL, error_message varchar NULL, error_date timestamp DEFAULT now() NULL, CONSTRAINT pk_summary_vendor_trx_id PRIMARY KEY (vendor_trx_id));

-- Permissions

ALTER TABLE transactions.mf_order_summary_error OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_summary_error TO cmotswrite;


-- transactions.mf_order_summary_history definition

-- Drop table

-- DROP TABLE transactions.mf_order_summary_history;

CREATE TABLE transactions.mf_order_summary_history ( history_id bigserial NOT NULL, id int8 NULL, order_no int8 NULL, trx_id int8 NULL, reg_no int8 NULL, trx_type varchar NULL, trx_status varchar NULL, mandate_id varchar NULL, trx_source varchar NULL, ispaused int4 NULL, istopup int4 NULL, modifycount int4 NULL, created_date timestamp NULL, trx_datetime timestamp NULL, start_day varchar NULL, trx_qty numeric(24, 6) NULL, installment_type varchar NULL, is_generatetoday bool NULL, stepup_type varchar NULL, stepup_amount numeric(24, 6) NULL, stepup_percent varchar NULL, stepup_start_date date NULL, vendor_trx_id int8 NULL, iscancel bool NULL, no_of_installment_paused varchar NULL, paused_date date NULL, topupdate date NULL, isskip bool NULL, skip_date date NULL, valid_from timestamp NULL, valid_to timestamp NULL, is_active bool NULL, trx_type_code int4 NULL, isresumed bool NULL, resumed_date date NULL, upcoming_due_date date NULL, previous_paid_date date NULL, totalinstallmentamt_paid int4 NULL, inserted_dt timestamp DEFAULT now()::timestamp without time zone NULL, switch_isin varchar(20) NULL, trx_status_code int4 NULL, totalinstallment_paid int4 NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL);

-- Permissions

ALTER TABLE transactions.mf_order_summary_history OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_order_summary_history TO cmotswrite WITH GRANT OPTION;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_order_summary_history TO appadmin;
GRANT SELECT ON TABLE transactions.mf_order_summary_history TO cmotsread WITH GRANT OPTION;


-- transactions.mf_order_summary_modify_log definition

-- Drop table

-- DROP TABLE transactions.mf_order_summary_modify_log;

CREATE TABLE transactions.mf_order_summary_modify_log ( id int8 NULL, order_no int8 NULL, trx_id int8 NULL, vendor_trx_id int8 NULL, display_trx_id varchar NULL, trx_datetime timestamp NULL, reg_no int8 NULL, ac_code varchar NULL, pan varchar NULL, mf_schcode int8 NULL, isincode varchar NULL, firstordertoday varchar(1) NULL, is_generatetoday bool NULL, trx_type_code int4 NULL, trx_type varchar NULL, trx_status_code int4 NULL, trx_status varchar NULL, trx_final_status_code int4 NULL, final_status varchar NULL, inv_plan_status_code int8 NULL, inv_plan_status varchar NULL, trx_amt numeric(24, 6) NULL, trx_qty numeric(24, 6) NULL, nav numeric(24, 6) NULL, order_nav numeric(24, 6) NULL, order_navdate date NULL, no_of_installment int4 NULL, installment_paid int4 NULL, installment_pending int4 NULL, start_date date NULL, end_date date NULL, folio_no varchar NULL, orderby varchar NULL, frequency varchar NULL, reinvestmentflag varchar NULL, mfimfdflag varchar NULL, order_remarks varchar NULL, euinnumber varchar NULL, rm_partner_code varchar NULL, dpc varchar(1) NULL, delivery_mode varchar NULL, user_id varchar NULL, trx_source varchar NULL, childordernumber varchar NULL, tokenno int4 NULL, mandate_id varchar NULL, mandate_amt numeric(24, 6) NULL, vendor_exchg_refno varchar NULL, mainsipregno varchar NULL, start_day varchar NULL, installment_type varchar NULL, upcoming_due_date date NULL, previous_paid_date date NULL, totalinstallmentamt_paid int4 NULL, totalinstallment_paid int4 NULL, switch_isin varchar(20) NULL, modifytype varchar NULL, modifycount int4 NULL, stepup_type varchar NULL, stepup_amount numeric(24, 6) NULL, stepup_percent varchar NULL, stepup_start_date date NULL, ispaused int4 NULL, paused_date date NULL, no_of_installment_paused varchar NULL, pausemodificationcount int4 NULL, pausecount int4 NULL, isresumed bool NULL, resumed_date date NULL, isskip bool NULL, skip_date date NULL, istopup int4 NULL, topupdate date NULL, topupcount int4 NULL, iscancel bool NULL, cancellation_date date NULL, datasource varchar NULL, modified_date timestamp NULL, created_date timestamp NULL, remarks varchar NULL, inserted_date timestamp NULL);
CREATE INDEX idx_vendor_trx_id_new ON transactions.mf_order_summary_modify_log USING btree (vendor_trx_id);

-- Permissions

ALTER TABLE transactions.mf_order_summary_modify_log OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_order_summary_modify_log TO cmotswrite;


-- transactions.mf_subsequent_order definition

-- Drop table

-- DROP TABLE transactions.mf_subsequent_order;

CREATE TABLE transactions.mf_subsequent_order ( id bigserial NOT NULL, isincode varchar NULL, order_no int8 NOT NULL, reg_no int8 NOT NULL, vendor_trx_id int8 NOT NULL, ac_code varchar NULL, trx_type_code int8 NULL, trx_type varchar NULL, orderdate date NOT NULL, amount numeric(12, 4) NULL, reg_date date NULL, status varchar NULL, orderedby varchar NULL, sysrefno varchar NULL, mandate_id int8 NULL, remarks varchar NULL, paymentrejection int4 NULL, created_date timestamp NULL, modified_date timestamp NULL, data_source varchar NULL, CONSTRAINT pk_subsequent_order PRIMARY KEY (order_no, vendor_trx_id, reg_no, orderdate));
CREATE INDEX idx_orderdate ON transactions.mf_subsequent_order USING btree (orderdate);
CREATE INDEX idx_reg_no ON transactions.mf_subsequent_order USING btree (reg_no);
CREATE INDEX idx_sub_vendor_trx_id ON transactions.mf_subsequent_order USING btree (vendor_trx_id);

-- Permissions

ALTER TABLE transactions.mf_subsequent_order OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_subsequent_order TO cmotswrite;


-- transactions.mf_subsequent_order_error definition

-- Drop table

-- DROP TABLE transactions.mf_subsequent_order_error;

CREATE TABLE transactions.mf_subsequent_order_error ( id bigserial NOT NULL, isincode varchar NULL, order_no int8 NULL, reg_no int8 NOT NULL, vendor_trx_id int8 NULL, ac_code varchar NULL, trx_type_code varchar NULL, trx_type varchar NULL, orderdate date NOT NULL, amount numeric(12, 4) NULL, reg_date date NULL, status varchar NULL, orderedby varchar NULL, sysrefno varchar NULL, mandate_id int8 NULL, remarks varchar NULL, paymentrejection int4 NULL, created_date timestamp NULL, modified_date timestamp NULL, data_source varchar NULL, error_message varchar NULL, error_date timestamp DEFAULT now() NULL, CONSTRAINT uk_subsequent_order_error UNIQUE (order_no, vendor_trx_id, reg_no, orderdate));

-- Permissions

ALTER TABLE transactions.mf_subsequent_order_error OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mf_subsequent_order_error TO cmotswrite;


-- transactions.mf_sync_history definition

-- Drop table

-- DROP TABLE transactions.mf_sync_history;

CREATE TABLE transactions.mf_sync_history ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, ucccode varchar NULL, sync_start_datetime timestamp NULL, sync_end_datetime timestamp NULL, status varchar NULL, "source" varchar NULL, initiated_by varchar NULL);

-- Permissions

ALTER TABLE transactions.mf_sync_history OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_sync_history TO cmotswrite;
GRANT SELECT ON TABLE transactions.mf_sync_history TO cmotsread;


-- transactions.mf_sync_history_log definition

-- Drop table

-- DROP TABLE transactions.mf_sync_history_log;

CREATE TABLE transactions.mf_sync_history_log ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, sync_id int4 NULL, ucccode varchar NULL, sync_start_datetime timestamp NULL, sync_end_datetime timestamp NULL, status varchar NULL, "source" varchar NULL, initiated_by varchar NULL);

-- Permissions

ALTER TABLE transactions.mf_sync_history_log OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_sync_history_log TO cmotswrite;
GRANT SELECT ON TABLE transactions.mf_sync_history_log TO cmotsread;


-- transactions.mf_viewed_history definition

-- Drop table

-- DROP TABLE transactions.mf_viewed_history;

CREATE TABLE transactions.mf_viewed_history ( viewed_id bigserial NOT NULL, login_code varchar NULL, mf_schcode int8 NULL, created_date timestamp DEFAULT CURRENT_TIMESTAMP NULL, CONSTRAINT mf_viewed_history_pkey PRIMARY KEY (viewed_id));

-- Permissions

ALTER TABLE transactions.mf_viewed_history OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.mf_viewed_history TO cmotswrite;
GRANT SELECT ON TABLE transactions.mf_viewed_history TO cmotsread;


-- transactions.otp definition

-- Drop table

-- DROP TABLE transactions.otp;

CREATE TABLE transactions.otp ( otp_id bigserial NOT NULL, sms_otp_code varchar NULL, email_otp_code varchar NULL, whatsapp_otp_code varchar NULL, opt_sent_datetime timestamp NULL, otp_expire_datetime timestamp NULL, otp_verfied_flg int4 NULL, client_email_id varchar NULL, client_mobile varchar NULL, category_code int4 DEFAULT 261 NULL, trx_id int8 NULL, inv_action_code int4 NULL, CONSTRAINT otp_id_pk PRIMARY KEY (otp_id));

-- Permissions

ALTER TABLE transactions.otp OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.otp TO cmotswrite WITH GRANT OPTION;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.otp TO appadmin;
GRANT SELECT ON TABLE transactions.otp TO cmotsread WITH GRANT OPTION;


-- transactions.otp_verification definition

-- Drop table

-- DROP TABLE transactions.otp_verification;

CREATE TABLE transactions.otp_verification ( otp_id bigserial NOT NULL, trx_id int8 NULL, requested_timestamp timestamp NULL, expire_timestamp timestamp NULL, verification_timestamp timestamp NULL, delivery_code int4 NULL, CONSTRAINT otp_verification_pkey PRIMARY KEY (otp_id));

-- Permissions

ALTER TABLE transactions.otp_verification OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.otp_verification TO cmotswrite;
GRANT SELECT ON TABLE transactions.otp_verification TO cmotsread;


-- transactions.rtatransactionreversal definition

-- Drop table

-- DROP TABLE transactions.rtatransactionreversal;

CREATE TABLE transactions.rtatransactionreversal ( tranid int8 NULL, schemename varchar NULL, clientpan varchar NULL, transactiondate timestamp NULL, folionumber varchar NULL, units float8 NULL, amount float8 NULL, transactiondescription varchar NULL, isin varchar NULL, updatedtime timestamp NULL);
CREATE INDEX idx_prod_transactiondate ON transactions.rtatransactionreversal USING btree (transactiondate);

-- Permissions

ALTER TABLE transactions.rtatransactionreversal OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.rtatransactionreversal TO cmotswrite WITH GRANT OPTION;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.rtatransactionreversal TO appadmin;
GRANT SELECT ON TABLE transactions.rtatransactionreversal TO cmotsread WITH GRANT OPTION;


-- transactions.stg_dion_mandate definition

-- Drop table

-- DROP TABLE transactions.stg_dion_mandate;

CREATE TABLE transactions.stg_dion_mandate ( id int4 NULL, mandateid varchar(50) NULL, clientcode varchar(50) NULL, clientname varchar(255) NULL, filler1 varchar(50) NULL, filler2 varchar(50) NULL, amount numeric(18, 2) NULL, modeofpayment varchar(50) NULL, bankname varchar(255) NULL, branch varchar(255) NULL, filler3 varchar(50) NULL, filler4 varchar(50) NULL, filler5 varchar(50) NULL, mandatetype varchar(50) NULL, mandatetypenew varchar(50) NULL, filler6 varchar(50) NULL, mandatedate date NULL, creationtime time NULL, memberid varchar(50) NULL, status varchar(255) NULL, remarks varchar(255) NULL, createdby varchar(50) NULL, createdon timestamp NULL, updatedby varchar(50) NULL, updatedon timestamp NULL, pdfcontent varchar(50) NULL, approveddate date NULL, accountnumber varchar(50) NULL, ifsccode varchar(11) NULL, mandatemode varchar(50) NULL, dateofreceived date NULL, clientstatus varchar(255) NULL, remark varchar NULL, scanmandatestatus varchar(255) NULL, scanmandateremarks varchar(255) NULL, clientname2 varchar(255) NULL, clientname3 varchar(255) NULL, scanuploadtime time NULL, rmcodescan varchar(50) NULL, subbrokercode varchar(50) NULL, schemetype varchar(50) NULL);
CREATE INDEX idx_mandateid ON transactions.stg_dion_mandate USING btree (mandateid);

-- Permissions

ALTER TABLE transactions.stg_dion_mandate OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_mandate TO cmotswrite;


-- transactions.stg_dion_orderbook definition

-- Drop table

-- DROP TABLE transactions.stg_dion_orderbook;

CREATE TABLE transactions.stg_dion_orderbook ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);
CREATE INDEX stg_dion_orderbook_clientcode ON transactions.stg_dion_orderbook USING btree (clientcode);
CREATE INDEX stg_dion_orderbook_idx ON transactions.stg_dion_orderbook USING btree (clientcode, txntype, txnid, status, paymentstatus);

-- Permissions

ALTER TABLE transactions.stg_dion_orderbook OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.stg_dion_orderbook TO cmotswrite WITH GRANT OPTION;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.stg_dion_orderbook TO appadmin;
GRANT SELECT ON TABLE transactions.stg_dion_orderbook TO cmotsread WITH GRANT OPTION;


-- transactions.stg_dion_orderbook_lumpsum definition

-- Drop table

-- DROP TABLE transactions.stg_dion_orderbook_lumpsum;

CREATE TABLE transactions.stg_dion_orderbook_lumpsum ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);
CREATE INDEX idx_clientcode ON transactions.stg_dion_orderbook_lumpsum USING btree (clientcode);
CREATE INDEX idx_stg_status_upper ON transactions.stg_dion_orderbook_lumpsum USING btree (upper((status)::text));
CREATE INDEX idx_stg_txntype_upper ON transactions.stg_dion_orderbook_lumpsum USING btree (upper((txntype)::text));
CREATE INDEX idx_txnid ON transactions.stg_dion_orderbook_lumpsum USING btree (txnid);
CREATE INDEX stg_dion_orderbook_lumpsum_clientcode ON transactions.stg_dion_orderbook_lumpsum USING btree (clientcode);
CREATE INDEX stg_dion_orderbook_lumpsum_idx ON transactions.stg_dion_orderbook_lumpsum USING btree (clientcode, txntype, txnid, status, paymentstatus);

-- Permissions

ALTER TABLE transactions.stg_dion_orderbook_lumpsum OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_orderbook_lumpsum TO cmotswrite;


-- transactions.stg_dion_orderbook_lumpsum_bkp06nov2025 definition

-- Drop table

-- DROP TABLE transactions.stg_dion_orderbook_lumpsum_bkp06nov2025;

CREATE TABLE transactions.stg_dion_orderbook_lumpsum_bkp06nov2025 ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_orderbook_lumpsum_bkp06nov2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_orderbook_lumpsum_bkp06nov2025 TO cmotswrite;


-- transactions.stg_dion_orderbook_sip definition

-- Drop table

-- DROP TABLE transactions.stg_dion_orderbook_sip;

CREATE TABLE transactions.stg_dion_orderbook_sip ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);
CREATE INDEX stg_dion_orderbook_sip_clientcode ON transactions.stg_dion_orderbook_sip USING btree (clientcode);
CREATE INDEX stg_dion_orderbook_sip_exchangerefno ON transactions.stg_dion_orderbook_sip USING btree (exchangerefno);
CREATE INDEX stg_dion_orderbook_sip_idx ON transactions.stg_dion_orderbook_sip USING btree (clientcode, txntype, txnid, status, paymentstatus);

-- Permissions

ALTER TABLE transactions.stg_dion_orderbook_sip OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_orderbook_sip TO cmotswrite;


-- transactions.stg_dion_orderbook_sip_bkp06nov2025 definition

-- Drop table

-- DROP TABLE transactions.stg_dion_orderbook_sip_bkp06nov2025;

CREATE TABLE transactions.stg_dion_orderbook_sip_bkp06nov2025 ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_orderbook_sip_bkp06nov2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_orderbook_sip_bkp06nov2025 TO cmotswrite;


-- transactions.stg_dion_orderbook_sip_bkp23nov2025 definition

-- Drop table

-- DROP TABLE transactions.stg_dion_orderbook_sip_bkp23nov2025;

CREATE TABLE transactions.stg_dion_orderbook_sip_bkp23nov2025 ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_orderbook_sip_bkp23nov2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_orderbook_sip_bkp23nov2025 TO cmotswrite;


-- transactions.stg_dion_orderbook_stp definition

-- Drop table

-- DROP TABLE transactions.stg_dion_orderbook_stp;

CREATE TABLE transactions.stg_dion_orderbook_stp ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);
CREATE INDEX stg_dion_orderbook_stp_clientcode ON transactions.stg_dion_orderbook_stp USING btree (clientcode);
CREATE INDEX stg_dion_orderbook_stp_idx ON transactions.stg_dion_orderbook_stp USING btree (clientcode, txntype, txnid, status, paymentstatus);
CREATE INDEX stg_dion_orderbook_stp_txnid ON transactions.stg_dion_orderbook_stp USING btree (txnid);

-- Permissions

ALTER TABLE transactions.stg_dion_orderbook_stp OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_orderbook_stp TO cmotswrite;


-- transactions.stg_dion_orderbook_swp definition

-- Drop table

-- DROP TABLE transactions.stg_dion_orderbook_swp;

CREATE TABLE transactions.stg_dion_orderbook_swp ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);
CREATE INDEX idx_swp_status_upper ON transactions.stg_dion_orderbook_swp USING btree (upper((status)::text));
CREATE INDEX idx_swp_txntype_upper ON transactions.stg_dion_orderbook_swp USING btree (upper((txntype)::text));
CREATE INDEX stg_dion_orderbook_swp_clientcode ON transactions.stg_dion_orderbook_swp USING btree (clientcode);
CREATE INDEX stg_dion_orderbook_swp_idx ON transactions.stg_dion_orderbook_swp USING btree (clientcode, txntype, txnid, status, paymentstatus);
CREATE INDEX stg_dion_orderbook_swp_txnid ON transactions.stg_dion_orderbook_swp USING btree (txnid);

-- Permissions

ALTER TABLE transactions.stg_dion_orderbook_swp OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_orderbook_swp TO cmotswrite;


-- transactions.stg_dion_orderbook_swp_bkp06nov2025 definition

-- Drop table

-- DROP TABLE transactions.stg_dion_orderbook_swp_bkp06nov2025;

CREATE TABLE transactions.stg_dion_orderbook_swp_bkp06nov2025 ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_orderbook_swp_bkp06nov2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_orderbook_swp_bkp06nov2025 TO cmotswrite;


-- transactions.stg_dion_sip_due_report definition

-- Drop table

-- DROP TABLE transactions.stg_dion_sip_due_report;

CREATE TABLE transactions.stg_dion_sip_due_report ( sid int4 NULL, memcd varchar(255) NULL, clientcode varchar(255) NULL, clientname varchar(255) NULL, internalrefno varchar(255) NULL, sipregnnumber varchar(255) NULL, regndate date NULL, amcname varchar(255) NULL, schemecode varchar(255) NULL, schemename varchar(255) NULL, frequencytype varchar(255) NULL, installmentamt numeric(10, 2) NULL, duedate date NULL, prevpaiddate date NULL, noofinstallmentspaid int4 NULL, totalinstallmentamtpaid numeric(10, 2) NULL, entryby varchar(255) NULL, mandateid varchar(255) NULL, schtype bpchar(1) NULL, dptrans bpchar(1) NULL, firstordertoday bpchar(1) NULL, createdby varchar(255) NULL, createdon timestamp NULL, clientid varchar(255) NULL, clientmode varchar(255) NULL, userid varchar(255) NULL, usertype varchar(255) NULL, traxmode varchar(255) NULL, mfimfdflag varchar(255) NULL, txntype varchar(255) NULL);
CREATE INDEX idx_stg_dion_sip_due_report ON transactions.stg_dion_sip_due_report USING btree (clientcode, sipregnnumber);
CREATE INDEX idx_stg_dion_sip_due_report_internalrefno ON transactions.stg_dion_sip_due_report USING btree (internalrefno);
CREATE INDEX idx_stg_dion_sip_due_report_sipregnnumber ON transactions.stg_dion_sip_due_report USING btree (sipregnnumber);

-- Permissions

ALTER TABLE transactions.stg_dion_sip_due_report OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_sip_due_report TO cmotswrite;


-- transactions.stg_dion_siporder definition

-- Drop table

-- DROP TABLE transactions.stg_dion_siporder;

CREATE TABLE transactions.stg_dion_siporder ( sipregdate date NULL, siporderno int8 NULL, txnid int8 NULL, sipregno int8 NULL, clientcode varchar NULL, schemename varchar NULL, txntype varchar NULL, amount numeric(24, 6) NULL, sipstartdate date NULL, sipenddate date NULL, foliono varchar NULL, status varchar NULL, orderedby varchar NULL, schemecode varchar NULL, isin varchar NULL, frequency varchar NULL, totalinstalments int4 NULL, instalementspaid int4 NULL, instalmentspending int4 NULL, mandateid varchar NULL, reinvestmentflag varchar(4) NULL, nav numeric(24, 6) NULL, mfimfdflag varchar NULL, modelportfolioname varchar NULL, remarks varchar NULL, vaildcount int4 NULL, invaildcount int4 NULL, amcname varchar NULL, euinnumber varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, rmcode varchar NULL, units numeric(24, 6) NULL, sipcancellationdate date NULL, dpc varchar(1) NULL, firstordertoday varchar(1) NULL, euindecl varchar(1) NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, switchisin varchar NULL, switchschemename varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, vctrxnstatus varchar NULL, childordernumber varchar NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, bankname varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, vcfiller3 varchar NULL, mandatetype varchar NULL, mandatestatus varchar NULL, "token" int4 NULL, amccode varchar NULL, mandateamount numeric(24, 6) NULL, ispaused int4 NULL, istopup int4 NULL, vcclientname varchar NULL, exchangerefnumber varchar NULL, vcparentcode varchar NULL, schemetype varchar NULL, fromorderno varchar NULL, toorderno varchar NULL, trxntime time NULL, pauseflag varchar(1) NULL, pauseminimuminstallments int4 NULL, pausemaximuminstallments int4 NULL, pausemodificationcount int4 NULL, topuptype varchar NULL, topupcount int4 NULL, pausecount int4 NULL, mainsipregno varchar NULL, modifytype varchar NULL, modifycount int4 NULL);
CREATE INDEX idx_siporder_txnid ON transactions.stg_dion_siporder USING btree (txnid);
CREATE INDEX idx_status ON transactions.stg_dion_siporder USING btree (upper((status)::text));

-- Permissions

ALTER TABLE transactions.stg_dion_siporder OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.stg_dion_siporder TO cmotswrite WITH GRANT OPTION;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.stg_dion_siporder TO appadmin;
GRANT SELECT ON TABLE transactions.stg_dion_siporder TO cmotsread WITH GRANT OPTION;


-- transactions.stg_dion_siporder_bkp06nov2025 definition

-- Drop table

-- DROP TABLE transactions.stg_dion_siporder_bkp06nov2025;

CREATE TABLE transactions.stg_dion_siporder_bkp06nov2025 ( sipregdate date NULL, siporderno int8 NULL, txnid int8 NULL, sipregno int8 NULL, clientcode varchar NULL, schemename varchar NULL, txntype varchar NULL, amount numeric(24, 6) NULL, sipstartdate date NULL, sipenddate date NULL, foliono varchar NULL, status varchar NULL, orderedby varchar NULL, schemecode varchar NULL, isin varchar NULL, frequency varchar NULL, totalinstalments int4 NULL, instalementspaid int4 NULL, instalmentspending int4 NULL, mandateid varchar NULL, reinvestmentflag varchar(4) NULL, nav numeric(24, 6) NULL, mfimfdflag varchar NULL, modelportfolioname varchar NULL, remarks varchar NULL, vaildcount int4 NULL, invaildcount int4 NULL, amcname varchar NULL, euinnumber varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, rmcode varchar NULL, units numeric(24, 6) NULL, sipcancellationdate date NULL, dpc varchar(1) NULL, firstordertoday varchar(1) NULL, euindecl varchar(1) NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, switchisin varchar NULL, switchschemename varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, vctrxnstatus varchar NULL, childordernumber varchar NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, bankname varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, vcfiller3 varchar NULL, mandatetype varchar NULL, mandatestatus varchar NULL, "token" int4 NULL, amccode varchar NULL, mandateamount numeric(24, 6) NULL, ispaused int4 NULL, istopup int4 NULL, vcclientname varchar NULL, exchangerefnumber varchar NULL, vcparentcode varchar NULL, schemetype varchar NULL, fromorderno varchar NULL, toorderno varchar NULL, trxntime time NULL, pauseflag varchar(1) NULL, pauseminimuminstallments int4 NULL, pausemaximuminstallments int4 NULL, pausemodificationcount int4 NULL, topuptype varchar NULL, topupcount int4 NULL, pausecount int4 NULL, mainsipregno varchar NULL, modifytype varchar NULL, modifycount int4 NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_siporder_bkp06nov2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_siporder_bkp06nov2025 TO cmotswrite;


-- transactions.stg_dion_siporder_bkp23nov2025 definition

-- Drop table

-- DROP TABLE transactions.stg_dion_siporder_bkp23nov2025;

CREATE TABLE transactions.stg_dion_siporder_bkp23nov2025 ( sipregdate date NULL, siporderno int8 NULL, txnid int8 NULL, sipregno int8 NULL, clientcode varchar NULL, schemename varchar NULL, txntype varchar NULL, amount numeric(24, 6) NULL, sipstartdate date NULL, sipenddate date NULL, foliono varchar NULL, status varchar NULL, orderedby varchar NULL, schemecode varchar NULL, isin varchar NULL, frequency varchar NULL, totalinstalments int4 NULL, instalementspaid int4 NULL, instalmentspending int4 NULL, mandateid varchar NULL, reinvestmentflag varchar(4) NULL, nav numeric(24, 6) NULL, mfimfdflag varchar NULL, modelportfolioname varchar NULL, remarks varchar NULL, vaildcount int4 NULL, invaildcount int4 NULL, amcname varchar NULL, euinnumber varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, rmcode varchar NULL, units numeric(24, 6) NULL, sipcancellationdate date NULL, dpc varchar(1) NULL, firstordertoday varchar(1) NULL, euindecl varchar(1) NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, switchisin varchar NULL, switchschemename varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, vctrxnstatus varchar NULL, childordernumber varchar NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, bankname varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, vcfiller3 varchar NULL, mandatetype varchar NULL, mandatestatus varchar NULL, "token" int4 NULL, amccode varchar NULL, mandateamount numeric(24, 6) NULL, ispaused int4 NULL, istopup int4 NULL, vcclientname varchar NULL, exchangerefnumber varchar NULL, vcparentcode varchar NULL, schemetype varchar NULL, fromorderno varchar NULL, toorderno varchar NULL, trxntime time NULL, pauseflag varchar(1) NULL, pauseminimuminstallments int4 NULL, pausemaximuminstallments int4 NULL, pausemodificationcount int4 NULL, topuptype varchar NULL, topupcount int4 NULL, pausecount int4 NULL, mainsipregno varchar NULL, modifytype varchar NULL, modifycount int4 NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_siporder_bkp23nov2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_siporder_bkp23nov2025 TO cmotswrite;


-- transactions.stg_dion_sipsubsequentorder definition

-- Drop table

-- DROP TABLE transactions.stg_dion_sipsubsequentorder;

CREATE TABLE transactions.stg_dion_sipsubsequentorder ( siporderno int8 NULL, clientcode varchar NULL, clientname varchar NULL, txntype varchar NULL, orderdate varchar NULL, amount numeric(12, 4) NULL, sipregdate varchar NULL, foliono varchar NULL, status varchar NULL, orderedby varchar NULL, sysrefno varchar NULL, schemecode varchar NULL, isin varchar NULL, frequency varchar NULL, mandateid int8 NULL, sipregno int8 NULL, clientid int8 NULL, remarks varchar NULL, sipstartdate varchar NULL, sipenddate varchar NULL, schemename varchar NULL, cancelallowed int4 NULL, paymentrejection int4 NULL, mfimfd varchar NULL, intrefno int8 NULL);
CREATE INDEX idx_stg_dion_sipsubsequentorder_clientcode ON transactions.stg_dion_sipsubsequentorder USING btree (clientcode);
CREATE INDEX idx_stg_dion_sipsubsequentorder_orderdate ON transactions.stg_dion_sipsubsequentorder USING btree (orderdate);
CREATE INDEX idx_stg_dion_sipsubsequentorder_sipregdate ON transactions.stg_dion_sipsubsequentorder USING btree (sipregdate);
CREATE INDEX idx_stg_dion_sipsubsequentorder_sipregno ON transactions.stg_dion_sipsubsequentorder USING btree (sipregno);

-- Permissions

ALTER TABLE transactions.stg_dion_sipsubsequentorder OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.stg_dion_sipsubsequentorder TO cmotswrite WITH GRANT OPTION;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.stg_dion_sipsubsequentorder TO appadmin;
GRANT SELECT ON TABLE transactions.stg_dion_sipsubsequentorder TO cmotsread WITH GRANT OPTION;


-- transactions.stg_dion_sipsubsequentorder_check definition

-- Drop table

-- DROP TABLE transactions.stg_dion_sipsubsequentorder_check;

CREATE TABLE transactions.stg_dion_sipsubsequentorder_check ( totalrecords varchar NULL, transaction_id varchar NULL, transaction_date varchar NULL, amcname varchar NULL, isin varchar NULL, schemename varchar NULL, status varchar NULL, amount varchar NULL, transaction_type varchar NULL, scheme_code varchar NULL, paymentmode varchar NULL, folionumber varchar NULL, remarks_bse_remarks varchar NULL, rmcode varchar NULL, paymentstatus varchar NULL, arn varchar NULL, subbrokercode varchar NULL, ordertype varchar NULL, navdate varchar NULL, fundtype varchar NULL, "token" varchar NULL, sipregdate varchar NULL, totalinstallments varchar NULL, exchangerefno varchar NULL, installmentspaid varchar NULL, sipfrequency varchar NULL, installmentspending varchar NULL, sipcancellationdate varchar NULL, mandatetype varchar NULL, mandatestatus varchar NULL, duedate varchar NULL, upi varchar NULL, mandate_id varchar NULL, clientcode varchar NULL, sip_start_date varchar NULL, sip_end_date varchar NULL, mfimfdflag varchar NULL, firstordertoday varchar NULL, settlementtype varchar NULL, dpc varchar NULL, transaction_time varchar NULL, alloted_units varchar NULL, poa varchar NULL, alloted_nav varchar NULL, currentnav varchar NULL, euindecl varchar NULL, clientname varchar NULL, traxmode varchar NULL, paymenttime varchar NULL, alloteddate varchar NULL, accountnumber varchar NULL, bankname varchar NULL, ifsc varchar NULL, amclogo varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_sipsubsequentorder_check OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_sipsubsequentorder_check TO cmotswrite;


-- transactions.stg_dion_stp_due_report definition

-- Drop table

-- DROP TABLE transactions.stg_dion_stp_due_report;

CREATE TABLE transactions.stg_dion_stp_due_report ( membercode varchar NULL, clientcode varchar NULL, clientname varchar NULL, internalrefno varchar NULL, stpregno varchar NULL, stpregdate varchar NULL, fromamcname varchar NULL, toamcname varchar NULL, schemecode varchar NULL, fromschemename varchar NULL, toschemename varchar NULL, frequencytype varchar NULL, installmentamt varchar NULL, duedate varchar NULL, prevpaiddate varchar NULL, no_ofinstallmentspaid varchar NULL, totalinstallmentamtpaid varchar NULL, entryby varchar NULL, dptrans varchar NULL, firstordertoday varchar NULL, txntype varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_stp_due_report OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_stp_due_report TO cmotswrite;


-- transactions.stg_dion_stporder definition

-- Drop table

-- DROP TABLE transactions.stg_dion_stporder;

CREATE TABLE transactions.stg_dion_stporder ( sipregdate date NULL, siporderno int8 NULL, txnid int8 NULL, sipregno int8 NULL, clientcode varchar NULL, schemename varchar NULL, txntype varchar NULL, amount numeric(24, 6) NULL, sipstartdate date NULL, sipenddate date NULL, foliono varchar NULL, status varchar NULL, orderedby varchar NULL, schemecode varchar NULL, isin varchar NULL, frequency varchar NULL, totalinstalments varchar NULL, instalementspaid varchar NULL, instalmentspending int4 NULL, mandateid varchar NULL, reinvestmentflag varchar(4) NULL, nav numeric(24, 6) NULL, mfimfdflag varchar NULL, modelportfolioname varchar NULL, remarks varchar NULL, vaildcount int4 NULL, invaildcount int4 NULL, amcname varchar NULL, euinnumber varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, rmcode varchar NULL, units numeric(24, 6) NULL, sipcancellationdate date NULL, dpc varchar(1) NULL, firstordertoday varchar(1) NULL, euindecl varchar(1) NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, switchisin varchar NULL, switchschemename varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, vctrxnstatus varchar NULL, childordernumber varchar NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, bankname varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, vcfiller3 varchar NULL, mandatetype varchar NULL, mandatestatus varchar NULL, "token" int4 NULL, amccode varchar NULL, mandateamount numeric(24, 6) NULL, ispaused int4 NULL, istopup int4 NULL, vcclientname varchar NULL, exchangerefnumber varchar NULL, vcparentcode varchar NULL, schemetype varchar NULL, fromorderno varchar NULL, toorderno varchar NULL, trxntime time NULL, pauseflag varchar(1) NULL, pauseminimuminstallments int4 NULL, pausemaximuminstallments int4 NULL, pausemodificationcount int4 NULL, topuptype varchar NULL, topupcount int4 NULL, pausecount int4 NULL, mainsipregno varchar NULL, modifytype varchar NULL, modifycount int4 NULL);
CREATE INDEX idx_stporder_txnid ON transactions.stg_dion_stporder USING btree (txnid);

-- Permissions

ALTER TABLE transactions.stg_dion_stporder OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_stporder TO cmotswrite;


-- transactions.stg_dion_stpsubsequentorder definition

-- Drop table

-- DROP TABLE transactions.stg_dion_stpsubsequentorder;

CREATE TABLE transactions.stg_dion_stpsubsequentorder ( txndate varchar NULL, txnid varchar NULL, amcname varchar NULL, isin varchar NULL, schemename varchar NULL, status varchar NULL, amount varchar NULL, txntype varchar NULL, schemecode varchar NULL, folionumber varchar NULL, remarks varchar NULL, arn varchar NULL, subbrokercode varchar NULL, ordertype varchar NULL, navdate varchar NULL, fundtype varchar NULL, "token" varchar NULL, exchangerefno varchar NULL, ifsc varchar NULL, accountnumber varchar NULL, bankname varchar NULL, clientcode varchar NULL, settlementtype varchar NULL, dpc varchar NULL, transactiontime varchar NULL, allottedunit varchar NULL, poa varchar NULL, currentnav varchar NULL, euinflag varchar NULL, vcclientname varchar NULL, traxmode varchar NULL, paymenttime varchar NULL, lastmodifiedon varchar NULL, lastmodifiedby varchar NULL, ordersource varchar NULL, euinnumber varchar NULL, orderedby varchar NULL, ordernav varchar NULL, ordernavdate varchar NULL, units varchar NULL, genratetoday varchar NULL, startdate varchar NULL, enddate varchar NULL, sipfrequency varchar NULL, tenure varchar NULL, switchfromisin varchar NULL, switch_to_status varchar NULL, switch_from_status varchar NULL, switch_to_amount varchar NULL, switch_from_amount varchar NULL, switch_to_scheme varchar NULL, switch_from_scheme varchar NULL, checkholdings varchar NULL, switchtoisin varchar NULL, instalments_paid varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_stpsubsequentorder OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_stpsubsequentorder TO cmotswrite;


-- transactions.stg_dion_swp_due_report definition

-- Drop table

-- DROP TABLE transactions.stg_dion_swp_due_report;

CREATE TABLE transactions.stg_dion_swp_due_report ( membercode varchar NULL, clientcode varchar NULL, clientname varchar NULL, internalrefno varchar NULL, swpregno varchar NULL, regdate varchar NULL, amcname varchar NULL, schemecode varchar NULL, schemename varchar NULL, frequencytype varchar NULL, installmentamt varchar NULL, duedate varchar NULL, prevpaiddate varchar NULL, no_ofinstallmentspaid varchar NULL, totalinstallmentamtsold varchar NULL, entryby varchar NULL, dptrans varchar NULL, firstorderflag varchar NULL, txntype varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_dion_swp_due_report OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_swp_due_report TO cmotswrite;


-- transactions.stg_dion_swporder definition

-- Drop table

-- DROP TABLE transactions.stg_dion_swporder;

CREATE TABLE transactions.stg_dion_swporder ( sipregdate date NULL, siporderno int8 NULL, txnid int8 NULL, sipregno int8 NULL, clientcode varchar NULL, schemename varchar NULL, txntype varchar NULL, amount numeric(24, 6) NULL, sipstartdate date NULL, sipenddate date NULL, foliono varchar NULL, status varchar NULL, orderedby varchar NULL, schemecode varchar NULL, isin varchar NULL, frequency varchar NULL, totalinstalments varchar NULL, instalementspaid varchar NULL, instalmentspending int4 NULL, mandateid varchar NULL, reinvestmentflag varchar(4) NULL, nav numeric(24, 6) NULL, mfimfdflag varchar NULL, modelportfolioname varchar NULL, remarks varchar NULL, vaildcount int4 NULL, invaildcount int4 NULL, amcname varchar NULL, euinnumber varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, rmcode varchar NULL, units numeric(24, 6) NULL, sipcancellationdate date NULL, dpc varchar(1) NULL, firstordertoday varchar(1) NULL, euindecl varchar(1) NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, switchisin varchar NULL, switchschemename varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, vctrxnstatus varchar NULL, childordernumber varchar NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, bankname varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, vcfiller3 varchar NULL, mandatetype varchar NULL, mandatestatus varchar NULL, "token" int4 NULL, amccode varchar NULL, mandateamount numeric(24, 6) NULL, ispaused int4 NULL, istopup int4 NULL, vcclientname varchar NULL, exchangerefnumber varchar NULL, vcparentcode varchar NULL, schemetype varchar NULL, fromorderno varchar NULL, toorderno varchar NULL, trxntime time NULL, pauseflag varchar(1) NULL, pauseminimuminstallments int4 NULL, pausemaximuminstallments int4 NULL, pausemodificationcount int4 NULL, topuptype varchar NULL, topupcount int4 NULL, pausecount int4 NULL, mainsipregno varchar NULL, modifytype varchar NULL, modifycount int4 NULL);
CREATE INDEX idx_swporder_txnid ON transactions.stg_dion_swporder USING btree (txnid);

-- Permissions

ALTER TABLE transactions.stg_dion_swporder OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_dion_swporder TO cmotswrite;


-- transactions.stg_mf_client_holdings_external definition

-- Drop table

-- DROP TABLE transactions.stg_mf_client_holdings_external;

CREATE TABLE transactions.stg_mf_client_holdings_external ( sync_id int4 NULL, pan varchar NULL, amcname varchar NULL, folio varchar NULL, schemecode varchar NULL, schemename varchar NULL, schemeoption varchar NULL, assetype varchar NULL, schemetype varchar NULL, nav numeric(18, 4) NULL, navdate date NULL, closingbalance numeric(18, 4) NULL, avlunits numeric(18, 4) NULL, avlamt numeric(18, 2) NULL, currentmarketvalue numeric(18, 2) NULL, costvalue numeric(18, 2) NULL, gainloss numeric(18, 2) NULL, gainlosspercentage numeric(18, 2) NULL, isin varchar NULL, decimalunits int4 NULL, decimalamt int4 NULL, decimalnav int4 NULL, isdemat varchar NULL, planmode varchar NULL, nomineestatus varchar NULL, brokercode varchar NULL, brokername varchar NULL, rtaname varchar NULL, mobile varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_mf_client_holdings_external OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.stg_mf_client_holdings_external TO cmotswrite;


-- transactions.stg_mf_mandate definition

-- Drop table

-- DROP TABLE transactions.stg_mf_mandate;

CREATE TABLE transactions.stg_mf_mandate ( id serial4 NOT NULL, mandateid varchar NOT NULL, ac_code varchar(20) NULL, acname varchar NULL, mandate_type bpchar(1) NULL, amount numeric(18, 2) NULL, start_date date NULL, end_date date NULL, bankname varchar(100) NULL, bank_ac_number varchar(50) NULL, ifsc_code varchar(11) NULL, status varchar(50) NULL, created_date timestamp NULL, modified_date timestamp NULL, trx_source varchar NULL, ucccode varchar NULL, client_owner varchar(200) NULL, upccode varchar(200) NULL, partner_code varchar(200) NULL, remarks varchar NULL, created_for varchar NULL, created_for_type varchar NULL, created_for_name varchar NULL, CONSTRAINT mandateid_pk_stg PRIMARY KEY (mandateid), CONSTRAINT unique_mandateid_bankno_stg UNIQUE (mandateid, bank_ac_number));
CREATE INDEX idx_mandate ON transactions.stg_mf_mandate USING btree (mandateid);

-- Permissions

ALTER TABLE transactions.stg_mf_mandate OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_mf_mandate TO cmotswrite;


-- transactions.stg_mf_order_detail definition

-- Drop table

-- DROP TABLE transactions.stg_mf_order_detail;

CREATE TABLE transactions.stg_mf_order_detail ( id bigserial NOT NULL, logintype varchar NULL, ucccode varchar NULL, ac_code varchar NULL, orderby varchar NULL, isincode varchar NULL, mf_schcode int8 NULL, trx_type varchar NULL, trx_amt numeric NULL, trx_qty numeric NULL, trx_source varchar NULL, order_nav numeric NULL, order_navdate date NULL, order_type varchar NULL, qty_or_amt_order varchar NULL, physicalflag varchar NULL, "token" int8 NULL, is_draft int4 NULL, folio_no varchar NULL, frequency varchar NULL, start_day bpchar(1) NULL, start_date date NULL, end_date date NULL, no_of_installment int4 NULL, delivery_mode varchar NULL, mandate_id varchar NULL, trx_status varchar NULL, modified_by varchar NULL, euinnumber varchar NULL, switch_isin varchar NULL, switch_grpcode varchar NULL, reinvestmentflag varchar NULL, mfimfdflag varchar NULL, mandate_amt numeric NULL, installment_type varchar NULL, is_generatetoday bool NULL, created_date timestamp NULL, modified_date timestamp NULL, rm_partner_code varchar NULL, error_validation varchar NULL, CONSTRAINT stg_mf_order_detail_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE transactions.stg_mf_order_detail OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_mf_order_detail TO cmotswrite;


-- transactions.stg_optimum_mandate definition

-- Drop table

-- DROP TABLE transactions.stg_optimum_mandate;

CREATE TABLE transactions.stg_optimum_mandate ( id int4 NULL, mandateid varchar(50) NULL, clientcode varchar(50) NULL, clientname varchar(255) NULL, filler1 varchar(50) NULL, filler2 varchar(50) NULL, amount numeric(18, 2) NULL, modeofpayment varchar(50) NULL, bankname varchar(255) NULL, branch varchar(255) NULL, filler3 varchar(50) NULL, filler4 varchar(50) NULL, filler5 varchar(50) NULL, mandatetype varchar(50) NULL, mandatetypenew varchar(50) NULL, filler6 varchar(50) NULL, mandatedate date NULL, creationtime time NULL, memberid varchar(50) NULL, status varchar(255) NULL, remarks varchar(255) NULL, createdby varchar(50) NULL, createdon date NULL, updatedby varchar(50) NULL, updatedon date NULL, pdfcontent varchar(50) NULL, approveddate date NULL, accountnumber varchar(50) NULL, ifsccode varchar(11) NULL, mandatemode varchar(50) NULL, dateofreceived date NULL, clientstatus varchar(255) NULL, remark varchar NULL, scanmandatestatus varchar(255) NULL, scanmandateremarks varchar(255) NULL, clientname2 varchar(255) NULL, clientname3 varchar(255) NULL, scanuploadtime time NULL, rmcodescan varchar(50) NULL, subbrokercode varchar(50) NULL, schemetype varchar(50) NULL);

-- Permissions

ALTER TABLE transactions.stg_optimum_mandate OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_optimum_mandate TO cmotswrite;


-- transactions.stg_optimum_orderbook definition

-- Drop table

-- DROP TABLE transactions.stg_optimum_orderbook;

CREATE TABLE transactions.stg_optimum_orderbook ( txndate date NULL, txnid int8 NULL, clientcode varchar NULL, clientname varchar NULL, schemename varchar NULL, txntype varchar NULL, "option" varchar NULL, nav numeric(24, 6) NULL, navdate date NULL, units numeric(24, 6) NULL, amount numeric(24, 6) NULL, closeaccountflag varchar(1) NULL, exchangerefno int8 NULL, status varchar NULL, startday int4 NULL, startdate date NULL, enddate date NULL, sipfrequency varchar NULL, foliono varchar NULL, genratetoday varchar(1) NULL, isspread varchar(1) NULL, dpc varchar(1) NULL, physicalflag varchar(3) NULL, redeemdate date NULL, redeemamount numeric(24, 6) NULL, orderremarks varchar NULL, ordersource varchar NULL, tenure int4 NULL, mandateid varchar NULL, orderedby varchar NULL, "mode" varchar NULL, validatemargin varchar NULL, brokerrefno varchar NULL, limitvalidation varchar NULL, checkholdings varchar NULL, "token" int4 NULL, isin varchar NULL, schemecode varchar NULL, switchisin varchar NULL, switchschemecode varchar NULL, minredeemflag varchar NULL, clientid int8 NULL, rntschemecode varchar NULL, euinflag varchar NULL, termcondtion varchar NULL, modelportfolioname varchar NULL, mfimfdflag varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, ordertype varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, amcname varchar NULL, shorttxntype varchar NULL, euinnumber varchar NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, paymentstatus varchar NULL, paymenttime timestamp NULL, switchtoken int4 NULL, switchscheme varchar NULL, rmcode varchar NULL, amoindicator varchar NULL, lastmodifiedby varchar NULL, lastmodifiedon date NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, childordernumber varchar NULL, mandatetype varchar NULL, bank varchar NULL, vcfiller3 varchar NULL, paymentrejection int4 NULL, vcparentcode varchar NULL, schemetype varchar NULL, pledgeqty numeric(24, 6) NULL, paymentremarks varchar NULL, vcchequenumber varchar NULL, vcchequebank varchar NULL, vcbankbranch varchar NULL, txntime varchar NULL, reqid varchar NULL, bolischequeentry varchar NULL, slipchequedate varchar NULL, upiid varchar NULL, pgrefno varchar NULL, omobile varchar NULL, omail varchar NULL, vendortype varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_optimum_orderbook OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_optimum_orderbook TO cmotswrite;


-- transactions.stg_optimum_sip_due_report definition

-- Drop table

-- DROP TABLE transactions.stg_optimum_sip_due_report;

CREATE TABLE transactions.stg_optimum_sip_due_report ( sid int4 NULL, memcd varchar(255) NULL, clientcode varchar(255) NULL, clientname varchar(255) NULL, internalrefno varchar(255) NULL, sipregnnumber varchar(255) NULL, regndate date NULL, amcname varchar(255) NULL, schemecode varchar(255) NULL, schemename varchar(255) NULL, frequencytype varchar(255) NULL, installmentamt numeric(10, 2) NULL, duedate date NULL, prevpaiddate date NULL, noofinstallmentspaid int4 NULL, totalinstallmentamtpaid numeric(10, 2) NULL, entryby varchar(255) NULL, mandateid varchar(255) NULL, schtype bpchar(1) NULL, dptrans bpchar(1) NULL, firstordertoday int4 NULL, createdby varchar(255) NULL, createdon timestamp NULL, clientid varchar(255) NULL, clientmode varchar(255) NULL, userid varchar(255) NULL, usertype varchar(255) NULL, traxmode varchar(255) NULL, mfimfdflag varchar(255) NULL, txntype varchar(255) NULL);

-- Permissions

ALTER TABLE transactions.stg_optimum_sip_due_report OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_optimum_sip_due_report TO cmotswrite;


-- transactions.stg_optimum_siporder definition

-- Drop table

-- DROP TABLE transactions.stg_optimum_siporder;

CREATE TABLE transactions.stg_optimum_siporder ( sipregdate date NULL, siporderno int8 NULL, txnid int8 NULL, sipregno int8 NULL, clientcode varchar NULL, schemename varchar NULL, txntype varchar NULL, amount numeric(24, 6) NULL, sipstartdate date NULL, sipenddate date NULL, foliono varchar NULL, status varchar NULL, orderedby varchar NULL, schemecode varchar NULL, isin varchar NULL, frequency varchar NULL, totalinstalments int4 NULL, instalementspaid int4 NULL, instalmentspending int4 NULL, mandateid varchar NULL, reinvestmentflag varchar(4) NULL, nav numeric(24, 6) NULL, mfimfdflag varchar NULL, modelportfolioname varchar NULL, remarks varchar NULL, vaildcount int4 NULL, invaildcount int4 NULL, amcname varchar NULL, euinnumber varchar NULL, subbrokercode varchar NULL, arn varchar NULL, paymentmode varchar NULL, rmcode varchar NULL, units numeric(24, 6) NULL, sipcancellationdate date NULL, dpc varchar(1) NULL, firstordertoday varchar(1) NULL, euindecl varchar(1) NULL, traxmode varchar NULL, settlementtype varchar NULL, clientmode varchar NULL, userid varchar NULL, usertype varchar NULL, switchisin varchar NULL, switchschemename varchar NULL, ordernav numeric(24, 6) NULL, ordernavdate date NULL, vctrxnstatus varchar NULL, childordernumber varchar NULL, accountnumber varchar NULL, ifsc varchar NULL, bankcode varchar NULL, bankmode varchar NULL, bankname varchar NULL, inbatchid int4 NULL, insubbatchid int4 NULL, vcfiller3 varchar NULL, mandatetype varchar NULL, mandatestatus varchar NULL, "token" int4 NULL, amccode varchar NULL, mandateamount numeric(24, 6) NULL, ispaused int4 NULL, istopup int4 NULL, vcclientname varchar NULL, exchangerefnumber varchar NULL, vcparentcode varchar NULL, schemetype varchar NULL, fromorderno varchar NULL, toorderno varchar NULL, trxntime time NULL, pauseflag varchar(1) NULL, pauseminimuminstallments int4 NULL, pausemaximuminstallments int4 NULL, pausemodificationcount int4 NULL, topuptype varchar NULL, topupcount int4 NULL, pausecount int4 NULL, mainsipregno varchar NULL, modifytype varchar NULL, modifycount int4 NULL);

-- Permissions

ALTER TABLE transactions.stg_optimum_siporder OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_optimum_siporder TO cmotswrite;


-- transactions.stg_optimum_sipsubsequentorder definition

-- Drop table

-- DROP TABLE transactions.stg_optimum_sipsubsequentorder;

CREATE TABLE transactions.stg_optimum_sipsubsequentorder ( siporderno int8 NULL, clientcode varchar NULL, clientname varchar NULL, txntype varchar NULL, orderdate varchar NULL, amount numeric(12, 4) NULL, sipregdate varchar NULL, foliono varchar NULL, status varchar NULL, orderedby varchar NULL, sysrefno varchar NULL, schemecode varchar NULL, isin varchar NULL, frequency varchar NULL, mandateid int8 NULL, sipregno int8 NULL, clientid int8 NULL, remarks varchar NULL, sipstartdate varchar NULL, sipenddate varchar NULL, schemename varchar NULL, cancelallowed int4 NULL, paymentrejection int4 NULL, mfimfd varchar NULL, intrefno int8 NULL);

-- Permissions

ALTER TABLE transactions.stg_optimum_sipsubsequentorder OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_optimum_sipsubsequentorder TO cmotswrite;


-- transactions.stg_qrc_transaction definition

-- Drop table

-- DROP TABLE transactions.stg_qrc_transaction;

CREATE TABLE transactions.stg_qrc_transaction ( accode varchar NULL, subtypeid int4 NULL, subtypename varchar NULL, createddate varchar NULL, status varchar NULL, statusid int4 NULL, substatus varchar NULL, substatusid int4 NULL, "action" varchar NULL, operation varchar NULL, dealercode varchar NULL, refresh_date timestamp DEFAULT CURRENT_TIMESTAMP NULL);

-- Permissions

ALTER TABLE transactions.stg_qrc_transaction OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_qrc_transaction TO cmotswrite;


-- transactions.stg_rta_transferin_transactions definition

-- Drop table

-- DROP TABLE transactions.stg_rta_transferin_transactions;

CREATE TABLE transactions.stg_rta_transferin_transactions ( tranid int4 NULL, schemename varchar NULL, clientpan varchar NULL, transactiondate date NULL, posteddate date NULL, folionumber varchar NULL, units numeric(18, 4) NULL, amount numeric(18, 4) NULL, transactiondescription varchar NULL, isin varchar NULL, updatedtime timestamp(6) NULL, transactiontype varchar NULL);

-- Permissions

ALTER TABLE transactions.stg_rta_transferin_transactions OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.stg_rta_transferin_transactions TO cmotswrite;


-- transactions.order_consent definition

-- Drop table

-- DROP TABLE transactions.order_consent;

CREATE TABLE transactions.order_consent ( id bigserial NOT NULL, consent_id varchar NULL, trx_id int8 NOT NULL, category_code int4 NOT NULL, consent_created_datetime timestamp NOT NULL, consent_status varchar NULL, consent_expire_date timestamp NULL, consent_approval_reject_datetime timestamp NULL, resent_count int4 DEFAULT 0 NULL, consent_link text NULL, consent_type int4 NOT NULL, issent int4 NULL, ac_code varchar NULL, ac_name varchar NULL, client_email_id varchar NULL, client_mobile varchar NULL, cc_email varchar NULL, bcc_email varchar NULL, otp_id int8 NULL, retry_count int4 NULL, logged_in_approval bool DEFAULT false NULL, inv_action_code int4 NULL, CONSTRAINT order_consent_pk PRIMARY KEY (trx_id, category_code, consent_created_datetime, consent_type), CONSTRAINT uk_order_consent UNIQUE (id), CONSTRAINT fk_order_consent FOREIGN KEY (otp_id) REFERENCES transactions.otp(otp_id));
CREATE INDEX idx_trx_id_action_code ON transactions.order_consent USING btree (trx_id, inv_action_code);

-- Permissions

ALTER TABLE transactions.order_consent OWNER TO cmotswrite;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.order_consent TO cmotswrite WITH GRANT OPTION;
GRANT TRUNCATE, INSERT, TRIGGER, SELECT, REFERENCES, DELETE, UPDATE ON TABLE transactions.order_consent TO appadmin;
GRANT SELECT ON TABLE transactions.order_consent TO cmotsread WITH GRANT OPTION;


-- transactions.mv_client_holding source

CREATE MATERIALIZED VIEW transactions.mv_client_holding
TABLESPACE pg_default
AS SELECT DISTINCT hol.holdingdate,
    hol.isincode,
    hol.isinname,
    hol.totalqty,
    hol.longtermqty,
    hol.shorttermqty,
    hol.foliotype,
    hol.display_foliono,
    hol.ucccode,
    hol.foliono,
    ucc.dp_flag,
    ucc.priority_ac_code,
    '2 Working days'::character varying AS redemptiontime,
    hol.category_code,
        CASE
            WHEN ucc.dp_flag::text = 'DP'::text AND (hol.foliotype::text = ANY (ARRAY['Demat'::character varying::text, 'Physical'::character varying::text])) THEN true
            WHEN ucc.dp_flag::text = 'D'::text AND hol.foliotype::text = 'Demat'::text THEN true
            WHEN ucc.dp_flag::text = 'P'::text AND hol.foliotype::text = 'Physical'::text THEN true
            ELSE false
        END AS redeem_allowed,
    trunc(nav.ltp::text::numeric, 3) AS nav,
    trunc(((trunc(nav.ltp::text::numeric, 3) * hol.totalqty)::text)::numeric, 4) AS marketvalue,
    isin.mf_schcode,
    hol.freeqty,
    NULL::date AS initial_purchase_date,
        CASE
            WHEN hol.category_code = 261 AND b.redeemflag::text = 'N'::text THEN 'Client is not allowed to sell MF due to missing POA/DDPI. Please enable the same to redeem MF'::text
            ELSE ''::text
        END AS remarks,
        CASE
            WHEN c.is_ap_allowed::text = 'N'::text THEN 'N'::text
            ELSE 'Y'::text
        END::character varying AS is_ap_allowed,
    isin.amccode
   FROM ( SELECT a.holdingdate,
            a.isin AS isincode,
            a.security AS isinname,
            COALESCE(b_1.totalqty, a.totalqty) AS totalqty,
            COALESCE(b_1.longtermqty, 0.000) AS longtermqty,
            COALESCE(b_1.shorttermqty, 0.000) AS shorttermqty,
            'Demat'::character varying AS foliotype,
            COALESCE(b_1.display_foliono, '999999'::character varying) AS display_foliono,
            a.ucccode,
            COALESCE(b_1.foliono, '999999'::character varying::text) AS foliono,
            COALESCE(c_1.freeqty, 0.000) AS freeqty,
            261 AS category_code
           FROM platform_reporting.holdingsummary a
             LEFT JOIN ( SELECT a_1.holdingdate,
                    a_1.isincode,
                    a_1.isinname,
                    a_1.totalqty,
                    a_1.longtermqty,
                    a_1.shorttermqty,
                    a_1.foliotype,
                    COALESCE(c_1_1.display_foliono, '999999'::character varying) AS display_foliono,
                    a_1.ucccode,
                    c_1_1.foliono
                   FROM ( SELECT a_1_1.holdingdate,
                            ucc_1.ucccode,
                            a_1_1.isin AS isincode,
                            a_1_1.schemename AS isinname,
                            sum(trunc(a_1_1.quantity::text::numeric, 3)) AS totalqty,
                            sum(trunc(a_1_1.longtermquantity::text::numeric, 3)) AS longtermqty,
                            sum(trunc(a_1_1.shorttermquantity::text::numeric, 3)) AS shorttermqty,
                            a_1_1.foliotype
                           FROM transactions.mf_holding a_1_1
                             JOIN master.dim_ucc ucc_1 ON a_1_1.investorpan::text = ucc_1.pan::text
                          WHERE a_1_1.foliotype::text = 'Demat'::text
                          GROUP BY a_1_1.holdingdate, ucc_1.ucccode, a_1_1.isin, a_1_1.schemename, a_1_1.foliotype) a_1
                     LEFT JOIN ( SELECT t.holdingdate,
                            t.ucccode,
                            t.isincode,
                            t.display_foliono,
                            t.foliono
                           FROM ( SELECT a_1_1.holdingdate,
                                    a_1_1.ucccode,
                                    a_1_1.isincode,
                                    a_1_1.folionumber AS display_foliono,
                                    split_part(a_1_1.folionumber::text, '/'::text, 1) AS foliono,
                                    row_number() OVER (PARTITION BY a_1_1.ucccode, a_1_1.isincode ORDER BY a_1_1.folionumber DESC) AS rnk
                                   FROM ( SELECT a_2.holdingdate,
    ucc_1.ucccode,
    a_2.isin AS isincode,
    a_2.folionumber,
    a_2.foliotype
   FROM transactions.mf_holding a_2
     JOIN master.dim_ucc ucc_1 ON a_2.investorpan::text = ucc_1.pan::text
  WHERE a_2.foliotype::text = 'Demat'::text) a_1_1
                                  WHERE a_1_1.foliotype::text = 'Demat'::text) t
                          WHERE t.rnk = 1) c_1_1 ON a_1.ucccode::text = c_1_1.ucccode::text AND a_1.isincode::text = c_1_1.isincode::text) b_1 ON a.ucccode::text = b_1.ucccode::text AND a.isin::text = b_1.isincode::text
             LEFT JOIN transactions.mf_clientholding_bsemforder c_1 ON a.ucccode::text = c_1.accountcode::text AND a.isin::text = c_1.isincode::text
          WHERE (a.assetclassid = ANY (ARRAY[3, 12, 29, 48])) AND a.holdingtype::text = ''::text
        UNION ALL
         SELECT a.holdingdate,
            a.isin AS isincode,
            a.schemename AS isinname,
            trunc(a.quantity::text::numeric, 3) AS totalqty,
            trunc(a.longtermquantity::text::numeric, 3) AS longtermqty,
            trunc(a.shorttermquantity::text::numeric, 3) AS shorttermqty,
            a.foliotype,
            a.folionumber AS display_foliono,
            ucc_1.ucccode,
            split_part(a.folionumber::text, '/'::text, 1) AS foliono,
            trunc(a.quantity::text::numeric, 3) AS freeqty,
            261 AS category_code
           FROM transactions.mf_holding a
             JOIN master.dim_ucc ucc_1 ON a.investorpan::text = ucc_1.pan::text
          WHERE a.foliotype::text = 'Physical'::text) hol
     LEFT JOIN ( SELECT DISTINCT holdingsummary.isin,
            holdingsummary.ltp
           FROM platform_reporting.holdingsummary
          WHERE holdingsummary.assetclassid = ANY (ARRAY[3, 12, 29, 48])) nav ON hol.isincode::text = nav.isin::text
     LEFT JOIN master.dim_ucc ucc ON hol.ucccode::text = ucc.ucccode::text
     LEFT JOIN master.dim_mf_isin isin ON hol.isincode::text = isin.isincode::text
     LEFT JOIN master.vw_mf_client_dp_status b ON ucc.priority_ac_code::text = b.ac_code::text
     LEFT JOIN master.dim_mf_check_ap_allowed c ON hol.display_foliono::text = c.foliono::text
UNION ALL
 SELECT a.aumdate::date AS holdingdate,
    a.scheme_id::character varying AS isincode,
    a.productname AS isinname,
    a.units::numeric AS totalqty,
    NULL::numeric AS longtermqty,
    NULL::numeric AS shorttermqty,
    'Demat'::character varying AS foliotype,
    a.folio AS display_foliono,
    u.ucccode,
    a.folio AS foliono,
    u.dp_flag,
    u.priority_ac_code,
    a.redemptiontime,
    a.category_code,
    NULL::boolean AS redeem_allowed,
    a.nav::numeric AS nav,
    a.currentvalue::numeric AS marketvalue,
    NULL::bigint AS mf_schcode,
    NULL::numeric AS freeqty,
    a.initial_purchase_date,
    NULL::text AS remarks,
    NULL::text AS is_ap_allowed,
    NULL::character varying AS amccode
   FROM aif_pms.aif_pms_folio a
     JOIN master.dim_ucc u ON upper(a.pan::text) = upper(u.pan::text)
WITH DATA;

-- Permissions

ALTER TABLE transactions.mv_client_holding OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mv_client_holding TO cmotswrite;


-- transactions.mv_client_holding_bkp_16nov2025 source

CREATE MATERIALIZED VIEW transactions.mv_client_holding_bkp_16nov2025
TABLESPACE pg_default
AS SELECT a.holdingdate,
    a.isincode,
    a.isinname,
    a.totalqty,
    a.longtermqty,
    a.shorttermqty,
    a.foliotype,
    a.display_foliono,
    a.ucccode,
    a.foliono,
    a.dp_flag,
    a.priority_ac_code,
    a.redemptiontime,
    a.category_code,
    a.redeem_allowed,
    a.nav,
    a.marketvalue,
    a.mf_schcode,
    a.freeqty,
    NULL::date AS initial_purchase_date,
        CASE
            WHEN a.category_code = 261 AND b.redeemflag::text = 'N'::text THEN 'Client is not allowed to sell MF due to missing POA/DDPI. Please enable the same to redeem MF'::text
            ELSE ''::text
        END AS remarks,
        CASE
            WHEN c.is_ap_allowed::text = 'N'::text THEN 'N'::text
            ELSE 'Y'::text
        END::character varying AS is_ap_allowed
   FROM ( SELECT a_1.holdingdate,
            a_1.isincode,
            a_1.isinname,
            sum(a_1.totalqty) AS totalqty,
            sum(a_1.longtermqty) AS longtermqty,
            sum(a_1.shorttermqty) AS shorttermqty,
            a_1.foliotype,
            a_1.display_foliono,
            a_1.ucccode,
            a_1.foliono,
            a_1.dp_flag,
            a_1.priority_ac_code,
            '2 Working days'::character varying AS redemptiontime,
            261 AS category_code,
                CASE
                    WHEN a_1.dp_flag::text = 'DP'::text AND (a_1.foliotype::text = ANY (ARRAY['Demat'::character varying::text, 'Physical'::character varying::text])) THEN true
                    WHEN a_1.dp_flag::text = 'D'::text AND a_1.foliotype::text = 'Demat'::text THEN true
                    WHEN a_1.dp_flag::text = 'P'::text AND a_1.foliotype::text = 'Physical'::text THEN true
                    ELSE false
                END AS redeem_allowed,
            a_1.ltp::numeric(15,4) AS nav,
            (a_1.ltp * sum(a_1.totalqty))::numeric(18,4) AS marketvalue,
            a_1.mf_schcode,
            sum(a_1.freeqty) AS freeqty
           FROM ( SELECT a_1_1.holdingdate,
                    a_1_1.isin AS isincode,
                    a_1_1.schemename AS isinname,
                    a_1_1.quantity::numeric(15,4) AS totalqty,
                    a_1_1.longtermquantity::numeric(15,4) AS longtermqty,
                    a_1_1.shorttermquantity::numeric(15,4) AS shorttermqty,
                    a_1_1.foliotype,
                    a_1_1.folionumber AS display_foliono,
                    c_1.ucccode,
                    split_part(a_1_1.folionumber::text, '/'::text, 1) AS foliono,
                    c_1.dp_flag,
                    c_1.priority_ac_code,
                    isin.mf_schcode,
                        CASE
                            WHEN hol.holdingtype = 'Demat'::text THEN hol.freeqty::numeric(15,4)
                            WHEN hol.holdingtype = 'Physical'::text THEN a_1_1.quantity::numeric(15,4)
                            ELSE hol.freeqty
                        END AS freeqty,
                    COALESCE(hol.ltp, 0.00) AS ltp
                   FROM transactions.mf_holding a_1_1
                     JOIN ( SELECT dim_customer.ac_code,
                            dim_customer.pan,
                            dim_customer.accountclosedate
                           FROM master.dim_customer
                          WHERE dim_customer.ac_type::text = 'EQ'::text AND dim_customer.accountclosedate IS NULL
                        UNION ALL
                         SELECT DISTINCT regexp_replace(dim_customer.ac_code::text, '(B|C|F)$'::text, ''::text, 'i'::text) AS ac_code,
                            dim_customer.pan,
                            dim_customer.accountclosedate
                           FROM master.dim_customer
                          WHERE dim_customer.ac_type::text = 'INV'::text AND dim_customer.accountclosedate IS NULL) b_1 ON a_1_1.accountcode::text = b_1.ac_code::text AND a_1_1.investorpan::text = b_1.pan::text
                     JOIN master.dim_ucc c_1 ON a_1_1.investorpan::text = c_1.pan::text
                     LEFT JOIN master.dim_mf_isin isin ON a_1_1.isin::text = isin.isincode::text
                     LEFT JOIN ( SELECT holdingsummary.accountcode,
                            holdingsummary.isin,
                            holdingsummary.freeqty,
                            holdingsummary.ltp,
                                CASE
                                    WHEN holdingsummary.holdingtype::text = ''::text THEN 'Demat'::text
                                    ELSE 'Physical'::text
                                END AS holdingtype,
                            holdingsummary.totalqty
                           FROM platform_reporting.holdingsummary
                          WHERE holdingsummary.assetclassid = ANY (ARRAY[3, 12, 48])) hol ON a_1_1.accountcode::text = hol.accountcode::text AND a_1_1.isin::text = hol.isin::text AND a_1_1.foliotype::text = hol.holdingtype) a_1
          WHERE COALESCE(a_1.isincode, ''::character varying)::text <> ''::text
          GROUP BY a_1.holdingdate, a_1.isincode, a_1.isinname, a_1.foliotype, a_1.display_foliono, a_1.ucccode, a_1.foliono, a_1.dp_flag, a_1.priority_ac_code, a_1.mf_schcode, a_1.ltp
        UNION ALL
         SELECT a_1.holdingdate,
            a_1.isincode,
            a_1.isinname,
            a_1.totalqty,
            a_1.longtermqty,
            a_1.shorttermqty,
            a_1.foliotype,
            a_1.display_foliono,
            a_1.ucccode,
            a_1.foliono,
            a_1.dp_flag,
            a_1.priority_ac_code,
            a_1.redemptiontime,
            a_1.category_code,
                CASE
                    WHEN a_1.dp_flag::text = 'DP'::text AND (a_1.foliotype = ANY (ARRAY['Demat'::character varying::text, 'Physical'::character varying::text])) THEN true
                    WHEN a_1.dp_flag::text = 'D'::text AND a_1.foliotype = 'Demat'::text THEN true
                    WHEN a_1.dp_flag::text = 'P'::text AND a_1.foliotype = 'Physical'::text THEN true
                    ELSE false
                END AS redeem_allowed,
            a_1.nav,
            a_1.marketvalue,
            a_1.mf_schcode,
            a_1.freeqty
           FROM ( SELECT a_1_1.holdingdate,
                    a_1_1.isin AS isincode,
                    a_1_1.security AS isinname,
                    a_1_1.totalqty::numeric(15,4) AS totalqty,
                        CASE
                            WHEN a_1_1.longtermquantity = 0::numeric AND a_1_1.shorttermquantity = 0::numeric THEN 0::numeric
                            ELSE a_1_1.longtermquantity::numeric(15,4)
                        END::numeric(15,4) AS longtermqty,
                        CASE
                            WHEN a_1_1.longtermquantity = 0::numeric AND a_1_1.shorttermquantity = 0::numeric THEN a_1_1.totalqty::numeric(15,4)
                            ELSE a_1_1.shorttermquantity::numeric(15,4)
                        END AS shorttermqty,
                        CASE
                            WHEN a_1_1.holdingtype::text = ''::text THEN 'Demat'::text
                            WHEN a_1_1.holdingtype::text = 'P'::text THEN 'Physical'::text
                            ELSE ''::text
                        END AS foliotype,
                    '999999'::character varying AS display_foliono,
                    c_1.ucccode,
                    NULL::text AS foliono,
                    c_1.dp_flag,
                    c_1.priority_ac_code,
                    '2 Working days'::character varying AS redemptiontime,
                    261 AS category_code,
                    a_1_1.ltp::numeric(15,4) AS nav,
                    (a_1_1.ltp * a_1_1.totalqty)::numeric(18,4) AS marketvalue,
                    isin.mf_schcode,
                    a_1_1.freeqty
                   FROM platform_reporting.holdingsummary a_1_1
                     LEFT JOIN transactions.mf_holding b_1 ON a_1_1.accountcode::text = b_1.accountcode::text AND a_1_1.isin::text = b_1.isin::text
                     JOIN master.dim_ucc c_1 ON a_1_1.accountcode::text = c_1.priority_ac_code::text
                     LEFT JOIN master.dim_mf_isin isin ON a_1_1.isin::text = isin.isincode::text
                  WHERE b_1.accountcode IS NULL AND b_1.isin IS NULL AND (a_1_1.assetclassid = ANY (ARRAY[3, 12, 48])) AND a_1_1.holdingtype::text = ''::text) a_1) a
     LEFT JOIN master.vw_mf_client_dp_status b ON a.priority_ac_code::text = b.ac_code::text
     LEFT JOIN master.dim_mf_check_ap_allowed c ON a.display_foliono::text = c.foliono::text
UNION ALL
 SELECT a.aumdate::date AS holdingdate,
    a.scheme_id::character varying AS isincode,
    a.productname AS isinname,
    a.units::numeric AS totalqty,
    NULL::numeric AS longtermqty,
    NULL::numeric AS shorttermqty,
    'Demat'::character varying AS foliotype,
    a.folio AS display_foliono,
    u.ucccode,
    a.folio AS foliono,
    u.dp_flag,
    u.priority_ac_code,
    a.redemptiontime,
    a.category_code,
    NULL::boolean AS redeem_allowed,
    a.nav::numeric AS nav,
    a.currentvalue::numeric AS marketvalue,
    NULL::bigint AS mf_schcode,
    NULL::numeric AS freeqty,
    a.initial_purchase_date,
    NULL::text AS remarks,
    NULL::text AS is_ap_allowed
   FROM aif_pms.aif_pms_folio a
     JOIN master.dim_ucc u ON upper(a.pan::text) = upper(u.pan::text)
WITH DATA;

-- Permissions

ALTER TABLE transactions.mv_client_holding_bkp_16nov2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mv_client_holding_bkp_16nov2025 TO cmotswrite;


-- transactions.mv_client_holding_bkp_21052025 source

CREATE MATERIALIZED VIEW transactions.mv_client_holding_bkp_21052025
TABLESPACE pg_default
AS SELECT a.holdingdate,
    a.isincode,
    a.isinname,
    a.totalqty,
    a.longtermqty,
    a.shorttermqty,
    a.foliotype,
    a.display_foliono,
    a.ucccode,
    a.foliono,
    a.dp_flag,
    a.priority_ac_code,
    a.redemptiontime,
    a.category_code,
    a.redeem_allowed,
    a.nav,
    a.marketvalue,
    a.mf_schcode,
    a.freeqty,
        CASE
            WHEN a.category_code = 261 AND b.redeemflag::text = 'N'::text THEN 'Client is not allowed to sell MF due to missing POA/DDPI. Please enable the same to redeem MF'::text
            ELSE ''::text
        END AS remarks,
        CASE
            WHEN c.is_ap_allowed::text = 'N'::text THEN 'N'::text
            ELSE 'Y'::text
        END::character varying AS is_ap_allowed
   FROM ( SELECT a_1.holdingdate,
            a_1.isincode,
            a_1.isinname,
            sum(a_1.totalqty) AS totalqty,
            sum(a_1.longtermqty) AS longtermqty,
            sum(a_1.shorttermqty) AS shorttermqty,
            a_1.foliotype,
            a_1.display_foliono,
            a_1.ucccode,
            a_1.foliono,
            a_1.dp_flag,
            a_1.priority_ac_code,
            '2 Working days'::character varying AS redemptiontime,
            261 AS category_code,
                CASE
                    WHEN a_1.dp_flag::text = 'DP'::text AND (a_1.foliotype::text = ANY (ARRAY['Demat'::character varying::text, 'Physical'::character varying::text])) THEN true
                    WHEN a_1.dp_flag::text = 'D'::text AND a_1.foliotype::text = 'Demat'::text THEN true
                    WHEN a_1.dp_flag::text = 'P'::text AND a_1.foliotype::text = 'Physical'::text THEN true
                    ELSE false
                END AS redeem_allowed,
            a_1.ltp::numeric(15,4) AS nav,
            (a_1.ltp * sum(a_1.totalqty))::numeric(18,4) AS marketvalue,
            a_1.mf_schcode,
            sum(a_1.freeqty) AS freeqty
           FROM ( SELECT a_1_1.holdingdate,
                    a_1_1.isin AS isincode,
                    a_1_1.schemename AS isinname,
                    a_1_1.quantity::numeric(15,4) AS totalqty,
                    a_1_1.longtermquantity::numeric(15,4) AS longtermqty,
                    a_1_1.shorttermquantity::numeric(15,4) AS shorttermqty,
                    a_1_1.foliotype,
                    a_1_1.folionumber AS display_foliono,
                    c_1.ucccode,
                    replace(a_1_1.folionumber::text, '/'::text, ''::text) AS foliono,
                    c_1.dp_flag,
                    c_1.priority_ac_code,
                    isin.mf_schcode,
                        CASE
                            WHEN hol.holdingtype = 'Demat'::text THEN hol.freeqty::numeric(15,4)
                            WHEN hol.holdingtype = 'Physical'::text THEN a_1_1.quantity::numeric(15,4)
                            ELSE hol.freeqty
                        END AS freeqty,
                    COALESCE(hol.ltp, 0.00) AS ltp
                   FROM transactions.mf_holding a_1_1
                     JOIN ( SELECT dim_customer.ac_code,
                            dim_customer.pan,
                            dim_customer.accountclosedate
                           FROM master.dim_customer
                          WHERE dim_customer.ac_type::text = 'EQ'::text AND dim_customer.accountclosedate IS NULL
                        UNION ALL
                         SELECT DISTINCT regexp_replace(dim_customer.ac_code::text, '(B|C|F)$'::text, ''::text, 'i'::text) AS ac_code,
                            dim_customer.pan,
                            dim_customer.accountclosedate
                           FROM master.dim_customer
                          WHERE dim_customer.ac_type::text = 'INV'::text AND dim_customer.accountclosedate IS NULL) b_1 ON a_1_1.accountcode::text = b_1.ac_code::text AND a_1_1.investorpan::text = b_1.pan::text
                     JOIN master.dim_ucc c_1 ON a_1_1.investorpan::text = c_1.pan::text
                     LEFT JOIN master.dim_mf_isin isin ON a_1_1.isin::text = isin.isincode::text
                     LEFT JOIN ( SELECT holdingsummary.accountcode,
                            holdingsummary.isin,
                            holdingsummary.freeqty,
                            holdingsummary.ltp,
                                CASE
                                    WHEN holdingsummary.holdingtype::text = ''::text THEN 'Demat'::text
                                    ELSE 'Physical'::text
                                END AS holdingtype,
                            holdingsummary.totalqty
                           FROM platform_reporting.holdingsummary
                          WHERE holdingsummary.assetclassid = ANY (ARRAY[3, 12, 48])) hol ON a_1_1.accountcode::text = hol.accountcode::text AND a_1_1.isin::text = hol.isin::text AND a_1_1.foliotype::text = hol.holdingtype) a_1
          WHERE COALESCE(a_1.isincode, ''::character varying)::text <> ''::text
          GROUP BY a_1.holdingdate, a_1.isincode, a_1.isinname, a_1.foliotype, a_1.display_foliono, a_1.ucccode, a_1.foliono, a_1.dp_flag, a_1.priority_ac_code, a_1.mf_schcode, a_1.ltp
        UNION ALL
         SELECT a_1.holdingdate,
            a_1.isincode,
            a_1.isinname,
            a_1.totalqty,
            a_1.longtermqty,
            a_1.shorttermqty,
            a_1.foliotype,
            a_1.display_foliono,
            a_1.ucccode,
            a_1.foliono,
            a_1.dp_flag,
            a_1.priority_ac_code,
            a_1.redemptiontime,
            a_1.category_code,
                CASE
                    WHEN a_1.dp_flag::text = 'DP'::text AND (a_1.foliotype = ANY (ARRAY['Demat'::character varying::text, 'Physical'::character varying::text])) THEN true
                    WHEN a_1.dp_flag::text = 'D'::text AND a_1.foliotype = 'Demat'::text THEN true
                    WHEN a_1.dp_flag::text = 'P'::text AND a_1.foliotype = 'Physical'::text THEN true
                    ELSE false
                END AS redeem_allowed,
            a_1.nav,
            a_1.marketvalue,
            a_1.mf_schcode,
            a_1.freeqty
           FROM ( SELECT a_1_1.holdingdate,
                    a_1_1.isin AS isincode,
                    a_1_1.security AS isinname,
                    a_1_1.totalqty::numeric(15,4) AS totalqty,
                        CASE
                            WHEN a_1_1.longtermquantity = 0::numeric AND a_1_1.shorttermquantity = 0::numeric THEN 0::numeric
                            ELSE a_1_1.longtermquantity::numeric(15,4)
                        END::numeric(15,4) AS longtermqty,
                        CASE
                            WHEN a_1_1.longtermquantity = 0::numeric AND a_1_1.shorttermquantity = 0::numeric THEN a_1_1.totalqty::numeric(15,4)
                            ELSE a_1_1.shorttermquantity::numeric(15,4)
                        END AS shorttermqty,
                        CASE
                            WHEN a_1_1.holdingtype::text = ''::text THEN 'Demat'::text
                            WHEN a_1_1.holdingtype::text = 'P'::text THEN 'Physical'::text
                            ELSE ''::text
                        END AS foliotype,
                    '999999'::character varying AS display_foliono,
                    c_1.ucccode,
                    NULL::text AS foliono,
                    c_1.dp_flag,
                    c_1.priority_ac_code,
                    '2 Working days'::character varying AS redemptiontime,
                    261 AS category_code,
                    a_1_1.ltp::numeric(15,4) AS nav,
                    (a_1_1.ltp * a_1_1.totalqty)::numeric(18,4) AS marketvalue,
                    isin.mf_schcode,
                    a_1_1.freeqty
                   FROM platform_reporting.holdingsummary a_1_1
                     LEFT JOIN transactions.mf_holding b_1 ON a_1_1.accountcode::text = b_1.accountcode::text AND a_1_1.isin::text = b_1.isin::text
                     JOIN master.dim_ucc c_1 ON a_1_1.accountcode::text = c_1.priority_ac_code::text
                     LEFT JOIN master.dim_mf_isin isin ON a_1_1.isin::text = isin.isincode::text
                  WHERE b_1.accountcode IS NULL AND b_1.isin IS NULL AND (a_1_1.assetclassid = ANY (ARRAY[3, 12, 48])) AND a_1_1.holdingtype::text = ''::text) a_1
        UNION ALL
         SELECT '2024-12-20'::date AS holdingdate,
            '2299'::character varying AS isincode,
            'ICICI Prudential Equity Opportunities Fund  Series II'::character varying AS isinname,
            13.6270 AS totalqty,
            13.6270 AS longtermqty,
            0.0000 AS shorttermqty,
            'Demat'::character varying AS foliotype,
            '1045034590'::character varying AS display_foliono,
            'NW23386307'::character varying AS ucccode,
            '1045034590'::text AS foliono,
            'D'::character varying AS dp_flag,
            '60133064'::character varying AS priority_ac_code,
            '2 Working days'::character varying AS redemptiontime,
            293 AS category_code,
            true AS redeem_allowed,
            27.6370 AS nav,
            376.61 AS marketvalue,
            16850 AS mf_schcode,
            13.6270 AS freeqty
        UNION ALL
         SELECT '2024-12-20'::date AS holdingdate,
            '1031'::character varying AS isincode,
            'All Cap Portfolio'::character varying AS isinname,
            13.6270 AS totalqty,
            13.6270 AS longtermqty,
            0.0000 AS shorttermqty,
            'Demat'::character varying AS foliotype,
            '1045034590'::character varying AS display_foliono,
            'NW23386307'::character varying AS ucccode,
            '1045034590'::text AS foliono,
            'D'::character varying AS dp_flag,
            '60133064'::character varying AS priority_ac_code,
            '2 Working days'::character varying AS redemptiontime,
            268 AS category_code,
            true AS redeem_allowed,
            27.6370 AS nav,
            376.61 AS marketvalue,
            16850 AS mf_schcode,
            13.6270 AS freeqty) a
     LEFT JOIN master.vw_mf_client_dp_status b ON a.priority_ac_code::text = b.ac_code::text
     LEFT JOIN master.dim_mf_check_ap_allowed c ON a.display_foliono::text = c.foliono::text
WITH DATA;

-- Permissions

ALTER TABLE transactions.mv_client_holding_bkp_21052025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mv_client_holding_bkp_21052025 TO cmotswrite;


-- transactions.mv_client_holding_foliokra source

CREATE MATERIALIZED VIEW transactions.mv_client_holding_foliokra
TABLESPACE pg_default
AS SELECT a.holdingdate,
    a.ucccode,
    a.foliotype,
    a.display_foliono,
    a.foliono,
    sum(a.totalqty) AS totalqty,
    sum(a.marketvalue) AS marketvalue,
    a.amccode
   FROM transactions.mv_client_holding a
  GROUP BY a.holdingdate, a.ucccode, a.foliotype, a.display_foliono, a.foliono, a.amccode
WITH DATA;

-- Permissions

ALTER TABLE transactions.mv_client_holding_foliokra OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mv_client_holding_foliokra TO cmotswrite;


-- transactions.mv_client_holding_test source

CREATE MATERIALIZED VIEW transactions.mv_client_holding_test
TABLESPACE pg_default
AS SELECT DISTINCT hol.holdingdate,
    hol.isincode,
    hol.isinname,
    hol.totalqty,
    hol.longtermqty,
    hol.shorttermqty,
    hol.foliotype,
    hol.display_foliono,
    hol.ucccode,
    hol.foliono,
    ucc.dp_flag,
    ucc.priority_ac_code,
    '2 Working days'::character varying AS redemptiontime,
    hol.category_code,
        CASE
            WHEN ucc.dp_flag::text = 'DP'::text AND (hol.foliotype::text = ANY (ARRAY['Demat'::character varying::text, 'Physical'::character varying::text])) THEN true
            WHEN ucc.dp_flag::text = 'D'::text AND hol.foliotype::text = 'Demat'::text THEN true
            WHEN ucc.dp_flag::text = 'P'::text AND hol.foliotype::text = 'Physical'::text THEN true
            ELSE false
        END AS redeem_allowed,
    nav.ltp AS nav,
    trunc(((nav.ltp * hol.totalqty)::text)::numeric, 4) AS marketvalue,
    isin.mf_schcode,
    hol.freeqty,
    NULL::date AS initial_purchase_date,
        CASE
            WHEN hol.category_code = 261 AND b.redeemflag::text = 'N'::text THEN 'Client is not allowed to sell MF due to missing POA/DDPI. Please enable the same to redeem MF'::text
            ELSE ''::text
        END AS remarks,
        CASE
            WHEN c.is_ap_allowed::text = 'N'::text THEN 'N'::text
            ELSE 'Y'::text
        END::character varying AS is_ap_allowed
   FROM ( SELECT a.holdingdate,
            a.isincode,
            a.isinname,
            a.totalqty,
            a.longtermqty,
            a.shorttermqty,
            a.foliotype,
            COALESCE(c_1.display_foliono, '999999'::character varying) AS display_foliono,
            a.ucccode,
            c_1.foliono,
            COALESCE(b_1.freeqty, 0.000) AS freeqty,
            261 AS category_code
           FROM ( SELECT a_1.holdingdate,
                    ucc_1.ucccode,
                    a_1.isin AS isincode,
                    a_1.schemename AS isinname,
                    sum(trunc(a_1.quantity::text::numeric, 3)) AS totalqty,
                    sum(trunc(a_1.longtermquantity::text::numeric, 3)) AS longtermqty,
                    sum(trunc(a_1.shorttermquantity::text::numeric, 3)) AS shorttermqty,
                    a_1.foliotype
                   FROM transactions.mf_holding a_1
                     JOIN master.dim_ucc ucc_1 ON a_1.investorpan::text = ucc_1.pan::text
                  WHERE a_1.foliotype::text = 'Demat'::text
                  GROUP BY a_1.holdingdate, ucc_1.ucccode, a_1.isin, a_1.schemename, a_1.foliotype) a
             LEFT JOIN transactions.mf_clientholding_bsemforder b_1 ON a.ucccode::text = b_1.accountcode::text AND a.isincode::text = b_1.isincode::text
             LEFT JOIN ( SELECT t.holdingdate,
                    t.ucccode,
                    t.isincode,
                    t.display_foliono,
                    t.foliono
                   FROM ( SELECT a_1.holdingdate,
                            a_1.ucccode,
                            a_1.isincode,
                            a_1.folionumber AS display_foliono,
                            split_part(a_1.folionumber::text, '/'::text, 1) AS foliono,
                            row_number() OVER (PARTITION BY a_1.ucccode, a_1.isincode ORDER BY a_1.folionumber DESC) AS rnk
                           FROM ( SELECT a_2.holdingdate,
                                    ucc_1.ucccode,
                                    a_2.isin AS isincode,
                                    a_2.folionumber,
                                    a_2.foliotype
                                   FROM transactions.mf_holding a_2
                                     JOIN master.dim_ucc ucc_1 ON a_2.investorpan::text = ucc_1.pan::text
                                  WHERE a_2.foliotype::text = 'Demat'::text) a_1
                          WHERE a_1.foliotype::text = 'Demat'::text) t
                  WHERE t.rnk = 1) c_1 ON a.ucccode::text = c_1.ucccode::text AND a.isincode::text = c_1.isincode::text
        UNION ALL
         SELECT a.holdingdate,
            a.isin AS isincode,
            a.schemename AS isinname,
            trunc(a.quantity::text::numeric, 3) AS totalqty,
            trunc(a.longtermquantity::text::numeric, 3) AS longtermqty,
            trunc(a.shorttermquantity::text::numeric, 3) AS shorttermqty,
            a.foliotype,
            a.folionumber AS display_foliono,
            ucc_1.ucccode,
            split_part(a.folionumber::text, '/'::text, 1) AS foliono,
            trunc(a.quantity::text::numeric, 3) AS freeqty,
            261 AS category_code
           FROM transactions.mf_holding a
             JOIN master.dim_ucc ucc_1 ON a.investorpan::text = ucc_1.pan::text
          WHERE a.foliotype::text = 'Physical'::text) hol
     LEFT JOIN ( SELECT DISTINCT holdingsummary.isin,
            holdingsummary.ltp
           FROM platform_reporting.holdingsummary
          WHERE holdingsummary.assetclassid = ANY (ARRAY[3, 12, 29, 48])) nav ON hol.isincode::text = nav.isin::text
     LEFT JOIN master.dim_ucc ucc ON hol.ucccode::text = ucc.ucccode::text
     LEFT JOIN master.dim_mf_isin isin ON hol.isincode::text = isin.isincode::text
     LEFT JOIN master.vw_mf_client_dp_status b ON ucc.priority_ac_code::text = b.ac_code::text
     LEFT JOIN master.dim_mf_check_ap_allowed c ON hol.display_foliono::text = c.foliono::text
UNION ALL
 SELECT a.aumdate::date AS holdingdate,
    a.scheme_id::character varying AS isincode,
    a.productname AS isinname,
    a.units::numeric AS totalqty,
    NULL::numeric AS longtermqty,
    NULL::numeric AS shorttermqty,
    'Demat'::character varying AS foliotype,
    a.folio AS display_foliono,
    u.ucccode,
    a.folio AS foliono,
    u.dp_flag,
    u.priority_ac_code,
    a.redemptiontime,
    a.category_code,
    NULL::boolean AS redeem_allowed,
    a.nav::numeric AS nav,
    a.currentvalue::numeric AS marketvalue,
    NULL::bigint AS mf_schcode,
    NULL::numeric AS freeqty,
    a.initial_purchase_date,
    NULL::text AS remarks,
    NULL::text AS is_ap_allowed
   FROM aif_pms.aif_pms_folio a
     JOIN master.dim_ucc u ON upper(a.pan::text) = upper(u.pan::text)
WITH DATA;

-- Permissions

ALTER TABLE transactions.mv_client_holding_test OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mv_client_holding_test TO cmotswrite;


-- transactions.mv_client_holdings_wo_folio source

CREATE MATERIALIZED VIEW transactions.mv_client_holdings_wo_folio
TABLESPACE pg_default
AS WITH tmp_holding AS (
         SELECT dc2.ucccode,
            sum(h.investedamount) AS investedamount
           FROM platform_reporting.holdingsummary h
             JOIN master.dim_customer dc2 ON h.accountcode::text = dc2.ac_code::text
          GROUP BY dc2.ucccode
        ), tmp_emp_hierarchy AS (
         SELECT emp.cip_empcode AS emp_code,
            emp.fullname AS emp_name,
            ra.cip_empcode AS ra_code,
            ra.fullname AS ra_name,
            mgr.level
           FROM master.dim_ed_empl_manager_matrix mgr
             JOIN master.dim_ed_employee emp ON mgr.empcode::text = emp.empcode::text
             JOIN master.dim_ed_employee ra ON mgr.managercode::text = ra.empcode::text
          WHERE emp.employeestatus::text = 'A'::text
          ORDER BY mgr.level
        ), tmp_holding_tmp AS (
         SELECT dc2.ucccode,
            sum(h.investedamount) AS investedamount
           FROM platform_reporting.holdingsummary h
             JOIN master.dim_customer dc2 ON h.accountcode::text = dc2.ac_code::text
          GROUP BY dc2.ucccode
        ), tmp_emp_hierarchy_tmp AS (
         SELECT emp.cip_empcode AS emp_code,
            emp.fullname AS emp_name,
            ra.cip_empcode AS ra_code,
            ra.fullname AS ra_name,
            mgr.level
           FROM master.dim_ed_empl_manager_matrix mgr
             JOIN master.dim_ed_employee emp ON mgr.empcode::text = emp.empcode::text
             JOIN master.dim_ed_employee ra ON mgr.managercode::text = ra.empcode::text
          WHERE emp.employeestatus::text = 'A'::text
          ORDER BY mgr.level
        ), tmp_data_tmp AS (
         SELECT du.priority_ac_code AS ac_code,
            du.ucccode,
            du.acname AS ac_name,
            du.pan,
            du.email,
            du.mobileno,
            du.clienttier AS client_tier,
            dct.tier_code AS client_tier_code,
            du.client_owner,
            emplvl.emp_code,
            emplvl.emp_name,
            emplvl.ra_code,
            emplvl.ra_name,
            COALESCE(p.upccode, ''::character varying) AS upccode,
            COALESCE(hol.investedamount, 0::numeric) AS inv_amt,
            concat(du.priority_ac_code, ' ', du.ucccode, ' ', upper(du.acname::text), ' ', upper(du.pan::text), ' ', upper(du.email::text), ' ', du.mobileno, ' ', COALESCE(p.upccode)) AS search_text
           FROM master.dim_ucc du
             JOIN tmp_emp_hierarchy_tmp emplvl ON du.client_owner::text = emplvl.emp_code::text
             LEFT JOIN tmp_holding_tmp hol ON du.ucccode::text = hol.ucccode::text
             LEFT JOIN master.dim_client_tier dct ON du.clienttier::text = dct.tier_name::text
             LEFT JOIN master.dim_customer dc ON du.priority_ac_code::text = dc.ac_code::text
             LEFT JOIN master.partner p ON dc.partnerowner::text = p.partner_code::text
          WHERE COALESCE(du.pan, ''::character varying)::text <> ''::text AND (du.pan::text = ANY (ARRAY['ABMPP0901A'::character varying, 'AUFPC2130C'::character varying, 'ALEPM7305F'::character varying, 'CWYPS0947J'::character varying, 'ANMPN8179L'::character varying, 'JTJPS3453L'::character varying, 'EUIPM3340D'::character varying, 'ERWPS1084P'::character varying, 'ANUPB3708P'::character varying, 'ANYPD4826C'::character varying]::text[]))
        ), tmp_tmp_data_tmp AS (
         SELECT tmp_data_tmp.ac_code,
            tmp_data_tmp.ucccode,
            tmp_data_tmp.ac_name,
            tmp_data_tmp.pan,
            tmp_data_tmp.email,
            tmp_data_tmp.mobileno,
            tmp_data_tmp.client_tier,
            tmp_data_tmp.client_tier_code,
            tmp_data_tmp.client_owner,
            tmp_data_tmp.emp_code,
            tmp_data_tmp.emp_name,
            tmp_data_tmp.ra_code,
            tmp_data_tmp.ra_name,
            tmp_data_tmp.upccode,
            tmp_data_tmp.inv_amt,
            tmp_data_tmp.search_text,
            row_number() OVER (PARTITION BY tmp_data_tmp.pan ORDER BY tmp_data_tmp.pan) AS id
           FROM tmp_data_tmp
        ), tmp_data_mapp AS (
         SELECT tmp_tmp_data_tmp.ac_code,
            tmp_tmp_data_tmp.ucccode,
            tmp_tmp_data_tmp.ac_name,
            tmp_tmp_data_tmp.pan,
            tmp_tmp_data_tmp.email,
            tmp_tmp_data_tmp.mobileno,
            tmp_tmp_data_tmp.client_tier,
            tmp_tmp_data_tmp.client_tier_code,
            '7216'::text AS client_owner,
            '7216'::text AS emp_code,
            'Vinayak Chaturvedi'::text AS emp_name,
            '7216'::text AS ra_code,
            'Vinayak Chaturvedi'::text AS ra_name,
            tmp_tmp_data_tmp.upccode,
            tmp_tmp_data_tmp.inv_amt,
            tmp_tmp_data_tmp.search_text
           FROM tmp_tmp_data_tmp
          WHERE tmp_tmp_data_tmp.id = 1
        )
 SELECT du.priority_ac_code AS ac_code,
    du.ucccode,
    du.acname AS ac_name,
    du.pan,
    du.email,
    du.mobileno,
    du.clienttier AS client_tier,
    dct.tier_code AS client_tier_code,
    du.client_owner,
    emplvl.emp_code,
    emplvl.emp_name,
    emplvl.ra_code,
    emplvl.ra_name,
    COALESCE(p.upccode, ''::character varying) AS upccode,
    COALESCE(hol.investedamount, 0::numeric) AS inv_amt,
    concat(du.priority_ac_code, ' ', du.ucccode, ' ', upper(du.acname::text), ' ', upper(du.pan::text), ' ', upper(du.email::text), ' ', du.mobileno, ' ', COALESCE(p.upccode)) AS search_text
   FROM master.dim_ucc du
     JOIN tmp_emp_hierarchy emplvl ON du.client_owner::text = emplvl.emp_code::text
     LEFT JOIN tmp_holding hol ON du.ucccode::text = hol.ucccode::text
     LEFT JOIN master.dim_client_tier dct ON du.clienttier::text = dct.tier_name::text
     LEFT JOIN master.dim_customer dc ON du.priority_ac_code::text = dc.ac_code::text
     LEFT JOIN master.partner p ON dc.partnerowner::text = p.partner_code::text
  WHERE COALESCE(du.pan, ''::character varying)::text <> ''::text
UNION ALL
 SELECT tmp_data_mapp.ac_code,
    tmp_data_mapp.ucccode,
    tmp_data_mapp.ac_name,
    tmp_data_mapp.pan,
    tmp_data_mapp.email,
    tmp_data_mapp.mobileno,
    tmp_data_mapp.client_tier,
    tmp_data_mapp.client_tier_code,
    tmp_data_mapp.client_owner,
    tmp_data_mapp.emp_code,
    tmp_data_mapp.emp_name,
    tmp_data_mapp.ra_code,
    tmp_data_mapp.ra_name,
    tmp_data_mapp.upccode,
    tmp_data_mapp.inv_amt,
    tmp_data_mapp.search_text
   FROM tmp_data_mapp
WITH DATA;

-- Permissions

ALTER TABLE transactions.mv_client_holdings_wo_folio OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mv_client_holdings_wo_folio TO cmotswrite;


-- transactions.mv_client_holdings_wo_folio_org source

CREATE MATERIALIZED VIEW transactions.mv_client_holdings_wo_folio_org
TABLESPACE pg_default
AS WITH tmp_holding AS (
         SELECT dc2.ucccode,
            sum(h.investedamount) AS investedamount
           FROM platform_reporting.holdingsummary h
             JOIN master.dim_customer dc2 ON h.accountcode::text = dc2.ac_code::text
          GROUP BY dc2.ucccode
        ), tmp_emp_hierarchy AS (
         SELECT emp.cip_empcode AS emp_code,
            emp.fullname AS emp_name,
            ra.cip_empcode AS ra_code,
            ra.fullname AS ra_name,
            mgr.level
           FROM master.dim_ed_empl_manager_matrix mgr
             JOIN master.dim_ed_employee emp ON mgr.empcode::text = emp.empcode::text
             JOIN master.dim_ed_employee ra ON mgr.managercode::text = ra.empcode::text
          WHERE emp.employeestatus::text = 'A'::text
          ORDER BY mgr.level
        )
 SELECT du.priority_ac_code AS ac_code,
    du.ucccode,
    du.acname AS ac_name,
    du.pan,
    du.email,
    du.mobileno,
    du.clienttier AS client_tier,
    dct.tier_code AS client_tier_code,
    du.client_owner,
    emplvl.emp_code,
    emplvl.emp_name,
    emplvl.ra_code,
    emplvl.ra_name,
    COALESCE(p.upccode, ''::character varying) AS upccode,
    COALESCE(hol.investedamount, 0::numeric) AS inv_amt,
    concat(du.priority_ac_code, ' ', du.ucccode, ' ', upper(du.acname::text), ' ', upper(du.pan::text), ' ', upper(du.email::text), ' ', du.mobileno, ' ', COALESCE(p.upccode)) AS search_text
   FROM master.dim_ucc du
     JOIN tmp_emp_hierarchy emplvl ON du.client_owner::text = emplvl.emp_code::text
     LEFT JOIN tmp_holding hol ON du.ucccode::text = hol.ucccode::text
     LEFT JOIN master.dim_client_tier dct ON du.clienttier::text = dct.tier_name::text
     LEFT JOIN master.dim_customer dc ON du.priority_ac_code::text = dc.ac_code::text
     LEFT JOIN master.partner p ON dc.partnerowner::text = p.partner_code::text
  WHERE COALESCE(du.pan, ''::character varying)::text <> ''::text
WITH DATA;

-- Permissions

ALTER TABLE transactions.mv_client_holdings_wo_folio_org OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.mv_client_holdings_wo_folio_org TO cmotswrite;


-- transactions.tmp_mv_mly_client_cat_revenue source

CREATE MATERIALIZED VIEW transactions.tmp_mv_mly_client_cat_revenue
TABLESPACE pg_default
AS SELECT aif.pan,
    aif.ucccode,
    COALESCE(du.clienttier, 'NA'::character varying) AS client_tier,
    aif.emp_code,
    aif.category_code,
    c.category_name,
    c.product_code,
    c.product_name,
    aif.lob_net_revenue,
    aif.rm_net_revenue,
    dd.month_end_date_key::character varying::date AS month_end_date,
    dd.month_end_date_key,
    concat(dd.month_name, '-', dd.year_name) AS month_name,
        CASE
            WHEN dd.last_x_month_incl_curday = 1 THEN true
            ELSE false
        END AS last_x_month,
    now()::date AS refresh_date
   FROM admin.fct_revenue_aif aif
     JOIN datamart.dim_date dd ON aif.month = dd.date_fld
     JOIN master.dim_ucc du ON aif.ucccode::text = du.ucccode::text
     JOIN master.mv_category c ON aif.category_code = c.category_code
  WHERE dd.last_x_month_incl_curday = 1
UNION ALL
 SELECT pms.pan,
    pms.ucccode,
    COALESCE(du.clienttier, 'NA'::character varying) AS client_tier,
    pms.emp_code,
    pms.category_code,
    c.category_name,
    c.product_code,
    c.product_name,
    pms.lob_net_revenue,
    pms.rm_net_revenue,
    dd.month_end_date_key::character varying::date AS month_end_date,
    dd.month_end_date_key,
    concat(dd.month_name, '-', dd.year_name) AS month_name,
        CASE
            WHEN dd.last_x_month_incl_curday = 1 THEN true
            ELSE false
        END AS last_x_month,
    now()::date AS refresh_date
   FROM admin.fct_revenue_pms pms
     JOIN datamart.dim_date dd ON pms.month = dd.date_fld
     JOIN master.dim_ucc du ON pms.ucccode::text = du.ucccode::text
     JOIN master.mv_category c ON pms.category_code = c.category_code
  WHERE dd.last_x_month_incl_curday = 1
UNION ALL
 SELECT fi.pan,
    fi.ucccode,
    COALESCE(du.clienttier, 'NA'::character varying) AS client_tier,
    fi.emp_code,
    fi.category_code,
    c.category_name,
    c.product_code,
    c.product_name,
    fi.lob_net_revenue,
    fi.rm_net_revenue,
    dd.month_end_date_key::character varying::date AS month_end_date,
    dd.month_end_date_key,
    concat(dd.month_name, '-', dd.year_name) AS month_name,
        CASE
            WHEN dd.last_x_month_incl_curday = 1 THEN true
            ELSE false
        END AS last_x_month,
    now()::date AS refresh_date
   FROM admin.fct_revenue_fi fi
     JOIN datamart.dim_date dd ON fi.month = dd.date_fld
     JOIN master.dim_ucc du ON fi.ucccode::text = du.ucccode::text
     JOIN master.mv_category c ON fi.category_code = c.category_code
  WHERE dd.last_x_month_incl_curday = 1
UNION ALL
 SELECT ins.pan,
    ins.ucccode,
    COALESCE(du.clienttier, 'NA'::character varying) AS client_tier,
    ins.emp_code,
    ins.category_code,
    c.category_name,
    c.product_code,
    c.product_name,
    ins.lob_net_revenue,
    ins.rm_net_revenue,
    dd.month_end_date_key::character varying::date AS month_end_date,
    dd.month_end_date_key,
    concat(dd.month_name, '-', dd.year_name) AS month_name,
        CASE
            WHEN dd.last_x_month_incl_curday = 1 THEN true
            ELSE false
        END AS last_x_month,
    now()::date AS refresh_date
   FROM admin.fct_revenue_insurance ins
     JOIN datamart.dim_date dd ON ins.month = dd.date_fld
     JOIN master.dim_ucc du ON ins.ucccode::text = du.ucccode::text
     JOIN master.mv_category c ON ins.category_code = c.category_code
  WHERE dd.last_x_month_incl_curday = 1
UNION ALL
 SELECT mf.pan,
    mf.ucccode,
    COALESCE(du.clienttier, 'NA'::character varying) AS client_tier,
    mf.emp_code,
    mf.category_code,
    c.category_name,
    c.product_code,
    c.product_name,
    mf.lob_net_revenue,
    mf.rm_net_revenue,
    dd.month_end_date_key::character varying::date AS month_end_date,
    dd.month_end_date_key,
    concat(dd.month_name, '-', dd.year_name) AS month_name,
        CASE
            WHEN dd.last_x_month_incl_curday = 1 THEN true
            ELSE false
        END AS last_x_month,
    now()::date AS refresh_date
   FROM admin.fct_revenue_mf mf
     JOIN datamart.dim_date dd ON mf.month = dd.date_fld
     JOIN master.dim_ucc du ON mf.ucccode::text = du.ucccode::text
     JOIN master.mv_category c ON mf.category_code = c.category_code
  WHERE dd.last_x_month_incl_curday = 1
UNION ALL
 SELECT ncd.pan,
    ncd.ucccode,
    COALESCE(du.clienttier, 'NA'::character varying) AS client_tier,
    ncd.emp_code,
    ncd.category_code,
    c.category_name,
    c.product_code,
    c.product_name,
    ncd.lob_net_revenue,
    ncd.rm_net_revenue,
    dd.month_end_date_key::character varying::date AS month_end_date,
    dd.month_end_date_key,
    concat(dd.month_name, '-', dd.year_name) AS month_name,
        CASE
            WHEN dd.last_x_month_incl_curday = 1 THEN true
            ELSE false
        END AS last_x_month,
    now()::date AS refresh_date
   FROM admin.fct_revenue_ncd ncd
     JOIN datamart.dim_date dd ON ncd.month = dd.date_fld
     JOIN master.dim_ucc du ON ncd.ucccode::text = du.ucccode::text
     JOIN master.mv_category c ON ncd.category_code = c.category_code
  WHERE dd.last_x_month_incl_curday = 1
UNION ALL
 SELECT otc.pan,
    otc.ucccode,
    COALESCE(du.clienttier, 'NA'::character varying) AS client_tier,
    otc.emp_code,
    otc.category_code,
    c.category_name,
    c.product_code,
    c.product_name,
    otc.lob_net_revenue,
    otc.rm_net_revenue,
    dd.month_end_date_key::character varying::date AS month_end_date,
    dd.month_end_date_key,
    concat(dd.month_name, '-', dd.year_name) AS month_name,
        CASE
            WHEN dd.last_x_month_incl_curday = 1 THEN true
            ELSE false
        END AS last_x_month,
    now()::date AS refresh_date
   FROM admin.fct_revenue_otc otc
     JOIN datamart.dim_date dd ON otc.month = dd.date_fld
     JOIN master.dim_ucc du ON otc.ucccode::text = du.ucccode::text
     JOIN master.mv_category c ON otc.category_code = c.category_code
  WHERE dd.last_x_month_incl_curday = 1
WITH DATA;

-- Permissions

ALTER TABLE transactions.tmp_mv_mly_client_cat_revenue OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.tmp_mv_mly_client_cat_revenue TO cmotswrite;


-- transactions.vw_com_mailer_mapper source

CREATE OR REPLACE VIEW transactions.vw_com_mailer_mapper
AS SELECT communication_mailer_mapper.subcategory_id,
    communication_mailer_mapper.template_placeholder,
    communication_mailer_mapper.mapping_field_name,
    communication_mailer_mapper.is_active
   FROM transactions.communication_mailer_mapper
  WHERE communication_mailer_mapper.is_active = 1
  ORDER BY communication_mailer_mapper.id;

-- Permissions

ALTER TABLE transactions.vw_com_mailer_mapper OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_com_mailer_mapper TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_com_mailer_mapper TO appadmin;
GRANT SELECT ON TABLE transactions.vw_com_mailer_mapper TO cmotsread WITH GRANT OPTION;


-- transactions.vw_com_mailer_mst source

CREATE OR REPLACE VIEW transactions.vw_com_mailer_mst
AS SELECT communication_mailer_mst.comid,
    ((('MF_Internal_'::text || to_char(communication_mailer_mst.insertdtm, 'YYYYMMDD'::text)) || '_'::text) || communication_mailer_mst.comid)::character varying AS uniqueid,
    communication_mailer_mst.sourceid,
    communication_mailer_mst.subcategoryid AS subcategory,
    communication_mailer_mst.subcategory AS subcategory_name,
    communication_mailer_mst.producttype,
    communication_mailer_mst.ordertype,
    communication_mailer_mst.inv_type,
    communication_mailer_mst.trx_id,
    communication_mailer_mst.vendor_trx_id,
    communication_mailer_mst.orderid,
    communication_mailer_mst.clientcode,
    initcap(communication_mailer_mst.clientname::text)::character varying AS clientname,
    to_char(communication_mailer_mst.orderdate::date::timestamp with time zone, 'DD-Mon-YY'::text)::character varying AS orderdate,
        CASE
            WHEN communication_mailer_mst.transaction_mode::text = 'D'::text THEN 'Demat'::character varying
            WHEN communication_mailer_mst.transaction_mode::text = 'P'::text THEN 'Physical'::character varying
            ELSE initcap(communication_mailer_mst.transaction_mode::text)::character varying
        END AS transaction_mode,
    initcap(communication_mailer_mst.fundname::text)::character varying AS fundname,
    communication_mailer_mst.amount::numeric(20,2)::character varying AS amount,
        CASE
            WHEN COALESCE(communication_mailer_mst.units, ''::character varying)::text = ''::text THEN communication_mailer_mst.units
            ELSE communication_mailer_mst.units::numeric(20,4)::character varying
        END AS units,
    initcap(communication_mailer_mst.rejection_reason::text)::character varying AS rejection_reason,
        CASE
            WHEN COALESCE(communication_mailer_mst.next_due_date, ''::character varying)::text = ''::text THEN communication_mailer_mst.next_due_date
            ELSE to_char(communication_mailer_mst.next_due_date::date::timestamp with time zone, 'DD-Mon-YY'::text)::character varying
        END AS next_due_date,
        CASE
            WHEN COALESCE(communication_mailer_mst.sip_start_date, ''::character varying)::text = ''::text THEN communication_mailer_mst.sip_start_date
            ELSE to_char(communication_mailer_mst.sip_start_date::date::timestamp with time zone, 'DD-Mon-YY'::text)::character varying
        END AS sip_start_date,
        CASE
            WHEN COALESCE(communication_mailer_mst.sip_end_date, ''::character varying)::text = ''::text THEN communication_mailer_mst.sip_end_date
            ELSE to_char(communication_mailer_mst.sip_end_date::date::timestamp with time zone, 'DD-Mon-YY'::text)::character varying
        END AS sip_end_date,
    initcap(communication_mailer_mst.frequency::text)::character varying AS frequency,
    communication_mailer_mst.installment_number,
    communication_mailer_mst.bankname,
    lpad("right"(communication_mailer_mst.bankacno::text, 4), length(communication_mailer_mst.bankacno::text), 'X'::text)::character varying AS bankacno,
    communication_mailer_mst.insertdtm,
    communication_mailer_mst.is_picked,
    communication_mailer_mst.mandateid,
    communication_mailer_mst.mandate_mode,
    communication_mailer_mst.tot_inv_amt,
    communication_mailer_mst.no_of_installment,
    communication_mailer_mst.count_installment_pause,
    initcap(communication_mailer_mst.fundname_switch::text)::character varying AS fundname_switch,
    ucc.rm_email,
    ucc.rm_mobile,
    communication_mailer_mst.modify_order_type,
    initcap(ucc.client_owner_name::text)::character varying AS rm_name,
    communication_mailer_mst.reflink,
        CASE
            WHEN communication_mailer_mst.clientcode::text = '60231602'::text THEN '101767'::character varying
            ELSE communication_mailer_mst.emp_code
        END AS emp_code,
        CASE
            WHEN communication_mailer_mst.clientcode::text = '60231602'::text THEN NULL::character varying
            ELSE communication_mailer_mst.partner_code
        END AS partner_code
   FROM transactions.communication_mailer_mst
     LEFT JOIN master.dim_ucc ucc ON communication_mailer_mst.clientcode::text = ucc.priority_ac_code::text
  WHERE COALESCE(communication_mailer_mst.subcategoryid, ''::character varying)::text <> ''::text AND communication_mailer_mst.is_picked = false AND communication_mailer_mst.clientcode::text <> 'EB000075'::text
  ORDER BY communication_mailer_mst.comid;

-- Permissions

ALTER TABLE transactions.vw_com_mailer_mst OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_com_mailer_mst TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_com_mailer_mst TO appadmin;
GRANT SELECT ON TABLE transactions.vw_com_mailer_mst TO cmotsread WITH GRANT OPTION;


-- transactions.vw_com_mailer_mst_bkp_09may2025 source

CREATE OR REPLACE VIEW transactions.vw_com_mailer_mst_bkp_09may2025
AS SELECT communication_mailer_mst.comid,
    ((('MF_Internal_'::text || to_char(communication_mailer_mst.insertdtm, 'YYYYMMDD'::text)) || '_'::text) || communication_mailer_mst.comid)::character varying AS uniqueid,
    communication_mailer_mst.sourceid,
    communication_mailer_mst.subcategoryid AS subcategory,
    communication_mailer_mst.subcategory AS subcategory_name,
    communication_mailer_mst.producttype,
    communication_mailer_mst.ordertype,
    communication_mailer_mst.inv_type,
    communication_mailer_mst.trx_id,
    communication_mailer_mst.vendor_trx_id,
    communication_mailer_mst.orderid,
    communication_mailer_mst.clientcode,
    initcap(communication_mailer_mst.clientname::text)::character varying AS clientname,
    to_char(communication_mailer_mst.orderdate::date::timestamp with time zone, 'DD-Mon-YY'::text)::character varying AS orderdate,
        CASE
            WHEN communication_mailer_mst.transaction_mode::text = 'D'::text THEN 'Demat'::character varying
            WHEN communication_mailer_mst.transaction_mode::text = 'P'::text THEN 'Physical'::character varying
            ELSE initcap(communication_mailer_mst.transaction_mode::text)::character varying
        END AS transaction_mode,
    initcap(communication_mailer_mst.fundname::text)::character varying AS fundname,
    communication_mailer_mst.amount::numeric(20,2)::character varying AS amount,
        CASE
            WHEN COALESCE(communication_mailer_mst.units, ''::character varying)::text = ''::text THEN communication_mailer_mst.units
            ELSE communication_mailer_mst.units::numeric(20,2)::character varying
        END AS units,
    initcap(communication_mailer_mst.rejection_reason::text)::character varying AS rejection_reason,
        CASE
            WHEN COALESCE(communication_mailer_mst.next_due_date, ''::character varying)::text = ''::text THEN communication_mailer_mst.next_due_date
            ELSE to_char(communication_mailer_mst.next_due_date::date::timestamp with time zone, 'DD-Mon-YY'::text)::character varying
        END AS next_due_date,
        CASE
            WHEN COALESCE(communication_mailer_mst.sip_start_date, ''::character varying)::text = ''::text THEN communication_mailer_mst.sip_start_date
            ELSE to_char(communication_mailer_mst.sip_start_date::date::timestamp with time zone, 'DD-Mon-YY'::text)::character varying
        END AS sip_start_date,
        CASE
            WHEN COALESCE(communication_mailer_mst.sip_end_date, ''::character varying)::text = ''::text THEN communication_mailer_mst.sip_end_date
            ELSE to_char(communication_mailer_mst.sip_end_date::date::timestamp with time zone, 'DD-Mon-YY'::text)::character varying
        END AS sip_end_date,
    initcap(communication_mailer_mst.frequency::text)::character varying AS frequency,
    communication_mailer_mst.installment_number,
    communication_mailer_mst.bankname,
    lpad("right"(communication_mailer_mst.bankacno::text, 4), length(communication_mailer_mst.bankacno::text), 'X'::text)::character varying AS bankacno,
    communication_mailer_mst.insertdtm,
    communication_mailer_mst.is_picked,
    communication_mailer_mst.mandateid,
    communication_mailer_mst.mandate_mode,
    communication_mailer_mst.tot_inv_amt,
    communication_mailer_mst.no_of_installment,
    communication_mailer_mst.count_installment_pause,
    communication_mailer_mst.fundname_switch,
    ucc.rm_email,
    ucc.rm_mobile,
    communication_mailer_mst.modify_order_type,
    initcap(ucc.client_owner_name::text)::character varying AS rm_name,
    communication_mailer_mst.reflink
   FROM transactions.communication_mailer_mst
     LEFT JOIN master.dim_ucc ucc ON communication_mailer_mst.clientcode::text = ucc.priority_ac_code::text
  WHERE COALESCE(communication_mailer_mst.subcategoryid, ''::character varying)::text <> ''::text AND communication_mailer_mst.is_picked = false AND communication_mailer_mst.clientcode::text <> 'EB000075'::text
  ORDER BY communication_mailer_mst.comid;

-- Permissions

ALTER TABLE transactions.vw_com_mailer_mst_bkp_09may2025 OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_com_mailer_mst_bkp_09may2025 TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_com_mailer_mst_bkp_09may2025 TO appadmin;
GRANT SELECT ON TABLE transactions.vw_com_mailer_mst_bkp_09may2025 TO cmotsread WITH GRANT OPTION;


-- transactions.vw_com_payment_reminder source

CREATE OR REPLACE VIEW transactions.vw_com_payment_reminder
AS SELECT mf_order_detail.trx_id,
    mf_order_detail.final_status
   FROM transactions.mf_order_detail
  WHERE mf_order_detail.created_date >= '2025-02-01 00:00:00'::timestamp without time zone AND mf_order_detail.vendor_trx_id IS NULL AND mf_order_detail.order_placed_by::text = 'RM'::text AND (mf_order_detail.trx_final_status_code = ANY (ARRAY[1, 3])) AND (mf_order_detail.ac_code::text = ANY (ARRAY['45901226'::character varying::text, '70130261'::character varying::text, '45774211'::character varying::text, '60139691'::character varying::text]))
  ORDER BY mf_order_detail.created_date;

-- Permissions

ALTER TABLE transactions.vw_com_payment_reminder OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_com_payment_reminder TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_com_payment_reminder TO appadmin;
GRANT SELECT ON TABLE transactions.vw_com_payment_reminder TO cmotsread WITH GRANT OPTION;


-- transactions.vw_comm_log_details source

CREATE OR REPLACE VIEW transactions.vw_comm_log_details
AS SELECT a.srno,
    a.txn_type,
    a.trigger_point,
    a.trx_id,
    a.ac_code,
    a.whatsappid,
    a.comm_mode,
    a.template_placeholders,
    a.values_placeholder,
    b.mobileno AS client_mobile,
    b.email AS client_email,
    b.rm_mobile,
    b.rm_email,
    b.user_name AS client_user_name,
    b.actype AS client_actype
   FROM transactions.communication_log_details a
     JOIN master.dim_ucc b ON a.ac_code::text = b.priority_ac_code::text
  WHERE a.is_picked = false;

-- Permissions

ALTER TABLE transactions.vw_comm_log_details OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_comm_log_details TO cmotswrite;
GRANT SELECT ON TABLE transactions.vw_comm_log_details TO cmotsread WITH GRANT OPTION;
GRANT ALL ON TABLE transactions.vw_comm_log_details TO appadmin;


-- transactions.vw_mf_cta_product source

CREATE OR REPLACE VIEW transactions.vw_mf_cta_product
AS SELECT a.mf_schcode,
    max(a.purallowed::text)::character varying AS purallowed,
    max(a.sipflag::text)::character varying AS sipflag,
    max(a.redeem_flg::text)::character varying AS redeem_flg,
    max(a.swpflag::text)::character varying AS swpflag,
    max(a.stpflag::text)::character varying AS stpflag,
    max(a.switchflag::text)::character varying AS switchflag,
    a.search_key
   FROM ( SELECT c.mf_schcode,
            'N'::character varying AS purallowed,
            'N'::character varying AS sipflag,
            'N'::character varying AS redeem_flg,
            'N'::character varying AS swpflag,
                CASE
                    WHEN regexp_replace(a_1.reg_in::text, '[\n\r\t]'::text, ''::text, 'g'::text)::character varying::text = 'Y'::text AND regexp_replace(a_1.reg_out::text, '[\n\r\t]'::text, ''::text, 'g'::text)::character varying::text = 'Y'::text THEN 'Y'::text
                    ELSE 'N'::text
                END::character varying AS stpflag,
            'N'::character varying AS switchflag,
            (COALESCE(c.isincode, ''::character varying)::text || ' '::text) || COALESCE(d.sch_name, ''::character varying)::text AS search_key
           FROM master.dim_mf_sip_swp_stp a_1
             JOIN master.stg_dim_mf_schememaster b ON b.isin = a_1.isincode::text
             JOIN master.dim_mf_isin c ON a_1.isincode::text = c.isincode::text
             JOIN platform_db.mv_mf_details d ON a_1.isincode::text = d.isincode::text
          WHERE (upper(b.settlementtype) <> ALL (ARRAY['L1'::text, 'L0'::text])) AND c.isactive = 1 AND a_1.txn_type::text = 'STP'::text
        UNION ALL
         SELECT b.mf_schcode,
            a_1.purallowed,
            a_1.sipflag,
            a_1.redallowed AS redeem_flg,
            a_1.swpflag,
            a_1.stpflag,
            a_1.switchflag,
            (COALESCE(b.isincode, ''::character varying)::text || ' '::text) || COALESCE(d.sch_name, ''::character varying)::text AS search_key
           FROM master.stg_dim_mf_schememaster a_1
             JOIN master.dim_mf_isin b ON a_1.isin = b.isincode::text
             JOIN platform_db.mv_mf_details d ON b.isincode::text = d.isincode::text
          WHERE (upper(a_1.settlementtype) <> ALL (ARRAY['L1'::text, 'L0'::text])) AND b.isactive = 1) a
  GROUP BY a.mf_schcode, a.search_key;

-- Permissions

ALTER TABLE transactions.vw_mf_cta_product OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_mf_cta_product TO cmotswrite;


-- transactions.vw_mf_cta_product_isin source

CREATE OR REPLACE VIEW transactions.vw_mf_cta_product_isin
AS SELECT a.mf_schcode,
    a.isincode,
    max(a.purallowed::text)::character varying AS purallowed,
    max(a.sipflag::text)::character varying AS sipflag,
    max(a.redeem_flg::text)::character varying AS redeem_flg,
    max(a.swpflag::text)::character varying AS swpflag,
    max(a.stpflag::text)::character varying AS stpflag,
    max(a.switchflag::text)::character varying AS switchflag
   FROM ( SELECT c.mf_schcode,
            a_1.isincode,
            'N'::character varying AS purallowed,
            'N'::character varying AS sipflag,
            'N'::character varying AS redeem_flg,
            'N'::character varying AS swpflag,
                CASE
                    WHEN regexp_replace(a_1.reg_in::text, '[\n\r\t]'::text, ''::text, 'g'::text)::character varying::text = 'Y'::text AND regexp_replace(a_1.reg_out::text, '[\n\r\t]'::text, ''::text, 'g'::text)::character varying::text = 'Y'::text THEN 'Y'::text
                    ELSE 'N'::text
                END::character varying AS stpflag,
            'N'::character varying AS switchflag
           FROM master.dim_mf_sip_swp_stp a_1
             JOIN master.stg_dim_mf_schememaster b ON b.isin = a_1.isincode::text
             JOIN master.dim_mf_isin c ON a_1.isincode::text = c.isincode::text
          WHERE (upper(b.settlementtype) <> ALL (ARRAY['L1'::text, 'L0'::text])) AND c.isactive = 1 AND a_1.txn_type::text = 'STP'::text
        UNION ALL
         SELECT b.mf_schcode,
            a_1.isin AS isincode,
            a_1.purallowed,
            a_1.sipflag,
            a_1.redallowed AS redeem_flg,
            a_1.swpflag,
            a_1.stpflag,
            a_1.switchflag
           FROM master.stg_dim_mf_schememaster a_1
             JOIN master.dim_mf_isin b ON a_1.isin = b.isincode::text
          WHERE (upper(a_1.settlementtype) <> ALL (ARRAY['L1'::text, 'L0'::text])) AND b.isactive = 1) a
  GROUP BY a.mf_schcode, a.isincode;

-- Permissions

ALTER TABLE transactions.vw_mf_cta_product_isin OWNER TO cmotswrite;
GRANT ALL ON TABLE transactions.vw_mf_cta_product_isin TO cmotswrite;



-- DROP FUNCTION transactions.fn_accept_mf_consent(_int8, int4, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_accept_mf_consent(v_trx_id bigint[], v_category_code integer, v_ac_code character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE result_row RECORD;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.trx_id = ANY($1) 
	AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date
			  AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE category_code = '261' AND consent_status_code = 1))
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS SELECT UNNEST(v_trx_id) trx_id, NULL::character varying as status, NULL::character varying as remarks;

		FOR result_row IN (SELECT UNNEST(v_trx_id) _id)
		LOOP

			IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.trx_id = result_row._id 
			AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date
					  AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE category_code = '261' AND consent_status_code = 1)
					  AND v_ac_code = CASE WHEN A.inv_action_code = 1 THEN (SELECT DISTINCT B.ac_code FROM transactions.mf_order_detail B
																			WHERE B.trx_id = result_row._id AND B.physicalflag <> 'P')
										   WHEN A.inv_action_code <> 1 THEN (SELECT DISTINCT C.ac_code FROM transactions.mf_order_detail_modification C
																			 WHERE C.trx_id = result_row._id AND C.physicalflag <> 'P') END
					 )
			THEN

				UPDATE temp_mf_trx A SET status = 'SUCCESS'::character varying, remarks = ('Consent Approved Successfully')::character varying
				WHERE A.trx_id = result_row._id;

				UPDATE transactions.order_consent A SET
				consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata'
				, logged_in_approval = true
				WHERE A.category_code = 261 AND A.trx_id = result_row._id 
				AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date
				AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE A.category_code = '261' AND consent_status_code = 1)
				AND A.inv_action_code = v_inv_action_code;

				IF(v_inv_action_code = 1)
				THEN

					UPDATE transactions.mf_order_detail A SET
					consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
					, consent_status_code = 2
					, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata', 
					modified_date = NOW() at time zone 'Asia/Kolkata'
					WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1);

					UPDATE transactions.mf_order_detail A SET
					final_status = B.trx_final_status,
					trx_final_status_code = B.trx_final_status_code,
					inv_plan_status_code = B.inv_plan_status_code,
					inv_plan_status = B.inv_plan_status,
					payment_status_code= case when A.trx_type_code=4 then 1 
						when A.trx_type_code=1 and A.is_generatetoday=true  then 1 else 0 end,
					payment_status=case when A.trx_type_code=4 then 'Pending' 
						when A.trx_type_code=1 and A.is_generatetoday=true  then 'Pending'  else null end
					FROM transactions.mf_order_detail D
					LEFT JOIN master.mv_map_category_status B
					ON UPPER(B.usertype) = UPPER(D.order_placed_by)
					AND D.physicalflag = B.physicalflag
					AND D.trx_type_code = B.trx_type_code
					AND D.is_generatetoday = B.is_generatetoday
					AND D.consent_status_code = B.consent_status_code
					AND D.payment_status_code = B.payment_status_code
					AND B.trx_status_code = D.trx_status_code
					AND B.inv_action_code = D.inv_action_code
					AND B.category_code = 261
					WHERE A.trx_id = D.trx_id 
					AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1)
					and A.consent_status_code=2 ;

					update transactions.mf_order_summary a
					set
					final_status = B.final_status,
					trx_final_status_code = B.trx_final_status_code,
					inv_plan_status_code = B.inv_plan_status_code,
					inv_plan_status = B.inv_plan_status,
					trx_type_code=b.trx_type_code,
					trx_status_Code=b.trx_status_Code
					from transactions.mf_order_detail b
					where a.trx_id = B.trx_id
					AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1)
					and b.consent_status_code=2 ;

					----------Inserting Data into transaction History Table----------

					UPDATE transactions.mf_order_detail_history A 
					SET valid_to = NOW() at time zone 'Asia/Kolkata', is_active = false
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1)
					AND A.is_active = true;

					INSERT INTO transactions.mf_order_detail_history
					(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
					, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
					,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
					SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
					, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, 
					NOW() at time zone 'Asia/Kolkata', true
					,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status	
					FROM transactions.mf_order_detail A
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1);

					UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

					----------Inserting Data into Summary transaction History Table----------
/*
					UPDATE transactions.mf_order_summary_history A SET valid_to = NOW(), is_active = false
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1)
					AND A.is_active = true;

					INSERT INTO transactions.mf_order_summary_history
					(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
					, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
					, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
					, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active
					,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
					SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
					, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
					, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
					, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
					,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
					FROM transactions.mf_order_summary A
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1);

					UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
*/
				ELSE

					----------Updating Data in Modification Stage Table----------

					UPDATE transactions.mf_order_detail_modification A 
					SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
					, consent_status_code = 2
					, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata', 
					modified_date = NOW() at time zone 'Asia/Kolkata'
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = result_row._id AND C.inv_action_code <> 1);

					UPDATE transactions.mf_order_detail_modification A SET
					final_status = B.trx_final_status,
					trx_final_status_code = B.trx_final_status_code,
					inv_plan_status_code = B.inv_plan_status_code,
					inv_plan_status = B.inv_plan_status
					FROM transactions.mf_order_detail_modification D
					LEFT JOIN master.mv_map_category_status B
					ON UPPER(B.usertype) = UPPER(D.order_placed_by)
					AND D.physicalflag = B.physicalflag
					AND D.trx_type_code = B.trx_type_code
					/* AND D.is_generatetoday = B.is_generatetoday */
					AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
					AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
					AND B.trx_status_code = D.trx_status_code
					AND B.inv_action_code = D.inv_action_code
					AND B.category_code = 261
					WHERE A.trx_id = D.trx_id
					AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code <> 1);
				
				END IF;

			ELSE

			UPDATE temp_mf_trx A SET status = 'FAILURE'::character varying
			, remarks = CASE WHEN (SELECT DISTINCT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.trx_id = result_row._id 
				AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date
								   AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE category_code = '261' AND consent_status_code = 1)
								   AND v_ac_code <> CASE WHEN A.inv_action_code = 1
														 THEN (SELECT DISTINCT B.ac_code FROM transactions.mf_order_detail B WHERE B.trx_id = result_row._id)
														 WHEN A.inv_action_code <> 1
														 THEN (SELECT DISTINCT C.ac_code FROM transactions.mf_order_detail_modification C WHERE C.trx_id = result_row._id) END
								  ) = 1
							 THEN ('Provided Ac_code for the transaction ID is not matching')::character varying
							 WHEN (SELECT DISTINCT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.trx_id = result_row._id 
				AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date
								   AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE category_code = '261' AND consent_status_code = 1)
								   AND v_ac_code = CASE WHEN A.inv_action_code = 1
														THEN (SELECT DISTINCT B.ac_code FROM transactions.mf_order_detail B WHERE B.trx_id = result_row._id)
														WHEN A.inv_action_code <> 1
														THEN (SELECT DISTINCT C.ac_code FROM transactions.mf_order_detail_modification C WHERE C.trx_id = result_row._id) END
								  ) = 1
							 THEN ('Provided Ac_code Folio Type is not Demat')::character varying END
			WHERE A.trx_id = result_row._id;								

			END IF;

		END LOOP;

		RETURN QUERY
		SELECT A.trx_id, A.status, A.remarks FROM temp_mf_trx A;

		DROP TABLE temp_mf_trx; 

	ELSE

		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, 'FAILURE'::character varying as status,'No Valid Consent for provided Transaction'::character varying as remarks;

	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_accept_mf_consent(_int8, int4, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent(_int8, int4, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent(_int8, int4, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent(_int8, int4, varchar, int4) TO cmotsread;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent(_int8, int4, varchar, int4) TO appadmin;

-- DROP FUNCTION transactions.fn_accept_mf_consent_bkp(_int8, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_accept_mf_consent_bkp(v_trx_id bigint[], v_category_code integer, v_ac_code character varying)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE result_row RECORD;

BEGIN

IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND NOW() < A.consent_expire_date
AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE consent_status_code = 1))
THEN

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS SELECT UNNEST(v_trx_id) trx_id, NULL::character varying as status, NULL::character varying as remarks;

FOR result_row IN (SELECT UNNEST(v_trx_id) _id)
LOOP

IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = result_row._id AND NOW() < A.consent_expire_date
AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE consent_status_code = 1)
AND v_ac_code = (SELECT DISTINCT B.ac_code FROM transactions.mf_order_detail B
WHERE B.trx_id = result_row._id AND B.physicalflag <> 'P'))
THEN

UPDATE temp_mf_trx A SET status = 'SUCCESS'::character varying, remarks = ('Consent Approved Successfully')::character varying
WHERE A.trx_id = result_row._id;

UPDATE transactions.order_consent A SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 2)
, consent_approval_reject_datetime = NOW()
, logged_in_approval = true
WHERE A.trx_id = result_row._id AND NOW() < A.consent_expire_date
AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE consent_status_code = 1);

UPDATE transactions.mf_order_detail A SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 2)
, consent_status_code = 2
, consent_approval_reject_datetime = NOW(), modified_date = NOW()
WHERE A.trx_id = result_row._id;

/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
WHEN C.is_generatetoday = FALSE THEN ''
WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = result_row._id;
*/

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
payment_status_code= case when A.trx_type_code=4 then 1 
	when A.trx_type_code=1 and A.is_generatetoday=true  then 1 else 0 end,
payment_status=case when A.trx_type_code=4 then 'Pending' 
	when A.trx_type_code=1 and A.is_generatetoday=true  then 'Pending'  else null end
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id 
AND A.trx_id = result_row._id
and A.consent_status_code=2 ;

update transactions.mf_order_summary a
set
final_status = B.final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
trx_type_code=b.trx_type_code,
trx_status_Code=b.trx_status_Code
from transactions.mf_order_detail b
where a.trx_id = B.trx_id
AND A.trx_id = result_row._id
and b.consent_status_code=2 ;

----------Inserting Data into transaction History Table----------

UPDATE transactions.mf_order_detail_history A SET valid_to = NOW(), is_active = false WHERE A.trx_id = result_row._id AND A.is_active = true;

INSERT INTO transactions.mf_order_detail_history
(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status	
FROM transactions.mf_order_detail A WHERE A.trx_id = result_row._id;

UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

----------Inserting Data into Summary transaction History Table----------
INSERT INTO transactions.mf_order_summary_history
(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active
,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A WHERE A.trx_id = result_row._id;

UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

ELSE

UPDATE temp_mf_trx A SET status = 'FAILURE'::character varying
, remarks = CASE WHEN (SELECT DISTINCT 1 FROM transactions.order_consent A WHERE A.trx_id = result_row._id AND NOW() < A.consent_expire_date
AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE consent_status_code = 1)
AND v_ac_code <> (SELECT DISTINCT B.ac_code FROM transactions.mf_order_detail B WHERE B.trx_id = result_row._id)) = 1
THEN ('Provided Ac_code for the transaction ID is not matching')::character varying
WHEN (SELECT DISTINCT 1 FROM transactions.order_consent A WHERE A.trx_id = result_row._id AND NOW() < A.consent_expire_date
AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE consent_status_code = 1)
AND v_ac_code = (SELECT DISTINCT B.ac_code FROM transactions.mf_order_detail B WHERE B.trx_id = result_row._id AND B.physicalflag = 'P')) = 1
THEN ('Provided Ac_code Folio Type is not Demat')::character varying END
WHERE A.trx_id = result_row._id;								

END IF;

END LOOP;

RETURN QUERY
SELECT A.trx_id, A.status, A.remarks FROM temp_mf_trx A;

DROP TABLE temp_mf_trx; 

ELSE

RETURN QUERY
SELECT UNNEST(v_trx_id) trx_id, 'FAILURE'::character varying as status,'No Valid Consent for provided Transaction'::character varying as remarks;

END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_accept_mf_consent_bkp(_int8, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent_bkp(_int8, int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent_bkp(_int8, int4, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent_bkp(_int8, int4, varchar) TO cmotsread;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent_bkp(_int8, int4, varchar) TO appadmin;

-- DROP FUNCTION transactions.fn_accept_mf_consent_bkp_09may2025(_int8, int4, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_accept_mf_consent_bkp_09may2025(v_trx_id bigint[], v_category_code integer, v_ac_code character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE result_row RECORD;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.trx_id = ANY($1) AND NOW() < A.consent_expire_date
			  AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE category_code = '261' AND consent_status_code = 1))
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS SELECT UNNEST(v_trx_id) trx_id, NULL::character varying as status, NULL::character varying as remarks;

		FOR result_row IN (SELECT UNNEST(v_trx_id) _id)
		LOOP

			IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.trx_id = result_row._id AND NOW() < A.consent_expire_date
					  AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE category_code = '261' AND consent_status_code = 1)
					  AND v_ac_code = CASE WHEN A.inv_action_code = 1 THEN (SELECT DISTINCT B.ac_code FROM transactions.mf_order_detail B
																			WHERE B.trx_id = result_row._id AND B.physicalflag <> 'P')
										   WHEN A.inv_action_code <> 1 THEN (SELECT DISTINCT C.ac_code FROM transactions.mf_order_detail_modification C
																			 WHERE C.trx_id = result_row._id AND C.physicalflag <> 'P') END
					 )
			THEN

				UPDATE temp_mf_trx A SET status = 'SUCCESS'::character varying, remarks = ('Consent Approved Successfully')::character varying
				WHERE A.trx_id = result_row._id;

				UPDATE transactions.order_consent A SET
				consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_approval_reject_datetime = NOW()
				, logged_in_approval = true
				WHERE A.category_code = 261 AND A.trx_id = result_row._id AND NOW() < A.consent_expire_date
				AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE A.category_code = '261' AND consent_status_code = 1)
				AND A.inv_action_code = v_inv_action_code;

				IF(v_inv_action_code = 1)
				THEN

					UPDATE transactions.mf_order_detail A SET
					consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
					, consent_status_code = 2
					, consent_approval_reject_datetime = NOW(), modified_date = NOW()
					WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1);

					UPDATE transactions.mf_order_detail A SET
					final_status = B.trx_final_status,
					trx_final_status_code = B.trx_final_status_code,
					inv_plan_status_code = B.inv_plan_status_code,
					inv_plan_status = B.inv_plan_status,
					payment_status_code= case when A.trx_type_code=4 then 1 
						when A.trx_type_code=1 and A.is_generatetoday=true  then 1 else 0 end,
					payment_status=case when A.trx_type_code=4 then 'Pending' 
						when A.trx_type_code=1 and A.is_generatetoday=true  then 'Pending'  else null end
					FROM transactions.mf_order_detail D
					LEFT JOIN master.mv_map_category_status B
					ON UPPER(B.usertype) = UPPER(D.order_placed_by)
					AND D.physicalflag = B.physicalflag
					AND D.trx_type_code = B.trx_type_code
					AND D.is_generatetoday = B.is_generatetoday
					AND D.consent_status_code = B.consent_status_code
					AND D.payment_status_code = B.payment_status_code
					AND B.trx_status_code = D.trx_status_code
					AND B.inv_action_code = D.inv_action_code
					AND B.category_code = 261
					WHERE A.trx_id = D.trx_id 
					AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1)
					and A.consent_status_code=2 ;

					update transactions.mf_order_summary a
					set
					final_status = B.final_status,
					trx_final_status_code = B.trx_final_status_code,
					inv_plan_status_code = B.inv_plan_status_code,
					inv_plan_status = B.inv_plan_status,
					trx_type_code=b.trx_type_code,
					trx_status_Code=b.trx_status_Code
					from transactions.mf_order_detail b
					where a.trx_id = B.trx_id
					AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1)
					and b.consent_status_code=2 ;

					----------Inserting Data into transaction History Table----------

					UPDATE transactions.mf_order_detail_history A SET valid_to = NOW(), is_active = false
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1)
					AND A.is_active = true;

					INSERT INTO transactions.mf_order_detail_history
					(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
					, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
					,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
					SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
					, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
					,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status	
					FROM transactions.mf_order_detail A
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1);

					UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

					----------Inserting Data into Summary transaction History Table----------

					UPDATE transactions.mf_order_summary_history A SET valid_to = NOW(), is_active = false
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1)
					AND A.is_active = true;

					INSERT INTO transactions.mf_order_summary_history
					(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
					, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
					, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
					, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active
					,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
					SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
					, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
					, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
					, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
					,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
					FROM transactions.mf_order_summary A
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code = 1);

					UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

				ELSE

					----------Updating Data in Modification Stage Table----------

					UPDATE transactions.mf_order_detail_modification A 
					SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
					, consent_status_code = 2
					, consent_approval_reject_datetime = NOW(), modified_date = NOW()
					WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = result_row._id AND C.inv_action_code <> 1);

					UPDATE transactions.mf_order_detail_modification A SET
					final_status = B.trx_final_status,
					trx_final_status_code = B.trx_final_status_code,
					inv_plan_status_code = B.inv_plan_status_code,
					inv_plan_status = B.inv_plan_status
					FROM transactions.mf_order_detail_modification D
					LEFT JOIN master.mv_map_category_status B
					ON UPPER(B.usertype) = UPPER(D.order_placed_by)
					AND D.physicalflag = B.physicalflag
					AND D.trx_type_code = B.trx_type_code
					/* AND D.is_generatetoday = B.is_generatetoday */
					AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
					AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
					AND B.trx_status_code = D.trx_status_code
					AND B.inv_action_code = D.inv_action_code
					AND B.category_code = 261
					WHERE A.trx_id = D.trx_id
					AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = result_row._id AND C.inv_action_code <> 1);
				
				END IF;

			ELSE

			UPDATE temp_mf_trx A SET status = 'FAILURE'::character varying
			, remarks = CASE WHEN (SELECT DISTINCT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.trx_id = result_row._id AND NOW() < A.consent_expire_date
								   AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE category_code = '261' AND consent_status_code = 1)
								   AND v_ac_code <> CASE WHEN A.inv_action_code = 1
														 THEN (SELECT DISTINCT B.ac_code FROM transactions.mf_order_detail B WHERE B.trx_id = result_row._id)
														 WHEN A.inv_action_code <> 1
														 THEN (SELECT DISTINCT C.ac_code FROM transactions.mf_order_detail_modification C WHERE C.trx_id = result_row._id) END
								  ) = 1
							 THEN ('Provided Ac_code for the transaction ID is not matching')::character varying
							 WHEN (SELECT DISTINCT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.trx_id = result_row._id AND NOW() < A.consent_expire_date
								   AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE category_code = '261' AND consent_status_code = 1)
								   AND v_ac_code = CASE WHEN A.inv_action_code = 1
														THEN (SELECT DISTINCT B.ac_code FROM transactions.mf_order_detail B WHERE B.trx_id = result_row._id)
														WHEN A.inv_action_code <> 1
														THEN (SELECT DISTINCT C.ac_code FROM transactions.mf_order_detail_modification C WHERE C.trx_id = result_row._id) END
								  ) = 1
							 THEN ('Provided Ac_code Folio Type is not Demat')::character varying END
			WHERE A.trx_id = result_row._id;								

			END IF;

		END LOOP;

		RETURN QUERY
		SELECT A.trx_id, A.status, A.remarks FROM temp_mf_trx A;

		DROP TABLE temp_mf_trx; 

	ELSE

		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, 'FAILURE'::character varying as status,'No Valid Consent for provided Transaction'::character varying as remarks;

	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_accept_mf_consent_bkp_09may2025(_int8, int4, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent_bkp_09may2025(_int8, int4, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent_bkp_09may2025(_int8, int4, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent_bkp_09may2025(_int8, int4, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_accept_mf_consent_bkp_09may2025(_int8, int4, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_arn_logentry(varchar, varchar, json);

CREATE OR REPLACE FUNCTION transactions.fn_arn_logentry(v_methodname character varying, v_errormsg character varying, v_paylod json)
 RETURNS TABLE(m_status text, m_message text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    BEGIN
        INSERT INTO transactions.ARN_logentry(methodname,errormsg,paylod)
        VALUES (v_methodname,v_errormsg,v_paylod);
        RETURN QUERY SELECT 'SUCCESS' as m_status,'Record added successfully' as m_message;
    EXCEPTION
        WHEN OTHERS THEN
		RETURN QUERY select 'FAILURE' AS m_status, SQLERRM as m_message ;
    END;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_arn_logentry(varchar, varchar, json) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_arn_logentry(varchar, varchar, json) TO public;
GRANT ALL ON FUNCTION transactions.fn_arn_logentry(varchar, varchar, json) TO cmotswrite;

-- DROP FUNCTION transactions.fn_autoexpired_order();

CREATE OR REPLACE FUNCTION transactions.fn_autoexpired_order()
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trxid AS
SELECT DISTINCT b.trx_id
FROM transactions.mf_order_detail a
JOIN transactions.order_consent b ON a.trx_id = b.trx_id AND a.inv_action_code = b.inv_action_code
WHERE a.vendor_trx_id IS NULL
AND a.trx_status_code <> 8 -- Order Rejected
AND a.trx_final_status_code not in (2,8)
and b.consent_status<>'Consent Expired'
AND b.consent_expire_date < NOW() at time zone 'Asia/Kolkata';

---------------------------------------------------------------------------------
CREATE TEMP TABLE IF NOT EXISTS temp_mf_trxid_modify AS
SELECT DISTINCT b.trx_id
FROM transactions.mf_order_detail_modification a
JOIN transactions.order_consent b ON a.trx_id = b.trx_id AND a.inv_action_code = b.inv_action_code
WHERE a.trx_status_code <> 8 -- Order Rejected
AND a.trx_final_status_code not in (2,8)
And a.consent_status_code=1
and b.consent_status<>'Consent Expired'
AND b.consent_expire_date < NOW() at time zone 'Asia/Kolkata';

---------------------------------------------------------------------------------
CREATE TEMP TABLE IF NOT EXISTS temp_mf_trxid_client AS
select trx_id from (
select distinct trx_id
--order_placed_by,physicalflag,is_generatetoday,trx_final_status_code,created_date
--,(select date_trunc('second', calendar_date) calendar_date 
--from platform_db.fn_get_future_tradingdays(created_date, 4)) as order_expiry
from transactions.mf_order_detail a
where order_placed_by='CLIENT' and physicalflag='D'
and trx_final_status_code in (1,3)
and NOW() at time zone 'Asia/Kolkata'>(select date_trunc('second', calendar_date) calendar_date 
from platform_db.fn_get_future_tradingdays(created_date, 4))
union
select distinct a.trx_id
--order_placed_by,physicalflag,is_generatetoday,trx_final_status_code,created_date
--,(select date_trunc('second', calendar_date) calendar_date 
--from platform_db.fn_get_future_tradingdays(created_date, 4)) as order_expiry
from transactions.mf_order_detail a
inner join transactions.otp b
on a.trx_id=b.trx_id
where order_placed_by='CLIENT' and physicalflag='P'
and trx_final_status_code in (1,3,7)
and NOW() at time zone 'Asia/Kolkata'>(select date_trunc('second', calendar_date) calendar_date 
from platform_db.fn_get_future_tradingdays(created_date, 4))
)a;

------------------------------------------
---to update lead status
truncate table transactions.auto_leadstatus_reject RESTART IDENTITY;

insert into transactions.auto_leadstatus_reject(trx_id)
SELECT DISTINCT b.trx_id
FROM transactions.mf_order_detail a
JOIN transactions.order_consent b ON a.trx_id = b.trx_id
WHERE a.vendor_trx_id IS NULL
AND a.trx_status_code <> 8 -- Order Rejected
AND b.consent_expire_date < NOW() at time zone 'Asia/Kolkata'
AND a.trx_final_status_code not in (2,8)
AND a.inv_type_code=3;
	
---------------------------------Order Book
-- Update transactions.mf_order_detail
UPDATE transactions.mf_order_detail
SET 
	modified_date = NOW() at time zone 'Asia/Kolkata',
	trx_status_code = 8,
	trx_status = 'Order Rejected',
	trx_final_status_code=2,
	final_status = 'Order Rejected',
	inv_plan_status_code=7,
	inv_plan_status='Order Rejected',
--	order_remarks = 'Order Expired due to Consent/payment not approved by client on time'
	order_remarks= case when consent_status_code<>2 then 'Order was not approved within the allowed timeline'
			else 'Payment against this order was not completed within the allowed timeline' end
WHERE trx_id IN (SELECT trx_id FROM temp_mf_trxid);

---for Client Orders

UPDATE transactions.mf_order_detail
SET 
	modified_date = NOW() at time zone 'Asia/Kolkata',
	trx_status_code = 8,
	trx_status = 'Order Rejected',
	trx_final_status_code=2,
	final_status = 'Order Rejected',
	inv_plan_status_code=7,
	inv_plan_status='Order Rejected',
	order_remarks= case when trx_final_status_code=7 then 'The order was not approved within the allowed timeline'
				when trx_final_status_code in (1,3) then 'Payment against this order was not completed within the allowed timeline' 
				end
WHERE trx_id IN (SELECT trx_id FROM temp_mf_trxid_client);

-- Update transactions.mf_order_detail_history
UPDATE transactions.mf_order_detail_history
SET valid_to = NOW() at time zone 'Asia/Kolkata', 
	is_active = false
WHERE trx_id IN (
SELECT a.trx_id FROM temp_mf_trxid a
union all
select a.trx_id from temp_mf_trxid_client a
)
AND is_active = true;

-- Insert into transactions.mf_order_detail_history
INSERT INTO transactions.mf_order_detail_history(
trx_id,vendor_trx_id,ucccode,ac_code,trx_type,trx_datetime,mandate_id,
trx_status,payment_status,order_remarks,trx_source,vendor_trx_status,
trx_type_code,trx_status_code,consent_status,consent_status_code,
payment_status_code,valid_from,is_active,final_status,trx_final_status_code,
inv_plan_status_code,inv_plan_status,inserted_dt
)
SELECT 
a.trx_id,a.vendor_trx_id,a.ucccode,a.ac_code,a.trx_type,a.trx_datetime,
a.mandate_id,a.trx_status,a.payment_status,a.order_remarks,a.trx_source,
a.vendor_trx_status,a.trx_type_code,a.trx_status_code,a.consent_status,
a.consent_status_code,a.payment_status_code,NOW() at time zone 'Asia/Kolkata',true as is_active,
a.final_status,a.trx_final_status_code,a.inv_plan_status_code,
a.inv_plan_status,NOW() at time zone 'Asia/Kolkata' as inserted_dt
FROM transactions.mf_order_detail a
WHERE a.trx_id IN (
select a.trx_id from temp_mf_trxid a
union all
select a.trx_id from temp_mf_trxid_client a
);

-- Update valid_to for active records
UPDATE transactions.mf_order_detail_history
SET valid_to = '9999-12-31'::timestamp
WHERE trx_id IN (
select a.trx_id from temp_mf_trxid a
union all
select a.trx_id from temp_mf_trxid_client a	
)
AND is_active = true 
AND valid_to IS NULL;

---------------------------------Summary Book

-- Update transactions.mf_order_summary
UPDATE transactions.mf_order_summary A 
SET
	trx_status_code=B.trx_status_code,
	trx_status=B.trx_status,
	final_status = B.final_status,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status,
	order_remarks=B.order_remarks
FROM transactions.mf_order_detail B
where A.trx_id=B.trx_id
and A.trx_id IN (
select a.trx_id from temp_mf_trxid a
union all
select a.trx_id from temp_mf_trxid_client a	
);

/*
-- Update transactions.mf_order_summary_history
UPDATE transactions.mf_order_summary_history a
	SET valid_to = NOW() at time zone 'Asia/Kolkata',is_active = false
FROM transactions.mf_order_summary b
WHERE a.trx_id IN (
select a.trx_id from temp_mf_trxid a
union all
select a.trx_id from temp_mf_trxid_client a
)
and is_active = true;

-------insert reject entry in History summary 
INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT distinct
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW() at time zone 'Asia/Kolkata',true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A 
join transactions.mf_order_summary_history b on A.trx_id=B.trx_id
WHERE A.trx_id IN (
select a.trx_id from temp_mf_trxid a
union all
select a.trx_id from temp_mf_trxid_client a	
);

-- Update valid_to for active records
UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;
*/

---------------------------------Order Book Modification
-- Update transactions.mf_order_detail
UPDATE transactions.mf_order_detail_modification A
SET 
	modified_date = NOW() at time zone 'Asia/Kolkata',
	trx_status_code = 8,
	trx_status = 'Order Rejected',
	trx_final_status_code=2,
	final_status = 'Order Rejected',
	inv_plan_status_code=7,
	inv_plan_status='Order Rejected',
--	order_remarks = 'Order Expired due to Consent/payment not approved by client on time'
	order_remarks= 'Order was not approved within the allowed timeline.'
WHERE A.trx_id IN (SELECT trx_id FROM temp_mf_trxid_modify);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.trx_id IN (SELECT DISTINCT M.org_trx_id FROM transactions.mf_order_detail_modification M
				 WHERE M.trx_id IN (SELECT trx_id FROM temp_mf_trxid_modify))
AND A.remarks IS NOT NULL;
-----------------------------------------------------------
drop table temp_mf_trxid;
drop table temp_mf_trxid_modify;
drop table temp_mf_trxid_client;
-----------------------------------------------------------
-- Return the status
	RETURN QUERY 
	SELECT 'Success'::character varying AS status;

EXCEPTION
    WHEN OTHERS THEN
        -- Log error if needed
        RETURN QUERY 
        SELECT 'Failure'::character varying AS status;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_autoexpired_order() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order() TO public;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order() TO cmotsread;

-- DROP FUNCTION transactions.fn_autoexpired_order_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_autoexpired_order_bkp_09may2025()
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trxid AS
SELECT DISTINCT b.trx_id
FROM transactions.mf_order_detail a
JOIN transactions.order_consent b ON a.trx_id = b.trx_id AND a.inv_action_code = b.inv_action_code
WHERE a.vendor_trx_id IS NULL
AND a.trx_status_code <> 8 -- Order Rejected
AND a.trx_final_status_code<>2
AND b.consent_expire_date < NOW() at time zone 'Asia/Kolkata';

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trxid_modify AS
SELECT DISTINCT b.trx_id
FROM transactions.mf_order_detail_modification a
JOIN transactions.order_consent b ON a.trx_id = b.trx_id AND a.inv_action_code = b.inv_action_code
WHERE a.trx_status_code <> 8 -- Order Rejected
AND a.trx_final_status_code<>2
And a.consent_status_code=1
AND b.consent_expire_date < NOW() at time zone 'Asia/Kolkata';

------------------------------------------
---to update lead status
truncate table transactions.auto_leadstatus_reject RESTART IDENTITY;

insert into transactions.auto_leadstatus_reject(trx_id)
SELECT DISTINCT b.trx_id
FROM transactions.mf_order_detail a
JOIN transactions.order_consent b ON a.trx_id = b.trx_id
WHERE a.vendor_trx_id IS NULL
AND a.trx_status_code <> 8 -- Order Rejected
AND b.consent_expire_date < NOW()
AND a.trx_final_status_code<>2
AND a.inv_type_code=3;
	
---------------------------------Order Book
-- Update transactions.mf_order_detail
UPDATE transactions.mf_order_detail
SET 
	modified_date = NOW() at time zone 'Asia/Kolkata',
	trx_status_code = 8,
	trx_status = 'Order Rejected',
	trx_final_status_code=2,
	final_status = 'Order Rejected',
	inv_plan_status_code=7,
	inv_plan_status='Order Rejected',
--	order_remarks = 'Order Expired due to Consent/payment not approved by client on time'
	order_remarks= case when consent_status_code<>2 then 'Order was not approved within the allowed timeline'
			else 'Payment against this order was not completed within the allowed timeline' end
WHERE trx_id IN (SELECT trx_id FROM temp_mf_trxid);

-- Update transactions.mf_order_detail_history
UPDATE transactions.mf_order_detail_history
SET valid_to = NOW() at time zone 'Asia/Kolkata', 
	is_active = false
WHERE trx_id IN (SELECT trx_id FROM temp_mf_trxid)
AND is_active = true;

-- Insert into transactions.mf_order_detail_history
INSERT INTO transactions.mf_order_detail_history(
trx_id,vendor_trx_id,ucccode,ac_code,trx_type,trx_datetime,mandate_id,
trx_status,payment_status,order_remarks,trx_source,vendor_trx_status,
trx_type_code,trx_status_code,consent_status,consent_status_code,
payment_status_code,valid_from,is_active,final_status,trx_final_status_code,
inv_plan_status_code,inv_plan_status,inserted_dt
)
SELECT 
a.trx_id,a.vendor_trx_id,a.ucccode,a.ac_code,a.trx_type,a.trx_datetime,
a.mandate_id,a.trx_status,a.payment_status,a.order_remarks,a.trx_source,
a.vendor_trx_status,a.trx_type_code,a.trx_status_code,a.consent_status,
a.consent_status_code,a.payment_status_code,NOW(),true as is_active,
a.final_status,a.trx_final_status_code,a.inv_plan_status_code,
a.inv_plan_status,NOW() at time zone 'Asia/Kolkata' as inserted_dt
FROM transactions.mf_order_detail a
WHERE a.trx_id IN (SELECT trx_id FROM temp_mf_trxid);

-- Update valid_to for active records
UPDATE transactions.mf_order_detail_history
SET valid_to = '9999-12-31'::timestamp
WHERE trx_id IN (SELECT trx_id FROM temp_mf_trxid)
AND is_active = true 
AND valid_to IS NULL;

---------------------------------Summary Book

-- Update transactions.mf_order_summary
UPDATE transactions.mf_order_summary A 
SET
	trx_status_code=B.trx_status_code,
	trx_status=B.trx_status,
	final_status = B.final_status,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status,
	order_remarks=B.order_remarks
FROM transactions.mf_order_detail B
where A.trx_id=B.trx_id
and A.trx_id IN (SELECT trx_id FROM temp_mf_trxid);

-- Update transactions.mf_order_summary_history
UPDATE transactions.mf_order_summary_history a
	SET valid_to = NOW() at time zone 'Asia/Kolkata',is_active = false
FROM transactions.mf_order_summary b
WHERE a.trx_id IN (SELECT trx_id FROM temp_mf_trxid)
and is_active = true;

-------insert reject entry in History summary 
INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT distinct
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW() at time zone 'Asia/Kolkata',true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A 
join transactions.mf_order_summary_history b on A.trx_id=B.trx_id
WHERE A.trx_id IN (SELECT trx_id FROM temp_mf_trxid);

-- Update valid_to for active records
UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

---------------------------------Order Book Modification
-- Update transactions.mf_order_detail
UPDATE transactions.mf_order_detail_modification A
SET 
	modified_date = NOW() at time zone 'Asia/Kolkata',
	trx_status_code = 8,
	trx_status = 'Order Rejected',
	trx_final_status_code=2,
	final_status = 'Order Rejected',
	inv_plan_status_code=7,
	inv_plan_status='Order Rejected',
--	order_remarks = 'Order Expired due to Consent/payment not approved by client on time'
	order_remarks= 'Order was not approved within the allowed timeline'
WHERE A.trx_id IN (SELECT trx_id FROM temp_mf_trxid_modify);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.trx_id IN (SELECT DISTINCT M.org_trx_id FROM transactions.mf_order_detail_modification M
				 WHERE M.trx_id IN (SELECT trx_id FROM temp_mf_trxid_modify))
AND A.remarks IS NOT NULL;
-----------------------------------------------------------
drop table temp_mf_trxid;
drop table temp_mf_trxid_modify;
-----------------------------------------------------------
-- Return the status
	RETURN QUERY 
	SELECT 'Success'::character varying AS status;

EXCEPTION
    WHEN OTHERS THEN
        -- Log error if needed
        RETURN QUERY 
        SELECT 'Failure'::character varying AS status;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_autoexpired_order_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order_bkp_09may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order_bkp_09may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order_bkp_09may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order_bkp_09may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_autoexpired_order_bkp_14jul2025();

CREATE OR REPLACE FUNCTION transactions.fn_autoexpired_order_bkp_14jul2025()
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trxid AS
SELECT DISTINCT b.trx_id
FROM transactions.mf_order_detail a
JOIN transactions.order_consent b ON a.trx_id = b.trx_id AND a.inv_action_code = b.inv_action_code
WHERE a.vendor_trx_id IS NULL
AND a.trx_status_code <> 8 -- Order Rejected
AND a.trx_final_status_code not in (2,8)
AND b.consent_expire_date < NOW() at time zone 'Asia/Kolkata';

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trxid_modify AS
SELECT DISTINCT b.trx_id
FROM transactions.mf_order_detail_modification a
JOIN transactions.order_consent b ON a.trx_id = b.trx_id AND a.inv_action_code = b.inv_action_code
WHERE a.trx_status_code <> 8 -- Order Rejected
AND a.trx_final_status_code not in (2,8)
And a.consent_status_code=1
AND b.consent_expire_date < NOW() at time zone 'Asia/Kolkata';

------------------------------------------
---to update lead status
truncate table transactions.auto_leadstatus_reject RESTART IDENTITY;

insert into transactions.auto_leadstatus_reject(trx_id)
SELECT DISTINCT b.trx_id
FROM transactions.mf_order_detail a
JOIN transactions.order_consent b ON a.trx_id = b.trx_id
WHERE a.vendor_trx_id IS NULL
AND a.trx_status_code <> 8 -- Order Rejected
AND b.consent_expire_date < NOW() at time zone 'Asia/Kolkata'
AND a.trx_final_status_code not in (2,8)
AND a.inv_type_code=3;
	
---------------------------------Order Book
-- Update transactions.mf_order_detail
UPDATE transactions.mf_order_detail
SET 
	modified_date = NOW() at time zone 'Asia/Kolkata',
	trx_status_code = 8,
	trx_status = 'Order Rejected',
	trx_final_status_code=2,
	final_status = 'Order Rejected',
	inv_plan_status_code=7,
	inv_plan_status='Order Rejected',
--	order_remarks = 'Order Expired due to Consent/payment not approved by client on time'
	order_remarks= case when consent_status_code<>2 then 'Order was not approved within the allowed timeline'
			else 'Payment against this order was not completed within the allowed timeline' end
WHERE trx_id IN (SELECT trx_id FROM temp_mf_trxid);

-- Update transactions.mf_order_detail_history
UPDATE transactions.mf_order_detail_history
SET valid_to = NOW() at time zone 'Asia/Kolkata', 
	is_active = false
WHERE trx_id IN (SELECT trx_id FROM temp_mf_trxid)
AND is_active = true;

-- Insert into transactions.mf_order_detail_history
INSERT INTO transactions.mf_order_detail_history(
trx_id,vendor_trx_id,ucccode,ac_code,trx_type,trx_datetime,mandate_id,
trx_status,payment_status,order_remarks,trx_source,vendor_trx_status,
trx_type_code,trx_status_code,consent_status,consent_status_code,
payment_status_code,valid_from,is_active,final_status,trx_final_status_code,
inv_plan_status_code,inv_plan_status,inserted_dt
)
SELECT 
a.trx_id,a.vendor_trx_id,a.ucccode,a.ac_code,a.trx_type,a.trx_datetime,
a.mandate_id,a.trx_status,a.payment_status,a.order_remarks,a.trx_source,
a.vendor_trx_status,a.trx_type_code,a.trx_status_code,a.consent_status,
a.consent_status_code,a.payment_status_code,NOW() at time zone 'Asia/Kolkata',true as is_active,
a.final_status,a.trx_final_status_code,a.inv_plan_status_code,
a.inv_plan_status,NOW() at time zone 'Asia/Kolkata' as inserted_dt
FROM transactions.mf_order_detail a
WHERE a.trx_id IN (SELECT trx_id FROM temp_mf_trxid);

-- Update valid_to for active records
UPDATE transactions.mf_order_detail_history
SET valid_to = '9999-12-31'::timestamp
WHERE trx_id IN (SELECT trx_id FROM temp_mf_trxid)
AND is_active = true 
AND valid_to IS NULL;

---------------------------------Summary Book

-- Update transactions.mf_order_summary
UPDATE transactions.mf_order_summary A 
SET
	trx_status_code=B.trx_status_code,
	trx_status=B.trx_status,
	final_status = B.final_status,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status,
	order_remarks=B.order_remarks
FROM transactions.mf_order_detail B
where A.trx_id=B.trx_id
and A.trx_id IN (SELECT trx_id FROM temp_mf_trxid);

-- Update transactions.mf_order_summary_history
UPDATE transactions.mf_order_summary_history a
	SET valid_to = NOW() at time zone 'Asia/Kolkata',is_active = false
FROM transactions.mf_order_summary b
WHERE a.trx_id IN (SELECT trx_id FROM temp_mf_trxid)
and is_active = true;

-------insert reject entry in History summary 
INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT distinct
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW() at time zone 'Asia/Kolkata',true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A 
join transactions.mf_order_summary_history b on A.trx_id=B.trx_id
WHERE A.trx_id IN (SELECT trx_id FROM temp_mf_trxid);

-- Update valid_to for active records
UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

---------------------------------Order Book Modification
-- Update transactions.mf_order_detail
UPDATE transactions.mf_order_detail_modification A
SET 
	modified_date = NOW() at time zone 'Asia/Kolkata',
	trx_status_code = 8,
	trx_status = 'Order Rejected',
	trx_final_status_code=2,
	final_status = 'Order Rejected',
	inv_plan_status_code=7,
	inv_plan_status='Order Rejected',
--	order_remarks = 'Order Expired due to Consent/payment not approved by client on time'
	order_remarks= 'Order was not approved within the allowed timeline'
WHERE A.trx_id IN (SELECT trx_id FROM temp_mf_trxid_modify);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.trx_id IN (SELECT DISTINCT M.org_trx_id FROM transactions.mf_order_detail_modification M
				 WHERE M.trx_id IN (SELECT trx_id FROM temp_mf_trxid_modify))
AND A.remarks IS NOT NULL;
-----------------------------------------------------------
drop table temp_mf_trxid;
drop table temp_mf_trxid_modify;
-----------------------------------------------------------
-- Return the status
	RETURN QUERY 
	SELECT 'Success'::character varying AS status;

EXCEPTION
    WHEN OTHERS THEN
        -- Log error if needed
        RETURN QUERY 
        SELECT 'Failure'::character varying AS status;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_autoexpired_order_bkp_14jul2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order_bkp_14jul2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order_bkp_14jul2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order_bkp_14jul2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_autoexpired_order_bkp_14jul2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_cancel_pause_resume_mf(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_cancel_pause_resume_mf(v_logintype character varying, v_logincode character varying, v_trx_source character varying, v_type_id integer, v_trx_id bigint, v_vendor_req character varying, v_pause_inst integer DEFAULT 0, v_natureoforder character varying DEFAULT NULL::character varying, v_created_for character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying, order_expiry timestamp without time zone, vendor_req character varying, installment_date_post_pause_resume date)
 LANGUAGE plpgsql
AS $function$

DECLARE v_id bigint;
DECLARE v_installment_date_post_pause_resume date;
DECLARE v_created_for_name character varying;
DECLARE v_created_for_type character varying;

BEGIN

SELECT 
	COALESCE(initcap(created_for_name), '') AS created_for_name,
	COALESCE(created_for_type, '') AS created_for_type
INTO v_created_for_name, v_created_for_type
FROM (
	SELECT a.fullname AS created_for_name, 'E' AS created_for_type
	FROM master.dim_ed_employee a
	WHERE ltrim(a.empcode, '0') = v_created_for

	UNION

	SELECT a.partner_name AS created_for_name, 'P' AS created_for_type
	FROM master.partner a
	WHERE a.upccode = v_created_for
	and upper(a.status)	='ACTIVE'
	--'PNW23054520' 
) sub
LIMIT 1;

-- Optional: use RAISE NOTICE to print the values
RAISE NOTICE 'Name: %, Type: %', v_created_for_name, v_created_for_type;	

/* SELECT * FROM master.investment_action
"category_code"	"inv_action_code"	"inv_action"	"isactive"
	261					1			"Transaction"		true
	261					2			"Pause"				true
	261					3			"Modify"			true
	261					4			"Cancel"			true */

	IF (v_type_id = 4 AND EXISTS(SELECT 1 FROM transactions.mf_order_summary A WHERE A.trx_type_code IN (1, 2, 3) AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id))
	THEN
		
		IF NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7))
		THEN

		update transactions.mf_order_detail A
			set inv_plan_status_code = 4 where A.trx_id = v_trx_id;
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;

			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, 
				modified_date, datasource, sip_frequency, sip_date, trx_amt,natureoforder,created_for,created_for_name,created_for_type
				)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 4
			, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 4)
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, 
			NOW() at time zone 'Asia/Kolkata', NOW() at time zone 'Asia/Kolkata', 'DION'::character varying
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id), A.trx_amt
				,v_natureoforder,v_created_for,v_created_for_name, v_created_for_type
			FROM transactions.mf_order_detail A WHERE A.trx_type_code IN (1, 2, 3) AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET remarks = 'Cancel Request in Progress'::character varying WHERE A.trx_id = v_trx_id;
			
			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Cancellation Application for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
			
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Cancellation for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;
		
	ELSIF (v_type_id = 2 AND v_pause_inst > 0 AND
--			EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id))
			EXISTS(SELECT 1 FROM transactions.mf_order_detail A
					JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id AND A.trx_type_code = 1
					JOIN master.dim_mf_exchange_isin E ON A.isincode = B.isincode AND A.tokenno = E.token AND txn_type = 'XSIP' AND TRIM(UPPER(B.frequency)) = TRIM(UPPER(E.frequency))
					WHERE B.trx_type_code = 1 AND B.inv_plan_status_code = 4 AND B.trx_id = v_trx_id 
		AND E.pause_modification_count::integer > COALESCE(B.pausecount, 0)))
		THEN
		
		IF (NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 2 AND A.trx_status_code = 7) AND
			NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7)))
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
			
/*			SELECT (B.upcoming_due_date + CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY' THEN v_pause_inst || ' MONTHS'
 											   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN v_pause_inst || ' QUARTER' 
											   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN (v_pause_inst*3) || ' MONTHS' 
											   WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN v_pause_inst || ' DAYS' END::interval)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;  */

			SELECT (COALESCE(B.upcoming_due_date, B.start_date)
							+ CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY' THEN ( v_pause_inst +
																		(case when B.upcoming_due_date is null then coalesce(B.installment_paid,0) else 0 end)::int ) || ' MONTHS'
								   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN (( v_pause_inst +
																		(case when B.upcoming_due_date is null then coalesce(B.installment_paid,0) else 0 end)::int )*3) || ' MONTHS' 
								   WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN ( v_pause_inst +
																		(case when B.upcoming_due_date is null then coalesce(B.installment_paid,0) else 0 end)::int ) || ' DAYS' END::interval)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;

			RAISE NOTICE 'Calculated date: %', v_installment_date_post_pause_resume;

			update transactions.mf_order_detail A
				set inv_plan_status_code = 4 where A.trx_id = v_trx_id;
			
			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource, no_of_inst_paused
			 , sip_frequency, sip_date, installment_date_post_pause_resume, trx_amt,natureoforder,created_for,created_for_name,created_for_type)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 2
			, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 2)
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, 
				NOW() at time zone 'Asia/Kolkata', NOW() at time zone 'Asia/Kolkata', 'DION'::character varying, v_pause_inst
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, v_installment_date_post_pause_resume, A.trx_amt,v_natureoforder,v_created_for,v_created_for_name, v_created_for_type
			FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET remarks = 'Pause Request in Progress'::character varying WHERE A.trx_id = v_trx_id;

			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Order Pause for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
		
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Pause for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;

	ELSIF (v_type_id = 0 AND EXISTS(SELECT 1 FROM transactions.mf_order_summary A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 2 AND A.trx_id = v_trx_id))
	THEN
		
		IF NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 0 AND A.trx_status_code = 7)
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
			
			SELECT (CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY'
						 THEN CASE WHEN EXTRACT('days' FROM B.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '1 Month'
								   ELSE TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY'
						 THEN CASE WHEN EXTRACT('days' FROM B.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '3 Months'
								   ELSE TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN current_date + Interval '2 Days' END)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;

			RAISE NOTICE 'Calculated date: %', v_installment_date_post_pause_resume;

			update transactions.mf_order_detail A
				set inv_plan_status_code = 2 where A.trx_id = v_trx_id;

			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource
			 , sip_frequency, sip_date, installment_date_post_pause_resume, trx_amt,natureoforder,created_for,created_for_name,created_for_type)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 0
			, 'Resume'::character varying
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, 
			NOW() at time zone 'Asia/Kolkata', NOW() at time zone 'Asia/Kolkata', 'DION'::character varying
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, v_installment_date_post_pause_resume, A.trx_amt,v_natureoforder,v_created_for,v_created_for_name, v_created_for_type
			FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 2 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			/* AND B.inv_action_code = D.inv_action_code */
			AND B.inv_action_code = 2
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
	
			UPDATE transactions.mf_order_summary A SET remarks = 'Resume Request in Progress'::character varying WHERE A.trx_id = v_trx_id;

			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Order Resume for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
		
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Resume for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;
		
	ELSE
	
		RETURN QUERY
		SELECT v_trx_id, 'FAILURE'::character varying as status, 'Invalid Input Parameters'::character varying as remarks
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, ''::character varying as vendor_req, current_date;
		
	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_cancel_pause_resume_mf(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_05sept2025(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_05sept2025(v_logintype character varying, v_logincode character varying, v_trx_source character varying, v_type_id integer, v_trx_id bigint, v_vendor_req character varying, v_pause_inst integer DEFAULT 0, v_natureoforder character varying DEFAULT NULL::character varying, v_created_for character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying, order_expiry timestamp without time zone, vendor_req character varying, installment_date_post_pause_resume date)
 LANGUAGE plpgsql
AS $function$

DECLARE v_id bigint;
DECLARE v_installment_date_post_pause_resume date;

BEGIN

/* SELECT * FROM master.investment_action
"category_code"	"inv_action_code"	"inv_action"	"isactive"
	261					1			"Transaction"		true
	261					2			"Pause"				true
	261					3			"Modify"			true
	261					4			"Cancel"			true */

	IF (v_type_id = 4 AND EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code IN (1, 2, 3) AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id))
	THEN
		
		IF NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7))
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;

			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, 
				modified_date, datasource, sip_frequency, sip_date, trx_amt,natureoforder,created_for
				)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 4
			, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 4)
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, 
			NOW() at time zone 'Asia/Kolkata', NOW() at time zone 'Asia/Kolkata', 'DION'::character varying
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id), A.trx_amt,v_natureoforder,v_created_for
			FROM transactions.mf_order_detail A WHERE A.trx_type_code IN (1, 2, 3) AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET remarks = 'Cancel Request in Progress'::character varying WHERE A.trx_id = v_trx_id;
			
			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Cancellation Application for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
			
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Cancellation for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;
		
	ELSIF (v_type_id = 2 AND v_pause_inst > 0 AND
--			EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id))
			EXISTS(SELECT 1 FROM transactions.mf_order_detail A
					JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id AND A.trx_type_code = 1
					JOIN master.dim_mf_exchange_isin E ON A.isincode = B.isincode AND A.tokenno = E.token AND txn_type = 'XSIP' AND TRIM(UPPER(B.frequency)) = TRIM(UPPER(E.frequency))
					WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id AND E.pause_modification_count::integer > COALESCE(B.pausecount, 0)))
		THEN
		
		IF (NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 2 AND A.trx_status_code = 7) AND
			NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7)))
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
			
/*			SELECT (B.upcoming_due_date + CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY' THEN v_pause_inst || ' MONTHS'
 											   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN v_pause_inst || ' QUARTER' 
											   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN (v_pause_inst*3) || ' MONTHS' 
											   WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN v_pause_inst || ' DAYS' END::interval)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;  */

			SELECT (COALESCE(B.upcoming_due_date, B.start_date)
							+ CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY' THEN ( v_pause_inst +
																		(case when B.upcoming_due_date is null then coalesce(B.installment_paid,0) else 0 end)::int ) || ' MONTHS'
								   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN (( v_pause_inst +
																		(case when B.upcoming_due_date is null then coalesce(B.installment_paid,0) else 0 end)::int )*3) || ' MONTHS' 
								   WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN ( v_pause_inst +
																		(case when B.upcoming_due_date is null then coalesce(B.installment_paid,0) else 0 end)::int ) || ' DAYS' END::interval)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;
			
			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource, no_of_inst_paused
			 , sip_frequency, sip_date, installment_date_post_pause_resume, trx_amt,natureoforder,created_for)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 2
			, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 2)
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, 
				NOW() at time zone 'Asia/Kolkata', NOW() at time zone 'Asia/Kolkata', 'DION'::character varying, v_pause_inst
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, v_installment_date_post_pause_resume, A.trx_amt,v_natureoforder,v_created_for
			FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET remarks = 'Pause Request in Progress'::character varying WHERE A.trx_id = v_trx_id;

			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Order Pause for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
		
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Pause for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;

	ELSIF (v_type_id = 0 AND EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 2 AND A.trx_id = v_trx_id))
	THEN
		
		IF NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 0 AND A.trx_status_code = 7)
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
			
			SELECT (CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY'
						 THEN CASE WHEN EXTRACT('days' FROM B.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '1 Month'
								   ELSE TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY'
						 THEN CASE WHEN EXTRACT('days' FROM B.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '3 Months'
								   ELSE TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN current_date + Interval '2 Days' END)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;

			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource
			 , sip_frequency, sip_date, installment_date_post_pause_resume, trx_amt,natureoforder,created_for)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 0
			, 'Resume'::character varying
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, 
			NOW() at time zone 'Asia/Kolkata', NOW() at time zone 'Asia/Kolkata', 'DION'::character varying
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, v_installment_date_post_pause_resume, A.trx_amt,v_natureoforder,v_created_for
			FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 2 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			/* AND B.inv_action_code = D.inv_action_code */
			AND B.inv_action_code = 2
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
	
			UPDATE transactions.mf_order_summary A SET remarks = 'Resume Request in Progress'::character varying WHERE A.trx_id = v_trx_id;

			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Order Resume for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
		
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Resume for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;
		
	ELSE
	
		RETURN QUERY
		SELECT v_trx_id, 'FAILURE'::character varying as status, 'Invalid Input Parameters'::character varying as remarks
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, ''::character varying as vendor_req, current_date;
		
	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_05sept2025(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_05sept2025(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_05sept2025(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_05sept2025(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_05sept2025(varchar, varchar, varchar, int4, int8, varchar, int4, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_09may2025(varchar, varchar, varchar, int4, int8, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_09may2025(v_logintype character varying, v_logincode character varying, v_trx_source character varying, v_type_id integer, v_trx_id bigint, v_vendor_req character varying, v_pause_inst integer DEFAULT 0)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying, order_expiry timestamp without time zone, vendor_req character varying, installment_date_post_pause_resume date)
 LANGUAGE plpgsql
AS $function$

DECLARE v_id bigint;
DECLARE v_installment_date_post_pause_resume date;

BEGIN

/* SELECT * FROM master.investment_action
"category_code"	"inv_action_code"	"inv_action"	"isactive"
	261					1			"Transaction"		true
	261					2			"Pause"				true
	261					3			"Modify"			true
	261					4			"Cancel"			true */

	IF (v_type_id = 4 AND EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code IN (1, 2, 3) AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id))
	THEN
		
		IF NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7))
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;

			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource, sip_frequency, sip_date, trx_amt)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) = 'RM' OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) = 'RM' OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 4
			, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 4)
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, NOW(), NOW(), 'DION'::character varying
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id), A.trx_amt
			FROM transactions.mf_order_detail A WHERE A.trx_type_code IN (1, 2, 3) AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET remarks = 'Cancel Request in Progress'::character varying WHERE A.trx_id = v_trx_id;
			
			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Cancellation Application for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
			
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Cancellation for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;
		
	ELSIF (v_type_id = 2 AND v_pause_inst > 0 AND
--			EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id))
			EXISTS(SELECT 1 FROM transactions.mf_order_detail A
					JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id AND A.trx_type_code = 1
					JOIN master.dim_mf_exchange_isin E ON A.isincode = B.isincode AND A.tokenno = E.token AND txn_type = 'XSIP' AND TRIM(UPPER(B.frequency)) = TRIM(UPPER(E.frequency))
					WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id AND E.pause_modification_count::integer > COALESCE(B.pausecount, 0)))
		THEN
		
		IF (NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 2 AND A.trx_status_code = 7) AND
			NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7)))
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
			
/*			SELECT (B.upcoming_due_date + CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY' THEN v_pause_inst || ' MONTHS'
 											   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN v_pause_inst || ' QUARTER' 
											   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN (v_pause_inst*3) || ' MONTHS' 
											   WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN v_pause_inst || ' DAYS' END::interval)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;  */

			SELECT (COALESCE(B.upcoming_due_date, B.start_date)
							+ CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY' THEN ( v_pause_inst +
																		(case when B.upcoming_due_date is null then B.installment_paid else 0 end)::int ) || ' MONTHS'
								   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN (( v_pause_inst +
																		(case when B.upcoming_due_date is null then B.installment_paid else 0 end)::int )*3) || ' MONTHS' 
								   WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN ( v_pause_inst +
																		(case when B.upcoming_due_date is null then B.installment_paid else 0 end)::int ) || ' DAYS' END::interval)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;
			
			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource, no_of_inst_paused
			 , sip_frequency, sip_date, installment_date_post_pause_resume, trx_amt)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) = 'RM' OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) = 'RM' OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 2
			, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 2)
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, NOW(), NOW(), 'DION'::character varying, v_pause_inst
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, v_installment_date_post_pause_resume, A.trx_amt
			FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET remarks = 'Pause Request in Progress'::character varying WHERE A.trx_id = v_trx_id;

			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Order Pause for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
		
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Pause for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;

	ELSIF (v_type_id = 0 AND EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 2 AND A.trx_id = v_trx_id))
	THEN
		
		IF NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 0 AND A.trx_status_code = 7)
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
			
			SELECT (CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY'
						 THEN CASE WHEN EXTRACT('days' FROM B.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '1 Month'
								   ELSE TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY'
						 THEN CASE WHEN EXTRACT('days' FROM B.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '3 Months'
								   ELSE TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN current_date + Interval '2 Days' END)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;

			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource
			 , sip_frequency, sip_date, installment_date_post_pause_resume, trx_amt)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) = 'RM' OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) = 'RM' OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 0
			, 'Resume'::character varying
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, NOW(), NOW(), 'DION'::character varying
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, v_installment_date_post_pause_resume, A.trx_amt
			FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 2 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			/* AND B.inv_action_code = D.inv_action_code */
			AND B.inv_action_code = 2
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
	
			UPDATE transactions.mf_order_summary A SET remarks = 'Resume Request in Progress'::character varying WHERE A.trx_id = v_trx_id;

			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Order Resume for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
		
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Resume for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;
		
	ELSE
	
		RETURN QUERY
		SELECT v_trx_id, 'FAILURE'::character varying as status, 'Invalid Input Parameters'::character varying as remarks
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, ''::character varying as vendor_req, current_date;
		
	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_09may2025(varchar, varchar, varchar, int4, int8, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_09may2025(varchar, varchar, varchar, int4, int8, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_09may2025(varchar, varchar, varchar, int4, int8, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_09may2025(varchar, varchar, varchar, int4, int8, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_09may2025(varchar, varchar, varchar, int4, int8, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_14jul2025(varchar, varchar, varchar, int4, int8, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_14jul2025(v_logintype character varying, v_logincode character varying, v_trx_source character varying, v_type_id integer, v_trx_id bigint, v_vendor_req character varying, v_pause_inst integer DEFAULT 0)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying, order_expiry timestamp without time zone, vendor_req character varying, installment_date_post_pause_resume date)
 LANGUAGE plpgsql
AS $function$

DECLARE v_id bigint;
DECLARE v_installment_date_post_pause_resume date;

BEGIN

/* SELECT * FROM master.investment_action
"category_code"	"inv_action_code"	"inv_action"	"isactive"
	261					1			"Transaction"		true
	261					2			"Pause"				true
	261					3			"Modify"			true
	261					4			"Cancel"			true */

	IF (v_type_id = 4 AND EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code IN (1, 2, 3) AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id))
	THEN
		
		IF NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7))
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;

			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource, sip_frequency, sip_date, trx_amt)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 4
			, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 4)
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, NOW(), NOW(), 'DION'::character varying
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id), A.trx_amt
			FROM transactions.mf_order_detail A WHERE A.trx_type_code IN (1, 2, 3) AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET remarks = 'Cancel Request in Progress'::character varying WHERE A.trx_id = v_trx_id;
			
			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Cancellation Application for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
			
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Cancellation for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;
		
	ELSIF (v_type_id = 2 AND v_pause_inst > 0 AND
--			EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id))
			EXISTS(SELECT 1 FROM transactions.mf_order_detail A
					JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id AND A.trx_type_code = 1
					JOIN master.dim_mf_exchange_isin E ON A.isincode = B.isincode AND A.tokenno = E.token AND txn_type = 'XSIP' AND TRIM(UPPER(B.frequency)) = TRIM(UPPER(E.frequency))
					WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id AND E.pause_modification_count::integer > COALESCE(B.pausecount, 0)))
		THEN
		
		IF (NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 2 AND A.trx_status_code = 7) AND
			NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7)))
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
			
/*			SELECT (B.upcoming_due_date + CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY' THEN v_pause_inst || ' MONTHS'
 											   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN v_pause_inst || ' QUARTER' 
											   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN (v_pause_inst*3) || ' MONTHS' 
											   WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN v_pause_inst || ' DAYS' END::interval)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;  */

			SELECT (COALESCE(B.upcoming_due_date, B.start_date)
							+ CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY' THEN ( v_pause_inst +
																		(case when B.upcoming_due_date is null then coalesce(B.installment_paid,0) else 0 end)::int ) || ' MONTHS'
								   WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY' THEN (( v_pause_inst +
																		(case when B.upcoming_due_date is null then coalesce(B.installment_paid,0) else 0 end)::int )*3) || ' MONTHS' 
								   WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN ( v_pause_inst +
																		(case when B.upcoming_due_date is null then coalesce(B.installment_paid,0) else 0 end)::int ) || ' DAYS' END::interval)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;
			
			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource, no_of_inst_paused
			 , sip_frequency, sip_date, installment_date_post_pause_resume, trx_amt)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 2
			, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 2)
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, NOW(), NOW(), 'DION'::character varying, v_pause_inst
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, v_installment_date_post_pause_resume, A.trx_amt
			FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET remarks = 'Pause Request in Progress'::character varying WHERE A.trx_id = v_trx_id;

			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Order Pause for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
		
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Pause for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;

	ELSIF (v_type_id = 0 AND EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 2 AND A.trx_id = v_trx_id))
	THEN
		
		IF NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 0 AND A.trx_status_code = 7)
		THEN
		
			SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
			
			SELECT (CASE WHEN UPPER(TRIM(B.frequency)) = 'MONTHLY'
						 THEN CASE WHEN EXTRACT('days' FROM B.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '1 Month'
								   ELSE TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(B.frequency)) = 'QUARTERLY'
						 THEN CASE WHEN EXTRACT('days' FROM B.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '3 Months'
								   ELSE TO_DATE((EXTRACT('days' FROM B.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(B.frequency)) = 'DAILY' THEN current_date + Interval '2 Days' END)::date
			INTO v_installment_date_post_pause_resume
			FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id;

			INSERT INTO transactions.mf_order_detail_modification
			(trx_id, orderby, vc_remarks, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode
			 , trx_type_code, trx_type, consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action
			 , physicalflag, mandate_id, trx_source, rm_partner_code, vendor_req, order_placed_by, created_date, modified_date, datasource
			 , sip_frequency, sip_date, installment_date_post_pause_resume, trx_amt)
			SELECT v_id, v_logincode, '11|I have decided to invest elsewhere', A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
			, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
			, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
			, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 0
			, 'Resume'::character varying
			, A.physicalflag, A.mandate_id, v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype, NOW(), NOW(), 'DION'::character varying
			, (SELECT B.frequency FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, (SELECT B.upcoming_due_date FROM transactions.mf_order_summary B WHERE B.trx_id = v_trx_id)
			, v_installment_date_post_pause_resume, A.trx_amt
			FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 2 AND A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			/* AND B.inv_action_code = D.inv_action_code */
			AND B.inv_action_code = 2
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
	
			UPDATE transactions.mf_order_summary A SET remarks = 'Resume Request in Progress'::character varying WHERE A.trx_id = v_trx_id;

			RETURN QUERY
			SELECT A.trx_id, 'SUCCESS'::character varying as status, ('Order Resume for ' || A.display_trx_id || ' sucessful')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, A.installment_date_post_pause_resume FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
		
		ELSE
		
			RETURN QUERY
			SELECT A.trx_id, 'FAILURE'::character varying as status, ('Resume for ' || A.display_trx_id || ' Failed')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, current_date FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		END IF;
		
	ELSE
	
		RETURN QUERY
		SELECT v_trx_id, 'FAILURE'::character varying as status, 'Invalid Input Parameters'::character varying as remarks
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, ''::character varying as vendor_req, current_date;
		
	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_14jul2025(varchar, varchar, varchar, int4, int8, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_14jul2025(varchar, varchar, varchar, int4, int8, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_14jul2025(varchar, varchar, varchar, int4, int8, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_14jul2025(varchar, varchar, varchar, int4, int8, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_cancel_pause_resume_mf_bkp_14jul2025(varchar, varchar, varchar, int4, int8, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_delete_older_errordata();

CREATE OR REPLACE FUNCTION transactions.fn_delete_older_errordata()
 RETURNS void
 LANGUAGE plpgsql
AS $function$

DECLARE
    error_message TEXT;
BEGIN
    BEGIN
        -- Delete records older than 7 days from mf_order_detail_error
        DELETE FROM transactions.mf_order_detail_error 
        WHERE error_date >= NOW() - INTERVAL '7 days';
    EXCEPTION WHEN OTHERS THEN
        error_message := 'Error occurred in mf_order_detail_error: ' || SQLERRM;
        RAISE NOTICE '%', error_message;
    END;

    BEGIN
        -- Delete records older than 7 days from mf_mandate_error
        DELETE FROM transactions.mf_mandate_error 
        WHERE inserted_dt >= NOW() - INTERVAL '7 days';
    EXCEPTION WHEN OTHERS THEN
        error_message := 'Error occurred in mf_mandate_error: ' || SQLERRM;
        RAISE NOTICE '%', error_message;
    END;

    BEGIN
        -- Delete records older than 7 days from mf_due_dates_error
        DELETE FROM transactions.mf_due_dates_error 
        WHERE error_date >= NOW() - INTERVAL '7 days';
    EXCEPTION WHEN OTHERS THEN
        error_message := 'Error occurred in mf_due_dates_error: ' || SQLERRM;
        RAISE NOTICE '%', error_message;
    END;

    BEGIN
        -- Delete records older than 7 days from mf_subsequent_order_error
        DELETE FROM transactions.mf_subsequent_order_error 
        WHERE error_date >= NOW() - INTERVAL '7 days';
    EXCEPTION WHEN OTHERS THEN
        error_message := 'Error occurred in mf_subsequent_order_error: ' || SQLERRM;
        RAISE NOTICE '%', error_message;
    END;

    BEGIN
        -- Delete records older than 7 days from mf_order_summary_error
        DELETE FROM transactions.mf_order_summary_error 
        WHERE error_date >= NOW() - INTERVAL '7 days';
    EXCEPTION WHEN OTHERS THEN
        error_message := 'Error occurred in mf_order_summary_error: ' || SQLERRM;
        RAISE NOTICE '%', error_message;
    END;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_delete_older_errordata() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_delete_older_errordata() TO cmotswrite;

-- DROP FUNCTION transactions.fn_generate_mf_arnform(int4, varchar, text, varchar, varchar, varchar, varchar, bool);

CREATE OR REPLACE FUNCTION transactions.fn_generate_mf_arnform(p_sync_id integer, p_ucccode character varying, p_isin text, p_folio character varying, p_arn_status character varying, p_usercode character varying, p_user_type character varying, p_isdownload boolean DEFAULT false)
 RETURNS TABLE(pan character varying, ac_name character varying, folio text, schemename text, amcname text, rtaname text, rm_name character varying, templateid integer, eventid integer, channelid integer, tomailid character varying, ccmailid character varying, providerref character varying, euin character varying, euinname character varying, planmode character varying, nuvamabrokercode character varying, nuvamabrokername character varying, brokercode character varying, brokername character varying)
 LANGUAGE plpgsql
AS $function$


DECLARE
    v_plsqltext TEXT;
   	v_updt_plsqltext TEXT;
   	v_folio text:='';
   	v_isin text:='';
   	v_euin varchar:='';
   v_millisec INT;
begin
	
	--select coalesce (c.euinno,'') into v_euin 
	--from master.certification c 
	--where c.user_type  = p_user_type
	--and c.user_code  = p_usercode;

 	v_millisec := EXTRACT(MILLISECONDS FROM clock_timestamp())::INT;

    IF v_millisec % 2 = 0 THEN
        v_euin := 'E077777';
    ELSE
        v_euin := 'E522044';
    END IF;


	IF p_folio IS NOT NULL AND trim(p_folio) <> '' THEN
        v_folio := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(f))
                FROM unnest(string_to_array(p_folio, ',')) AS f
            ), ','
        );
    END IF;

    IF p_isin IS NOT NULL AND trim(p_isin) <> '' THEN
        v_isin := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(i))
                FROM unnest(string_to_array(p_isin, ',')) AS i
            ), ','
        );
    END IF;

    v_updt_plsqltext := format($sql$
       update transactions.mf_client_holdings_external exthol
        set arn_transfer_status = %L,
        	updated_date = current_timestamp at TIME ZONE'Asia/Kolkata'
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, p_arn_status ,p_ucccode, p_sync_id);

    v_plsqltext := format($sql$
        SELECT
		    exthol.pan,
            du.acname AS ac_name,
            CAST(exthol.folio AS TEXT) AS folio,
            CAST(initcap(dmi.isinname)  AS TEXT) AS schemename,
			CAST(initcap(exthol.amcname) AS text) amcname,
			--CAST(initcap(exthol.rtaname) AS text) rtaname,
			(CASE WHEN LOWER(SUBSTRING(exthol.rtaname, 1, 4)) = 'kfin' THEN 'KFIN Tech'
         		ELSE UPPER(exthol.rtaname) END )::text AS rtaname,
            du.client_owner_name as rm_name,
			cast (7 as int ) as templateid,
			cast (1 as int ) as eventid ,
			cast (1 as int ) as channelid,
			cast (du.rm_email as varchar) as tomailid,
			cast (du.rm_email as varchar) as ccmailid,
			cast ('Netcore' as varchar )as providerref,
			cast(%L as varchar) AS euin,
			cast('' as varchar) as euinname,
			UPPER(SUBSTRING(nav.schplan , 1, 1))::varchar AS planmode,
			CASE WHEN UPPER(SUBSTRING(nav.schplan, 1, 1)) = 'D' THEN 'INZ000005231' ELSE '70892' END ::varchar AS nuvamabrokercode,
			cast ('Nuvama Wealth & Investment Ltd.' as varchar) as nuvamabrokername,
			exthol.brokercode as brokercode,
			exthol.brokername as brokername
        FROM transactions.mf_client_holdings_external exthol
        JOIN master.dim_ucc du ON exthol.ucccode = du.ucccode
        join master.dim_mf_isin dmi on exthol.isin = dmi.isincode
        join platform_db.mv_mf_details nav on exthol.isin = nav.isincode
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, coalesce (v_euin,'') , p_ucccode, p_sync_id);

    IF v_folio IS NOT NULL AND v_folio <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';
       	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';

    END IF;

    IF v_isin IS NOT NULL AND v_isin <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';
    	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';

    END IF;

   	v_plsqltext := v_plsqltext || ' order by exthol.folio';

   	--RAISE NOTICE 'v_updt_plsqltext :%',v_updt_plsqltext;
   	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;

   	EXECUTE v_updt_plsqltext ;
   	RETURN QUERY EXECUTE v_plsqltext ;

end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_generate_mf_arnform(int4, varchar, text, varchar, varchar, varchar, varchar, bool) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_generate_mf_arnform(int4, varchar, text, varchar, varchar, varchar, varchar, bool) TO cmotswrite;

-- DROP FUNCTION transactions.fn_generate_mf_arnform_bkp12082025(int4, varchar, text, varchar, varchar, varchar, varchar, bool);

CREATE OR REPLACE FUNCTION transactions.fn_generate_mf_arnform_bkp12082025(p_sync_id integer, p_ucccode character varying, p_isin text, p_folio character varying, p_arn_status character varying, p_usercode character varying, p_user_type character varying, p_isdownload boolean DEFAULT false)
 RETURNS TABLE(pan character varying, ac_name character varying, folio text, schemename text, amcname text, rtaname text, rm_name character varying, templateid integer, eventid integer, channelid integer, tomailid character varying, ccmailid character varying, providerref character varying, euin character varying, planmode character varying, brokercode character varying, brokername character varying)
 LANGUAGE plpgsql
AS $function$


DECLARE
    v_plsqltext TEXT;
   	v_updt_plsqltext TEXT;
   	v_folio text:='';
   	v_isin text:='';
   	v_euin varchar:='';
   v_millisec INT;
begin
	
	--select coalesce (c.euinno,'') into v_euin 
	--from master.certification c 
	--where c.user_type  = p_user_type
	--and c.user_code  = p_usercode;

 	v_millisec := EXTRACT(MILLISECONDS FROM clock_timestamp())::INT;

    IF v_millisec % 2 = 0 THEN
        v_euin := 'E077777';
    ELSE
        v_euin := 'E522044';
    END IF;


	IF p_folio IS NOT NULL AND trim(p_folio) <> '' THEN
        v_folio := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(f))
                FROM unnest(string_to_array(p_folio, ',')) AS f
            ), ','
        );
    END IF;

    IF p_isin IS NOT NULL AND trim(p_isin) <> '' THEN
        v_isin := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(i))
                FROM unnest(string_to_array(p_isin, ',')) AS i
            ), ','
        );
    END IF;

    v_updt_plsqltext := format($sql$
       update transactions.mf_client_holdings_external exthol
        set arn_transfer_status = %L,
        	updated_date = current_timestamp at TIME ZONE'Asia/Kolkata'
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, p_arn_status ,p_ucccode, p_sync_id);

    v_plsqltext := format($sql$
        SELECT
		    exthol.pan,
            du.acname AS ac_name,
            CAST(exthol.folio AS TEXT) AS folio,
            CAST(initcap(dmi.isinname)  AS TEXT) AS schemename,
			CAST(initcap(exthol.amcname) AS text) amcname,
			--CAST(initcap(exthol.rtaname) AS text) rtaname,
			(CASE WHEN LOWER(SUBSTRING(exthol.rtaname, 1, 4)) = 'kfin' THEN 'KFIN Tech'
         		ELSE UPPER(exthol.rtaname) END )::text AS rtaname,
            du.client_owner_name as rm_name,
			cast (7 as int ) as templateid,
			cast (1 as int ) as eventid ,
			cast (1 as int ) as channelid,
			cast (du.rm_email as varchar) as tomailid,
			cast (du.rm_email as varchar) as ccmailid,
			cast ('Netcore' as varchar )as providerref,
			cast(%L as varchar) AS euin,
			UPPER(SUBSTRING(nav.schplan , 1, 1))::varchar AS planmode,
			CASE WHEN UPPER(SUBSTRING(nav.schplan, 1, 1)) = 'D' THEN 'INZ000005231' ELSE '70892' END ::varchar AS brokercode,
			cast ('Nuvama Wealth & Investment Ltd.' as varchar) as brokername
        FROM transactions.mf_client_holdings_external exthol
        JOIN master.dim_ucc du ON exthol.ucccode = du.ucccode
        join master.dim_mf_isin dmi on exthol.isin = dmi.isincode
        join platform_db.mv_mf_details nav on exthol.isin = nav.isincode
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, coalesce (v_euin,'') , p_ucccode, p_sync_id);

    IF v_folio IS NOT NULL AND v_folio <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';
       	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';

    END IF;

    IF v_isin IS NOT NULL AND v_isin <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';
    	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';

    END IF;

   	v_plsqltext := v_plsqltext || ' order by exthol.folio';

   	--RAISE NOTICE 'v_updt_plsqltext :%',v_updt_plsqltext;
   	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;

   	EXECUTE v_updt_plsqltext ;
   	RETURN QUERY EXECUTE v_plsqltext ;

end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_generate_mf_arnform_bkp12082025(int4, varchar, text, varchar, varchar, varchar, varchar, bool) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_generate_mf_arnform_bkp12082025(int4, varchar, text, varchar, varchar, varchar, varchar, bool) TO cmotswrite;

-- DROP FUNCTION transactions.fn_generate_mf_arnform_bkp30072025(int4, varchar, text, varchar, varchar, varchar, varchar, bool);

CREATE OR REPLACE FUNCTION transactions.fn_generate_mf_arnform_bkp30072025(p_sync_id integer, p_ucccode character varying, p_isin text, p_folio character varying, p_arn_status character varying, p_usercode character varying, p_user_type character varying, p_isdownload boolean DEFAULT false)
 RETURNS TABLE(pan character varying, ac_name character varying, folio text, schemename text, amcname text, rtaname text, rm_name character varying, templateid integer, eventid integer, channelid integer, tomailid character varying, ccmailid character varying, providerref character varying, euin character varying, planmode character varying, brokercode character varying, brokername character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
    v_plsqltext TEXT;
   	v_updt_plsqltext TEXT;
   	v_folio text:='';
   	v_isin text:='';
   	v_euin varchar:='';
begin
	
	select coalesce (c.euinno,'') into v_euin 
	from master.certification c 
	where c.user_type  = p_user_type
	and c.user_code  = p_usercode;


	IF p_folio IS NOT NULL AND trim(p_folio) <> '' THEN
        v_folio := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(f))
                FROM unnest(string_to_array(p_folio, ',')) AS f
            ), ','
        );
    END IF;

    IF p_isin IS NOT NULL AND trim(p_isin) <> '' THEN
        v_isin := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(i))
                FROM unnest(string_to_array(p_isin, ',')) AS i
            ), ','
        );
    END IF;

    v_updt_plsqltext := format($sql$
       update transactions.mf_client_holdings_external exthol
        set arn_transfer_status = %L,
        	updated_date = current_timestamp at TIME ZONE'Asia/Kolkata'
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, p_arn_status ,p_ucccode, p_sync_id);

    v_plsqltext := format($sql$
        SELECT
		    exthol.pan,
            du.acname AS ac_name,
            CAST(exthol.folio AS TEXT) AS folio,
            CAST(initcap(dmi.isinname)  AS TEXT) AS schemename,
			CAST(initcap(exthol.amcname) AS text) amcname,
			--CAST(initcap(exthol.rtaname) AS text) rtaname,
			(CASE WHEN LOWER(SUBSTRING(exthol.rtaname, 1, 4)) = 'kfin' THEN 'KFIN Tech'
         		ELSE UPPER(exthol.rtaname) END )::text AS rtaname,
            du.client_owner_name as rm_name,
			cast (7 as int ) as templateid,
			cast (1 as int ) as eventid ,
			cast (1 as int ) as channelid,
			cast (du.rm_email as varchar) as tomailid,
			cast (du.rm_email as varchar) as ccmailid,
			cast ('Netcore' as varchar )as providerref,
			cast(%L as varchar) AS euin,
			UPPER(SUBSTRING(nav.schplan , 1, 1))::varchar AS planmode,
			CASE WHEN UPPER(SUBSTRING(nav.schplan, 1, 1)) = 'D' THEN 'INZ000005231' ELSE '70892' END ::varchar AS brokercode,
			cast ('Nuvama Wealth & Investment Ltd.' as varchar) as brokername
        FROM transactions.mf_client_holdings_external exthol
        JOIN master.dim_ucc du ON exthol.ucccode = du.ucccode
        join master.dim_mf_isin dmi on exthol.isin = dmi.isincode
        join platform_db.mv_mf_details nav on exthol.isin = nav.isincode
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, coalesce (v_euin,'') , p_ucccode, p_sync_id);

    IF v_folio IS NOT NULL AND v_folio <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';
       	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';

    END IF;

    IF v_isin IS NOT NULL AND v_isin <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';
    	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';

    END IF;

   	v_plsqltext := v_plsqltext || ' order by exthol.folio';

   	--RAISE NOTICE 'v_updt_plsqltext :%',v_updt_plsqltext;
   	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;

   	EXECUTE v_updt_plsqltext ;
   	RETURN QUERY EXECUTE v_plsqltext ;

end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_generate_mf_arnform_bkp30072025(int4, varchar, text, varchar, varchar, varchar, varchar, bool) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_generate_mf_arnform_bkp30072025(int4, varchar, text, varchar, varchar, varchar, varchar, bool) TO cmotswrite;

-- DROP FUNCTION transactions.fn_generate_mf_arnform_bkp_28072025(int4, varchar, text, varchar, varchar, varchar, varchar, bool);

CREATE OR REPLACE FUNCTION transactions.fn_generate_mf_arnform_bkp_28072025(p_sync_id integer, p_ucccode character varying, p_isin text, p_folio character varying, p_arn_status character varying, p_usercode character varying, p_user_type character varying, p_isdownload boolean DEFAULT false)
 RETURNS TABLE(pan character varying, ac_name character varying, folio text, schemename text, amcname text, rtaname text, rm_name character varying, templateid integer, eventid integer, channelid integer, tomailid character varying, ccmailid character varying, providerref character varying, euin character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
    v_plsqltext TEXT;
   	v_updt_plsqltext TEXT;
   	v_folio text:='';
   	v_isin text:='';
   	v_euin varchar:='';
begin
	
	select coalesce (c.euinno,'') into v_euin 
	from master.certification c 
	where c.user_type  = p_user_type
	and c.user_code  = p_usercode;


	IF p_folio IS NOT NULL AND trim(p_folio) <> '' THEN
        v_folio := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(f))
                FROM unnest(string_to_array(p_folio, ',')) AS f
            ), ','
        );
    END IF;

    IF p_isin IS NOT NULL AND trim(p_isin) <> '' THEN
        v_isin := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(i))
                FROM unnest(string_to_array(p_isin, ',')) AS i
            ), ','
        );
    END IF;

    v_updt_plsqltext := format($sql$
       update transactions.mf_client_holdings_external exthol
        set arn_transfer_status = %L,
        	updated_date = current_timestamp at TIME ZONE'Asia/Kolkata'
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, p_arn_status ,p_ucccode, p_sync_id);

    v_plsqltext := format($sql$
        SELECT
		    exthol.pan,
            du.acname AS ac_name,
            CAST(exthol.folio AS TEXT) AS folio,
            CAST(initcap(dmi.isinname)  AS TEXT) AS schemename,
			CAST(initcap(exthol.amcname) AS text) amcname,
			CAST(initcap(exthol.rtaname) AS text) rtaname,
            du.client_owner_name as rm_name,
			cast (7 as int ) as templateid,
			cast (1 as int ) as eventid ,
			cast (1 as int ) as channelid,
			cast (du.rm_email as varchar) as tomailid,
			cast (du.rm_email as varchar) as ccmailid,
			cast ('Netcore' as varchar )as providerref,
			cast(%L as varchar) AS euin
        FROM transactions.mf_client_holdings_external exthol
        JOIN master.dim_ucc du ON exthol.ucccode = du.ucccode
        join master.dim_mf_isin dmi on exthol.isin = dmi.isincode
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, coalesce (v_euin,'') , p_ucccode, p_sync_id);

    IF v_folio IS NOT NULL AND v_folio <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';
       	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';

    END IF;

    IF v_isin IS NOT NULL AND v_isin <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';
    	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';

    END IF;

   	v_plsqltext := v_plsqltext || ' order by exthol.folio';

   	--RAISE NOTICE 'v_updt_plsqltext :%',v_updt_plsqltext;
   	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;

   	EXECUTE v_updt_plsqltext ;
   	RETURN QUERY EXECUTE v_plsqltext ;

end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_generate_mf_arnform_bkp_28072025(int4, varchar, text, varchar, varchar, varchar, varchar, bool) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_generate_mf_arnform_bkp_28072025(int4, varchar, text, varchar, varchar, varchar, varchar, bool) TO cmotswrite;

-- DROP FUNCTION transactions.fn_generate_mf_arnform_new(int4, varchar, text, varchar, varchar, varchar, varchar, bool);

CREATE OR REPLACE FUNCTION transactions.fn_generate_mf_arnform_new(p_sync_id integer, p_ucccode character varying, p_isin text, p_folio character varying, p_arn_status character varying, p_usercode character varying, p_user_type character varying, p_isdownload boolean DEFAULT false)
 RETURNS TABLE(pan character varying, ac_name character varying, folio text, schemename text, amcname text, rtaname text, rm_name character varying, templateid integer, eventid integer, channelid integer, tomailid character varying, ccmailid character varying, providerref character varying, euin character varying, planmode character varying, brokercode character varying, brokername character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
    v_plsqltext TEXT;
   	v_updt_plsqltext TEXT;
   	v_folio text:='';
   	v_isin text:='';
   	v_euin varchar:='';
begin
	
	select coalesce (c.euinno,'') into v_euin 
	from master.certification c 
	where c.user_type  = p_user_type
	and c.user_code  = p_usercode;


	IF p_folio IS NOT NULL AND trim(p_folio) <> '' THEN
        v_folio := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(f))
                FROM unnest(string_to_array(p_folio, ',')) AS f
            ), ','
        );
    END IF;

    IF p_isin IS NOT NULL AND trim(p_isin) <> '' THEN
        v_isin := array_to_string(
            ARRAY(
                SELECT quote_literal(trim(i))
                FROM unnest(string_to_array(p_isin, ',')) AS i
            ), ','
        );
    END IF;

    v_updt_plsqltext := format($sql$
       update transactions.mf_client_holdings_external exthol
        set arn_transfer_status = %L,
        	updated_date = current_timestamp at TIME ZONE'Asia/Kolkata'
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, p_arn_status ,p_ucccode, p_sync_id);

    v_plsqltext := format($sql$
        SELECT
		    exthol.pan,
            du.acname AS ac_name,
            CAST(exthol.folio AS TEXT) AS folio,
            CAST(initcap(dmi.isinname)  AS TEXT) AS schemename,
			CAST(initcap(exthol.amcname) AS text) amcname,
			CAST(initcap(exthol.rtaname) AS text) rtaname,
            du.client_owner_name as rm_name,
			cast (7 as int ) as templateid,
			cast (1 as int ) as eventid ,
			cast (1 as int ) as channelid,
			cast (du.rm_email as varchar) as tomailid,
			cast (du.rm_email as varchar) as ccmailid,
			cast ('Netcore' as varchar )as providerref,
			cast(%L as varchar) AS euin,
			UPPER(SUBSTRING(nav.schplan , 1, 1))::varchar AS planmode,
			CASE WHEN UPPER(SUBSTRING(nav.schplan, 1, 1)) = 'D' THEN 'INZ000005231' ELSE '70892' END ::varchar AS brokercode,
			cast ('Nuvama Wealth & Investment Ltd.' as varchar) as brokername
        FROM transactions.mf_client_holdings_external exthol
        JOIN master.dim_ucc du ON exthol.ucccode = du.ucccode
        join master.dim_mf_isin dmi on exthol.isin = dmi.isincode
        join platform_db.mv_mf_details nav on exthol.isin = nav.isincode
        WHERE exthol.ucccode = %L
        AND exthol.sync_history_id = %s
    $sql$, coalesce (v_euin,'') , p_ucccode, p_sync_id);

    IF v_folio IS NOT NULL AND v_folio <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';
       	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.folio IN (' || v_folio || ')';

    END IF;

    IF v_isin IS NOT NULL AND v_isin <> '' THEN

    	v_plsqltext := v_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';
    	v_updt_plsqltext := v_updt_plsqltext || ' AND exthol.isin IN (' || v_isin || ')';

    END IF;

   	v_plsqltext := v_plsqltext || ' order by exthol.folio';

   	--RAISE NOTICE 'v_updt_plsqltext :%',v_updt_plsqltext;
   	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;

   	EXECUTE v_updt_plsqltext ;
   	RETURN QUERY EXECUTE v_plsqltext ;

end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_generate_mf_arnform_new(int4, varchar, text, varchar, varchar, varchar, varchar, bool) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_generate_mf_arnform_new(int4, varchar, text, varchar, varchar, varchar, varchar, bool) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_aggregatedholding(int4, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_aggregatedholding(p_scheme_id integer, p_category_code integer, p_client_code character varying)
 RETURNS TABLE(m_amount numeric, m_units numeric, m_initial_purchase_date text, m_holdingdate date, m_redemptiontime character varying, m_rmname character varying, m_rmcode character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        SUM(a.marketvalue) AS m_amount,
        SUM(a.totalqty) AS m_units,
        min(a.initial_purchase_date)::TEXT AS m_initial_purchase_date,
        max(a.holdingdate),
        a.redemptiontime AS m_redemptiontime,
        e.fullname as rmname,
        e.empcode as rmcode 
    FROM transactions.mv_client_holding a
    INNER JOIN master.dim_ucc ucc ON a.ucccode = ucc.ucccode 
    INNER JOIN master.dim_ed_employee e ON e.cip_empcode = ucc.client_owner
    -- change left join to inner join...this was done for testing purpose
    --LEFT JOIN aif_pms.aifpms_reverse_feed feed ON a.isincode = feed.scheme_id::VARCHAR and a.ucccode = feed.ucccode
  WHERE a.isincode = p_scheme_id::varchar
   AND   a.category_code = p_category_code
   AND   a.ucccode = p_client_code
    GROUP BY a.redemptiontime,e.fullname ,e.empcode;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_aggregatedholding(int4, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_aggregatedholding(int4, int4, varchar) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_aifpms_recentclientsearch(int4, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_aifpms_recentclientsearch(p_logincode integer, p_category_code integer, p_usertype character varying)
 RETURNS TABLE(ucccode character varying, clientname character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

    CREATE TEMP TABLE IF NOT EXISTS temp_aifpms_ucc AS
    SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1 = 0;

    INSERT INTO temp_aifpms_ucc(ucccode)
    SELECT DISTINCT a.ucccode
    FROM master.dim_ucc a
	WHERE
		CASE
		WHEN upper(p_usertype) = 'C' THEN a.priority_ac_code = p_logincode
		--WHEN upper(p_usertype) = 'E' AND coalesce(p_logincode, '') <> '' THEN a.client_owner = p_logincode AND a.priority_ac_code = p_logincode
		WHEN upper(p_usertype) = 'E' AND coalesce(p_logincode, '') <> ''  THEN a.client_owner = p_logincode
		--WHEN upper(p_usertype) = 'P' AND coalesce(p_logincode, '') <> '' THEN a.partnerowner = p_logincode AND a.priority_ac_code = p_logincode
		WHEN upper(p_usertype) = 'P' AND coalesce(p_logincode, '') <> ''  THEN a.partnerowner = p_logincode
		ELSE FALSE
	end;

    RETURN QUERY
    SELECT a.ucccode,
           a.clientname
    FROM aif_pms.category_client_recent_search a
    WHERE a.category_code = p_category_code
      AND a.ucccode IN (SELECT DISTINCT b.ucccode FROM temp_aifpms_ucc b)
    ORDER BY a.category_code DESC
    LIMIT 5;
   
-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
-------------------------------------------------------------


END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_aifpms_recentclientsearch(int4, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_aifpms_recentclientsearch(int4, int4, varchar) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_arn_inprogress(int4, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_arn_inprogress(p_sync_id integer, p_ucccode character varying, p_usercode character varying, p_user_type character varying)
 RETURNS TABLE(folios character varying, isins character varying)
 LANGUAGE plpgsql
AS $function$

begin
	
	return query
	select --folio ,isin 
	STRING_AGG(folio, ',' ORDER BY id) :: varchar AS folios,
  	STRING_AGG(isin, ',' ORDER BY id) :: varchar  AS isins
	FROM transactions.mf_client_holdings_external
	where sync_history_id  = p_sync_id and ucccode = p_ucccode and arn_transfer_status = 'In Progress'
    and avlunits > 0;
	
end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_arn_inprogress(int4, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_arn_inprogress(int4, varchar, varchar, varchar) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_bank_list(text, int4, int4, bool, text);

CREATE OR REPLACE FUNCTION transactions.fn_get_bank_list(p_search_key text DEFAULT NULL::text, p_page_index integer DEFAULT 1, p_page_size integer DEFAULT 10, p_orderbydesc boolean DEFAULT false, p_orderby text DEFAULT NULL::text)
 RETURNS TABLE(bank_name character varying, bankcode character varying, logo_url character varying, icon_url character varying, total_pages integer, total_records integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
    filter text := '';
    count_sql text;
    total_records integer;
    total_pages integer;
    order_clause text := '';
    pagination_clause text := '';
BEGIN
    -- Apply search filter
    IF p_search_key IS NOT NULL THEN
       -- filter := filter || ' AND lower(bankname) ILIKE ''%' || replace(lower(p_search_key), '''', '''''') || '%''';
          filter := filter || ' AND (lower(bankname) ILIKE ''%' || replace(lower(p_search_key), '''', '''''') || '%'' OR lower(bankcode) ILIKE ''%' || replace(lower(p_search_key), '''', '''''') || '%'')';

    END IF;
    
    -- Count total records for pagination
    count_sql := 'SELECT COUNT(*) FROM transactions.bank WHERE seg = ''eq''' || filter;
    EXECUTE count_sql INTO total_records;
    
    -- Calculate total pages
    total_pages := CEIL(total_records::NUMERIC / COALESCE(p_page_size, 10))::INTEGER;
    
    -- Apply ordering
    IF p_orderby IS NOT NULL THEN
        order_clause := ' ORDER BY ' || p_orderby || CASE WHEN p_orderbydesc THEN ' DESC' ELSE ' ASC' END;
    ELSE
        order_clause := ' ORDER BY bankname ASC'; -- Default ordering
    END IF;
    
    -- Apply pagination
    pagination_clause := ' LIMIT ' || p_page_size || ' OFFSET ' || ((p_page_index - 1) * p_page_size);
    
    -- Return query with filtering, sorting, and pagination
    RETURN QUERY EXECUTE 
    'WITH cte AS (
        SELECT DISTINCT bankcode, bankname, logo_url, icon_url FROM transactions.bank WHERE seg = ''eq''' || filter || '
    )
    SELECT bankname, bankcode, logo_url, icon_url, ' || total_pages || ', ' || total_records || '
    FROM cte ' || order_clause || pagination_clause;
    
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_bank_list(text, int4, int4, bool, text) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_bank_list(text, int4, int4, bool, text) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_client_details(varchar, int8, int4);

CREATE OR REPLACE FUNCTION transactions.fn_get_client_details(v_ac_code character varying, v_trx_id bigint, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(ac_code character varying, ac_name character varying, mobileno character varying, email character varying, ac_type character varying, ucccode character varying, advisor_name character varying, advisor_mobile character varying, advisor_email character varying, helpdesk_number text, helpdesk_email text, employee_type text, client_pan character varying, client_dob timestamp without time zone, userid character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_advisor_name character varying;
DECLARE v_advisor_mobile character varying;
DECLARE v_advisor_email character varying;
DECLARE v_natureoforder character varying;

BEGIN

v_natureoforder := (select upper(natureoforder) from transactions.mf_order_detail where trx_id=v_trx_id);

IF(upper(v_natureoforder)='ADMIN')	
Then 
select 
A.advisor_name::character varying as advisor_name,
A.advisor_mobile::character varying as advisor_mobile,
A.advisor_email::character varying as advisor_email
into v_advisor_name,v_advisor_mobile,v_advisor_email
from (
	select distinct 
	ucc.fullname as advisor_name,
	ucc.officemobile as advisor_mobile,
	ucc.emp_b_email as advisor_email
	from transactions.mf_order_detail a
	left join master.dim_ed_employee ucc
	on ltrim(ucc.empcode, '0') = coalesce(a.created_for,a.orderby)
	where a.trx_id=v_trx_id
	and a.order_placed_by<>'CLIENT'
)A where A.advisor_email is not null
limit 1;

Else
select 
A.advisor_name::character varying as advisor_name,
A.advisor_mobile::character varying as advisor_mobile,
A.advisor_email::character varying as advisor_email
into v_advisor_name,v_advisor_mobile,v_advisor_email
from (
	select distinct 
	ucc.client_owner_name as advisor_name,
	ucc.rm_mobile as advisor_mobile,
	ucc.rm_email as advisor_email
	from transactions.mf_order_detail a
	left join master.dim_ucc ucc
	on ucc.client_owner = coalesce(a.created_for,a.orderby)
	where a.trx_id=v_trx_id
	and a.order_placed_by<>'CLIENT'
	union
	select distinct 
	ucc.partner_name as advisor_name,
	ucc.partner_mobile as advisor_mobile,
	ucc.partner_email as advisor_email
	from transactions.mf_order_detail a
	left join master.dim_ucc ucc
	on ucc.partner_code = coalesce(a.created_for,a.orderby)
	where a.trx_id=v_trx_id
	and a.order_placed_by<>'CLIENT'
)A where A.advisor_email is not null
limit 1;
END IF;

	IF v_inv_action_code=1 
	THEN 
    RETURN QUERY
    SELECT 
        a.ac_code AS ac_code,
        b.acname AS ac_name,
	--	b.mobileno
        coalesce(a.mobileno,b.mobileno)::character varying as mobileno,
		coalesce(a.email,b.email)::character varying as email,
      --  a.email,
        b.actype AS ac_type,
        b.ucccode,
CASE 
    WHEN COALESCE(v_advisor_name, '') = '' THEN 
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.client_owner_name
            ELSE b.partner_name 
        END
    ELSE v_advisor_name
END AS advisor_name,
CASE 
    WHEN COALESCE(v_advisor_mobile, '') = '' THEN 
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_mobile
            ELSE b.partner_mobile
        END
    ELSE v_advisor_mobile
END AS advisor_mobile,
CASE 
    WHEN COALESCE(v_advisor_email, '') = '' THEN 		
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_email
            ELSE b.partner_email
        END
    ELSE v_advisor_email
END AS advisor_email,
        '1800-102-3335' AS helpdesk_number,
        'helpdesk@nuvama.com' AS helpdesk_email,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN 'E'
            ELSE 'P'
        END AS employee_type,
        b.pan AS client_pan,
        b.birthdate AS client_dob,
        b.user_name AS userid
    FROM transactions.mf_order_detail a
	inner join master.dim_ucc b
	on a.ac_code=b.priority_ac_code
    WHERE a.ac_code = v_ac_code and a.trx_id=v_trx_id;

ELSE

    RETURN QUERY
    SELECT 
        a.ac_code AS ac_code,
        b.acname AS ac_name,
	--	b.mobileno
        coalesce(c.mobileno,b.mobileno)::character varying as mobileno,
		coalesce(c.email,b.email)::character varying as email,
      --  a.email,
        b.actype AS ac_type,
        b.ucccode,
CASE 
    WHEN COALESCE(v_advisor_name, '') = '' THEN 
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.client_owner_name
            ELSE b.partner_name 
        END
    ELSE v_advisor_name
END AS advisor_name,
CASE 
    WHEN COALESCE(v_advisor_mobile, '') = '' THEN 
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_mobile
            ELSE b.partner_mobile
        END
    ELSE v_advisor_mobile
END AS advisor_mobile,
CASE 
    WHEN COALESCE(v_advisor_email, '') = '' THEN 		
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_email
            ELSE b.partner_email
        END
    ELSE v_advisor_email
END AS advisor_email,
        '1800-102-3335' AS helpdesk_number,
        'helpdesk@nuvama.com' AS helpdesk_email,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN 'E'
            ELSE 'P'
        END AS employee_type,
        b.pan AS client_pan,
        b.birthdate AS client_dob,
        b.user_name AS userid
    FROM transactions.mf_order_detail_modification a
	inner join transactions.mf_order_detail c on a.org_trx_id=c.trx_id
	inner join master.dim_ucc b on a.ac_code=b.priority_ac_code
    WHERE a.ac_code = v_ac_code and a.trx_id=v_trx_id;
END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_client_details(varchar, int8, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_details(varchar, int8, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_client_details(varchar, int8, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_details(varchar, int8, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_client_details(varchar, int8, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_client_details(varchar, int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_client_details(v_ac_code character varying, v_trx_id bigint)
 RETURNS TABLE(ac_code character varying, ac_name character varying, mobileno character varying, email character varying, ac_type character varying, ucccode character varying, advisor_name character varying, advisor_mobile character varying, advisor_email character varying, helpdesk_number text, helpdesk_email text, employee_type text, client_pan character varying, client_dob timestamp without time zone, userid character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        a.ac_code AS ac_code,
        b.acname AS ac_name,
	--	b.mobileno
        coalesce(a.mobileno,b.mobileno)::character varying as mobileno,
		coalesce(a.email,b.email)::character varying as email,
      --  a.email,
        b.actype AS ac_type,
        b.ucccode,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.client_owner_name
            ELSE b.partner_name
        END AS advisor_name,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_mobile
            ELSE b.partner_mobile
        END AS advisor_mobile,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_email
            ELSE b.partner_email
        END AS advisor_email,
        '1800-102-3335' AS helpdesk_number,
        'helpdesk@nuvama.com' AS helpdesk_email,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN 'E'
            ELSE 'P'
        END AS employee_type,
        b.pan AS client_pan,
        b.birthdate AS client_dob,
        b.user_name AS userid
    FROM transactions.mf_order_detail a
	inner join master.dim_ucc b
	on a.ac_code=b.priority_ac_code
    WHERE a.ac_code = v_ac_code and a.trx_id=v_trx_id;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_client_details(varchar, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_details(varchar, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_client_details(varchar, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_details(varchar, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_client_details(varchar, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_client_details_bkp_14jul2025(varchar, int8, int4);

CREATE OR REPLACE FUNCTION transactions.fn_get_client_details_bkp_14jul2025(v_ac_code character varying, v_trx_id bigint, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(ac_code character varying, ac_name character varying, mobileno character varying, email character varying, ac_type character varying, ucccode character varying, advisor_name character varying, advisor_mobile character varying, advisor_email character varying, helpdesk_number text, helpdesk_email text, employee_type text, client_pan character varying, client_dob timestamp without time zone, userid character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

	if(v_inv_action_code)=1
	then 
	
    RETURN QUERY
    SELECT 
        a.ac_code AS ac_code,
        b.acname AS ac_name,
	--	b.mobileno
        coalesce(a.mobileno,b.mobileno)::character varying as mobileno,
		coalesce(a.email,b.email)::character varying as email,
      --  a.email,
        b.actype AS ac_type,
        b.ucccode,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.client_owner_name
            ELSE b.partner_name
        END AS advisor_name,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_mobile
            ELSE b.partner_mobile
        END AS advisor_mobile,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_email
            ELSE b.partner_email
        END AS advisor_email,
        '1800-102-3335' AS helpdesk_number,
        'helpdesk@nuvama.com' AS helpdesk_email,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN 'E'
            ELSE 'P'
        END AS employee_type,
        b.pan AS client_pan,
        b.birthdate AS client_dob,
        b.user_name AS userid
    FROM transactions.mf_order_detail a
	inner join master.dim_ucc b
	on a.ac_code=b.priority_ac_code
    WHERE a.ac_code = v_ac_code and a.trx_id=v_trx_id;

ELSE

    RETURN QUERY
    SELECT 
        a.ac_code AS ac_code,
        b.acname AS ac_name,
	--	b.mobileno
        coalesce(c.mobileno,b.mobileno)::character varying as mobileno,
		coalesce(c.email,b.email)::character varying as email,
      --  a.email,
        b.actype AS ac_type,
        b.ucccode,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.client_owner_name
            ELSE b.partner_name
        END AS advisor_name,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_mobile
            ELSE b.partner_mobile
        END AS advisor_mobile,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_email
            ELSE b.partner_email
        END AS advisor_email,
        '1800-102-3335' AS helpdesk_number,
        'helpdesk@nuvama.com' AS helpdesk_email,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN 'E'
            ELSE 'P'
        END AS employee_type,
        b.pan AS client_pan,
        b.birthdate AS client_dob,
        b.user_name AS userid
    FROM transactions.mf_order_detail_modification a
	inner join transactions.mf_order_detail c on a.org_trx_id=c.trx_id
	inner join master.dim_ucc b on a.ac_code=b.priority_ac_code
    WHERE a.ac_code = v_ac_code and a.trx_id=v_trx_id;
END IF;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_client_details_bkp_14jul2025(varchar, int8, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_details_bkp_14jul2025(varchar, int8, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_client_details_bkp_14jul2025(varchar, int8, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_details_bkp_14jul2025(varchar, int8, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_client_details_bkp_14jul2025(varchar, int8, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_client_details_test(varchar, int8, int4);

CREATE OR REPLACE FUNCTION transactions.fn_get_client_details_test(v_ac_code character varying, v_trx_id bigint, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(ac_code character varying, ac_name character varying, mobileno character varying, email character varying, ac_type character varying, ucccode character varying, advisor_name character varying, advisor_mobile character varying, advisor_email character varying, helpdesk_number text, helpdesk_email text, employee_type text, client_pan character varying, client_dob timestamp without time zone, userid character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_advisor_name character varying;
DECLARE v_advisor_mobile character varying;
DECLARE v_advisor_email character varying;
DECLARE v_natureoforder character varying;

BEGIN

v_natureoforder := (select upper(natureoforder) from transactions.mf_order_detail where trx_id=v_trx_id);

IF(upper(v_natureoforder)='ADMIN')	
Then 
select 
A.advisor_name::character varying as advisor_name,
A.advisor_mobile::character varying as advisor_mobile,
A.advisor_email::character varying as advisor_email
into v_advisor_name,v_advisor_mobile,v_advisor_email
from (
	select distinct 
	ucc.fullname as advisor_name,
	ucc.officemobile as advisor_mobile,
	ucc.emp_b_email as advisor_email
	from transactions.mf_order_detail a
	left join master.dim_ed_employee ucc
	on ltrim(ucc.empcode, '0') = coalesce(a.created_for,a.orderby)
	where a.trx_id=v_trx_id
	and a.order_placed_by<>'CLIENT'
)A where A.advisor_email is not null
limit 1;

Else
select 
A.advisor_name::character varying as advisor_name,
A.advisor_mobile::character varying as advisor_mobile,
A.advisor_email::character varying as advisor_email
into v_advisor_name,v_advisor_mobile,v_advisor_email
from (
	select distinct 
	ucc.client_owner_name as advisor_name,
	ucc.rm_mobile as advisor_mobile,
	ucc.rm_email as advisor_email
	from transactions.mf_order_detail a
	left join master.dim_ucc ucc
	on ucc.client_owner = coalesce(a.created_for,a.orderby)
	where a.trx_id=v_trx_id
	and a.order_placed_by<>'CLIENT'
	union
	select distinct 
	ucc.partner_name as advisor_name,
	ucc.partner_mobile as advisor_mobile,
	ucc.partner_email as advisor_email
	from transactions.mf_order_detail a
	left join master.dim_ucc ucc
	on ucc.partner_code = coalesce(a.created_for,a.orderby)
	where a.trx_id=v_trx_id
	and a.order_placed_by<>'CLIENT'
)A where A.advisor_email is not null
limit 1;
END IF;

	IF v_inv_action_code=1 
	THEN 
    RETURN QUERY
    SELECT 
        a.ac_code AS ac_code,
        b.acname AS ac_name,
	--	b.mobileno
        coalesce(a.mobileno,b.mobileno)::character varying as mobileno,
		coalesce(a.email,b.email)::character varying as email,
      --  a.email,
        b.actype AS ac_type,
        b.ucccode,
CASE 
    WHEN COALESCE(v_advisor_name, '') = '' THEN 
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.client_owner_name
            ELSE b.partner_name 
        END
    ELSE v_advisor_name
END AS advisor_name,
CASE 
    WHEN COALESCE(v_advisor_mobile, '') = '' THEN 
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_mobile
            ELSE b.partner_mobile
        END
    ELSE v_advisor_mobile
END AS advisor_mobile,
CASE 
    WHEN COALESCE(v_advisor_email, '') = '' THEN 		
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_email
            ELSE b.partner_email
        END
    ELSE v_advisor_email
END AS advisor_email,
        '1800-102-3335' AS helpdesk_number,
        'helpdesk@nuvama.com' AS helpdesk_email,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN 'E'
            ELSE 'P'
        END AS employee_type,
        b.pan AS client_pan,
        b.birthdate AS client_dob,
        b.user_name AS userid
    FROM transactions.mf_order_detail a
	inner join master.dim_ucc b
	on a.ac_code=b.priority_ac_code
    WHERE a.ac_code = v_ac_code and a.trx_id=v_trx_id;

ELSE

    RETURN QUERY
    SELECT 
        a.ac_code AS ac_code,
        b.acname AS ac_name,
	--	b.mobileno
        coalesce(c.mobileno,b.mobileno)::character varying as mobileno,
		coalesce(c.email,b.email)::character varying as email,
      --  a.email,
        b.actype AS ac_type,
        b.ucccode,
CASE 
    WHEN COALESCE(v_advisor_name, '') = '' THEN 
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.client_owner_name
            ELSE b.partner_name 
        END
    ELSE v_advisor_name
END AS advisor_name,
CASE 
    WHEN COALESCE(v_advisor_mobile, '') = '' THEN 
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_mobile
            ELSE b.partner_mobile
        END
    ELSE v_advisor_mobile
END AS advisor_mobile,
CASE 
    WHEN COALESCE(v_advisor_email, '') = '' THEN 		
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN b.rm_email
            ELSE b.partner_email
        END
    ELSE v_advisor_email
END AS advisor_email,
        '1800-102-3335' AS helpdesk_number,
        'helpdesk@nuvama.com' AS helpdesk_email,
        CASE 
            WHEN COALESCE(b.partner_code, '') = '' THEN 'E'
            ELSE 'P'
        END AS employee_type,
        b.pan AS client_pan,
        b.birthdate AS client_dob,
        b.user_name AS userid
    FROM transactions.mf_order_detail_modification a
	inner join transactions.mf_order_detail c on a.org_trx_id=c.trx_id
	inner join master.dim_ucc b on a.ac_code=b.priority_ac_code
    WHERE a.ac_code = v_ac_code and a.trx_id=v_trx_id;
END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_client_details_test(varchar, int8, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_details_test(varchar, int8, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_client_details_test(varchar, int8, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_details_test(varchar, int8, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_client_details_test(varchar, int8, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_client_dpflag(varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_client_dpflag(v_ac_code character varying)
 RETURNS TABLE(ac_code character varying, acname character varying, email character varying, actype character varying, dp_flag character varying, direct_plan_enabled_flg character varying, kacctype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
BEGIN

RETURN QUERY
select a.priority_ac_code as ac_code,a.acname,a.email,
a.actype,a.dp_flag,a.direct_plan_enabled_flg,a.kacctype
from master.dim_ucc a
where a.priority_ac_code=v_ac_code;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_client_dpflag(varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_dpflag(varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_client_dpflag(varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_dpflag(varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_client_dpflag(varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_client_dpflag_bkp_14jul2025(varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_client_dpflag_bkp_14jul2025(v_ac_code character varying)
 RETURNS TABLE(ac_code character varying, acname character varying, email character varying, actype character varying, dp_flag character varying, direct_plan_enabled_flg character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
BEGIN

RETURN QUERY
select a.priority_ac_code as ac_code,a.acname,a.email,
a.actype,a.dp_flag,a.direct_plan_enabled_flg
from master.dim_ucc a
where a.priority_ac_code=v_ac_code;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_client_dpflag_bkp_14jul2025(varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_dpflag_bkp_14jul2025(varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_client_dpflag_bkp_14jul2025(varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_client_dpflag_bkp_14jul2025(varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_client_dpflag_bkp_14jul2025(varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_clientpending_approval_details(varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_clientpending_approval_details(v_ac_code character varying)
 RETURNS TABLE(display_trx_id character varying, trx_id bigint, ac_acode character varying, isincode character varying, trx_type character varying, nav numeric, navdate date, trx_amt numeric, trx_qty numeric, delivery_mode character varying, mandate_id character varying, bank_name character varying, bank_ac_number character varying, final_status character varying, created_date timestamp without time zone, consent_id character varying, mf_schcode bigint, switch_mf_schcode bigint, start_date date, end_date date, frequency character varying, user_id character varying, firstordertoday character varying, category_code integer, display_amt character varying, inv_action_code integer, pan character varying, client_bank_name character varying, client_bank_ac_number character varying, no_of_installment integer, folio_no character varying, mobileno character varying, email character varying, isinname character varying, switch_isin_name character varying, order_placed_by character varying, order_placed_by_name character varying, next_installment_date date)
 LANGUAGE plpgsql
AS $function$

DECLARE
v_ucccode character varying;

BEGIN

v_ucccode := (select distinct a.ucccode
from master.dim_ucc a
WHERE a.priority_ac_code = v_ac_code);

-----------------------------------------------------
CREATE TEMP TABLE IF NOT EXISTS temp_created_for AS
select created_for::character varying as created_for,
INITCAP(created_for_name)::character varying as created_for_name
FROM (
	SELECT ltrim(a.empcode, '0') as created_for,a.fullname AS created_for_name
	FROM master.dim_ed_employee a
	WHERE employeestatus='A'
	UNION
	SELECT a.upccode as created_for,a.partner_name AS created_for_name 
	FROM master.partner a
	WHERE upper(a.status)	='ACTIVE'
	--'PNW23054520' 
) sub;
-------------------------------------------------------------------------------
	
RETURN QUERY
select distinct
a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type,a.nav,a.navdate,
a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
c.consent_id,a.mf_schcode,a.switch_mf_schcode,d.start_date,d.end_date,
INITCAP(d.frequency):: character varying as frequency,
b.user_name as user_id,d.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,d.no_of_installment
,a.folio_no,
coalesce(a.mobileno,b.mobileno) as mobileno,
coalesce(a.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
,coalesce(a.created_for_name,mst.created_for_name) as order_placed_by_name
,d.upcoming_due_date::date as next_installment_date
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
inner join (
select a.trx_id,a.category_code,a.consent_status,a.consent_id
from transactions.order_consent a
where a.consent_type=1
and a.inv_action_code=1
and a.consent_status='Consent Pending'
) c on a.trx_id =c.trx_id 
left join transactions.mf_order_summary d on a.trx_id =d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on a.switch_isin = isin.isincode
left join temp_created_for mst
on a.created_for = mst.created_for
where a.trx_final_status_code = 7
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type, a.nav,a.navdate,a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
--a.delivery_mode,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, a.switch_mf_schcode, 
c.start_date, c.end_date, 
INITCAP(c.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,c.no_of_installment
,a.folio_no,
--b.mobileno,b.email,
coalesce(a.mobileno,b.mobileno) as mobileno,
coalesce(a.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
,coalesce(a.created_for_name,mst.created_for_name) as order_placed_by_name
,c.upcoming_due_date::date as next_installment_date
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.trx_id =c.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on a.switch_isin = isin.isincode
left join temp_created_for mst
on a.created_for = mst.created_for
where a.trx_final_status_code = 3
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type, a.nav,a.navdate,a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
--a.delivery_mode,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, a.switch_mf_schcode, 
c.start_date,c.end_date, 
INITCAP(c.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,c.no_of_installment
,a.folio_no,
--b.mobileno,b.email,
coalesce(a.mobileno,b.mobileno) as mobileno,
coalesce(a.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
,coalesce(a.created_for_name,mst.created_for_name) as order_placed_by_name
,c.upcoming_due_date::date as next_installment_date
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.trx_id =c.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on a.switch_isin = isin.isincode
left join temp_created_for mst
on a.created_for = mst.created_for
where a.trx_final_status_code = 1
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------	
select distinct
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode, 
--e.trx_type
case when a.inv_action_code=2 then cast(e.trx_type ||' Pause' as character varying)
when a.inv_action_code=3 then cast(e.trx_type ||' Modify' as character varying)
when a.inv_action_code=4 then cast(e.trx_type ||' Cancel' as character varying)
when a.inv_action_code=0 then cast(e.trx_type ||' Resume' as character varying)
else e.trx_type end as trx_type,
--,null::numeric(15,2) as nav, null::date as navdate, a.trx_amt::numeric(15,2) as trx_amt, null::numeric as trx_qty,null as delivery_mode, a.mandate_id
dt.nav, dt.navdate, COALESCE(a.trx_amt, dt.trx_amt)::numeric(15,2) as trx_amt, dt.trx_qty,
--dt.delivery_mode,
case when dt.delivery_mode='D' then 'DEMAT'
when dt.delivery_mode='P' then 'PHYSICAL'
else dt.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
c.consent_id,a.mf_schcode,
dt.switch_mf_schcode::bigint as switch_mf_schcode,
--a.start_day::date as start_date,
coalesce(a.start_day::date,d.start_date)::date  as start_date,
d.end_date,
INITCAP(
coalesce(a.frequency,d.frequency)
):: character varying as frequency,
b.user_name as user_id,d.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, dt.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan,
bnk.bankname::character varying as client_bank_name,
bnk.bankaccno::character varying as client_bank_ac_number
,d.no_of_installment
,dt.folio_no,
--b.mobileno,b.email,
coalesce(dt.mobileno,b.mobileno) as mobileno,
coalesce(dt.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
,coalesce(a.created_for_name,mst.created_for_name) as order_placed_by_name
,coalesce(a.installment_date_post_pause_resume,d.upcoming_due_date)::date as next_installment_date
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
inner join (select a.trx_id,a.category_code,a.consent_status,a.consent_id
			from transactions.order_consent a
			where a.consent_type=1 and a.inv_action_code<>1
		   ) c on a.trx_id =c.trx_id 
left join transactions.mf_order_summary d on a.org_trx_id = d.trx_id
left join transactions.mf_order_detail dt on a.org_trx_id = dt.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
	left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON b.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on dt.switch_isin = isin.isincode
left join temp_created_for mst
on a.created_for = mst.created_for
where a.trx_final_status_code = 7
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct 
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode,
--e.trx_type
case when a.inv_action_code=2 then cast(e.trx_type ||' Pause' as character varying)
when a.inv_action_code=3 then cast(e.trx_type ||' Modify' as character varying)
when a.inv_action_code=4 then cast(e.trx_type ||' Cancel' as character varying)
	when a.inv_action_code=0 then cast(e.trx_type ||' Resume' as character varying)
else e.trx_type end as trx_type,
--, null::numeric(15,2) as nav,null::date as navdate,a.trx_amt::numeric(15,2) as trx_amt,
d.nav, d.navdate, COALESCE(a.trx_amt, d.trx_amt)::numeric(15,2) as trx_amt,
d.trx_qty,
--d.delivery_mode,
case when d.delivery_mode='D' then 'DEMAT'
when d.delivery_mode='P' then 'PHYSICAL'
else d.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, 
d.switch_mf_schcode::bigint as switch_mf_schcode, 
--a.start_day::date as start_date, 
coalesce(a.start_day::date,c.start_date)::date  as start_date,
c.end_date,
INITCAP(coalesce(a.frequency,c.frequency)
):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, d.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan,
bnk.bankname::character varying as client_bank_name,
bnk.bankaccno::character varying as client_bank_ac_number
,c.no_of_installment
,d.folio_no,
--b.mobileno,b.email,
coalesce(d.mobileno,b.mobileno) as mobileno,
coalesce(d.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
,coalesce(a.created_for_name,mst.created_for_name) as order_placed_by_name
,coalesce(a.installment_date_post_pause_resume,c.upcoming_due_date)::date as next_installment_date
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.org_trx_id =c.trx_id
left join transactions.mf_order_detail d on a.org_trx_id = d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
	and e.category_code=261
	left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON b.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on d.switch_isin = isin.isincode
left join temp_created_for mst
on a.created_for = mst.created_for
where a.trx_final_status_code = 3
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct 
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode, e.trx_type
--, null::numeric(15,2) as nav,null::date as navdate,a.trx_amt::numeric(15,2) as trx_amt,
, d.nav, d.navdate, COALESCE(a.trx_amt, d.trx_amt)::numeric(15,2) as trx_amt,
d.trx_qty,
--d.delivery_mode,
case when d.delivery_mode='D' then 'DEMAT'
when d.delivery_mode='P' then 'PHYSICAL'
else d.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, 
d.switch_mf_schcode::bigint as switch_mf_schcode, 
--c.start_date, 
coalesce(a.start_day::date,c.start_date)::date  as start_date,
c.end_date,
INITCAP(
coalesce(a.frequency,c.frequency)
):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, d.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan,
bnk.bankname::character varying as client_bank_name,
bnk.bankaccno::character varying as client_bank_ac_number
,c.no_of_installment
,d.folio_no,
--b.mobileno,b.email,
coalesce(d.mobileno,b.mobileno) as mobileno,
coalesce(d.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
,coalesce(a.created_for_name,mst.created_for_name) as order_placed_by_name
,coalesce(a.installment_date_post_pause_resume,c.upcoming_due_date)::date as next_installment_date
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.org_trx_id =c.trx_id
left join transactions.mf_order_detail d on a.org_trx_id = d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON b.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on d.switch_isin = isin.isincode
left join temp_created_for mst
on a.created_for = mst.created_for
where a.trx_final_status_code = 1
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
order by created_date desc;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_clientpending_approval_details(varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details(varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details(varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details(varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details(varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09may2025(varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09may2025(v_ac_code character varying)
 RETURNS TABLE(display_trx_id character varying, trx_id bigint, ac_acode character varying, isincode character varying, trx_type character varying, nav numeric, navdate date, trx_amt numeric, trx_qty numeric, delivery_mode character varying, mandate_id character varying, bank_name character varying, bank_ac_number character varying, final_status character varying, created_date timestamp without time zone, consent_id character varying, mf_schcode bigint, switch_mf_schcode bigint, start_date date, end_date date, frequency character varying, user_id character varying, firstordertoday character varying, category_code integer, display_amt character varying, inv_action_code integer, pan character varying, client_bank_name character varying, client_bank_ac_number character varying, no_of_installment integer)
 LANGUAGE plpgsql
AS $function$

DECLARE
v_ucccode character varying;

BEGIN

v_ucccode := (select distinct a.ucccode
from master.dim_ucc a
WHERE a.priority_ac_code = v_ac_code);

RETURN QUERY
select a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type,a.nav,a.navdate,
a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
c.consent_id,a.mf_schcode,a.switch_mf_schcode,d.start_date,d.end_date,
INITCAP(d.frequency):: character varying as frequency,
b.user_name as user_id,d.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,d.no_of_installment
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
inner join (
select a.trx_id,a.category_code,a.consent_status,a.consent_id
from transactions.order_consent a
where a.consent_type=1
and a.inv_action_code=1
) c on a.trx_id =c.trx_id 
left join transactions.mf_order_summary d on a.trx_id =d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
where a.trx_final_status_code = 7
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type, a.nav,a.navdate,a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
--a.delivery_mode,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, a.switch_mf_schcode, 
c.start_date, c.end_date, 
INITCAP(c.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,c.no_of_installment
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.trx_id =c.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
where a.trx_final_status_code = 3
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type, a.nav,a.navdate,a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
--a.delivery_mode,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, a.switch_mf_schcode, 
c.start_date, c.end_date, 
INITCAP(c.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,c.no_of_installment
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.trx_id =c.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
where a.trx_final_status_code = 1
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------	
select 
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode, 
--e.trx_type
case when a.inv_action_code=2 then cast(e.trx_type ||' Pause' as character varying)
when a.inv_action_code=3 then cast(e.trx_type ||' Modify' as character varying)
when a.inv_action_code=4 then cast(e.trx_type ||' Cancel' as character varying)
when a.inv_action_code=0 then cast(e.trx_type ||' Resume' as character varying)
else e.trx_type end as trx_type,
--,null::numeric(15,2) as nav, null::date as navdate, a.trx_amt::numeric(15,2) as trx_amt, null::numeric as trx_qty,null as delivery_mode, a.mandate_id
dt.nav, dt.navdate, COALESCE(a.trx_amt, dt.trx_amt)::numeric(15,2) as trx_amt, dt.trx_qty,
--dt.delivery_mode,
case when dt.delivery_mode='D' then 'DEMAT'
when dt.delivery_mode='P' then 'PHYSICAL'
else dt.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
c.consent_id,a.mf_schcode,
null::bigint  as switch_mf_schcode,
a.start_day::date as start_date,d.end_date,
INITCAP(a.frequency):: character varying as frequency,
b.user_name as user_id,d.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, dt.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,null::character varying as client_bank_name
,null::character varying as client_bank_ac_number
,d.no_of_installment
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
inner join (select a.trx_id,a.category_code,a.consent_status,a.consent_id
			from transactions.order_consent a
			where a.consent_type=1 and a.inv_action_code<>1
		   ) c on a.trx_id =c.trx_id 
left join transactions.mf_order_summary d on a.org_trx_id = d.trx_id
left join transactions.mf_order_detail dt on a.org_trx_id = dt.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
where a.trx_final_status_code = 7
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct 
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode,
--e.trx_type
case when a.inv_action_code=2 then cast(e.trx_type ||' Pause' as character varying)
when a.inv_action_code=3 then cast(e.trx_type ||' Modify' as character varying)
when a.inv_action_code=4 then cast(e.trx_type ||' Cancel' as character varying)
	when a.inv_action_code=0 then cast(e.trx_type ||' Resume' as character varying)
else e.trx_type end as trx_type,
--, null::numeric(15,2) as nav,null::date as navdate,a.trx_amt::numeric(15,2) as trx_amt,
d.nav, d.navdate, COALESCE(a.trx_amt, d.trx_amt)::numeric(15,2) as trx_amt,
d.trx_qty,
--d.delivery_mode,
case when d.delivery_mode='D' then 'DEMAT'
when d.delivery_mode='P' then 'PHYSICAL'
else d.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, null::bigint as switch_mf_schcode, 
a.start_day::date as start_date, c.end_date,
INITCAP(a.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, d.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,null::character varying as client_bank_name
,null::character varying as client_bank_ac_number
,c.no_of_installment
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.org_trx_id =c.trx_id
left join transactions.mf_order_detail d on a.org_trx_id = d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
where a.trx_final_status_code = 3
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct 
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode, e.trx_type
--, null::numeric(15,2) as nav,null::date as navdate,a.trx_amt::numeric(15,2) as trx_amt,
, d.nav, d.navdate, COALESCE(a.trx_amt, d.trx_amt)::numeric(15,2) as trx_amt,
d.trx_qty,
--d.delivery_mode,
case when d.delivery_mode='D' then 'DEMAT'
when d.delivery_mode='P' then 'PHYSICAL'
else d.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, null::bigint as switch_mf_schcode, 
c.start_date, c.end_date,
INITCAP(c.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, d.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,null::character varying as client_bank_name
,null::character varying as client_bank_ac_number
,c.no_of_installment
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.org_trx_id =c.trx_id
left join transactions.mf_order_detail d on a.org_trx_id = d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code and e.category_code=261
where a.trx_final_status_code = 1
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
order by created_date desc;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09may2025(varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09may2025(varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09may2025(varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09may2025(varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09may2025(varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09sept2025(varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09sept2025(v_ac_code character varying)
 RETURNS TABLE(display_trx_id character varying, trx_id bigint, ac_acode character varying, isincode character varying, trx_type character varying, nav numeric, navdate date, trx_amt numeric, trx_qty numeric, delivery_mode character varying, mandate_id character varying, bank_name character varying, bank_ac_number character varying, final_status character varying, created_date timestamp without time zone, consent_id character varying, mf_schcode bigint, switch_mf_schcode bigint, start_date date, end_date date, frequency character varying, user_id character varying, firstordertoday character varying, category_code integer, display_amt character varying, inv_action_code integer, pan character varying, client_bank_name character varying, client_bank_ac_number character varying, no_of_installment integer, folio_no character varying, mobileno character varying, email character varying, isinname character varying, switch_isin_name character varying, order_placed_by character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
v_ucccode character varying;

BEGIN

v_ucccode := (select distinct a.ucccode
from master.dim_ucc a
WHERE a.priority_ac_code = v_ac_code);

RETURN QUERY
select distinct
a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type,a.nav,a.navdate,
a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
c.consent_id,a.mf_schcode,a.switch_mf_schcode,d.start_date,d.end_date,
INITCAP(d.frequency):: character varying as frequency,
b.user_name as user_id,d.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,d.no_of_installment
,a.folio_no,
coalesce(a.mobileno,b.mobileno) as mobileno,
coalesce(a.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
inner join (
select a.trx_id,a.category_code,a.consent_status,a.consent_id
from transactions.order_consent a
where a.consent_type=1
and a.inv_action_code=1
and a.consent_status='Consent Pending'
) c on a.trx_id =c.trx_id 
left join transactions.mf_order_summary d on a.trx_id =d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on a.switch_isin = isin.isincode
where a.trx_final_status_code = 7
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type, a.nav,a.navdate,a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
--a.delivery_mode,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, a.switch_mf_schcode, 
c.start_date, c.end_date, 
INITCAP(c.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,c.no_of_installment
,a.folio_no,
--b.mobileno,b.email,
coalesce(a.mobileno,b.mobileno) as mobileno,
coalesce(a.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.trx_id =c.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on a.switch_isin = isin.isincode
where a.trx_final_status_code = 3
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type, a.nav,a.navdate,a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
--a.delivery_mode,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, a.switch_mf_schcode, 
c.start_date,c.end_date, 
INITCAP(c.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,c.no_of_installment
,a.folio_no,
--b.mobileno,b.email,
coalesce(a.mobileno,b.mobileno) as mobileno,
coalesce(a.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.trx_id =c.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on a.switch_isin = isin.isincode
where a.trx_final_status_code = 1
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------	
select distinct
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode, 
--e.trx_type
case when a.inv_action_code=2 then cast(e.trx_type ||' Pause' as character varying)
when a.inv_action_code=3 then cast(e.trx_type ||' Modify' as character varying)
when a.inv_action_code=4 then cast(e.trx_type ||' Cancel' as character varying)
when a.inv_action_code=0 then cast(e.trx_type ||' Resume' as character varying)
else e.trx_type end as trx_type,
--,null::numeric(15,2) as nav, null::date as navdate, a.trx_amt::numeric(15,2) as trx_amt, null::numeric as trx_qty,null as delivery_mode, a.mandate_id
dt.nav, dt.navdate, COALESCE(a.trx_amt, dt.trx_amt)::numeric(15,2) as trx_amt, dt.trx_qty,
--dt.delivery_mode,
case when dt.delivery_mode='D' then 'DEMAT'
when dt.delivery_mode='P' then 'PHYSICAL'
else dt.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
c.consent_id,a.mf_schcode,
dt.switch_mf_schcode::bigint as switch_mf_schcode,
--a.start_day::date as start_date,
coalesce(a.start_day::date,d.start_date)::date  as start_date,
d.end_date,
INITCAP(
coalesce(a.frequency,d.frequency)
):: character varying as frequency,
b.user_name as user_id,d.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, dt.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan,
bnk.bankname::character varying as client_bank_name,
bnk.bankaccno::character varying as client_bank_ac_number
,d.no_of_installment
,dt.folio_no,
--b.mobileno,b.email,
coalesce(dt.mobileno,b.mobileno) as mobileno,
coalesce(dt.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
inner join (select a.trx_id,a.category_code,a.consent_status,a.consent_id
			from transactions.order_consent a
			where a.consent_type=1 and a.inv_action_code<>1
		   ) c on a.trx_id =c.trx_id 
left join transactions.mf_order_summary d on a.org_trx_id = d.trx_id
left join transactions.mf_order_detail dt on a.org_trx_id = dt.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
	left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON b.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on dt.switch_isin = isin.isincode
where a.trx_final_status_code = 7
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct 
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode,
--e.trx_type
case when a.inv_action_code=2 then cast(e.trx_type ||' Pause' as character varying)
when a.inv_action_code=3 then cast(e.trx_type ||' Modify' as character varying)
when a.inv_action_code=4 then cast(e.trx_type ||' Cancel' as character varying)
	when a.inv_action_code=0 then cast(e.trx_type ||' Resume' as character varying)
else e.trx_type end as trx_type,
--, null::numeric(15,2) as nav,null::date as navdate,a.trx_amt::numeric(15,2) as trx_amt,
d.nav, d.navdate, COALESCE(a.trx_amt, d.trx_amt)::numeric(15,2) as trx_amt,
d.trx_qty,
--d.delivery_mode,
case when d.delivery_mode='D' then 'DEMAT'
when d.delivery_mode='P' then 'PHYSICAL'
else d.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, 
d.switch_mf_schcode::bigint as switch_mf_schcode, 
--a.start_day::date as start_date, 
coalesce(a.start_day::date,c.start_date)::date  as start_date,
c.end_date,
INITCAP(coalesce(a.frequency,c.frequency)
):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, d.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan,
bnk.bankname::character varying as client_bank_name,
bnk.bankaccno::character varying as client_bank_ac_number
,c.no_of_installment
,d.folio_no,
--b.mobileno,b.email,
coalesce(d.mobileno,b.mobileno) as mobileno,
coalesce(d.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.org_trx_id =c.trx_id
left join transactions.mf_order_detail d on a.org_trx_id = d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
	and e.category_code=261
	left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON b.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on d.switch_isin = isin.isincode
where a.trx_final_status_code = 3
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct 
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode, e.trx_type
--, null::numeric(15,2) as nav,null::date as navdate,a.trx_amt::numeric(15,2) as trx_amt,
, d.nav, d.navdate, COALESCE(a.trx_amt, d.trx_amt)::numeric(15,2) as trx_amt,
d.trx_qty,
--d.delivery_mode,
case when d.delivery_mode='D' then 'DEMAT'
when d.delivery_mode='P' then 'PHYSICAL'
else d.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, 
d.switch_mf_schcode::bigint as switch_mf_schcode, 
--c.start_date, 
coalesce(a.start_day::date,c.start_date)::date  as start_date,
c.end_date,
INITCAP(
coalesce(a.frequency,c.frequency)
):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, d.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan,
bnk.bankname::character varying as client_bank_name,
bnk.bankaccno::character varying as client_bank_ac_number
,c.no_of_installment
,d.folio_no,
--b.mobileno,b.email,
coalesce(d.mobileno,b.mobileno) as mobileno,
coalesce(d.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
,a.order_placed_by
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.org_trx_id =c.trx_id
left join transactions.mf_order_detail d on a.org_trx_id = d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON b.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on d.switch_isin = isin.isincode
where a.trx_final_status_code = 1
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
order by created_date desc;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09sept2025(varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09sept2025(varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09sept2025(varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09sept2025(varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_09sept2025(varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_clientpending_approval_details_bkp_14jul2025(varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_clientpending_approval_details_bkp_14jul2025(v_ac_code character varying)
 RETURNS TABLE(display_trx_id character varying, trx_id bigint, ac_acode character varying, isincode character varying, trx_type character varying, nav numeric, navdate date, trx_amt numeric, trx_qty numeric, delivery_mode character varying, mandate_id character varying, bank_name character varying, bank_ac_number character varying, final_status character varying, created_date timestamp without time zone, consent_id character varying, mf_schcode bigint, switch_mf_schcode bigint, start_date date, end_date date, frequency character varying, user_id character varying, firstordertoday character varying, category_code integer, display_amt character varying, inv_action_code integer, pan character varying, client_bank_name character varying, client_bank_ac_number character varying, no_of_installment integer, folio_no character varying, mobileno character varying, email character varying, isinname character varying, switch_isin_name character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
v_ucccode character varying;

BEGIN

v_ucccode := (select distinct a.ucccode
from master.dim_ucc a
WHERE a.priority_ac_code = v_ac_code);

RETURN QUERY
select distinct
a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type,a.nav,a.navdate,
a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
c.consent_id,a.mf_schcode,a.switch_mf_schcode,d.start_date,d.end_date,
INITCAP(d.frequency):: character varying as frequency,
b.user_name as user_id,d.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,d.no_of_installment
,a.folio_no,
coalesce(a.mobileno,b.mobileno) as mobileno,
coalesce(a.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
inner join (
select a.trx_id,a.category_code,a.consent_status,a.consent_id
from transactions.order_consent a
where a.consent_type=1
and a.inv_action_code=1
and a.consent_status='Consent Pending'
) c on a.trx_id =c.trx_id 
left join transactions.mf_order_summary d on a.trx_id =d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on a.switch_isin = isin.isincode
where a.trx_final_status_code = 7
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type, a.nav,a.navdate,a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
--a.delivery_mode,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, a.switch_mf_schcode, 
c.start_date, c.end_date, 
INITCAP(c.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,c.no_of_installment
,a.folio_no,
--b.mobileno,b.email,
coalesce(a.mobileno,b.mobileno) as mobileno,
coalesce(a.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.trx_id =c.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on a.switch_isin = isin.isincode
where a.trx_final_status_code = 3
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct a.display_trx_id,a.trx_id,v_ac_code as ac_code,a.isincode,
e.trx_type, a.nav,a.navdate,a.trx_amt::numeric(15,2) as trx_amt,
a.trx_qty,
--a.delivery_mode,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, a.switch_mf_schcode, 
c.start_date,c.end_date, 
INITCAP(c.frequency):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(a.trx_amt, '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,c.no_of_installment
,a.folio_no,
--b.mobileno,b.email,
coalesce(a.mobileno,b.mobileno) as mobileno,
coalesce(a.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
from transactions.mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.trx_id =c.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on a.switch_isin = isin.isincode
where a.trx_final_status_code = 1
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------	
select distinct
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode, 
--e.trx_type
case when a.inv_action_code=2 then cast(e.trx_type ||' Pause' as character varying)
when a.inv_action_code=3 then cast(e.trx_type ||' Modify' as character varying)
when a.inv_action_code=4 then cast(e.trx_type ||' Cancel' as character varying)
when a.inv_action_code=0 then cast(e.trx_type ||' Resume' as character varying)
else e.trx_type end as trx_type,
--,null::numeric(15,2) as nav, null::date as navdate, a.trx_amt::numeric(15,2) as trx_amt, null::numeric as trx_qty,null as delivery_mode, a.mandate_id
dt.nav, dt.navdate, COALESCE(a.trx_amt, dt.trx_amt)::numeric(15,2) as trx_amt, dt.trx_qty,
--dt.delivery_mode,
case when dt.delivery_mode='D' then 'DEMAT'
when dt.delivery_mode='P' then 'PHYSICAL'
else dt.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
c.consent_id,a.mf_schcode,
dt.switch_mf_schcode::bigint as switch_mf_schcode,
--a.start_day::date as start_date,
coalesce(a.start_day::date,d.start_date)::date  as start_date,
d.end_date,
INITCAP(
coalesce(a.frequency,d.frequency)
):: character varying as frequency,
b.user_name as user_id,d.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, dt.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan,
bnk.bankname::character varying as client_bank_name,
bnk.bankaccno::character varying as client_bank_ac_number
,d.no_of_installment
,dt.folio_no,
--b.mobileno,b.email,
coalesce(dt.mobileno,b.mobileno) as mobileno,
coalesce(dt.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
inner join (select a.trx_id,a.category_code,a.consent_status,a.consent_id
			from transactions.order_consent a
			where a.consent_type=1 and a.inv_action_code<>1
		   ) c on a.trx_id =c.trx_id 
left join transactions.mf_order_summary d on a.org_trx_id = d.trx_id
left join transactions.mf_order_detail dt on a.org_trx_id = dt.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
and e.category_code=261
	left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON b.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on dt.switch_isin = isin.isincode
where a.trx_final_status_code = 7
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct 
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode,
--e.trx_type
case when a.inv_action_code=2 then cast(e.trx_type ||' Pause' as character varying)
when a.inv_action_code=3 then cast(e.trx_type ||' Modify' as character varying)
when a.inv_action_code=4 then cast(e.trx_type ||' Cancel' as character varying)
	when a.inv_action_code=0 then cast(e.trx_type ||' Resume' as character varying)
else e.trx_type end as trx_type,
--, null::numeric(15,2) as nav,null::date as navdate,a.trx_amt::numeric(15,2) as trx_amt,
d.nav, d.navdate, COALESCE(a.trx_amt, d.trx_amt)::numeric(15,2) as trx_amt,
d.trx_qty,
--d.delivery_mode,
case when d.delivery_mode='D' then 'DEMAT'
when d.delivery_mode='P' then 'PHYSICAL'
else d.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, 
d.switch_mf_schcode::bigint as switch_mf_schcode, 
--a.start_day::date as start_date, 
coalesce(a.start_day::date,c.start_date)::date  as start_date,
c.end_date,
INITCAP(coalesce(a.frequency,c.frequency)
):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, d.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan,
bnk.bankname::character varying as client_bank_name,
bnk.bankaccno::character varying as client_bank_ac_number
,c.no_of_installment
,d.folio_no,
--b.mobileno,b.email,
coalesce(d.mobileno,b.mobileno) as mobileno,
coalesce(d.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.org_trx_id =c.trx_id
left join transactions.mf_order_detail d on a.org_trx_id = d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code
	and e.category_code=261
	left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON b.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on d.switch_isin = isin.isincode
where a.trx_final_status_code = 3
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
--------
union 
--------
select distinct 
--a.display_trx_id,
cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
a.trx_id,
v_ac_code as ac_code,a.isincode, e.trx_type
--, null::numeric(15,2) as nav,null::date as navdate,a.trx_amt::numeric(15,2) as trx_amt,
, d.nav, d.navdate, COALESCE(a.trx_amt, d.trx_amt)::numeric(15,2) as trx_amt,
d.trx_qty,
--d.delivery_mode,
case when d.delivery_mode='D' then 'DEMAT'
when d.delivery_mode='P' then 'PHYSICAL'
else d.delivery_mode end delivery_mode,
a.mandate_id,
a.bank_name,a.bank_ac_number,a.final_status,
date_trunc('second', a.created_date) as created_date,
NULL::character varying as consent_id, a.mf_schcode, 
d.switch_mf_schcode::bigint as switch_mf_schcode, 
--c.start_date, 
coalesce(a.start_day::date,c.start_date)::date  as start_date,
c.end_date,
INITCAP(
coalesce(a.frequency,c.frequency)
):: character varying as frequency,
b.user_name as user_id,c.firstordertoday,261::int as category_code
,to_char(COALESCE(a.trx_amt, d.trx_amt), '9,999,999,999,999.00')::character varying as display_amt
,a.inv_action_code,b.pan,
bnk.bankname::character varying as client_bank_name,
bnk.bankaccno::character varying as client_bank_ac_number
,c.no_of_installment
,d.folio_no,
--b.mobileno,b.email,
coalesce(d.mobileno,b.mobileno) as mobileno,
coalesce(d.email,b.email) as email,
INITCAP(a.isinname)::character varying as isinname, 
INITCAP(isin.isinname)::character varying as switch_isin_name
from transactions.mf_order_detail_modification a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c on a.org_trx_id =c.trx_id
left join transactions.mf_order_detail d on a.org_trx_id = d.trx_id
inner join master.trx_type e on a.trx_type_code = e.trx_type_code and e.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode=v_ucccode
				) bk WHERE bk.rn = 1
			) bnk ON b.ucccode = bnk.ucccode
left join master.dim_mf_isin isin on d.switch_isin = isin.isincode
where a.trx_final_status_code = 1
and a.created_date >=(a.created_date - interval '6' day)
and a.ac_code=v_ac_code
order by created_date desc;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_clientpending_approval_details_bkp_14jul2025(varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_14jul2025(varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_14jul2025(varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_14jul2025(varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_clientpending_approval_details_bkp_14jul2025(varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_holdingamttoqty(int4, int4, varchar, varchar, numeric);

CREATE OR REPLACE FUNCTION transactions.fn_get_holdingamttoqty(p_scheme_id integer, p_category_code integer, p_client_code character varying, p_folio_number character varying, p_amount numeric DEFAULT NULL::numeric)
 RETURNS TABLE(m_quantity numeric, m_marketvalue numeric, m_message text)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_nav NUMERIC; -- NAV as NUMERIC
    v_qty NUMERIC; -- Resultant quantity as NUMERIC
    v_total_folio_amount NUMERIC; -- Total folio amount
    v_total_qty     numeric;
begin
	
	-- unique nav identification..? with folio_number and without folio_number
	
	/*

SELECT * 
FROM transactions.fn_get_holdingamttoqty(
    p_scheme_id := 10006, 
    p_category_code := 268, 
    p_client_code := 'NW23204808', 
    p_folio_number := '1045034590',
    p_amount := 2000

);
	 */

    -- Fetch NAV
    IF COALESCE(p_folio_number, '') <> '' THEN
        SELECT nav
        INTO v_nav
        FROM transactions.mv_client_holding
        WHERE isincode = p_scheme_id::VARCHAR
          AND category_code = p_category_code
          AND ucccode = p_client_code
          AND foliono = p_folio_number
        LIMIT 1;

    -- Fetch total folio market value
        SELECT SUM(marketvalue), SUM(totalqty)
        INTO   v_total_folio_amount,
               v_total_qty
        FROM   transactions.mv_client_holding
        WHERE  isincode = p_scheme_id::VARCHAR
          AND  category_code = p_category_code
          AND  ucccode = p_client_code
          AND  foliono = p_folio_number;
    
    END IF;

    -- Check NAV and calculate quantity
    IF p_amount > 0 and v_nav > 0 THEN
        IF p_amount > COALESCE(v_total_folio_amount, 0) THEN
            RETURN QUERY
            SELECT --0::NUMERIC AS quantity,
            		ROUND(p_amount / v_nav, 2) AS quantity,
                   COALESCE(v_total_folio_amount, 0) AS marketvalue,
                   'Entered amount exceeds the total value of the folio.' AS message;  
        ELSE
            v_qty := ROUND(p_amount / v_nav, 2);
            RETURN QUERY
            SELECT v_qty AS quantity,
                   COALESCE(v_total_folio_amount, 0) AS marketvalue,
                   'SUCCESS' AS message;
        
       END IF;
    elsif COALESCE(p_amount,0) = 0 and v_nav > 0 then
            RETURN QUERY
            SELECT v_total_qty AS quantity,
                   COALESCE(v_total_folio_amount, 0) AS marketvalue,
                   'SUCCESS' AS message;         
    ELSE
        RETURN QUERY
        SELECT 0::NUMERIC AS quantity,
               COALESCE(v_total_folio_amount, 0) AS marketvalue,
               'FAILURE: NAV not available.' AS message;
    END IF;


EXCEPTION
    WHEN OTHERS THEN
        -- Log the error and return failure message
        RETURN QUERY
        SELECT 0::NUMERIC AS quantity,
               0::NUMERIC AS marketvalue,
               'FAILURE: Error:' || sqlerrm  AS message;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_holdingamttoqty(int4, int4, varchar, varchar, numeric) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_holdingamttoqty(int4, int4, varchar, varchar, numeric) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_holdingsummary(int4, int4, text, text);

CREATE OR REPLACE FUNCTION transactions.fn_get_holdingsummary(p_category_code integer, p_scheme_id integer DEFAULT NULL::integer, p_ucccode text DEFAULT NULL::text, p_folio_number text DEFAULT NULL::text)
 RETURNS TABLE(empcode character varying, fullname character varying, initial_purchase_date text, holdingdate date, isincode text, isinname text, totalqty numeric, longtermqty numeric, shorttermqty numeric, foliotype text, display_foliono text, ucccode text, foliono text, dp_flag text, priority_ac_code text, redemptiontime text, category_code integer, redeem_allowed boolean, nav numeric, marketvalue numeric, mf_schcode text)
 LANGUAGE plpgsql
AS $function$

begin
	
	/*
		SELECT * 
		FROM transactions.fn_get_holdingsummary(
		    p_category_code => 268,           
		    p_scheme_id => 1031,              
		    p_ucccode => 'NW23386307',       
		    p_folio_number => '1045034590'   
		);
	 */
	
    RETURN QUERY
    SELECT 
        ed.emp_code as empcode,
        ed.emp_name as fullname,
        TO_CHAR(a.initial_purchase_date, 'DD Mon YYYY') AS initial_purchase_date,
        a.holdingdate, 
        a.isincode::TEXT, 
        a.isinname::TEXT, 
        a.totalqty, 
        a.longtermqty, 
        a.shorttermqty, 
        a.foliotype::TEXT, 
        a.display_foliono::TEXT, 
        a.ucccode::TEXT, 
        a.foliono::TEXT, 
        a.dp_flag::TEXT, 
        a.priority_ac_code::TEXT, 
        a.redemptiontime::TEXT, 
        a.category_code, 
        a.redeem_allowed, 
        a.nav, 
        a.marketvalue, 
        a.mf_schcode::TEXT
    FROM transactions.mv_client_holding a
JOIN master.dim_ucc ucc    ON a.ucccode = ucc.ucccode 
--JOIN master.dim_ed_employee ed  ON ed.cip_empcode = ucc.client_owner
JOIN master.dim_employee ed  ON ed.emp_code = ucc.client_owner
--    LEFT JOIN aif_pms.aifpms_reverse_feed feed 
--        ON a.isincode = feed.scheme_id::TEXT 
--        and feed.ucccode = ucc.ucccode 
    WHERE a.category_code = p_category_code
      AND (p_scheme_id IS NULL OR a.isincode = p_scheme_id::TEXT)
      AND (p_ucccode IS NULL OR a.ucccode = p_ucccode)
      AND (p_folio_number IS NULL OR a.foliono = p_folio_number::TEXT);
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_holdingsummary(int4, int4, text, text) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_holdingsummary(int4, int4, text, text) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_investment_value_data();

CREATE OR REPLACE FUNCTION transactions.fn_get_investment_value_data()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    VALUES
        (1, '0 - 5 Lakhs'::character varying),
        (2, '5 - 15 Lakhs'::character varying),
        (3, '15 - 30 Lakhs'::character varying),
        (4, '30 - 50 Lakhs'::character varying),
        (5, '50 Lakhs - 1Cr'::character varying),
        (6, '1 Cr+'::character varying);
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_investment_value_data() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_investment_value_data() TO public;
GRANT ALL ON FUNCTION transactions.fn_get_investment_value_data() TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_lead_status(int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_lead_status(v_trx_id bigint)
 RETURNS TABLE(trx_id bigint, lead_id character varying, final_status character varying, lead_status character varying, created_date timestamp without time zone, display_trx_id character varying, trx_amt numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN QUERY
select 
a.trx_id,a.lead_id,a.final_status,b.lead_status,
date_trunc('second',a.created_date) as created_date,
a.display_trx_id,a.trx_amt
from (
select	
a.trx_id,a.lead_id,a.final_status,a.created_date,
a.display_trx_id,a.trx_amt,
case when a.trx_final_status_code=8 then 2 
else a.trx_final_status_code end trx_final_status_code
from transactions.mf_order_detail a
where a.trx_id=v_trx_id
)a
inner join master.trx_final_status b
on a.trx_final_status_code=b.trx_final_status_code
where a.trx_id=v_trx_id;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_lead_status(int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_lead_status(int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_lead_status(int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_lead_status(int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_lead_status(int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_amc_detail(varchar, varchar, int4, _varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_amc_detail(v_logintype character varying, v_logincode character varying, v_categorycode integer, v_clienttier character varying[] DEFAULT NULL::character varying[], v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(holdingdate date, advisorcode character varying, fundhouse character varying, ucccode character varying, acname character varying, accountcode character varying, isin character varying, isinname character varying, folionumber character varying, total_amt numeric, mf_schcode character varying, clienttier character varying, categorycode integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_logintype='RM'
THEN
	
	IF v_categorycode=261 and v_clienttier is null
	Then
		RETURN QUERY
		select 
		a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,
		sum(marketvalue) as total_amt,
		a.mf_schcode,a.clienttier,v_categorycode as categorycode
		from (
		select 
		a.holdingdate,ucc.client_owner as advisorcode,
		sch.company_name as fundhouse,ucc.ucccode,ucc.acname,
		ucc.priority_ac_code as accountcode,
		a.isincode as isin,sch.sch_name as isinname,
		a.foliono::character varying as folionumber,
--		(a.quantity*sch.nav)::numeric(18,2) as marketvalue,
		a.marketvalue::numeric(18,2) as marketvalue,
		sch.mf_schcode:: character varying as mf_schcode,ucc.clienttier
		FROM transactions.mv_client_holding a
--		INNER JOIN master.dim_customer b
--		ON a.accountcode = b.ac_code
		INNER JOIN master.dim_ucc ucc
		ON a.ucccode = ucc.ucccode
		INNER JOIN platform_db.mv_mf_details sch
		ON a.isincode = sch.isincode
		WHERE 
		ucc.client_owner = v_logincode
		AND (
		  COALESCE(v_search, '') = '' 
		  OR (
			(COALESCE(ucc.acname, '') || ' ' || 
			COALESCE(ucc.ucccode, '') || ' ' || 
			COALESCE(ucc.pan, '') || ' ' || 
			COALESCE(ucc.clienttier, '') || ' ' ||
			COALESCE(ucc.priority_ac_code, '') || ' ' ||
			COALESCE(sch.isincode, '')|| ' ' ||
			COALESCE(sch.sch_name, '')|| ' ' ||
			COALESCE(sch.company_name, '')
		) ~* v_search)
		)
--		AND a.quantity <> 0.00
		AND a.category_code=261
		)a
		where a.marketvalue<>0.00
	--	and (case when coalesce(v_clienttier,'')='' then true else
	--	a.clienttier ~* v_clienttier end )
		group by a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,a.mf_schcode,a.clienttier
		order by a.fundhouse,a.isinname,a.accountcode;

ELSIF v_categorycode=261 and v_clienttier is not null
	Then
		RETURN QUERY
		select 
		a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,
		a.folionumber,
		sum(marketvalue) as total_amt,
		a.mf_schcode,a.clienttier,v_categorycode as categorycode
		from (
		select 
		a.holdingdate,ucc.client_owner as advisorcode,
		sch.company_name as fundhouse,ucc.ucccode,ucc.acname,
		ucc.priority_ac_code as accountcode,
		a.isincode as isin,sch.sch_name as isinname,
--		a.folionumber,
		a.foliono::character varying as folionumber,
--		(a.quantity*sch.nav)::numeric(18,2) as marketvalue,
		a.marketvalue::numeric(18,2) as marketvalue,
		sch.mf_schcode:: character varying as mf_schcode,ucc.clienttier
		FROM transactions.mv_client_holding a
--		INNER JOIN master.dim_customer b
--		ON a.accountcode = b.ac_code
		INNER JOIN master.dim_ucc ucc
		ON a.ucccode = ucc.ucccode
		INNER JOIN platform_db.mv_mf_details sch
		ON a.isincode = sch.isincode
		WHERE 
		ucc.client_owner = v_logincode
		AND (
		  COALESCE(v_search, '') = '' 
		  OR (
			(COALESCE(ucc.acname, '') || ' ' || 
			COALESCE(ucc.ucccode, '') || ' ' || 
			COALESCE(ucc.pan, '') || ' ' || 
			COALESCE(ucc.clienttier, '') || ' ' ||
			COALESCE(ucc.priority_ac_code, '') || ' ' ||
			COALESCE(sch.isincode, '')|| ' ' ||
			COALESCE(sch.sch_name, '')|| ' ' ||
			COALESCE(sch.company_name, '')
		) ~* v_search)
		)
--		AND a.quantity <> 0.00
		AND a.category_code=261
		)a
		where a.marketvalue<>0.00
	    and upper(a.clienttier)= ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
		group by a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,a.mf_schcode,a.clienttier
		order by a.fundhouse,a.isinname,a.accountcode;

ELSIF v_categorycode=268 and v_clienttier is null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=268 and v_clienttier is not null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=293 and v_clienttier is null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=293 and v_clienttier is not null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;
	
	ELSE 
		RETURN QUERY
		select 
		now():: date as holdingdate,
		v_logincode as advisorcode,
		''::character varying as fundhouse,
		''::character varying as ucccode,
		''::character varying as acname,
		''::character varying as accountcode,
		''::character varying as isin,
		''::character varying as isinname,
		''::character varying as folionumber,
		0.00::numeric(18,2) as total_amt,
		''::character varying as mf_schcode,
		''::character varying as clienttier,
		v_categorycode as categorycode;
	End IF;	

ELSIF v_logintype='PARTNER'
THEN
	IF v_categorycode=261 and v_clienttier is null
	Then
		RETURN QUERY
		select 
		a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,
		sum(marketvalue) as total_amt,
		a.mf_schcode,a.clienttier,v_categorycode as categorycode
		from (
		select 
		a.holdingdate,ucc.partner_code as advisorcode,
		sch.company_name as fundhouse,ucc.ucccode,ucc.acname,
		ucc.priority_ac_code as accountcode,
		a.isin,sch.sch_name as isinname,
		a.folionumber,
		(a.quantity*sch.nav)::numeric(18,2) as marketvalue,
		sch.mf_schcode:: character varying as mf_schcode,ucc.clienttier
		FROM transactions.mf_holding a
		INNER JOIN master.dim_customer b
		ON a.accountcode = b.ac_code
		INNER JOIN master.dim_ucc ucc
		ON b.pan = ucc.pan
		INNER JOIN platform_db.mv_mf_details sch
		ON a.isin = sch.isincode
		WHERE 
		ucc.partner_code = v_logincode
		AND (
		  COALESCE(v_search, '') = '' 
		  OR (
			(COALESCE(ucc.acname, '') || ' ' || 
			COALESCE(ucc.ucccode, '') || ' ' || 
			COALESCE(ucc.pan, '') || ' ' || 
			COALESCE(ucc.clienttier, '') || ' ' ||
			COALESCE(ucc.priority_ac_code, '') || ' ' ||
			COALESCE(sch.isincode, '')|| ' ' ||
			COALESCE(sch.sch_name, '')|| ' ' ||
			COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.quantity <> 0.00
		)a
		where a.marketvalue<>0.00
	--	and (case when coalesce(v_clienttier,'')='' then true else
	--	a.clienttier ~* v_clienttier end )
		group by a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,a.mf_schcode,a.clienttier
		order by a.fundhouse,a.isinname,a.accountcode;

	ELSIF v_categorycode=261 and v_clienttier is not null
	Then
		RETURN QUERY
		select 
		a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,
		sum(marketvalue) as total_amt,
		a.mf_schcode,a.clienttier,v_categorycode as categorycode
		from (
		select 
		a.holdingdate,ucc.partner_code as advisorcode,
		sch.company_name as fundhouse,ucc.ucccode,ucc.acname,
		ucc.priority_ac_code as accountcode,
		a.isin,sch.sch_name as isinname,
		a.folionumber,
		(a.quantity*sch.nav)::numeric(18,2) as marketvalue,
		sch.mf_schcode:: character varying as mf_schcode,ucc.clienttier
		FROM transactions.mf_holding a
		INNER JOIN master.dim_customer b
		ON a.accountcode = b.ac_code
		INNER JOIN master.dim_ucc ucc
		ON b.pan = ucc.pan
		INNER JOIN platform_db.mv_mf_details sch
		ON a.isin = sch.isincode
		WHERE 
		ucc.partner_code = v_logincode
		AND (
		  COALESCE(v_search, '') = '' 
		  OR (
			(COALESCE(ucc.acname, '') || ' ' || 
			COALESCE(ucc.ucccode, '') || ' ' || 
			COALESCE(ucc.pan, '') || ' ' || 
			COALESCE(ucc.clienttier, '') || ' ' ||
			COALESCE(ucc.priority_ac_code, '') || ' ' ||
			COALESCE(sch.isincode, '')|| ' ' ||
			COALESCE(sch.sch_name, '')|| ' ' ||
			COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.quantity <> 0.00
		)a
		where a.marketvalue<>0.00
		and upper(a.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
		group by a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,a.mf_schcode,a.clienttier
		order by a.fundhouse,a.isinname,a.accountcode;

ELSIF v_categorycode=268 and v_clienttier is null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
and ucc.partner_code = v_logincode
and a.category_code=v_categorycode
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--	A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=268 and v_clienttier is not null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
and ucc.partner_code = v_logincode
and a.category_code=v_categorycode
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=293 and v_clienttier is null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
and ucc.partner_code = v_logincode
and a.category_code=v_categorycode
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--	A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=293 and v_clienttier is not null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
and ucc.partner_code = v_logincode
and a.category_code=v_categorycode
)A
where A.clienttier = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

	ELSE 
		RETURN QUERY
		select 
		now():: date as holdingdate,
		v_logincode as advisorcode,
		''::character varying as fundhouse,
		''::character varying as ucccode,
		''::character varying as acname,
		''::character varying as accountcode,
		''::character varying as isin,
		''::character varying as isinname,
		''::character varying as folionumber,
		0.00::numeric(18,2) as total_amt,
		''::character varying as mf_schcode,
		''::character varying as clienttier,
		v_categorycode as categorycode;
	End IF;	
END IF;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_amc_detail(varchar, varchar, int4, _varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail(varchar, varchar, int4, _varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail(varchar, varchar, int4, _varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail(varchar, varchar, int4, _varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail(varchar, varchar, int4, _varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_amc_detail_bkp_05sept2025(varchar, varchar, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_amc_detail_bkp_05sept2025(v_logintype character varying, v_logincode character varying, v_categorycode integer, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(holdingdate date, advisorcode character varying, fundhouse character varying, ucccode character varying, acname character varying, accountcode character varying, isin character varying, isinname character varying, folionumber character varying, total_amt numeric, mf_schcode character varying, clienttier character varying, categorycode integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_categorycode=261 
Then
RETURN QUERY
select 
a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
a.accountcode,a.isin,a.isinname,a.folionumber,
sum(marketvalue) as total_amt,
a.mf_schcode,a.clienttier,v_categorycode as categorycode
from (
select 
a.holdingdate,ucc.client_owner as advisorcode,
sch.company_name as fundhouse,ucc.ucccode,ucc.acname,
ucc.priority_ac_code as accountcode,
a.isin,sch.sch_name as isinname,
a.folionumber,
(a.quantity*sch.nav)::numeric(18,2) as marketvalue,
sch.mf_schcode:: character varying as mf_schcode,ucc.clienttier
FROM transactions.mf_holding a
INNER JOIN master.dim_customer b
ON a.accountcode = b.ac_code
INNER JOIN master.dim_ucc ucc
ON b.pan = ucc.pan
INNER JOIN platform_db.mv_mf_details sch
ON a.isin = sch.isincode
WHERE 
ucc.client_owner = v_logincode
AND (
  COALESCE(v_search, '') = '' 
  OR (
	(COALESCE(ucc.acname, '') || ' ' || 
	COALESCE(ucc.ucccode, '') || ' ' || 
	COALESCE(ucc.pan, '') || ' ' || 
	COALESCE(ucc.clienttier, '') || ' ' ||
	COALESCE(ucc.priority_ac_code, '') || ' ' ||
	COALESCE(sch.isincode, '')|| ' ' ||
	COALESCE(sch.company_name, '')
) ~* v_search)
)
AND a.quantity <> 0.00
)a
group by a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
a.accountcode,a.isin,a.isinname,a.folionumber,a.mf_schcode,a.clienttier
order by a.fundhouse,a.isinname,a.accountcode;

ELSE 
RETURN QUERY
select 
now():: date as holdingdate,
v_logincode as advisorcode,
''::character varying as fundhouse,
''::character varying as ucccode,
''::character varying as acname,
''::character varying as accountcode,
''::character varying as isin,
''::character varying as isinname,
''::character varying as folionumber,
0.00::numeric(18,2) as total_amt,
''::character varying as mf_schcode,
''::character varying as clienttier,
v_categorycode as categorycode;
End IF;	

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_amc_detail_bkp_05sept2025(varchar, varchar, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail_bkp_05sept2025(varchar, varchar, int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail_bkp_05sept2025(varchar, varchar, int4, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail_bkp_05sept2025(varchar, varchar, int4, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail_bkp_05sept2025(varchar, varchar, int4, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_amc_detail_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_amc_detail_bkp_26sept2025(v_logintype character varying, v_logincode character varying, v_categorycode integer, v_clienttier character varying[] DEFAULT NULL::character varying[], v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(holdingdate date, advisorcode character varying, fundhouse character varying, ucccode character varying, acname character varying, accountcode character varying, isin character varying, isinname character varying, folionumber character varying, total_amt numeric, mf_schcode character varying, clienttier character varying, categorycode integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_logintype='RM'
THEN
	
	IF v_categorycode=261 and v_clienttier is null
	Then
		RETURN QUERY
		select 
		a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,
		sum(marketvalue) as total_amt,
		a.mf_schcode,a.clienttier,v_categorycode as categorycode
		from (
		select 
		a.holdingdate,ucc.client_owner as advisorcode,
		sch.company_name as fundhouse,ucc.ucccode,ucc.acname,
		ucc.priority_ac_code as accountcode,
		a.isin,sch.sch_name as isinname,
		a.folionumber,
		(a.quantity*sch.nav)::numeric(18,2) as marketvalue,
		sch.mf_schcode:: character varying as mf_schcode,ucc.clienttier
		FROM transactions.mf_holding a
		INNER JOIN master.dim_customer b
		ON a.accountcode = b.ac_code
		INNER JOIN master.dim_ucc ucc
		ON b.pan = ucc.pan
		INNER JOIN platform_db.mv_mf_details sch
		ON a.isin = sch.isincode
		WHERE 
		ucc.client_owner = v_logincode
		AND (
		  COALESCE(v_search, '') = '' 
		  OR (
			(COALESCE(ucc.acname, '') || ' ' || 
			COALESCE(ucc.ucccode, '') || ' ' || 
			COALESCE(ucc.pan, '') || ' ' || 
			COALESCE(ucc.clienttier, '') || ' ' ||
			COALESCE(ucc.priority_ac_code, '') || ' ' ||
			COALESCE(sch.isincode, '')|| ' ' ||
			COALESCE(sch.sch_name, '')|| ' ' ||
			COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.quantity <> 0.00
		)a
		where a.marketvalue<>0.00
	--	and (case when coalesce(v_clienttier,'')='' then true else
	--	a.clienttier ~* v_clienttier end )
		group by a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,a.mf_schcode,a.clienttier
		order by a.fundhouse,a.isinname,a.accountcode;

ELSIF v_categorycode=261 and v_clienttier is not null
	Then
		RETURN QUERY
		select 
		a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,
		sum(marketvalue) as total_amt,
		a.mf_schcode,a.clienttier,v_categorycode as categorycode
		from (
		select 
		a.holdingdate,ucc.client_owner as advisorcode,
		sch.company_name as fundhouse,ucc.ucccode,ucc.acname,
		ucc.priority_ac_code as accountcode,
		a.isin,sch.sch_name as isinname,
		a.folionumber,
		(a.quantity*sch.nav)::numeric(18,2) as marketvalue,
		sch.mf_schcode:: character varying as mf_schcode,ucc.clienttier
		FROM transactions.mf_holding a
		INNER JOIN master.dim_customer b
		ON a.accountcode = b.ac_code
		INNER JOIN master.dim_ucc ucc
		ON b.pan = ucc.pan
		INNER JOIN platform_db.mv_mf_details sch
		ON a.isin = sch.isincode
		WHERE 
		ucc.client_owner = v_logincode
		AND (
		  COALESCE(v_search, '') = '' 
		  OR (
			(COALESCE(ucc.acname, '') || ' ' || 
			COALESCE(ucc.ucccode, '') || ' ' || 
			COALESCE(ucc.pan, '') || ' ' || 
			COALESCE(ucc.clienttier, '') || ' ' ||
			COALESCE(ucc.priority_ac_code, '') || ' ' ||
			COALESCE(sch.isincode, '')|| ' ' ||
			COALESCE(sch.sch_name, '')|| ' ' ||
			COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.quantity <> 0.00
		)a
		where a.marketvalue<>0.00
	    and upper(a.clienttier)= ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
		group by a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,a.mf_schcode,a.clienttier
		order by a.fundhouse,a.isinname,a.accountcode;

ELSIF v_categorycode=268 and v_clienttier is null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
--and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=268 and v_clienttier is not null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
--and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=293 and v_clienttier is null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
--and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=293 and v_clienttier is not null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
--and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;
	
	ELSE 
		RETURN QUERY
		select 
		now():: date as holdingdate,
		v_logincode as advisorcode,
		''::character varying as fundhouse,
		''::character varying as ucccode,
		''::character varying as acname,
		''::character varying as accountcode,
		''::character varying as isin,
		''::character varying as isinname,
		''::character varying as folionumber,
		0.00::numeric(18,2) as total_amt,
		''::character varying as mf_schcode,
		''::character varying as clienttier,
		v_categorycode as categorycode;
	End IF;	

ELSIF v_logintype='PARTNER'
THEN
	IF v_categorycode=261 and v_clienttier is null
	Then
		RETURN QUERY
		select 
		a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,
		sum(marketvalue) as total_amt,
		a.mf_schcode,a.clienttier,v_categorycode as categorycode
		from (
		select 
		a.holdingdate,ucc.partner_code as advisorcode,
		sch.company_name as fundhouse,ucc.ucccode,ucc.acname,
		ucc.priority_ac_code as accountcode,
		a.isin,sch.sch_name as isinname,
		a.folionumber,
		(a.quantity*sch.nav)::numeric(18,2) as marketvalue,
		sch.mf_schcode:: character varying as mf_schcode,ucc.clienttier
		FROM transactions.mf_holding a
		INNER JOIN master.dim_customer b
		ON a.accountcode = b.ac_code
		INNER JOIN master.dim_ucc ucc
		ON b.pan = ucc.pan
		INNER JOIN platform_db.mv_mf_details sch
		ON a.isin = sch.isincode
		WHERE 
		ucc.partner_code = v_logincode
		AND (
		  COALESCE(v_search, '') = '' 
		  OR (
			(COALESCE(ucc.acname, '') || ' ' || 
			COALESCE(ucc.ucccode, '') || ' ' || 
			COALESCE(ucc.pan, '') || ' ' || 
			COALESCE(ucc.clienttier, '') || ' ' ||
			COALESCE(ucc.priority_ac_code, '') || ' ' ||
			COALESCE(sch.isincode, '')|| ' ' ||
			COALESCE(sch.sch_name, '')|| ' ' ||
			COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.quantity <> 0.00
		)a
		where a.marketvalue<>0.00
	--	and (case when coalesce(v_clienttier,'')='' then true else
	--	a.clienttier ~* v_clienttier end )
		group by a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,a.mf_schcode,a.clienttier
		order by a.fundhouse,a.isinname,a.accountcode;

	ELSIF v_categorycode=261 and v_clienttier is not null
	Then
		RETURN QUERY
		select 
		a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,
		sum(marketvalue) as total_amt,
		a.mf_schcode,a.clienttier,v_categorycode as categorycode
		from (
		select 
		a.holdingdate,ucc.partner_code as advisorcode,
		sch.company_name as fundhouse,ucc.ucccode,ucc.acname,
		ucc.priority_ac_code as accountcode,
		a.isin,sch.sch_name as isinname,
		a.folionumber,
		(a.quantity*sch.nav)::numeric(18,2) as marketvalue,
		sch.mf_schcode:: character varying as mf_schcode,ucc.clienttier
		FROM transactions.mf_holding a
		INNER JOIN master.dim_customer b
		ON a.accountcode = b.ac_code
		INNER JOIN master.dim_ucc ucc
		ON b.pan = ucc.pan
		INNER JOIN platform_db.mv_mf_details sch
		ON a.isin = sch.isincode
		WHERE 
		ucc.partner_code = v_logincode
		AND (
		  COALESCE(v_search, '') = '' 
		  OR (
			(COALESCE(ucc.acname, '') || ' ' || 
			COALESCE(ucc.ucccode, '') || ' ' || 
			COALESCE(ucc.pan, '') || ' ' || 
			COALESCE(ucc.clienttier, '') || ' ' ||
			COALESCE(ucc.priority_ac_code, '') || ' ' ||
			COALESCE(sch.isincode, '')|| ' ' ||
			COALESCE(sch.sch_name, '')|| ' ' ||
			COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.quantity <> 0.00
		)a
		where a.marketvalue<>0.00
		and upper(a.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
		group by a.holdingdate,a.advisorcode,a.fundhouse,a.ucccode,a.acname,
		a.accountcode,a.isin,a.isinname,a.folionumber,a.mf_schcode,a.clienttier
		order by a.fundhouse,a.isinname,a.accountcode;

ELSIF v_categorycode=268 and v_clienttier is null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
--and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--	A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=268 and v_clienttier is not null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
--and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=293 and v_clienttier is null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
--and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--	A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

ELSIF v_categorycode=293 and v_clienttier is not null
Then
RETURN QUERY
select
a.aumdate as holdingdate,
--a.advisorcode,
v_logincode as advisorcode,
a.issuer_name as fundhouse,
a.ucccode,a.acname,a.priority_ac_code as accountcode,a.isincode as isin,
a.isin_name,a.folio as folionumber,
sum(currentvalue) as total_amt,''::character varying as mf_schcode,
a.clienttier,a.category_code
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where aumdate::date>='2025-04-30'
--and ucc.client_owner = v_logincode
and a.category_code=v_categorycode
)A
where A.clienttier = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name,a.clienttier;

	ELSE 
		RETURN QUERY
		select 
		now():: date as holdingdate,
		v_logincode as advisorcode,
		''::character varying as fundhouse,
		''::character varying as ucccode,
		''::character varying as acname,
		''::character varying as accountcode,
		''::character varying as isin,
		''::character varying as isinname,
		''::character varying as folionumber,
		0.00::numeric(18,2) as total_amt,
		''::character varying as mf_schcode,
		''::character varying as clienttier,
		v_categorycode as categorycode;
	End IF;	
END IF;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_amc_detail_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_detail_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_amc_summary(varchar, varchar, int4, _varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_amc_summary(v_logintype character varying, v_logincode character varying, v_categorycode integer, v_clienttier character varying[] DEFAULT NULL::character varying[], v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(holdingdate date, advisor_code character varying, fundhouse character varying, amc_logo character varying, totalvalue numeric, categorycode integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_logintype='RM'
THEN
IF v_categorycode=261 and v_clienttier is null
Then
	RETURN QUERY
	SELECT 
	    a.holdingdate,
	    a.advisorcode,
	    a.fundhouse,
		a.amc_logo,
	    SUM(a.marketvalue) AS totalvalue
		,v_categorycode as categorycode
	FROM (
	    SELECT 
	        a.holdingdate,
	        a.priority_ac_code as accountcode,
	        a.isincode as isin,
	        a.marketvalue,
	        ucc.acname,
	        ucc.priority_ac_code,
	        ucc.ucccode,
	        ucc.client_owner AS advisorcode,
	        sch.company_name AS fundhouse,
			sch.amc_logo as amc_logo
			,ucc.clienttier
	    FROM transactions.mv_client_holding a
--	    INNER JOIN master.dim_customer b
--	        ON a.accountcode = b.ac_code
	    INNER JOIN master.dim_ucc ucc
	        ON a.ucccode = ucc.ucccode
	    INNER JOIN platform_db.mv_mf_details sch
	        ON a.isincode = sch.isincode
	    WHERE 
	        ucc.client_owner = v_logincode
	        AND (
	  	COALESCE(v_search, '') = '' 
	  	OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(sch.sch_name, '')|| ' ' ||
		COALESCE(sch.company_name, '')
		) ~* v_search)
		)
--		AND a.assetclassid IN (3, 12, 48)
		AND a.category_code=261
		AND a.marketvalue <> 0.00
--		AND (case when coalesce(v_clienttier,'')='' then true else
--		a.clienttier ~* v_clienttier end )
	) a
	where a.marketvalue <> 0.00
	GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=261 and v_clienttier is not null
Then
	RETURN QUERY
	SELECT 
	    a.holdingdate,
	    a.advisorcode,
	    a.fundhouse,
		a.amc_logo,
	    SUM(a.marketvalue) AS totalvalue
		,v_categorycode as categorycode
	FROM (
	    SELECT 
	        a.holdingdate,
	        a.priority_ac_code as accountcode,
	        a.isincode as isin,
	        a.marketvalue,
	        ucc.acname,
	        ucc.priority_ac_code,
	        ucc.ucccode,
	        ucc.client_owner AS advisorcode,
	        sch.company_name AS fundhouse,
			sch.amc_logo as amc_logo
			,ucc.clienttier
	    FROM transactions.mv_client_holding a
--	    INNER JOIN master.dim_customer b
--	        ON a.accountcode = b.ac_code
	    INNER JOIN master.dim_ucc ucc
	        ON b.ucccode = ucc.ucccode
	    INNER JOIN platform_db.mv_mf_details sch
	        ON a.isincode = sch.isincode
	    WHERE 
	        ucc.client_owner = v_logincode
	        AND (
	  	COALESCE(v_search, '') = '' 
	  	OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(sch.sch_name, '')|| ' ' ||
		COALESCE(sch.company_name, '')
		) ~* v_search)
		)
--		AND a.assetclassid IN (3, 12, 48)
		AND a.category_code=261
		AND a.marketvalue <> 0.00
		and upper(a.clienttier)= ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
	) a
	where a.marketvalue <> 0.00
	GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=268 and v_clienttier is null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=268 and v_clienttier is not null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=293 and v_clienttier is null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
--and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=293 and v_clienttier is not null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSE
	RETURN QUERY
	SELECT 
	now()::date as holdingdate,
	v_logincode as advisorcode,
	''::character varying as fundhouse,
	''::character varying as amc_logo,
	0.00::numeric(18,2) totalvalue
	,v_categorycode as categorycode;
END IF;	

ELSIF v_logintype='PARTNER'
THEN
IF v_categorycode=261 and v_clienttier is null 
Then
	RETURN QUERY
	SELECT 
	    a.holdingdate,
	    a.advisorcode,
	    a.fundhouse,
		a.amc_logo,
	    SUM(a.marketvalue) AS totalvalue
		,v_categorycode as categorycode
	FROM (
	    SELECT 
	        a.holdingdate,
	        a.accountcode,
	        a.isin,
	        a.marketvalue,
	        ucc.acname,
	        ucc.priority_ac_code,
	        ucc.ucccode,
	        ucc.partner_code AS advisorcode,
	        sch.company_name AS fundhouse,
			sch.amc_logo as amc_logo
			,ucc.clienttier
	    FROM platform_reporting.holdingsummary a
	    INNER JOIN master.dim_customer b
	        ON a.accountcode = b.ac_code
	    INNER JOIN master.dim_ucc ucc
	        ON b.pan = ucc.pan
	    INNER JOIN platform_db.mv_mf_details sch
	        ON a.isin = sch.isincode
	    WHERE 
	        ucc.partner_code = v_logincode
	        AND (
	  	COALESCE(v_search, '') = '' 
	  	OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(sch.sch_name, '')|| ' ' ||
		COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.assetclassid IN (3, 12, 48)
		AND a.marketvalue <> 0.00
	) a
	where a.marketvalue <> 0.00
--	and (case when coalesce(v_clienttier,'')='' then true else
--	a.clienttier ~* v_clienttier end )
	GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=261 and v_clienttier is not null 
Then
	RETURN QUERY
	SELECT 
	    a.holdingdate,
	    a.advisorcode,
	    a.fundhouse,
		a.amc_logo,
	    SUM(a.marketvalue) AS totalvalue
		,v_categorycode as categorycode
	FROM (
	    SELECT 
	        a.holdingdate,
	        a.accountcode,
	        a.isin,
	        a.marketvalue,
	        ucc.acname,
	        ucc.priority_ac_code,
	        ucc.ucccode,
	        ucc.partner_code AS advisorcode,
	        sch.company_name AS fundhouse,
			sch.amc_logo as amc_logo
			,ucc.clienttier
	    FROM platform_reporting.holdingsummary a
	    INNER JOIN master.dim_customer b
	        ON a.accountcode = b.ac_code
	    INNER JOIN master.dim_ucc ucc
	        ON b.pan = ucc.pan
	    INNER JOIN platform_db.mv_mf_details sch
	        ON a.isin = sch.isincode
	    WHERE 
	        ucc.partner_code = v_logincode
	        AND (
	  	COALESCE(v_search, '') = '' 
	  	OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(sch.sch_name, '')|| ' ' ||
		COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.assetclassid IN (3, 12, 48)
		AND a.marketvalue <> 0.00
	) a
	where a.marketvalue <> 0.00
	and upper(a.clienttier)= ANY (
  	SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
	GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=268 and v_clienttier is null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
and ucc.partner_code = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=268 and v_clienttier is not null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
and ucc.partner_code = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=293 and v_clienttier is null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
and ucc.partner_code = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=293 and v_clienttier is not null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
now()::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
and ucc.partner_code = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSE
	RETURN QUERY
	SELECT 
	now()::date as holdingdate,
	v_logincode as advisorcode,
	''::character varying as fundhouse,
	''::character varying as amc_logo,
	0.00::numeric(18,2) totalvalue
	,v_categorycode as categorycode;	
END IF;	

END IF;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_amc_summary(varchar, varchar, int4, _varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary(varchar, varchar, int4, _varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary(varchar, varchar, int4, _varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary(varchar, varchar, int4, _varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary(varchar, varchar, int4, _varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_amc_summary_bkp_05sept2025(varchar, varchar, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_amc_summary_bkp_05sept2025(v_logintype character varying, v_logincode character varying, v_categorycode integer, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(holdingdate date, advisor_code character varying, fundhouse character varying, amc_logo character varying, totalvalue numeric, categorycode integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_categorycode=261 
Then
RETURN QUERY
SELECT 
    a.holdingdate,
    a.advisorcode,
    a.fundhouse,
	a.amc_logo,
    SUM(a.marketvalue) AS totalvalue
	,v_categorycode as categorycode
FROM (
    SELECT 
        a.holdingdate,
        a.accountcode,
        a.isin,
        a.marketvalue,
        ucc.acname,
        ucc.priority_ac_code,
        ucc.ucccode,
        ucc.client_owner AS advisorcode,
        sch.company_name AS fundhouse,
		sch.amc_logo as amc_logo
    FROM platform_reporting.holdingsummary a
    INNER JOIN master.dim_customer b
        ON a.accountcode = b.ac_code
    INNER JOIN master.dim_ucc ucc
        ON b.pan = ucc.pan
    INNER JOIN platform_db.mv_mf_details sch
        ON a.isin = sch.isincode
    WHERE 
        ucc.client_owner = v_logincode
        AND (
  	COALESCE(v_search, '') = '' 
  	OR (
	(COALESCE(ucc.acname, '') || ' ' || 
	COALESCE(ucc.ucccode, '') || ' ' || 
	COALESCE(ucc.pan, '') || ' ' || 
	COALESCE(ucc.clienttier, '') || ' ' ||
	COALESCE(ucc.priority_ac_code, '') || ' ' ||
	COALESCE(sch.isincode, '')|| ' ' ||
	COALESCE(sch.company_name, '')
	) ~* v_search)
	)
	AND a.assetclassid IN (3, 12, 48)
	AND a.marketvalue <> 0.00
) a
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
ORDER BY a.fundhouse,totalvalue;

ELSE
RETURN QUERY
SELECT 
now()::date as holdingdate,
v_logincode as advisorcode,
''::character varying as fundhouse,
''::character varying as amc_logo,
0.00::numeric(18,2) totalvalue
,v_categorycode as categorycode;

END IF;	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_amc_summary_bkp_05sept2025(varchar, varchar, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary_bkp_05sept2025(varchar, varchar, int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary_bkp_05sept2025(varchar, varchar, int4, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary_bkp_05sept2025(varchar, varchar, int4, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary_bkp_05sept2025(varchar, varchar, int4, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_amc_summary_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_amc_summary_bkp_26sept2025(v_logintype character varying, v_logincode character varying, v_categorycode integer, v_clienttier character varying[] DEFAULT NULL::character varying[], v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(holdingdate date, advisor_code character varying, fundhouse character varying, amc_logo character varying, totalvalue numeric, categorycode integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_logintype='RM'
THEN
IF v_categorycode=261 and v_clienttier is null
Then
	RETURN QUERY
	SELECT 
	    a.holdingdate,
	    a.advisorcode,
	    a.fundhouse,
		a.amc_logo,
	    SUM(a.marketvalue) AS totalvalue
		,v_categorycode as categorycode
	FROM (
	    SELECT 
	        a.holdingdate,
	        a.accountcode,
	        a.isin,
	        a.marketvalue,
	        ucc.acname,
	        ucc.priority_ac_code,
	        ucc.ucccode,
	        ucc.client_owner AS advisorcode,
	        sch.company_name AS fundhouse,
			sch.amc_logo as amc_logo
			,ucc.clienttier
	    FROM platform_reporting.holdingsummary a
	    INNER JOIN master.dim_customer b
	        ON a.accountcode = b.ac_code
	    INNER JOIN master.dim_ucc ucc
	        ON b.pan = ucc.pan
	    INNER JOIN platform_db.mv_mf_details sch
	        ON a.isin = sch.isincode
	    WHERE 
	        ucc.client_owner = v_logincode
	        AND (
	  	COALESCE(v_search, '') = '' 
	  	OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(sch.sch_name, '')|| ' ' ||
		COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.assetclassid IN (3, 12, 48)
		AND a.marketvalue <> 0.00
--		AND (case when coalesce(v_clienttier,'')='' then true else
--		a.clienttier ~* v_clienttier end )
	) a
	where a.marketvalue <> 0.00
	GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=261 and v_clienttier is not null
Then
	RETURN QUERY
	SELECT 
	    a.holdingdate,
	    a.advisorcode,
	    a.fundhouse,
		a.amc_logo,
	    SUM(a.marketvalue) AS totalvalue
		,v_categorycode as categorycode
	FROM (
	    SELECT 
	        a.holdingdate,
	        a.accountcode,
	        a.isin,
	        a.marketvalue,
	        ucc.acname,
	        ucc.priority_ac_code,
	        ucc.ucccode,
	        ucc.client_owner AS advisorcode,
	        sch.company_name AS fundhouse,
			sch.amc_logo as amc_logo
			,ucc.clienttier
	    FROM platform_reporting.holdingsummary a
	    INNER JOIN master.dim_customer b
	        ON a.accountcode = b.ac_code
	    INNER JOIN master.dim_ucc ucc
	        ON b.pan = ucc.pan
	    INNER JOIN platform_db.mv_mf_details sch
	        ON a.isin = sch.isincode
	    WHERE 
	        ucc.client_owner = v_logincode
	        AND (
	  	COALESCE(v_search, '') = '' 
	  	OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(sch.sch_name, '')|| ' ' ||
		COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.assetclassid IN (3, 12, 48)
		AND a.marketvalue <> 0.00
		and upper(a.clienttier)= ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
	) a
	where a.marketvalue <> 0.00
	GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=268 and v_clienttier is null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
--and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=268 and v_clienttier is not null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
--and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=293 and v_clienttier is null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
--and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=293 and v_clienttier is not null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
--and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSE
	RETURN QUERY
	SELECT 
	now()::date as holdingdate,
	v_logincode as advisorcode,
	''::character varying as fundhouse,
	''::character varying as amc_logo,
	0.00::numeric(18,2) totalvalue
	,v_categorycode as categorycode;
END IF;	

ELSIF v_logintype='PARTNER'
THEN
IF v_categorycode=261 and v_clienttier is null 
Then
	RETURN QUERY
	SELECT 
	    a.holdingdate,
	    a.advisorcode,
	    a.fundhouse,
		a.amc_logo,
	    SUM(a.marketvalue) AS totalvalue
		,v_categorycode as categorycode
	FROM (
	    SELECT 
	        a.holdingdate,
	        a.accountcode,
	        a.isin,
	        a.marketvalue,
	        ucc.acname,
	        ucc.priority_ac_code,
	        ucc.ucccode,
	        ucc.partner_code AS advisorcode,
	        sch.company_name AS fundhouse,
			sch.amc_logo as amc_logo
			,ucc.clienttier
	    FROM platform_reporting.holdingsummary a
	    INNER JOIN master.dim_customer b
	        ON a.accountcode = b.ac_code
	    INNER JOIN master.dim_ucc ucc
	        ON b.pan = ucc.pan
	    INNER JOIN platform_db.mv_mf_details sch
	        ON a.isin = sch.isincode
	    WHERE 
	        ucc.partner_code = v_logincode
	        AND (
	  	COALESCE(v_search, '') = '' 
	  	OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(sch.sch_name, '')|| ' ' ||
		COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.assetclassid IN (3, 12, 48)
		AND a.marketvalue <> 0.00
	) a
	where a.marketvalue <> 0.00
--	and (case when coalesce(v_clienttier,'')='' then true else
--	a.clienttier ~* v_clienttier end )
	GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=261 and v_clienttier is not null 
Then
	RETURN QUERY
	SELECT 
	    a.holdingdate,
	    a.advisorcode,
	    a.fundhouse,
		a.amc_logo,
	    SUM(a.marketvalue) AS totalvalue
		,v_categorycode as categorycode
	FROM (
	    SELECT 
	        a.holdingdate,
	        a.accountcode,
	        a.isin,
	        a.marketvalue,
	        ucc.acname,
	        ucc.priority_ac_code,
	        ucc.ucccode,
	        ucc.partner_code AS advisorcode,
	        sch.company_name AS fundhouse,
			sch.amc_logo as amc_logo
			,ucc.clienttier
	    FROM platform_reporting.holdingsummary a
	    INNER JOIN master.dim_customer b
	        ON a.accountcode = b.ac_code
	    INNER JOIN master.dim_ucc ucc
	        ON b.pan = ucc.pan
	    INNER JOIN platform_db.mv_mf_details sch
	        ON a.isin = sch.isincode
	    WHERE 
	        ucc.partner_code = v_logincode
	        AND (
	  	COALESCE(v_search, '') = '' 
	  	OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(sch.sch_name, '')|| ' ' ||
		COALESCE(sch.company_name, '')
		) ~* v_search)
		)
		AND a.assetclassid IN (3, 12, 48)
		AND a.marketvalue <> 0.00
	) a
	where a.marketvalue <> 0.00
	and upper(a.clienttier)= ANY (
  	SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
	GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=268 and v_clienttier is null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
--and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=268 and v_clienttier is not null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
--and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=293 and v_clienttier is null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
--and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
--where (case when coalesce(v_clienttier,'')='' then true else
--A.clienttier ~* v_clienttier end )
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSIF v_categorycode=293 and v_clienttier is not null 
Then
RETURN QUERY
select 
a.holdingdate,
--a.advisorcode,
a.advisorcode,
a.fundhouse,
a.amc_logo,
sum(currentvalue) as totalvalue
,v_categorycode as categorycode
from (
select
a.aumdate as holdingdate,a.category_code,a.issuer_name as fundhouse,
a.pan,a.folio,a.logo_url as amc_logo,a.acname,a.priority_ac_code,
a.ucccode,--a.advisorcode,
v_logincode as advisorcode,
a.isincode,a.isin_name,
sum(currentvalue) as currentvalue
from (
select 
--a.aumdate,
'2025-06-30'::date as aumdate,
a.category_code,i.issuer_name,a.currentvalue::numeric(18,2) as currentvalue,
a.pan,folio,i.logo_url,ucc.acname,ucc.priority_ac_code,ucc.ucccode,
ucc.client_owner as advisorcode,isin.isincode,isin.isin_name,ucc.clienttier
from aif_pms.aif_pms_folio a
left join master.dim_aif_pms_scheme b on a.scheme_id = b.scheme_id 
inner join master.issuer i on b.issuer_code = i.issuer_code
inner join master.dim_ucc ucc on a.pan = ucc.pan
left join (
	select scheme_id,isincode,isin_name 
	from (
		select scheme_id,isincode,isin_name,
		row_number() over (partition by scheme_id order by isincode) rnk
		from master.map_aifpms_scheme_isin
	)a
	where rnk=1
) isin on a.scheme_id = isin.scheme_id
where a.aumdate::date>='2025-04-30'
and a.category_code=v_categorycode
--and ucc.client_owner = v_logincode
and (
COALESCE(v_search, '') = '' 
OR (
		(COALESCE(ucc.acname, '') || ' ' || 
		COALESCE(ucc.ucccode, '') || ' ' || 
		COALESCE(ucc.pan, '') || ' ' || 
		COALESCE(ucc.clienttier, '') || ' ' ||
		COALESCE(ucc.priority_ac_code, '') || ' ' ||
		--COALESCE(sch.isincode, '')|| ' ' ||
		COALESCE(i.issuer_name, '')
		) ~* v_search
	)
)
)A
where upper(A.clienttier) = ANY (
  		SELECT upper(clienttier_element) FROM unnest(v_clienttier) AS clienttier_element)
group by a.aumdate,a.category_code,a.issuer_name,a.pan,
a.folio,a.logo_url,a.acname,a.priority_ac_code,
a.ucccode,a.advisorcode,a.isincode,a.isin_name
)A
GROUP BY a.holdingdate,a.advisorcode,a.fundhouse,a.amc_logo
	ORDER BY a.fundhouse,totalvalue;

ELSE
	RETURN QUERY
	SELECT 
	now()::date as holdingdate,
	v_logincode as advisorcode,
	''::character varying as fundhouse,
	''::character varying as amc_logo,
	0.00::numeric(18,2) totalvalue
	,v_categorycode as categorycode;	
END IF;	

END IF;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_amc_summary_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_amc_summary_bkp_26sept2025(varchar, varchar, int4, _varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_arntrf_orderbook(varchar, varchar, text, text, varchar, varchar, varchar, bool, int4, int4, text);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_arntrf_orderbook(p_usercode character varying, p_user_type character varying, p_search_text text DEFAULT NULL::text, p_client_tier text DEFAULT NULL::text, p_from_date character varying DEFAULT NULL::text, p_to_date character varying DEFAULT NULL::text, p_orderby character varying DEFAULT NULL::character varying, p_orderbydesc boolean DEFAULT false, p_page_index integer DEFAULT 1, p_page_size integer DEFAULT 10, p_orderstatus_id text DEFAULT NULL::text)
 RETURNS TABLE(sync_id integer, ac_code character varying, ucccode character varying, ac_name character varying, pan character varying, client_tier character varying, sch_name character varying, isin_code character varying, folio_no character varying, placed_on timestamp without time zone, aval_unit numeric, current_value numeric, status character varying, total_pages integer, total_records integer)
 LANGUAGE plpgsql
AS $function$

Declare
   	v_plsqltext TEXT;
    v_filter TEXT := '';
    v_count TEXT;
    v_total_records INTEGER;
    v_total_pages INTEGER;
   	v_order_clause text;
   	v_isadmin boolean:= false;
begin
	
--	if coalesce(p_usercode,'') <> ''
--	then
--		v_filter:= v_filter || ' and ord.emp_code = ' || quote_literal (p_usercode) ;
--	end if;
	
	if exists (
				select dee.cip_empcode
				from master.map_emp_user_role a join master.dim_ed_employee dee 
				on a.emp_id = dee.cip_empid 
				where dee.cip_empcode = p_usercode
				and a.role_code = 467
				)
	then 
		v_isadmin:= true;
	end if;

	if ( coalesce(p_usercode,'') <> '' and v_isadmin = false )
	then
		v_filter:= v_filter || ' and ord.emp_code = ' || quote_literal (p_usercode) ;
	end if;

	if coalesce(p_search_text,'') <> ''
	then
		v_filter:= v_filter || ' and ord.search_text ilike ' || '''%' || p_search_text || '%''';
	end if;
	
	if coalesce(p_client_tier,'') <> ''
	then
		v_filter := v_filter || ' and ord.client_tier_code in (' || 
                  array_to_string(
                      ARRAY(
                          SELECT (trim(tier))
                          FROM unnest(string_to_array(p_client_tier, ',')) AS tier
                      ), ',') || ')';
                     
	end if;
	
	if coalesce(p_orderstatus_id,'')<> ''
	then
		v_filter := v_filter || ' and ord.orderstatus_id in (' || 
                  array_to_string(
                      ARRAY(
                          SELECT (trim(ordsts))
                          FROM unnest(string_to_array(p_orderstatus_id, ',')) AS ordsts
                      ), ',') || ')';
                     
	end if;
	
	IF ( coalesce(p_from_date,'') <> '' and coalesce(p_to_date,'') <> '' )
	then
    	v_filter := v_filter || ' and cast (ord.placed_on as date ) between ' || ' cast (' ||quote_literal(p_from_date) || ' as date )' || ' and ' || ' cast (' ||quote_literal(p_to_date) || ' as date )';
    	
    END IF;
   
	v_count := '	with tmp_orderbook
	as
	(
	select 
		du.priority_ac_code as ac_code ,
		tier.tier_code as client_tier_code,
		ext.updated_date as placed_on ,
		ext.arn_transfer_status  as status,
		sync.initiated_by as emp_code,
		concat(upper(du.acname),'' '',upper(du.pan),'' '',upper(nav.isinname),'' '',upper(ext.isin),'' '',ext.folio) as search_text,
		case when coalesce (ext.arn_transfer_status,'''') = ''In Progress'' then 1
				when coalesce (ext.arn_transfer_status,'''') = ''Completed'' then 2
				when coalesce (ext.arn_transfer_status,'''') = ''Expired'' then 3
		 			else 0 end orderstatus_id
	from transactions.mf_client_holdings_external ext join master.dim_ucc du 
		on ext.ucccode = du.ucccode 
		join master.dim_client_tier tier on du.clienttier = tier.tier_name
		join transactions.mf_sync_history sync on sync.id = ext.sync_history_id
		join platform_db.mv_mf_details nav on ext.isin = nav.isincode
		
	where coalesce (ext.arn_transfer_status,'''') not in (''To be Initiated'','''')
	)
	select count(ord.ac_code) from tmp_orderbook ord WHERE 1 = 1' || v_filter;
	
	EXECUTE v_count INTO v_total_records;

	--RAISE NOTICE 'v_count :%',v_count;

	v_total_pages := CEIL(v_total_records::NUMERIC / COALESCE(p_page_size, 10))::INTEGER;
	
	--RAISE NOTICE 'v_total_pages :%',v_total_pages;
	--RAISE NOTICE 'v_total_pages :%',v_total_records;

    
   
   	v_plsqltext := '
	with tmp_orderbook
	as
	(
	select ext.sync_history_id as sync_id ,
		du.priority_ac_code as ac_code ,
		ext.ucccode as ucccode,
		cast (initcap(du.acname) as varchar ) as ac_name,
		du.pan as pan ,
		du.email as email ,
		du.mobileno as mobileno,
		du.clienttier as client_tier,
		tier.tier_code as client_tier_code,
		cast (initcap(nav.isinname) as varchar )as sch_name,
		ext.isin as isin_code,
		ext.folio as folio_no,
		cast (ext.updated_date as timestamp ) as placed_on ,
		ext.avlunits as aval_unit ,
		cast ((ext.avlunits * nav.nav) as numeric(18,4)) as current_value,
		ext.arn_transfer_status as status,
		sync.initiated_by as emp_code,
		case when coalesce (ext.arn_transfer_status,'''') = ''In Progress'' then 1
				when coalesce (ext.arn_transfer_status,'''') = ''Completed'' then 2
				when coalesce (ext.arn_transfer_status,'''') = ''Expired'' then 3
		 			else 0 end orderstatus_id,
		concat(upper(du.acname),'' '',upper(du.pan),'' '',upper(nav.isinname),'' '',upper(ext.isin),'' '',ext.folio) as search_text
	from transactions.mf_client_holdings_external ext join master.dim_ucc du 
		on ext.ucccode = du.ucccode 
		join platform_db.mv_mf_details nav on ext.isin = nav.isincode
		join master.dim_client_tier tier on du.clienttier = tier.tier_name
		join transactions.mf_sync_history sync on sync.id = ext.sync_history_id

	where coalesce (ext.arn_transfer_status,'''') not in (''To be Initiated'','''')
	)
	select 		
		ord.sync_id , 
		ord.ac_code , 
		ord.ucccode , 
		ord.ac_name , 
		ord.pan , 
		ord.client_tier ,
		ord.sch_name ,
		ord.isin_code ,
		ord.folio_no ,
		ord.placed_on ,
		ord.aval_unit ,
		ord.current_value ,
		ord.status 
	from tmp_orderbook ord 	WHERE 1 = 1' || v_filter;
	
	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
	
	IF coalesce(p_orderby,'') <> '' 
	THEN
        v_order_clause := ' ORDER BY ord.' || p_orderby || CASE WHEN p_orderbydesc = false THEN ' DESC nulls last' ELSE ' ASC nulls last' END;
	else
		v_order_clause := ' ORDER BY ord.ac_name';
    END IF;
		
   	v_plsqltext := v_plsqltext || v_order_clause;
	
   	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
    	
	v_plsqltext := v_plsqltext || format(' OFFSET %s ROWS FETCH NEXT %s ROWS ONLY', 
                                 COALESCE(p_page_size * (p_page_index - 1), 0), 
                                 COALESCE(p_page_size, 10));
    
    --RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
   
    v_plsqltext := '
		select 
			sync_id , 
			ac_code ,
			ucccode,
			ac_name,
			pan,
			client_tier,
			sch_name,
			isin_code,
			folio_no,
		    placed_on,	
			aval_unit ,
			current_value,
			status ,  ' || v_total_pages || ' AS total_pages, ' || v_total_records || ' AS total_records FROM (' || v_plsqltext || ') subquery';
                            
	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
   
	RETURN QUERY EXECUTE v_plsqltext;

		
end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_arntrf_orderbook(varchar, varchar, text, text, varchar, varchar, varchar, bool, int4, int4, text) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_arntrf_orderbook(varchar, varchar, text, text, varchar, varchar, varchar, bool, int4, int4, text) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_arntrf_orderbook(varchar, varchar, text, text, varchar, varchar, varchar, bool, int4, int4, text) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_mf_assettype_detail(varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_assettype_detail(v_logintype character varying, v_logincode character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(advisor_code character varying, holdingdate date, ucccode character varying, clientcode character varying, pan character varying, clientname character varying, clienttier character varying, equity_amount numeric, equity_pct numeric, debt_amount numeric, debt_pct numeric, hybrid_amount numeric, hybrid_pct numeric, commodity_amount numeric, commodity_pct numeric, total_amount numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN QUERY
SELECT 
	sub.advisor_code,sub.holdingdate,sub.ucccode,sub.clientcode,
    sub.pan,sub.clientname,sub.clienttier,   
    -- Amount & Percentage by asset type
    COALESCE(SUM(sub.amount) FILTER (WHERE sub.assettype = 'equity'), 0.00) AS equity_amount,
    COALESCE(ROUND(100.0 * SUM(sub.amount) FILTER (WHERE sub.assettype = 'equity') / NULLIF(SUM(sub.amount), 0), 2), 0.00) AS equity_pct,

    COALESCE(SUM(sub.amount) FILTER (WHERE sub.assettype = 'debt'), 0.00) AS debt_amount,
    COALESCE(ROUND(100.0 * SUM(sub.amount) FILTER (WHERE sub.assettype = 'debt') / NULLIF(SUM(sub.amount), 0), 2), 0.00) AS debt_pct,

    COALESCE(SUM(sub.amount) FILTER (WHERE sub.assettype = 'hybrid'), 0.00) AS hybrid_amount,
    COALESCE(ROUND(100.0 * SUM(sub.amount) FILTER (WHERE sub.assettype = 'hybrid') / NULLIF(SUM(sub.amount), 0), 2), 0.00) AS hybrid_pct,

    COALESCE(SUM(sub.amount) FILTER (WHERE sub.assettype = 'commodity'), 0.00) AS commodity_amount,
    COALESCE(ROUND(100.0 * SUM(sub.amount) FILTER (WHERE sub.assettype = 'commodity') / NULLIF(SUM(sub.amount), 0), 2), 0.00) AS commodity_pct,
    -- Total
    SUM(sub.amount) AS total_amount
--	,sub.mf_schcode
from (
    select 
		b.client_owner AS advisor_code,
        a.holdingdate,b.ucccode,b.priority_ac_code AS clientcode,
        b.pan,b.acname AS clientname,
        COALESCE(b.clienttier, 'Blue') AS clienttier,
        a.isin,a.security,
        (
            CASE 
                WHEN a.security ILIKE '%Gold%' OR a.security ILIKE '%Silver%' THEN 'commodity'
                WHEN a.assetname ILIKE '%Equity%' THEN 'equity'
                WHEN a.assetname ILIKE '%Debt%' THEN 'debt'
                WHEN a.assetname ILIKE '%Hybrid%' THEN 'hybrid'
                ELSE 'others'
            END
        )::character varying AS assettype,
        a.marketvalue AS amount,isin.mf_schcode    
    FROM platform_reporting.holdingsummary a
    INNER JOIN master.dim_ucc b ON a.accountcode = b.priority_ac_code
	INNER JOIN master.dim_mf_isin isin on a.isin =isin.isincode
    WHERE b.client_owner= v_logincode--in ('100040','100037')
	AND (
          COALESCE(v_search, '') = '' 
          OR (
			(COALESCE(b.acname, '') || ' ' || 
        	COALESCE(b.ucccode, '') || ' ' || 
        	COALESCE(b.pan, '') || ' ' || 
        	COALESCE(b.clienttier, '') || ' ' ||
        	COALESCE(b.priority_ac_code, ''))
			~* v_search)
		)
    AND a.assetclassid IN (3, 12, 48)
    AND a.marketvalue <> 0.00
) AS sub
GROUP BY sub.holdingdate,sub.ucccode,sub.clientcode,sub.pan,sub.clientname,sub.clienttier,sub.advisor_code--,sub.mf_schcode
ORDER BY sub.advisor_code,sub.clientname;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_assettype_detail(varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_assettype_detail(varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_assettype_detail(varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_assettype_detail(varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_assettype_detail(varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_assettype_summary(varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_assettype_summary(v_logintype character varying, v_logincode character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(advisor_code character varying, equity_amount numeric, equity_pct numeric, debt_amount numeric, debt_pct numeric, hybrid_amount numeric, hybrid_pct numeric, commodity_amount numeric, commodity_pct numeric, total_amount numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN QUERY
SELECT 
    sub.advisor_code,
    -- Total amount per asset type
    COALESCE(SUM(sub.amount) FILTER (WHERE sub.assettype = 'equity'), 0.00) AS equity_amount,
	COALESCE(ROUND(100.0 * SUM(sub.amount) FILTER (WHERE sub.assettype = 'equity') / NULLIF(SUM(sub.amount), 0), 2),0.00) AS equity_pct,
    
    COALESCE(SUM(sub.amount) FILTER (WHERE sub.assettype = 'debt'), 0.00) AS debt_amount,
	COALESCE(ROUND(100.0 * SUM(sub.amount) FILTER (WHERE sub.assettype = 'debt') / NULLIF(SUM(sub.amount), 0), 2),0.00) AS debt_pct,
    
    COALESCE(SUM(sub.amount) FILTER (WHERE sub.assettype = 'hybrid'), 0.00) AS hybrid_amount,
	COALESCE(ROUND(100.0 * SUM(sub.amount) FILTER (WHERE sub.assettype = 'hybrid') / NULLIF(SUM(sub.amount), 0), 2),0.00) AS hybrid_pct,
   
    COALESCE(SUM(sub.amount) FILTER (WHERE sub.assettype = 'commodity'), 0.00) AS commodity_amount,
	COALESCE(ROUND(100.0 * SUM(sub.amount) FILTER (WHERE sub.assettype = 'commodity') / NULLIF(SUM(sub.amount), 0), 2),0.00) AS commodity_pct,
    -- Grand total
    SUM(sub.amount) AS total_amount
 	FROM (
    SELECT 
        b.client_owner AS advisor_code,
        (
            CASE 
                WHEN a.security ILIKE '%Gold%' OR a.security ILIKE '%Silver%' THEN 'commodity'
                WHEN a.assetname ILIKE '%Equity%' THEN 'equity'
                WHEN a.assetname ILIKE '%Debt%' THEN 'debt'
                WHEN a.assetname ILIKE '%Hybrid%' THEN 'hybrid'
                ELSE 'others'
            END
        )::character varying AS assettype,
        a.marketvalue AS amount
    FROM platform_reporting.holdingsummary a
    INNER JOIN master.dim_ucc b ON a.accountcode = b.priority_ac_code
	INNER JOIN master.dim_mf_isin isin on a.isin =isin.isincode
    WHERE 
        b.client_owner=v_logincode --in ('100040','100037')
	AND (
          COALESCE(v_search, '') = '' 
          OR (
			(COALESCE(b.acname, '') || ' ' || 
        	COALESCE(ucccode, '') || ' ' || 
        	COALESCE(pan, '') || ' ' || 
        	COALESCE(clienttier, '') || ' ' ||
        	COALESCE(priority_ac_code, ''))
			~* v_search)
		)
	AND a.assetclassid IN (3, 12, 48)
    AND a.marketvalue <> 0.00
) AS sub
GROUP BY sub.advisor_code
ORDER BY sub.advisor_code;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_assettype_summary(varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_assettype_summary(varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_assettype_summary(varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_assettype_summary(varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_assettype_summary(varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_bookmark_data(varchar, int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_bookmark_data(v_login_code character varying DEFAULT NULL::character varying, v_mf_schcode bigint DEFAULT NULL::bigint)
 RETURNS TABLE(bookmark_id bigint, login_code character varying, mf_schcode bigint, created_date timestamp without time zone)
 LANGUAGE plpgsql
AS $function$

BEGIN

	RETURN QUERY
	SELECT A.bookmark_id, A.login_code, A.mf_schcode, A.created_date FROM transactions.mf_bookmark_history A
	WHERE CASE WHEN v_login_code IS NOT NULL AND v_login_code <> '' THEN A.login_code = v_login_code ELSE TRUE END
	AND CASE WHEN v_mf_schcode IS NOT NULL THEN A.mf_schcode = v_mf_schcode ELSE TRUE END;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_bookmark_data(varchar, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_bookmark_data(varchar, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_bookmark_data(varchar, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_bookmark_data(varchar, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_bookmark_data(varchar, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_challan_details();

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_challan_details()
 RETURNS TABLE(ac_code character varying, payment_trxid character varying, trx_id bigint[], collectionentry_groupid character varying, collectionentry_remarks character varying, cheque_date date)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        a.ac_code,
        a.payment_trxid,
        COALESCE(array_agg(DISTINCT a.trx_id), '{}'::bigint[]) AS trx_id,
		a.collectionentry_groupid,a.collectionentry_remarks,a.cheque_date
    FROM transactions.mf_order_detail a
    WHERE a.created_date::date >= (now()::date - INTERVAL '10 days')::date
      AND a.trx_type_code = 4
      AND upper(a.payment_method) = 'CHEQUE'
      AND a.collectionentry_groupid IS NOT NULL
      AND a.deposit_challanno IS NULL
      AND a.payment_trxid IS NOT NULL
    GROUP BY a.ac_code, a.payment_trxid, a.collectionentry_groupid, a.collectionentry_remarks,a.cheque_date;

EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred: %', SQLERRM;
        RAISE;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_challan_details() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_challan_details() TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_challan_details() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_challan_details() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_challan_details() TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_cheque_details();

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_cheque_details()
 RETURNS TABLE(ac_code character varying, payment_trxid character varying, trx_id bigint[], vendor_exchg_refno bigint[], total_order_amt numeric, bank_ac_number character varying, cheque_number character varying, cheque_date date, cheque_amt numeric, exchange_bank character varying, bank_ifsc character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        a.ac_code,
        a.payment_trxid,
        COALESCE(array_agg(DISTINCT a.trx_id::bigint ), '{}'::bigint[]) AS trx_id,
        COALESCE(array_agg(DISTINCT a.vendor_exchg_refno::bigint ), '{}'::bigint[]) AS vendor_exchg_refno,
        SUM(a.trx_amt)::numeric(15,4) AS total_order_amt,
        a.bank_ac_number,
        a.cheque_number,
        a.cheque_date,
        a.cheque_amt,
        a.exchange_bank,
        a.bank_ifsc
    FROM transactions.mf_order_detail a
    WHERE a.created_date::date >= (CURRENT_DATE - INTERVAL '10 days')
      AND a.trx_type_code = 4
      AND upper(a.payment_method) = 'CHEQUE'
      AND a.collectionentry_groupid IS NULL
      AND a.vendor_exchg_refno IS NOT NULL
      AND a.payment_trxid IS NOT NULL
    GROUP BY a.ac_code, a.payment_trxid, a.bank_ac_number, a.cheque_number, 
             a.cheque_date, a.cheque_amt, a.exchange_bank, a.bank_ifsc;

EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error in fn_get_mf_cheque_details: %', SQLERRM;
        RAISE;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_cheque_details() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cheque_details() TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cheque_details() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cheque_details() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cheque_details() TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_client_exthol_comm_data(int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_client_exthol_comm_data(p_templateid integer, p_date character varying DEFAULT NULL::character varying)
 RETURNS TABLE(acname character varying, rm_name character varying, folio character varying, schemename character varying, templateid integer, eventid integer, channelid integer, tomailid character varying, ccmailid character varying, providerref character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

IF (coalesce(p_templateid,0) = 9)
THEN
RETURN QUERY
SELECT DISTINCT du.acname , 
		du.client_owner_name as rm_name , 
		ext.folio , 
		ext.schemename  , 
		cast (9 as int ) as templateid,
		cast (1 as int ) as eventid , 
		cast (1 as int ) as channelid , 
		--du.rm_email  as tomailid ,
		cast (du.rm_email as varchar) as tomailid,
		cast (du.rm_email as varchar) as ccmailid,
		cast ('Netcore' as varchar )as providerref
from transactions.mf_client_holdings_external ext join master.dim_ucc du 
on ext.ucccode = du.ucccode 
where ext.arn_transfer_status  = 'Completed'
and cast (ext.updated_date as date ) = cast (current_timestamp at TIME ZONE'Asia/Kolkata' as date);

ELSE 
RETURN QUERY
SELECT DISTINCT du.acname , 
		du.client_owner_name as rm_name , 
		ext.folio , 
		ext.schemename  , 
		cast (10 as int ) as templateid,
		cast (1 as int ) as eventid , 
		cast (1 as int ) as channelid ,
		--du.rm_email  as tomailid ,
		cast (du.rm_email as varchar) as tomailid,
		cast (du.rm_email as varchar) as ccmailid,
		cast ('Netcore' as varchar )as providerref
from transactions.mf_client_holdings_external ext join master.dim_ucc du 
on ext.ucccode = du.ucccode 
where ext.arn_transfer_status  = 'Expired'
and cast (ext.updated_date as date ) = cast (current_timestamp at TIME ZONE'Asia/Kolkata' as date );


END IF;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_client_exthol_comm_data(int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_client_exthol_comm_data(int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_client_exthol_comm_data(int4, varchar) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_mf_clientholdings_ext(varchar, varchar, text, text, varchar, bool, int4, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_clientholdings_ext(p_usercode character varying, p_user_type character varying, p_search_text text DEFAULT NULL::text, p_client_tier text DEFAULT NULL::text, p_orderby character varying DEFAULT NULL::character varying, p_orderbydesc boolean DEFAULT false, p_page_index integer DEFAULT 1, p_page_size integer DEFAULT 10, p_invamt_range_id character varying DEFAULT NULL::character varying)
 RETURNS TABLE(sync_id integer, ac_code character varying, ucccode character varying, ac_name character varying, pan character varying, email character varying, mobileno character varying, client_tier character varying, client_owner character varying, inv_amt numeric, folio_no integer, last_sync_date date, is_3mthago boolean, is_transferin boolean, total_pages integer, total_records integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_plsqltext TEXT;
    v_filter TEXT := '';
    v_count TEXT;
    v_total_records INTEGER;
    v_total_pages INTEGER;
   	v_order_clause text;
begin
	
	if coalesce(p_usercode,'') <> ''
	then
		if (coalesce(p_user_type,'') = 'E')
		then
			v_filter:= v_filter || ' and ext.ra_code = ' || quote_literal (p_usercode) ;
		else
			v_filter:= v_filter || ' and ext.upccode = ' || quote_literal (p_usercode) ;
		end if;
	end if;

	if coalesce(p_search_text,'') <> ''
	then
		v_filter:= v_filter || ' and ext.search_text ilike ' || '''%' || p_search_text || '%''';
	end if;
	
	if coalesce(p_client_tier,'') <> ''
	then
		--v_filter:= v_filter || ' and hol.client_tier = ''' ||  p_client_tier || '''' ;
		--v_filter:= v_filter || ' and hol.client_tier = ' || quote_literal (p_client_tier) ;
		v_filter := v_filter || ' and ext.client_tier_code in (' || 
                  array_to_string(
                      ARRAY(
                          SELECT (trim(tier))
                          FROM unnest(string_to_array(p_client_tier, ',')) AS tier
                      ), ',') || ')';
                     
                     
                     
	end if;

	if coalesce(p_invamt_range_id,'')<> ''
	then
		v_filter := v_filter || ' and ext.invamt_range_id in (' || 
                  array_to_string(
                      ARRAY(
                          SELECT (trim(tier))
                          FROM unnest(string_to_array(p_invamt_range_id, ',')) AS tier
                      ), ',') || ')';
                     
	end if;
	
	
	v_count := 'with tmp_sync_history
	as
	(
		select syn.id as sync_id , syn.ucccode , syn.sync_end_datetime as last_sync_date, 
			syn.initiated_by as emp_code , 
			syn.status ,
			row_number()over(partition by syn.ucccode order by syn.id desc) as id  
		from transactions.mf_sync_history syn 
		where syn.status = ''Completed''
	),
	tmp_syn_data
	as
	(
		select a.sync_id , a.ucccode , a.last_sync_date , a.emp_code ,  a.status 
		from tmp_sync_history a
		where a.id = 1
	),
	tmp_holding_ext
	as
	(
	select b.sync_id , 
		b.ucccode , 
		sum( case when ext.isexternal  = true then ext.costvalue else 0 end ) as inv_amt, 
		count(distinct case when ext.isexternal  = true and ext.avlunits > 0  then ext.folio else null end  ) as folio_no
	from tmp_syn_data b left outer join transactions.mf_client_holdings_external ext
	on b.sync_id = ext.sync_history_id
	group by b.sync_id , b.ucccode
	), 
	tmp_emp_hierarchy 
	AS 
	(
         SELECT emp.cip_empcode AS emp_code,
            emp.fullname AS emp_name,
            ra.cip_empcode AS ra_code,
            ra.fullname AS ra_name,
            mgr.level
           FROM master.dim_ed_empl_manager_matrix mgr
             JOIN master.dim_ed_employee emp ON mgr.empcode::text = emp.empcode::text
             JOIN master.dim_ed_employee ra ON mgr.managercode::text = ra.empcode::text
          WHERE emp.employeestatus::text = ''A''::text
			ORDER BY mgr.level
    ),
    tmp_ext_data
    as
    (
    SELECT du.priority_ac_code AS ac_code , 
		emplvl.ra_code ,
		p.upccode,
		du.clienttier as client_tier,
	    tier.tier_code as client_tier_code,
		case when coalesce (hol.inv_amt,0) <= 500000 then 1
		 	when coalesce (hol.inv_amt,0) > 500000 and coalesce (hol.inv_amt,0) <= 1500000 then 2
		 	when coalesce (hol.inv_amt,0) > 1500000 and coalesce (hol.inv_amt,0) <= 3000000 then 3
		 	when coalesce (hol.inv_amt,0) > 3000000 and coalesce (hol.inv_amt,0) <= 5000000 then 4
		 	when coalesce (hol.inv_amt,0) > 5000000 and coalesce (hol.inv_amt,0) <= 10000000 then 5
		 else 6 end invamt_range_id, 
		concat(UPPER(du.priority_ac_code), '' '', UPPER(du.ucccode), '' '', UPPER(du.acname), '' '', UPPER(du.pan), '' '', UPPER(du.email), '' '', du.mobileno) AS search_text
   	FROM tmp_holding_ext hol JOIN master.dim_ucc du ON hol.ucccode::text = du.ucccode::text
	join master.dim_client_tier tier on du.clienttier = tier.tier_name
	JOIN tmp_emp_hierarchy emplvl ON du.client_owner::text = emplvl.emp_code::text
	left join master.dim_customer dc on dc.ac_code = du.priority_ac_code
	left join master.partner p on dc.partnerowner = p.partner_code
     
     )
     select count(ext.ac_code) from tmp_ext_data ext WHERE 1 = 1' || v_filter;
    EXECUTE v_count INTO v_total_records;

    
    v_total_pages := CEIL(v_total_records::NUMERIC / COALESCE(p_page_size, 10))::INTEGER;
   
   	v_plsqltext := 'with tmp_sync_history
	as
	(
		select syn.id as sync_id , syn.ucccode , cast (syn.sync_end_datetime as date ) as last_sync_date, 
			syn.initiated_by as emp_code , 
			syn.status ,
			row_number()over(partition by syn.ucccode order by syn.id desc) as id  
		from transactions.mf_sync_history syn 
		where syn.status = ''Completed''
	),
	tmp_syn_data
	as
	(
		select a.sync_id , a.ucccode , a.last_sync_date , a.emp_code ,  a.status 
		from tmp_sync_history a
		where a.id = 1
	),
	tmp_holding_ext
	as
	(
	select b.sync_id , 
			b.ucccode , 
			sum( case when ext.isexternal  = true then ext.costvalue else 0 end) as inv_amt, 
			count(distinct case when ext.isexternal  = true and ext.avlunits > 0  then ext.folio else null end  ) as folio_no
	from tmp_syn_data b left outer join transactions.mf_client_holdings_external ext
	on b.sync_id = ext.sync_history_id
	group by b.sync_id , b.ucccode
	), 
	tmp_emp_hierarchy 
	AS 
	(
         SELECT emp.cip_empcode AS emp_code,
            emp.fullname AS emp_name,
            ra.cip_empcode AS ra_code,
            ra.fullname AS ra_name,
            mgr.level
           FROM master.dim_ed_empl_manager_matrix mgr
             JOIN master.dim_ed_employee emp ON mgr.empcode::text = emp.empcode::text
             JOIN master.dim_ed_employee ra ON mgr.managercode::text = ra.empcode::text
          WHERE emp.employeestatus::text = ''A''::text
          ORDER BY mgr.level
    ),
	tmp_is_transfer_enable
	as
	(
		select distinct sync_history_id  
		from transactions.mf_client_holdings_external exthol
		where exthol.isexternal = true
		and exthol.avlunits > 0	
		and exthol.arn_transfer_status = ''To be Initiated''
	),
    tmp_ext_data
    as
    (
    SELECT 
	    hol.sync_id as sync_id,
		du.priority_ac_code AS ac_code,
	    du.ucccode,
	    cast (initcap(du.acname) as varchar ) as ac_name,
	    du.pan,
	    du.email,
	    du.mobileno,
		du.clienttier as client_tier,
	    tier.tier_code as client_tier_code,
	    du.client_owner,
		emplvl.ra_code,
		p.upccode,
	    coalesce (hol.inv_amt,0) AS inv_amt,
		case when coalesce (hol.inv_amt,0) <= 500000 then 1
		 	when coalesce (hol.inv_amt,0) > 500000 and coalesce (hol.inv_amt,0) <= 1500000 then 2
		 	when coalesce (hol.inv_amt,0) > 1500000 and coalesce (hol.inv_amt,0) <= 3000000 then 3
		 	when coalesce (hol.inv_amt,0) > 3000000 and coalesce (hol.inv_amt,0) <= 5000000 then 4
		 	when coalesce (hol.inv_amt,0) > 5000000 and coalesce (hol.inv_amt,0) <= 10000000 then 5
		 else 6 end invamt_range_id,
	    cast (hol.folio_no as int ) as folio_no,
	    cast (sync.last_sync_date as date ) as last_sync_date,
		case when cast (sync.last_sync_date as date )  + INTERVAL ''90 Days'' < current_timestamp at TIME ZONE''Asia/Kolkata'' then true else false end as is_3mthago,
		case when coalesce(trf.sync_history_id,0)  <> 0 then true else false end as is_transferin,
	    concat(upper(du.priority_ac_code), '' '', upper(du.ucccode), '' '', upper(du.acname), '' '', upper(du.pan), '' '', upper(du.email), '' '', du.mobileno) AS search_text
   FROM tmp_holding_ext hol JOIN master.dim_ucc du ON hol.ucccode::text = du.ucccode::text
	join master.dim_client_tier tier on du.clienttier = tier.tier_name	
     JOIN tmp_emp_hierarchy emplvl ON du.client_owner::text = emplvl.emp_code::text
	 join tmp_syn_data sync on hol.sync_id = sync.sync_id
	 left join master.dim_customer dc on dc.ac_code = du.priority_ac_code
	 left join master.partner p on dc.partnerowner = p.partner_code
	 left join tmp_is_transfer_enable trf on trf.sync_history_id = hol.sync_id
     )
     select distinct ext.sync_id,
			ext.ac_code ,
			ext.ucccode,
		    ext.ac_name ,
		    ext.pan,
		    ext.email,
		    ext.mobileno,
		    ext.client_tier ,
		    ext.client_owner,
		    ext.inv_amt,
		    ext.folio_no,
		    ext.last_sync_date,
			ext.is_3mthago,
			ext.is_transferin
		    	
     from tmp_ext_data ext

	WHERE 1 = 1' || v_filter;
	
	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
	IF coalesce(p_orderby,'') <> '' 
	THEN
        v_order_clause := ' ORDER BY ext.' || p_orderby || CASE WHEN p_orderbydesc = false THEN ' DESC nulls last' ELSE ' ASC nulls last' END;
	else
		v_order_clause := ' ORDER BY ext.ac_name';
    END IF;
		v_plsqltext := v_plsqltext || v_order_clause;
	
    	
	
	v_plsqltext := v_plsqltext || format(' OFFSET %s ROWS FETCH NEXT %s ROWS ONLY', 
                                 COALESCE(p_page_size * (p_page_index - 1), 0), 
                                 COALESCE(p_page_size, 10));

    v_plsqltext := 'select sync_id , ac_code ,
			ucccode,
			ac_name,
			pan,
			email,
			mobileno,
			client_tier,
			client_owner,
			inv_amt,
			folio_no,
		    last_sync_date,	
			is_3mthago,
			is_transferin , ' || v_total_pages || ' AS total_pages, ' || v_total_records || ' AS total_records FROM (' || v_plsqltext || ') subquery';
	
   	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
   	
   	
   	--RAISE NOTICE 'v_order_clause :%',v_order_clause;
   	RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
   
	RETURN QUERY EXECUTE v_plsqltext;

	

end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_clientholdings_ext(varchar, varchar, text, text, varchar, bool, int4, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_clientholdings_ext(varchar, varchar, text, text, varchar, bool, int4, int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_clientholdings_ext(varchar, varchar, text, text, varchar, bool, int4, int4, varchar) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_mf_clientholdings_ext_test(varchar, varchar, text, text, varchar, bool, int4, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_clientholdings_ext_test(p_usercode character varying, p_user_type character varying, p_search_text text DEFAULT NULL::text, p_client_tier text DEFAULT NULL::text, p_orderby character varying DEFAULT NULL::character varying, p_orderbydesc boolean DEFAULT false, p_page_index integer DEFAULT 1, p_page_size integer DEFAULT 10, p_invamt_range_id character varying DEFAULT NULL::character varying)
 RETURNS TABLE(sync_id integer, ac_code character varying, ucccode character varying, ac_name character varying, pan character varying, email character varying, mobileno character varying, client_tier character varying, client_owner character varying, inv_amt numeric, folio_no integer, last_sync_date date, is_3mthago boolean, is_transferin boolean, total_pages integer, total_records integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_plsqltext TEXT;
    v_filter TEXT := '';
    v_count TEXT;
    v_total_records INTEGER;
    v_total_pages INTEGER;
   	v_order_clause text;
begin
	
	if coalesce(p_usercode,'') <> ''
	then
		if (coalesce(p_user_type,'') = 'E')
		then
			v_filter:= v_filter || ' and ext.ra_code = ' || quote_literal (p_usercode) ;
		else
			v_filter:= v_filter || ' and ext.upccode = ' || quote_literal (p_usercode) ;
		end if;
	end if;

	if coalesce(p_search_text,'') <> ''
	then
		v_filter:= v_filter || ' and ext.search_text ilike ' || '''%' || p_search_text || '%''';
	end if;
	
	if coalesce(p_client_tier,'') <> ''
	then
		--v_filter:= v_filter || ' and hol.client_tier = ''' ||  p_client_tier || '''' ;
		--v_filter:= v_filter || ' and hol.client_tier = ' || quote_literal (p_client_tier) ;
		v_filter := v_filter || ' and ext.client_tier_code in (' || 
                  array_to_string(
                      ARRAY(
                          SELECT (trim(tier))
                          FROM unnest(string_to_array(p_client_tier, ',')) AS tier
                      ), ',') || ')';
                     
                     
                     
	end if;

	if coalesce(p_invamt_range_id,'')<> ''
	then
		v_filter := v_filter || ' and ext.invamt_range_id in (' || 
                  array_to_string(
                      ARRAY(
                          SELECT (trim(tier))
                          FROM unnest(string_to_array(p_invamt_range_id, ',')) AS tier
                      ), ',') || ')';
                     
	end if;
	
	
	v_count := 'with tmp_sync_history
	as
	(
		select syn.id as sync_id , syn.ucccode , syn.sync_end_datetime as last_sync_date, 
			syn.initiated_by as emp_code , 
			syn.status ,
			row_number()over(partition by syn.ucccode order by syn.id desc) as id  
		from transactions.mf_sync_history syn 
		where syn.status = ''Completed''
	),
	tmp_syn_data
	as
	(
		select a.sync_id , a.ucccode , a.last_sync_date , a.emp_code ,  a.status 
		from tmp_sync_history a
		where a.id = 1
	),
	tmp_holding_ext
	as
	(
	select b.sync_id , 
		b.ucccode , 
		sum( case when ext.isexternal  = true then ext.costvalue else 0 end ) as inv_amt, 
		count(distinct case when ext.isexternal  = true and ext.avlunits > 0  then ext.folio else null end  ) as folio_no
	from tmp_syn_data b left outer join transactions.mf_client_holdings_external ext
	on b.sync_id = ext.sync_history_id
	group by b.sync_id , b.ucccode
	), 
	tmp_emp_hierarchy 
	AS 
	(
         SELECT emp.cip_empcode AS emp_code,
            emp.fullname AS emp_name,
            ra.cip_empcode AS ra_code,
            ra.fullname AS ra_name,
            mgr.level
           FROM master.dim_ed_empl_manager_matrix mgr
             JOIN master.dim_ed_employee emp ON mgr.empcode::text = emp.empcode::text
             JOIN master.dim_ed_employee ra ON mgr.managercode::text = ra.empcode::text
          WHERE emp.employeestatus::text = ''A''::text
			ORDER BY mgr.level
    ),
    tmp_ext_data
    as
    (
    SELECT du.priority_ac_code AS ac_code , 
		emplvl.ra_code ,
		p.upccode,
		du.clienttier as client_tier,
	    tier.tier_code as client_tier_code,
		case when coalesce (hol.inv_amt,0) <= 500000 then 1
		 	when coalesce (hol.inv_amt,0) > 500000 and coalesce (hol.inv_amt,0) <= 1500000 then 2
		 	when coalesce (hol.inv_amt,0) > 1500000 and coalesce (hol.inv_amt,0) <= 3000000 then 3
		 	when coalesce (hol.inv_amt,0) > 3000000 and coalesce (hol.inv_amt,0) <= 5000000 then 4
		 	when coalesce (hol.inv_amt,0) > 5000000 and coalesce (hol.inv_amt,0) <= 10000000 then 5
		 else 6 end invamt_range_id, 
		concat(UPPER(du.priority_ac_code), '' '', UPPER(du.ucccode), '' '', UPPER(du.acname), '' '', UPPER(du.pan), '' '', UPPER(du.email), '' '', du.mobileno) AS search_text
   	FROM tmp_holding_ext hol JOIN master.dim_ucc du ON hol.ucccode::text = du.ucccode::text
	join master.dim_client_tier tier on du.clienttier = tier.tier_name
	JOIN tmp_emp_hierarchy emplvl ON du.client_owner::text = emplvl.emp_code::text
	left join master.dim_customer dc on dc.ac_code = du.priority_ac_code
	left join master.partner p on dc.partnerowner = p.partner_code
     
     )
     select count(ext.ac_code) from tmp_ext_data ext WHERE 1 = 1' || v_filter;
    EXECUTE v_count INTO v_total_records;

    
    v_total_pages := CEIL(v_total_records::NUMERIC / COALESCE(p_page_size, 10))::INTEGER;
   
   	v_plsqltext := 'with tmp_sync_history
	as
	(
		select syn.id as sync_id , syn.ucccode , cast (syn.sync_end_datetime as date ) as last_sync_date, 
			syn.initiated_by as emp_code , 
			syn.status ,
			row_number()over(partition by syn.ucccode order by syn.id desc) as id  
		from transactions.mf_sync_history syn 
		where syn.status = ''Completed''
	),
	tmp_syn_data
	as
	(
		select a.sync_id , a.ucccode , a.last_sync_date , a.emp_code ,  a.status 
		from tmp_sync_history a
		where a.id = 1
	),
	tmp_holding_ext
	as
	(
	select b.sync_id , 
			b.ucccode , 
			sum( case when ext.isexternal  = true then ext.costvalue else 0 end) as inv_amt, 
			count(distinct case when ext.isexternal  = true and ext.avlunits > 0  then ext.folio else null end  ) as folio_no
	from tmp_syn_data b left outer join transactions.mf_client_holdings_external ext
	on b.sync_id = ext.sync_history_id
	group by b.sync_id , b.ucccode
	), 
	tmp_emp_hierarchy 
	AS 
	(
         SELECT emp.cip_empcode AS emp_code,
            emp.fullname AS emp_name,
            ra.cip_empcode AS ra_code,
            ra.fullname AS ra_name,
            mgr.level
           FROM master.dim_ed_empl_manager_matrix mgr
             JOIN master.dim_ed_employee emp ON mgr.empcode::text = emp.empcode::text
             JOIN master.dim_ed_employee ra ON mgr.managercode::text = ra.empcode::text
          WHERE emp.employeestatus::text = ''A''::text
          ORDER BY mgr.level
    ),
	tmp_is_transfer_enable
	as
	(
		select distinct sync_history_id  
		from transactions.mf_client_holdings_external exthol
		where exthol.isexternal = true
		and exthol.avlunits > 0	
		and exthol.arn_transfer_status = ''To be Initiated''
	),
    tmp_ext_data
    as
    (
    SELECT 
	    hol.sync_id as sync_id,
		du.priority_ac_code AS ac_code,
	    du.ucccode,
	    cast (initcap(du.acname) as varchar ) as ac_name,
	    du.pan,
	    du.email,
	    du.mobileno,
		du.clienttier as client_tier,
	    tier.tier_code as client_tier_code,
	    du.client_owner,
		emplvl.ra_code,
		p.upccode,
	    coalesce (hol.inv_amt,0) AS inv_amt,
		case when coalesce (hol.inv_amt,0) <= 500000 then 1
		 	when coalesce (hol.inv_amt,0) > 500000 and coalesce (hol.inv_amt,0) <= 1500000 then 2
		 	when coalesce (hol.inv_amt,0) > 1500000 and coalesce (hol.inv_amt,0) <= 3000000 then 3
		 	when coalesce (hol.inv_amt,0) > 3000000 and coalesce (hol.inv_amt,0) <= 5000000 then 4
		 	when coalesce (hol.inv_amt,0) > 5000000 and coalesce (hol.inv_amt,0) <= 10000000 then 5
		 else 6 end invamt_range_id,
	    cast (hol.folio_no as int ) as folio_no,
	    cast (sync.last_sync_date as date ) as last_sync_date,
		case when cast (sync.last_sync_date as date )  + INTERVAL ''90 Days'' < current_timestamp at TIME ZONE''Asia/Kolkata'' then true else false end as is_3mthago,
		case when coalesce(trf.sync_history_id,0)  <> 0 then true else false end as is_transferin,
	    concat(upper(du.priority_ac_code), '' '', upper(du.ucccode), '' '', upper(du.acname), '' '', upper(du.pan), '' '', upper(du.email), '' '', du.mobileno) AS search_text
   FROM tmp_holding_ext hol JOIN master.dim_ucc du ON hol.ucccode::text = du.ucccode::text
	join master.dim_client_tier tier on du.clienttier = tier.tier_name	
     JOIN tmp_emp_hierarchy emplvl ON du.client_owner::text = emplvl.emp_code::text
	 join tmp_syn_data sync on hol.sync_id = sync.sync_id
	 left join master.dim_customer dc on dc.ac_code = du.priority_ac_code
	 left join master.partner p on dc.partnerowner = p.partner_code
	 left join tmp_is_transfer_enable trf on trf.sync_history_id = hol.sync_id
     )
     select distinct ext.sync_id,
			ext.ac_code ,
			ext.ucccode,
		    ext.ac_name ,
		    ext.pan,
		    ext.email,
		    ext.mobileno,
		    ext.client_tier ,
		    ext.client_owner,
		    ext.inv_amt,
		    ext.folio_no,
		    ext.last_sync_date,
			ext.is_3mthago,
			ext.is_transferin
		    	
     from tmp_ext_data ext

	WHERE 1 = 1' || v_filter;
	
	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
	IF coalesce(p_orderby,'') <> '' 
	THEN
        v_order_clause := ' ORDER BY ext.' || p_orderby || CASE WHEN p_orderbydesc = false THEN ' DESC nulls last' ELSE ' ASC nulls last' END;
	else
		v_order_clause := ' ORDER BY ext.ac_name';
    END IF;
		v_plsqltext := v_plsqltext || v_order_clause;
	
    	
	
	v_plsqltext := v_plsqltext || format(' OFFSET %s ROWS FETCH NEXT %s ROWS ONLY', 
                                 COALESCE(p_page_size * (p_page_index - 1), 0), 
                                 COALESCE(p_page_size, 10));

    v_plsqltext := 'select sync_id , ac_code ,
			ucccode,
			ac_name,
			pan,
			email,
			mobileno,
			client_tier,
			client_owner,
			inv_amt,
			folio_no,
		    last_sync_date,	
			is_3mthago,
			is_transferin , ' || v_total_pages || ' AS total_pages, ' || v_total_records || ' AS total_records FROM (' || v_plsqltext || ') subquery';
	
   	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
   	
   	
   	--RAISE NOTICE 'v_order_clause :%',v_order_clause;
   	RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
   
	RETURN QUERY EXECUTE v_plsqltext;

	

end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_clientholdings_ext_test(varchar, varchar, text, text, varchar, bool, int4, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_clientholdings_ext_test(varchar, varchar, text, text, varchar, bool, int4, int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_clientholdings_ext_test(varchar, varchar, text, text, varchar, bool, int4, int4, varchar) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_mf_clientholdings_wo_folio(varchar, varchar, text, text, varchar, bool, int4, int4);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_clientholdings_wo_folio(p_usercode character varying, p_user_type character varying, p_search_text text DEFAULT NULL::text, p_client_tier text DEFAULT NULL::text, p_orderby character varying DEFAULT NULL::character varying, p_orderbydesc boolean DEFAULT false, p_page_index integer DEFAULT 1, p_page_size integer DEFAULT 10)
 RETURNS TABLE(ac_code character varying, ucccode character varying, ac_name character varying, pan character varying, email character varying, mobileno character varying, client_tier character varying, client_owner character varying, inv_amt numeric, total_pages integer, total_records integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_plsqltext TEXT;
    v_filter TEXT := '';
    v_count TEXT;
    v_total_records INTEGER;
    v_total_pages INTEGER;
   	v_order_clause text;
   
begin
	
	if coalesce(p_usercode,'') <> ''
	then
		if (coalesce(p_user_type,'') = 'E')
		then
			v_filter:= v_filter || ' and hol.ra_code = ' || quote_literal (p_usercode) ;
		else
			v_filter:= v_filter || ' and hol.upccode = ' || quote_literal (p_usercode) ;
		end if;
	end if;

	if coalesce(p_search_text,'') <> ''
	then
		v_filter:= v_filter || ' and hol.search_text ilike ' || '''%' || p_search_text || '%''';
	end if;
	
	if coalesce(p_client_tier,'')  <> ''
	then
		--v_filter:= v_filter || ' and hol.client_tier = ''' ||  p_client_tier || '''' ;
		--v_filter:= v_filter || ' and hol.client_tier = ' || quote_literal (p_client_tier) ;
		v_filter := v_filter || ' and hol.client_tier_code in (' || 
                  array_to_string(
                      ARRAY(
                          SELECT (trim(tier))
                          FROM unnest(string_to_array(p_client_tier, ',')) AS tier
                      ), ',') || ')';
                     
	end if;
	

	--RAISE NOTICE 'search_text :%',v_filter;
	
	v_count := 'SELECT COUNT(distinct hol.ac_code) 
			FROM transactions.mv_client_holdings_wo_folio hol left join transactions.mf_client_holdings_external msh 
				on hol.ucccode = msh.ucccode 
				where msh.ucccode is null
				and 1 = 1' || v_filter;
    EXECUTE v_count INTO v_total_records;

    -- Calculate total pages
    v_total_pages := CEIL(v_total_records::NUMERIC / COALESCE(p_page_size, 10))::INTEGER;
   	
   		
	v_plsqltext := 'select distinct 
			hol.ac_code ,
			hol.ucccode,
			cast (hol.ac_name as varchar ) as ac_name,
			hol.pan,
			hol.email,
			hol.mobileno,
			hol.client_tier,
			hol.client_owner,
			hol.inv_amt
	from transactions.mv_client_holdings_wo_folio hol left join transactions.mf_client_holdings_external msh 
				on hol.ucccode = msh.ucccode 
				where msh.ucccode is null
				and 1 = 1' || v_filter;
	
	--IF coalesce(p_orderby,'') <> '' 
	--THEN
    --    v_order_clause := ' ORDER BY hol.' || p_orderby || CASE WHEN p_orderbydesc = false THEN ' DESC nulls last' ELSE ' ASC nulls last' END;
    --else
    --	v_order_clause := ' ORDER BY hol.ac_name';
	--END IF;

	--v_plsqltext := v_plsqltext || v_order_clause;
			
	v_plsqltext := v_plsqltext;		
	
	v_plsqltext := v_plsqltext || format(' OFFSET %s ROWS FETCH NEXT %s ROWS ONLY', 
                                 COALESCE(p_page_size * (p_page_index - 1), 0), 
                                 COALESCE(p_page_size, 10));
                                
    IF coalesce(p_orderby,'') <> '' 
	THEN
        v_order_clause := ' ORDER BY ' || p_orderby || CASE WHEN p_orderbydesc = false THEN ' DESC nulls last' ELSE ' ASC nulls last' END;
    else
    	v_order_clause := ' ORDER BY ac_name';
	END IF;

    v_plsqltext := 'select distinct 
			ac_code ,
			ucccode,
			ac_name,
			pan,
			email,
			mobileno,
			client_tier,
			client_owner,
			inv_amt, ' || v_total_pages || ' AS total_pages, ' || v_total_records || ' AS total_records FROM (' || v_plsqltext || ') subquery' || v_order_clause;
	
   	RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
	RETURN QUERY EXECUTE v_plsqltext;

end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_clientholdings_wo_folio(varchar, varchar, text, text, varchar, bool, int4, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_clientholdings_wo_folio(varchar, varchar, text, text, varchar, bool, int4, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_clientholdings_wo_folio(varchar, varchar, text, text, varchar, bool, int4, int4) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_mf_cta_detail(varchar, int4, varchar, varchar, int8, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_cta_detail(v_logintype character varying, v_cta_tab integer, v_ac_code character varying, v_isincode character varying, v_trx_id bigint, v_inv_action_code integer DEFAULT 1, v_typeoforder character varying DEFAULT 'Main'::character varying)
 RETURNS TABLE(display_trx_id character varying, ac_code character varying, ucccode character varying, isincode character varying, trx_type_code integer, trx_type character varying, trx_final_status_code integer, final_status character varying, resend_consent_request character varying, resend_payment_link character varying, duplicate character varying, view_details character varying, view_all_sips character varying, view_all_stps character varying, view_all_swps character varying, place_order_again character varying, cancel character varying, modify character varying, purallowed_flg character varying, redeem_allowed_flg character varying, sip_flg character varying, stp_flg character varying, swp_flg character varying, switch_flg character varying, pause_flg character varying, resume_flg character varying, approve_order character varying, pay_now character varying, retry_payment character varying, invest_again character varying, my_holdings character varying, reject character varying, primary_cta character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_freq character varying;
DECLARE
    v_ismodified_allowed character varying := 'Y';
	
BEGIN

v_freq := (select frequency from transactions.mf_order_summary where trx_id=v_trx_id);

----- To check if any modification request exist for the day
    IF EXISTS (
        SELECT 1
        FROM transactions.mf_order_detail_modification
        WHERE created_date::date = (NOW() AT TIME ZONE 'Asia/Kolkata')::date
          AND consent_status_code <> 3
          AND org_trx_id = v_trx_id
    ) THEN
        v_ismodified_allowed := 'N';
    END IF;
	
IF(v_logintype='RM' or v_logintype='PARTNER')
THEN
	
IF(v_cta_tab=0 and v_typeoforder='Main')
THEN

RAISE NOTICE 'Login Type: %', v_logintype;
RAISE NOTICE 'Tab Code: %', v_cta_tab;
RAISE NOTICE 'typeoforder: %', v_typeoforder;

RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,a.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
    (CASE WHEN a.trx_final_status_code = 7 THEN 'Y' ELSE 'N' END)::character varying AS Resend_Consent_request,
    (CASE WHEN a.trx_final_status_code IN (1, 3) THEN 'Y' ELSE 'N' END)::character varying AS Resend_Payment_link,
    (CASE WHEN a.trx_final_status_code IN (2, 6) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
	 'N'::character varying AS View_all_SIPs,
	 'N'::character varying AS View_all_STPs,
	 'N'::character varying AS View_all_SWPs,
	(CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,
    (
	CASE 
--	WHEN coalesce(f.remarks,'')='' and a.trx_final_status_code =4 and a.trx_type_code = 1 then 'Y'
--	when a.trx_type_code in (2,3) and a.trx_final_status_code =4 THEN 'Y' 
	WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Cancel,
--    (CASE WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Cancel,
	(CASE 
	WHEN a.trx_final_status_code IN (7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Modify, 
--	'N'::character varying AS Modify,
--  coalesce(d.purallowedflg,'N')::character varying as purallowed_flg,
    'Y'::character varying as purallowed_flg,
 --   coalesce(c.redemption_allowed,'N') as redeem_allowed_flg,
	(
	case when a.trx_type_code=1 and c.redemption_allowed='Y' then 'Y'
	when a.trx_type_code=2 and c.redemption_allowed='Y' then 'Y'
	when a.trx_type_code=3 and c.redemption_allowed='Y' then 'Y'
	when a.trx_type_code=4 and c.redemption_allowed='Y' then 'Y'
	when a.trx_type_code=5 and a.trx_final_status_code not in (4,5) 
	and c.redemption_allowed='Y' then 'Y'
	when a.trx_type_code=6 and c.redemption_allowed='Y' then 'Y'
--	else coalesce(c.redemption_allowed,'N') 
	else 'N' end
	)::character varying as redeem_allowed_flg,
	(
	case when a.trx_type_code=1 and a.trx_final_status_code not in (4,5) 
	and d.sip_flg='Y' then 'Y'
	when a.trx_type_code=2 and d.sip_flg='Y' then 'Y'
	when a.trx_type_code=3 and d.sip_flg='Y' then 'Y'
	when a.trx_type_code=4 and d.sip_flg='Y' then 'Y'
	when a.trx_type_code=5 and d.sip_flg='Y' then 'Y'
	when a.trx_type_code=6 and d.sip_flg='Y' then 'Y'
--	else coalesce(d.sip_flg,'N') 
	else 'N' end
	)::character varying as sip_flg,
--  coalesce(d.sip_flg,'N')::character varying as sip_flg,
--    'N'::character varying as sip_flg,
--   case when coalesce(c.stp_flg,'N') as stp_flg,
	(
	case when a.trx_type_code=1 and c.stp_flg='Y' then 'Y'
	when a.trx_type_code=2 and a.trx_final_status_code not in (4,5) 
	and c.stp_flg='Y' then 'Y'
	when a.trx_type_code=3 and c.stp_flg='Y' then 'Y'
	when a.trx_type_code=4 and c.stp_flg='Y' then 'Y'
	when a.trx_type_code=6 and c.stp_flg='Y' then 'Y'
--	else coalesce(c.stp_flg,'N') 
	else 'N' end
	)::character varying as stp_flg,
    (
	case when a.trx_type_code=1 and c.swp_flg='Y' then 'Y'
	when a.trx_type_code=2 and c.swp_flg='Y' then 'Y'
	when a.trx_type_code=3 and a.trx_final_status_code not in (4,5) 
	and c.swp_flg='Y' then 'Y'
	when a.trx_type_code=4 and c.swp_flg='Y' then 'Y'
	when a.trx_type_code=6 and c.swp_flg='Y' then 'Y'
--	else coalesce(c.swp_flg,'N')
	else 'N' end
	)::character varying as swp_flg,
	(
	case when a.trx_type_code=1 and c.switch_flg='Y' then 'Y'
	when a.trx_type_code=2 and c.switch_flg='Y' then 'Y'
	when a.trx_type_code=3 and c.switch_flg='Y' then 'Y'
	when a.trx_type_code=4 and c.switch_flg='Y' then 'Y'
	when a.trx_type_code=6 and a.trx_final_status_code not in (4,5) 
	and c.switch_flg='Y' then 'Y'
--	else coalesce(c.switch_flg,'N') 
	else 'N' end
	)::character varying as switch_flg,
--	'N'::character varying as stp_flg,
--	'N'::character varying as swp_flg,
--	'N'::character varying as switch_flg,
/*	
	(case when a.trx_type_code=1 and a.trx_final_status_code =4 
	and a.inv_plan_status_code = 4
	and e.pause_flg='Y' then 'Y' 
	else 'N' end)::character varying as pause_flg,
*/
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
/*	(case when a.trx_type_code=1 and a.inv_plan_status_code=2 then 'Y' 
	else 'N' end)::character varying as resume_flg,
*/
'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.trx_final_status_code= 7 then 'Resend_Consent_request'
when a.trx_final_status_code in (1,3) then 'Resend_Payment_link'
when a.trx_final_status_code in (2,6) then 'Duplicate'
when a.trx_final_status_code = 5 then 'Explore_other_funds'
when a.trx_final_status_code = 4 and a.trx_type_code=5 then 'Place_Order_again'
when a.trx_final_status_code = 4 and a.trx_type_code in (1,4,5,6) then 'Place_Order_again'
when a.trx_final_status_code = 4 and a.trx_type_code in (2,3) then 'Explore_other_funds'
else 'Explore_other_funds' end)::character varying as primary_cta
FROM transactions.mf_order_detail a
INNER JOIN master.dim_ucc b ON a.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
left join transactions.mf_order_summary f
 on a.trx_id =f.trx_id
WHERE a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;
--and inv_action_code=v_inv_action_code;

Elsif (v_cta_tab=0 and v_typeoforder<>'Main')
Then 

RAISE NOTICE 'Login Type: %', v_logintype;
RAISE NOTICE 'Tab Code: %', v_cta_tab;
RAISE NOTICE 'typeoforder: %', v_typeoforder;

RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,a.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
    (CASE WHEN a.trx_final_status_code = 7 THEN 'Y' ELSE 'N' END)::character varying AS Resend_Consent_request,
--    (CASE WHEN a.trx_final_status_code IN (1, 3) THEN 'Y' ELSE 'N' END)::character varying AS Resend_Payment_link,
--    (CASE WHEN a.trx_final_status_code IN (2, 6) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
'N'::character varying AS Resend_Payment_link,
	'N'::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
	 'N'::character varying AS View_all_SIPs,
	 'N'::character varying AS View_all_STPs,
	 'N'::character varying AS View_all_SWPs,
/*	(CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,
  */
	'N'::character varying AS Place_Order_again,
	(
	CASE 
--	WHEN a.trx_type_code in (1,2,3) and a.trx_final_status_code =4 THEN 'Y' 
	WHEN a.trx_final_status_code IN (7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Cancel,

--	'N'::character varying AS Cancel,
--    (CASE WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
--  coalesce(d.purallowedflg,'N')::character varying as purallowed_flg,
    'N'::character varying as purallowed_flg,
--    coalesce(c.redemption_allowed,'N') as redeem_allowed_flg,
	'N'::character varying as redeem_allowed_flg,
--  coalesce(d.sip_flg,'N')::character varying as sip_flg,
    'N'::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
/*
	(case when a.trx_type_code=1 and a.trx_final_status_code =4 
	and a.inv_plan_status_code = 4
	and e.pause_flg='Y' then 'Y' 
	else 'N' end)::character varying as pause_flg,
*/
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
	/*
	(case when a.trx_type_code=1 and a.inv_plan_status_code=2 then 'Y' 
	else 'N' end)::character varying as resume_flg,
*/
	'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.trx_final_status_code= 7 then 'Resend_Consent_request'
else 'Explore_other_funds' end)::character varying as primary_cta
FROM transactions.mf_order_detail_modification a
INNER JOIN master.dim_ucc b ON a.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;
--and inv_action_code=v_inv_action_code;

Elsif (v_cta_tab=1)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  	'N'::character varying AS Resend_Consent_request,
  	'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7)  THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
	/*
    (CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,	
*/
	'N'::character varying AS Place_Order_again,
	(CASE WHEN a.inv_plan_status_code IN (2, 4) and coalesce(a.remarks,'')='' and v_ismodified_allowed='Y'
	AND ABS(( coalesce(upcoming_due_date,start_date)::date - now()::date)::int) > 2
	THEN 'Y' ELSE 'N' END)::character varying AS Cancel, 
--	(CASE WHEN a.inv_plan_status_code IN (2, 4) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Modify,
/*	(
	CASE WHEN a.inv_plan_status_code in(2,4) 
	and now()::date >=(ord.created_date + INTERVAL '2 days' )::date 
	and coalesce(a.remarks,'')=''
	then 'Y' else 'N' end
	)::character varying AS Modify,
*/
--	LPAD(TO_CHAR(start_date::date, 'DD'), 2, '0')::int 
--	LPAD(TO_CHAR(now()::date, 'DD'), 2, '0')::int
--	/*
(
  CASE 
    WHEN a.inv_plan_status_code IN (2,4) 
  --    AND a.start_date::date < now()::date 
      AND g.installment_number >= 1
    AND ABS(( coalesce(upcoming_due_date,start_date)::date - now()::date)::int) > 7
      AND COALESCE(a.remarks, '') = ''
	and v_ismodified_allowed='Y'
    THEN 'Y' 
    ELSE 'N' 
  END
)::character varying AS Modify,
--	*/
--'Y' ::character varying AS Modify,
    'Y'::character varying as purallowed_flg,
--	(CASE WHEN a.inv_plan_status_code in (1,2) and c.redemption_allowed='Y' THEN 'Y' 
--	ELSE 'N' END)::character varying as redeem_allowed_flg,
	coalesce(c.redemption_allowed,'N') ::character varying as redeem_allowed_flg,
    (CASE WHEN a.inv_plan_status_code in (1) and d.sip_flg='Y' THEN 'Y' 
	ELSE 'N' END)::character varying as sip_flg,
   coalesce(c.stp_flg,'N')::character varying as stp_flg,
--'N'::character varying as stp_flg,
	  coalesce(c.swp_flg,'N')::character varying as swp_flg,
	coalesce(c.switch_flg,'N')::character varying as switch_flg,
	(CASE WHEN a.inv_plan_status_code = 4 and coalesce(a.remarks,'')='' 
	and e.pause_flg='Y' and f.pause_flag='Y' 
	and coalesce(f.pause_modification_count,0) > COALESCE(a.pausecount,0)
	and v_ismodified_allowed='Y'
	AND ABS(( coalesce(upcoming_due_date,start_date)::date - now()::date)::int) > 4
	then 'Y' else 'N' End
	)::character varying as pause_flg,
	(CASE WHEN a.inv_plan_status_code = 2 and coalesce(a.remarks,'')=''  
	and v_ismodified_allowed='Y'
	then 'Y' else 'N' End)::character varying as resume_flg,
--	'N'::character varying as pause_flg,
--	'N'::character varying as resume_flg,
'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.inv_plan_status_code =1 then 'Duplicate'
WHEN a.trx_id in ('405201','389606') then 'Place_Order_again'
when a.inv_plan_status_code= 4 and v_ismodified_allowed='Y' and COALESCE(a.remarks, '') <> '' then 'Explore_other_funds'
when a.inv_plan_status_code =2 and v_ismodified_allowed='Y' and COALESCE(a.remarks, '') <> '' then 'Explore_other_funds'
when a.inv_plan_status_code= 4 and v_ismodified_allowed='Y' and f.pause_flag='N' then 'Explore_other_funds'
when a.inv_plan_status_code= 4 and v_ismodified_allowed='Y' and f.pause_flag='Y' 
and coalesce(f.pause_modification_count,0) > COALESCE(a.pausecount,0)
and ABS(( coalesce(upcoming_due_date,start_date)::date - now()::date)::int) > 4
then 'Pause'
when a.inv_plan_status_code =2 and v_ismodified_allowed='Y' then 'Resume'
when a.inv_plan_status_code= 4 and v_ismodified_allowed='N' then 'Explore_other_funds'
when a.inv_plan_status_code =2 and v_ismodified_allowed='N' then 'Explore_other_funds'
else 'Explore_other_funds' end)::character varying as primary_cta
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
ON a.isincode=e.isincode
left join (
select exch.isincode,exch.frequency,exch.sipflag,exch.stpflag,exch.swpflag,
exch.switchflag,exch.pause_flag,
exch.pause_modification_count::int as pause_modification_count
from master.dim_mf_exchange_isin exch
where exch.txn_type='XSIP' and exch.isincode=v_isincode and exch.frequency=v_freq
) f
on a.isincode = f.isincode
left join(
select subs.trx_type_code,subs.order_no,subs.reg_no,subs.vendor_trx_id,
subs.orderdate,subs.amount,subs.reg_date,subs.status,subs.remarks,
row_number() over(partition by subs.reg_no order by subs.orderdate) as installment_number
from transactions.mf_subsequent_order subs
where orderedby='Exchange Triggered'
--and reg_no=227821	
)g on a.vendor_trx_id = g.vendor_trx_id
WHERE a.trx_type_code=1 
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;

Elsif (v_cta_tab=2)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  'N'::character varying AS Resend_Consent_request,
  'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
    'N'::character varying AS Place_Order_again,
	(CASE WHEN a.inv_plan_status_code=4 and coalesce(a.remarks,'')='' THEN 'Y' ELSE 'N' END)::character varying AS Cancel,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
    'Y'::character varying as purallowed_flg,
	coalesce(c.redemption_allowed,'N') ::character varying as redeem_allowed_flg,
    (CASE WHEN --a.inv_plan_status_code in (1) and 
	d.sip_flg='Y' THEN 'Y' 
	ELSE 'N' END)::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
	'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.inv_plan_status_code= 4 and coalesce(a.remarks,'')='' then 'Cancel'
when a.inv_plan_status_code= 4 and coalesce(a.remarks,'')<>'' then 'Explore_other_funds'
else 'Duplicate' end)::character varying as primary_cta
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
	left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_type_code=2
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;

Elsif (v_cta_tab=3)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  'N'::character varying AS Resend_Consent_request,
  'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
    'N'::character varying AS Place_Order_again,
	(CASE WHEN a.inv_plan_status_code=4 and coalesce(a.remarks,'')='' THEN 'Y' ELSE 'N' END)::character varying AS Cancel,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
    'Y'::character varying as purallowed_flg,
--	coalesce(c.redemption_allowed,'N') ::character varying as redeem_allowed_flg,
	'N'::character varying AS redeem_allowed_flg,
    (CASE WHEN d.sip_flg='Y' THEN 'Y' 
	ELSE 'N' END)::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
	'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.inv_plan_status_code= 4 and coalesce(a.remarks,'')='' then 'Cancel'
when a.inv_plan_status_code= 4 and coalesce(a.remarks,'')<>'' then 'Explore_other_funds'
else 'Duplicate' end)::character varying as primary_cta
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
	left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_type_code=3
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;
END IF;

END IF;

IF (v_logintype='CLIENT')
Then

IF(v_cta_tab=0 and v_inv_action_code=1)
THEN

RAISE NOTICE 'Login Type: %', v_logintype;
RAISE NOTICE 'Tab Code: %', v_cta_tab;
RAISE NOTICE 'typeoforder: %', v_typeoforder;

RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,a.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
--    (CASE WHEN a.trx_final_status_code = 7 THEN 'Y' ELSE 'N' END)::character varying AS Resend_Consent_request,
--    (CASE WHEN a.trx_final_status_code IN (1, 3) THEN 'Y' ELSE 'N' END)::character varying AS Resend_Payment_link,
	'N'::character varying AS Resend_Consent_request,
	'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.trx_final_status_code =2 THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
	'Y'::character varying AS View_Details,
	'N'::character varying AS View_all_SIPs,
	'N'::character varying AS View_all_STPs,
	'N'::character varying AS View_all_SWPs,
	'N'::character varying AS Place_Order_again,
--    'N'::character varying AS Cancel,
   (CASE WHEN a.trx_final_status_code IN (1, 3) THEN 'Y' ELSE 'N' END)::character varying AS Cancel,
--	(CASE 
--	WHEN a.trx_final_status_code IN (1,3) THEN 'Y'
--	ELSE 'N' END
--	)::character varying AS Modify, 
	'N'::character varying AS Modify,
--  coalesce(d.purallowedflg,'N')::character varying as purallowed_flg,
    'N'::character varying as purallowed_flg,
    coalesce(c.redemption_allowed,'N') as redeem_allowed_flg,
--  coalesce(d.sip_flg,'N')::character varying as sip_flg,
	'N'::character varying as sip_flg,
--    'N'::character varying as sip_flg,
--   case when coalesce(c.stp_flg,'N') as stp_flg,
--	(case when a.ac_code='457742110' and c.switch_flg='Y' then 'Y'
--	when c.stp_flg='Y' then 'Y' else 'N' end)::character varying as stp_flg,
--   coalesce(c.swp_flg,'N') as swp_flg,
--   coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
--	(case when a.trx_type_code=1 and a.trx_final_status_code =4 and e.pause_flg='Y' then 'Y' 
--	else 'N' end)::character varying as pause_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
--	(case when a.trx_type_code=1 and a.inv_plan_status_code=2 then 'Y' 
--	else 'N' end)::character varying as resume_flg
	    (CASE WHEN a.trx_final_status_code = 7 THEN 'Y' ELSE 'N' END)::character varying AS approve_order,
    (CASE WHEN a.trx_final_status_code =3 THEN 'Y' ELSE 'N' END)::character varying AS pay_now,
    (CASE WHEN a.trx_final_status_code =1 THEN 'Y' ELSE 'N' END)::character varying AS retry_payment,
   	(CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS invest_again,
	(CASE 
        WHEN a.trx_type_code IN (1, 4, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS my_holdings,
	    (
	CASE 
--	WHEN coalesce(f.remarks,'')='' and a.trx_final_status_code =4 and a.trx_type_code = 1 then 'Y'
--	when a.trx_type_code in (2,3) and a.trx_final_status_code =4 THEN 'Y' 
	WHEN a.trx_final_status_code IN (7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS reject,
--'Explore_other_funds'::character varying as primary_cta
(case 
when a.trx_final_status_code= 7 then 'approve_order'
when a.trx_final_status_code in (1,3) then 'pay_now'
when a.trx_final_status_code in (2) then 'Duplicate'
when a.trx_final_status_code = 5 then 'Explore_other_funds'
when a.trx_final_status_code = 4 and a.trx_type_code=5 then 'invest_again'
when a.trx_final_status_code = 4 and a.trx_type_code in (1,4,5,6) then 'invest_again'
when a.trx_final_status_code = 4 and a.trx_type_code in (2,3) then 'Explore_other_funds'
else 'Explore_other_funds' end)::character varying as primary_cta
FROM transactions.mf_order_detail a
INNER JOIN master.dim_ucc b ON a.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
left join transactions.mf_order_summary f
 on a.trx_id =f.trx_id
WHERE a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;
--and inv_action_code=v_inv_action_code;

Elsif (v_cta_tab=0 and v_inv_action_code<>1)
Then 

RAISE NOTICE 'Login Type: %', v_logintype;
RAISE NOTICE 'Tab Code: %', v_cta_tab;
RAISE NOTICE 'typeoforder: %', v_typeoforder;

RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,a.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
    'N'::character varying AS Resend_Consent_request,
	'N'::character varying AS Resend_Payment_link,
	'N'::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
	 'N'::character varying AS View_all_SIPs,
	 'N'::character varying AS View_all_STPs,
	 'N'::character varying AS View_all_SWPs,
/*	(CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,
  */
	'N'::character varying AS Place_Order_again,
	(
	CASE 
--	WHEN a.trx_type_code in (1,2,3) and a.trx_final_status_code =4 THEN 'Y' 
	WHEN a.trx_final_status_code IN (7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Cancel,

--	'N'::character varying AS Cancel,
--    (CASE WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
--  coalesce(d.purallowedflg,'N')::character varying as purallowed_flg,
    'N'::character varying as purallowed_flg,
--    coalesce(c.redemption_allowed,'N') as redeem_allowed_flg,
	'N'::character varying as redeem_allowed_flg,
--  coalesce(d.sip_flg,'N')::character varying as sip_flg,
    'N'::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
/*
	(case when a.trx_type_code=1 and a.trx_final_status_code =4 
	and a.inv_plan_status_code = 4
	and e.pause_flg='Y' then 'Y' 
	else 'N' end)::character varying as pause_flg,
*/
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
	/*
	(case when a.trx_type_code=1 and a.inv_plan_status_code=2 then 'Y' 
	else 'N' end)::character varying as resume_flg,
*/
(case when a.trx_final_status_code= 7 then 'Y'else 'N' end)::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.trx_final_status_code= 7 then 'approve_order'
else 'Explore_other_funds' end)::character varying as primary_cta
FROM transactions.mf_order_detail_modification a
INNER JOIN master.dim_ucc b ON a.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;

Elsif (v_cta_tab=1)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  	'N'::character varying AS Resend_Consent_request,
  	'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7)  THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
	/*
    (CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,	
*/
	'N'::character varying AS Place_Order_again,
--	(CASE WHEN a.inv_plan_status_code =4 and coalesce(a.remarks,'')=''
--	THEN 'Y' ELSE 'N' END)::character varying AS Cancel, 

	(CASE 
	WHEN a.trx_id in ('419718') then 'N'
	WHEN a.inv_plan_status_code =4 and coalesce(a.remarks,'')=''
	AND ABS(( coalesce(upcoming_due_date,start_date)::date - now()::date)::int) > 4
	THEN 'Y' ELSE 'N' END)::character varying AS Cancel, 
	
--	(CASE WHEN a.inv_plan_status_code IN (2, 4) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Modify,
/*	(
	CASE WHEN a.inv_plan_status_code in(2,4) 
	and now()::date >=(ord.created_date + INTERVAL '2 days' )::date 
	and coalesce(a.remarks,'')=''
	then 'Y' else 'N' end
	)::character varying AS Modify,
*/
--	LPAD(TO_CHAR(start_date::date, 'DD'), 2, '0')::int 
--	LPAD(TO_CHAR(now()::date, 'DD'), 2, '0')::int
	/*
(
  CASE 
    WHEN a.inv_plan_status_code IN (2,4) 
  --    AND a.start_date::date < now()::date 
      AND g.installment_number >= 1
    AND ABS(( coalesce(upcoming_due_date,start_date)::date - now()::date)::int) > 7
      AND COALESCE(a.remarks, '') = ''
    THEN 'Y' 
    ELSE 'N' 
  END
)::character varying AS Modify,
*/
'N' ::character varying AS Modify,
    'Y'::character varying as purallowed_flg,
--	(CASE WHEN a.inv_plan_status_code in (1,2) and c.redemption_allowed='Y' THEN 'Y' 
--	ELSE 'N' END)::character varying as redeem_allowed_flg,
	coalesce(c.redemption_allowed,'N') ::character varying as redeem_allowed_flg,
    (CASE WHEN a.inv_plan_status_code in (1,7) and d.sip_flg='Y' THEN 'Y' 
	ELSE 'N' END)::character varying as sip_flg,
--   coalesce(c.stp_flg,'N')::character varying as stp_flg,
'N'::character varying as stp_flg,
--	  coalesce(c.swp_flg,'N')::character varying as swp_flg,
	'N'::character varying as swp_flg,
--	coalesce(c.switch_flg,'N')::character varying as switch_flg,
	'N'::character varying as switch_flg,
/*	(CASE WHEN a.inv_plan_status_code = 4 and coalesce(a.remarks,'')='' 
	and e.pause_flg='Y' and f.pause_flag='Y' 
	and coalesce(f.pause_modification_count,0) > COALESCE(a.pausecount,0)
	then 'Y' else 'N' End
	)::character varying as pause_flg,
*/

--	(CASE WHEN a.inv_plan_status_code = 2 and coalesce(a.remarks,'')=''  then 'Y' else 'N' End)::character varying as resume_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
/*
	(case 
when a.inv_plan_status_code= 4 then 'Pause'
when a.inv_plan_status_code =2 then 'Resume'
else 'Duplicate' end)::character varying as primary_cta
*/
--'Explore_other_funds'::character varying as primary_cta
(
case WHEN a.trx_id in ('419718','481782') then 'Place_Order_again'
else 'Explore_other_funds' end
)::character varying as primary_cta
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
ON a.isincode=e.isincode
left join (
select exch.isincode,exch.frequency,exch.sipflag,exch.stpflag,exch.swpflag,
exch.switchflag,exch.pause_flag,
exch.pause_modification_count::int as pause_modification_count
from master.dim_mf_exchange_isin exch
where exch.txn_type='XSIP' and exch.isincode=v_isincode and exch.frequency=v_freq
) f
on a.isincode = f.isincode
left join(
select subs.trx_type_code,subs.order_no,subs.reg_no,subs.vendor_trx_id,
subs.orderdate,subs.amount,subs.reg_date,subs.status,subs.remarks,
row_number() over(partition by subs.reg_no order by subs.orderdate) as installment_number
from transactions.mf_subsequent_order subs
where orderedby='Exchange Triggered'
--and reg_no=227821	
)g on a.vendor_trx_id = g.vendor_trx_id
WHERE a.trx_type_code=1 
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;

END IF;
END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_cta_detail(varchar, int4, varchar, varchar, int8, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail(varchar, int4, varchar, varchar, int8, int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail(varchar, int4, varchar, varchar, int8, int4, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail(varchar, int4, varchar, varchar, int8, int4, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail(varchar, int4, varchar, varchar, int8, int4, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_cta_detail_bkp_09may2025(varchar, int4, varchar, varchar, int8, int4);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_cta_detail_bkp_09may2025(v_logintype character varying, v_cta_tab integer, v_ac_code character varying, v_isincode character varying, v_trx_id bigint, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(display_trx_id character varying, ac_code character varying, ucccode character varying, isincode character varying, trx_type_code integer, trx_type character varying, trx_final_status_code integer, final_status character varying, resend_consent_request character varying, resend_payment_link character varying, duplicate character varying, view_details character varying, view_all_sips character varying, view_all_stps character varying, view_all_swps character varying, place_order_again character varying, cancel character varying, modify character varying, purallowed_flg character varying, redeem_allowed_flg character varying, sip_flg character varying, stp_flg character varying, swp_flg character varying, switch_flg character varying, pause_flg character varying, resume_flg character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF(v_logintype='RM' or v_logintype='PARTNER')
THEN
	
IF(v_cta_tab=0 and v_inv_action_code=1)
THEN
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,a.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
    (CASE WHEN a.trx_final_status_code = 7 THEN 'Y' ELSE 'N' END)::character varying AS Resend_Consent_request,
    (CASE WHEN a.trx_final_status_code IN (1, 3) THEN 'Y' ELSE 'N' END)::character varying AS Resend_Payment_link,
    (CASE WHEN a.trx_final_status_code IN (2, 6) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
	 'N'::character varying AS View_all_SIPs,
	 'N'::character varying AS View_all_STPs,
	 'N'::character varying AS View_all_SWPs,
	(CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,
    (
	CASE 
--	WHEN coalesce(f.remarks,'')='' and a.trx_final_status_code =4 and a.trx_type_code = 1 then 'Y'
--	when a.trx_type_code in (2,3) and a.trx_final_status_code =4 THEN 'Y' 
	WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Cancel,
--    (CASE WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
--  coalesce(d.purallowedflg,'N')::character varying as purallowed_flg,
    'N'::character varying as purallowed_flg,
    coalesce(c.redemption_allowed,'N') as redeem_allowed_flg,
--  coalesce(d.sip_flg,'N')::character varying as sip_flg,
    'N'::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
--	(case when a.trx_type_code=1 and a.trx_final_status_code =4 and e.pause_flg='Y' then 'Y' 
--	else 'N' end)::character varying as pause_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg
--	(case when a.trx_type_code=1 and a.inv_plan_status_code=2 then 'Y' 
--	else 'N' end)::character varying as resume_flg
FROM transactions.mf_order_detail a
INNER JOIN master.dim_ucc b ON a.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
left join transactions.mf_order_summary f
 on a.trx_id =f.trx_id
WHERE a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode
and inv_action_code=v_inv_action_code;

Elsif (v_cta_tab=0 and v_inv_action_code<>1)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,a.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
    (CASE WHEN a.trx_final_status_code = 7 THEN 'Y' ELSE 'N' END)::character varying AS Resend_Consent_request,
    (CASE WHEN a.trx_final_status_code IN (1, 3) THEN 'Y' ELSE 'N' END)::character varying AS Resend_Payment_link,
    (CASE WHEN a.trx_final_status_code IN (2, 6) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
	 'N'::character varying AS View_all_SIPs,
	 'N'::character varying AS View_all_STPs,
	 'N'::character varying AS View_all_SWPs,
/*	(CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,
  */
	'N'::character varying AS Place_Order_again,
	(
	CASE 
--	WHEN a.trx_type_code in (1,2,3) and a.trx_final_status_code =4 THEN 'Y' 
	WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Cancel,

--	'N'::character varying AS Cancel,
--    (CASE WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
--  coalesce(d.purallowedflg,'N')::character varying as purallowed_flg,
    'N'::character varying as purallowed_flg,
    coalesce(c.redemption_allowed,'N') as redeem_allowed_flg,
--  coalesce(d.sip_flg,'N')::character varying as sip_flg,
    'N'::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
--	(case when a.trx_type_code=1 and a.trx_final_status_code =4 and e.pause_flg='Y' then 'Y' 
--	else 'N' end)::character varying as pause_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg
FROM transactions.mf_order_detail_modification a
INNER JOIN master.dim_ucc b ON a.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode
and inv_action_code=v_inv_action_code;

Elsif (v_cta_tab=1)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  	'N'::character varying AS Resend_Consent_request,
  	'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7)  THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    ('Y')::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
	/*
    (CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,	
*/
	'N'::character varying AS Place_Order_again,
	(CASE WHEN a.inv_plan_status_code IN (2, 4) and coalesce(a.remarks,'')=''
	THEN 'Y' ELSE 'N' END)::character varying AS Cancel, 
--	(CASE WHEN a.inv_plan_status_code IN (2, 4) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
	'N'::character varying AS Modify,
    'N'::character varying as purallowed_flg,
	(CASE WHEN a.inv_plan_status_code in (1,2) and c.redemption_allowed='Y' THEN 'Y' 
	ELSE 'N' END)::character varying as redeem_allowed_flg,
    (CASE WHEN a.inv_plan_status_code in (1,2) and d.sip_flg='Y' THEN 'Y' 
	ELSE 'N' END)::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
	--coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
--	(CASE WHEN a.inv_plan_status_code = 4 then 'Y' else 'N' End)::character varying as pause_flg,
--	(CASE WHEN a.inv_plan_status_code = 2 then 'Y' else 'N' End)::character varying as resume_flg
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_type_code=1 
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;

Elsif (v_cta_tab=2)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  'N'::character varying AS Resend_Consent_request,
  'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
    'N'::character varying AS Place_Order_again,
	(CASE WHEN a.inv_plan_status_code=4 THEN 'Y' ELSE 'N' END)::character varying AS Cancel,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
    'N'::character varying as purallowed_flg,
    'N'::character varying as redeem_allowed_flg,
    'N'::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
	left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_type_code=2
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;

Elsif (v_cta_tab=3)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  'N'::character varying AS Resend_Consent_request,
  'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
    'N'::character varying AS Place_Order_again,
	(CASE WHEN a.inv_plan_status_code=4 THEN 'Y' ELSE 'N' END)::character varying AS Cancel,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
    'N'::character varying as purallowed_flg,
    'N'::character varying as redeem_allowed_flg,
    'N'::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
	left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_type_code=3
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;
END IF;
END IF;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_cta_detail_bkp_09may2025(varchar, int4, varchar, varchar, int8, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail_bkp_09may2025(varchar, int4, varchar, varchar, int8, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail_bkp_09may2025(varchar, int4, varchar, varchar, int8, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail_bkp_09may2025(varchar, int4, varchar, varchar, int8, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail_bkp_09may2025(varchar, int4, varchar, varchar, int8, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_cta_detail_bkp_14jul2025(varchar, int4, varchar, varchar, int8, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_cta_detail_bkp_14jul2025(v_logintype character varying, v_cta_tab integer, v_ac_code character varying, v_isincode character varying, v_trx_id bigint, v_inv_action_code integer DEFAULT 1, v_typeoforder character varying DEFAULT 'main'::character varying)
 RETURNS TABLE(display_trx_id character varying, ac_code character varying, ucccode character varying, isincode character varying, trx_type_code integer, trx_type character varying, trx_final_status_code integer, final_status character varying, resend_consent_request character varying, resend_payment_link character varying, duplicate character varying, view_details character varying, view_all_sips character varying, view_all_stps character varying, view_all_swps character varying, place_order_again character varying, cancel character varying, modify character varying, purallowed_flg character varying, redeem_allowed_flg character varying, sip_flg character varying, stp_flg character varying, swp_flg character varying, switch_flg character varying, pause_flg character varying, resume_flg character varying, approve_order character varying, pay_now character varying, retry_payment character varying, invest_again character varying, my_holdings character varying, reject character varying, primary_cta character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
v_freq character varying;
	
BEGIN

v_freq := (select frequency from transactions.mf_order_summary where trx_id=v_trx_id);
	
IF(v_logintype='RM' or v_logintype='PARTNER')
THEN
	
IF(v_cta_tab=0 and v_inv_action_code=1)
THEN
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,a.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
    (CASE WHEN a.trx_final_status_code = 7 THEN 'Y' ELSE 'N' END)::character varying AS Resend_Consent_request,
    (CASE WHEN a.trx_final_status_code IN (1, 3) THEN 'Y' ELSE 'N' END)::character varying AS Resend_Payment_link,
    (CASE WHEN a.trx_final_status_code IN (2, 6) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
	 'N'::character varying AS View_all_SIPs,
	 'N'::character varying AS View_all_STPs,
	 'N'::character varying AS View_all_SWPs,
	(CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,
    (
	CASE 
--	WHEN coalesce(f.remarks,'')='' and a.trx_final_status_code =4 and a.trx_type_code = 1 then 'Y'
--	when a.trx_type_code in (2,3) and a.trx_final_status_code =4 THEN 'Y' 
	WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Cancel,
--    (CASE WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Cancel,
	(CASE 
	WHEN a.trx_final_status_code IN (7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Modify, 
--	'N'::character varying AS Modify,
--  coalesce(d.purallowedflg,'N')::character varying as purallowed_flg,
    'Y'::character varying as purallowed_flg,
 --   coalesce(c.redemption_allowed,'N') as redeem_allowed_flg,
	(
	case when a.trx_type_code=1 and a.trx_final_status_code =4 and c.redemption_allowed='Y' then 'Y'
	when a.trx_type_code=2 and a.trx_final_status_code =4 then 'N'
	when a.trx_type_code=3 and a.trx_final_status_code =4 then 'N'
	when a.trx_type_code=4 and a.trx_final_status_code =4 and c.redemption_allowed='Y' then 'Y'
	when a.trx_type_code=6 and a.trx_final_status_code =4 then 'N'
--	else coalesce(c.redemption_allowed,'N') 
	else 'N' end
	)::character varying as redeem_allowed_flg,
	(
	case when a.trx_type_code=1 and a.trx_final_status_code =4 then 'N'
	when a.trx_type_code=2 and d.sip_flg='Y' then 'Y'
	when a.trx_type_code=3 and d.sip_flg='Y' then 'Y'
	when a.trx_type_code=4 and d.sip_flg='Y' then 'Y'
	when a.trx_type_code=5 and d.sip_flg='Y' then 'Y'
	when a.trx_type_code=6 and d.sip_flg='Y' then 'Y'
--	else coalesce(d.sip_flg,'N') 
	else 'N' end
	)::character varying as sip_flg,
--  coalesce(d.sip_flg,'N')::character varying as sip_flg,
--    'N'::character varying as sip_flg,
--   case when coalesce(c.stp_flg,'N') as stp_flg,
	(
	case when a.trx_type_code=1 and c.stp_flg='Y' then 'Y'
	when a.trx_type_code=2 and a.trx_final_status_code =4 then 'N'
	when a.trx_type_code=3 and a.trx_final_status_code =4 then 'N'
	when a.trx_type_code=4 and c.stp_flg='Y' then 'Y'
	when a.trx_type_code=6 and a.trx_final_status_code =4 then 'N'
--	else coalesce(c.stp_flg,'N') 
	else 'N' end
	)::character varying as stp_flg,
    (
	case when a.trx_type_code=1 and c.swp_flg='Y' then 'Y'
	when a.trx_type_code=2 then 'N'
	when a.trx_type_code=3 then 'N'
	when a.trx_type_code=4 and c.swp_flg='Y' then 'Y'
	when a.trx_type_code=6 then 'N'
--	else coalesce(c.swp_flg,'N')
	else 'N' end
	)::character varying as swp_flg,
	
	(
	case when a.trx_type_code=1 and c.switch_flg='Y' then 'Y'
	when a.trx_type_code=2 and a.trx_final_status_code =4 then 'N'
	when a.trx_type_code=3 and a.trx_final_status_code =4 then 'N'
	when a.trx_type_code=4 and c.switch_flg='Y' then 'Y'
	when a.trx_type_code=6  then 'N'
	else 'N' end
	)::character varying as switch_flg,
	
  --  'N'::character varying as switch_flg,
--	'N'::character varying as stp_flg,
--	'N'::character varying as swp_flg,
--	'N'::character varying as switch_flg,
/*	
	(case when a.trx_type_code=1 and a.trx_final_status_code =4 
	and a.inv_plan_status_code = 4
	and e.pause_flg='Y' then 'Y' 
	else 'N' end)::character varying as pause_flg,
*/
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
/*	(case when a.trx_type_code=1 and a.inv_plan_status_code=2 then 'Y' 
	else 'N' end)::character varying as resume_flg,
*/
'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.trx_final_status_code= 7 then 'Resend_Consent_request'
when a.trx_final_status_code in (2,6) then 'Duplicate'
when a.trx_final_status_code = 5 then 'Explore_other_funds'
when a.trx_final_status_code = 4 and a.trx_type_code=5 then 'Place_Order_again'
when a.trx_final_status_code = 4 and a.trx_type_code in (1,4,5,6) then 'Place_Order_again'
when a.trx_final_status_code = 4 and a.trx_type_code in (2,3) then 'Explore_other_funds'
else 'Explore_other_funds' end)::character varying as primary_cta
FROM transactions.mf_order_detail a
INNER JOIN master.dim_ucc b ON a.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
left join transactions.mf_order_summary f
 on a.trx_id =f.trx_id
WHERE a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;
--and inv_action_code=v_inv_action_code;

Elsif (v_cta_tab=0 and v_inv_action_code<>1)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,a.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
    (CASE WHEN a.trx_final_status_code = 7 THEN 'Y' ELSE 'N' END)::character varying AS Resend_Consent_request,
--    (CASE WHEN a.trx_final_status_code IN (1, 3) THEN 'Y' ELSE 'N' END)::character varying AS Resend_Payment_link,
--    (CASE WHEN a.trx_final_status_code IN (2, 6) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
'N'::character varying AS Resend_Payment_link,
	'N'::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
	 'N'::character varying AS View_all_SIPs,
	 'N'::character varying AS View_all_STPs,
	 'N'::character varying AS View_all_SWPs,
/*	(CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,
  */
	'N'::character varying AS Place_Order_again,
	(
	CASE 
--	WHEN a.trx_type_code in (1,2,3) and a.trx_final_status_code =4 THEN 'Y' 
	WHEN a.trx_final_status_code IN (7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Cancel,

--	'N'::character varying AS Cancel,
--    (CASE WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
--  coalesce(d.purallowedflg,'N')::character varying as purallowed_flg,
    'N'::character varying as purallowed_flg,
--    coalesce(c.redemption_allowed,'N') as redeem_allowed_flg,
	'N'::character varying as redeem_allowed_flg,
--  coalesce(d.sip_flg,'N')::character varying as sip_flg,
    'N'::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
/*
	(case when a.trx_type_code=1 and a.trx_final_status_code =4 
	and a.inv_plan_status_code = 4
	and e.pause_flg='Y' then 'Y' 
	else 'N' end)::character varying as pause_flg,
*/
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
	/*
	(case when a.trx_type_code=1 and a.inv_plan_status_code=2 then 'Y' 
	else 'N' end)::character varying as resume_flg,
*/
	'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.trx_final_status_code= 7 then 'Resend_Consent_request'
else 'Explore_other_funds' end)::character varying as primary_cta
FROM transactions.mf_order_detail_modification a
INNER JOIN master.dim_ucc b ON a.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;
--and inv_action_code=v_inv_action_code;

Elsif (v_cta_tab=1)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  	'N'::character varying AS Resend_Consent_request,
  	'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7)  THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
	/*
    (CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS Place_Order_again,	
*/
	'N'::character varying AS Place_Order_again,
	(CASE WHEN a.inv_plan_status_code IN (2, 4) and coalesce(a.remarks,'')=''
	THEN 'Y' ELSE 'N' END)::character varying AS Cancel, 
--	(CASE WHEN a.inv_plan_status_code IN (2, 4) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Modify,
/*	(
	CASE WHEN a.inv_plan_status_code in(2,4) 
	and now()::date >=(ord.created_date + INTERVAL '2 days' )::date 
	and coalesce(a.remarks,'')=''
	then 'Y' else 'N' end
	)::character varying AS Modify,
*/
--	LPAD(TO_CHAR(start_date::date, 'DD'), 2, '0')::int 
--	LPAD(TO_CHAR(now()::date, 'DD'), 2, '0')::int
/*
(
  CASE 
    WHEN a.inv_plan_status_code IN (2,4) 
      AND a.start_date::date < now()::date 
      AND g.installment_number >= 1
    AND ABS((start_date::date - now()::date)::int) > 7
      AND COALESCE(a.remarks, '') = ''
    THEN 'Y' 
    ELSE 'N' 
  END
)::character varying AS Modify,
*/
'N' ::character varying AS Modify,
    'Y'::character varying as purallowed_flg,
--	(CASE WHEN a.inv_plan_status_code in (1,2) and c.redemption_allowed='Y' THEN 'Y' 
--	ELSE 'N' END)::character varying as redeem_allowed_flg,
	coalesce(c.redemption_allowed,'N') ::character varying as redeem_allowed_flg,
    (CASE WHEN a.inv_plan_status_code in (1) and d.sip_flg='Y' THEN 'Y' 
	ELSE 'N' END)::character varying as sip_flg,
   coalesce(c.stp_flg,'N')::character varying as stp_flg,
--'N'::character varying as stp_flg,
	  coalesce(c.swp_flg,'N')::character varying as swp_flg,
	coalesce(c.switch_flg,'N')::character varying as switch_flg,
--	'N'::character varying as switch_flg,
	(CASE WHEN a.inv_plan_status_code = 4 and coalesce(a.remarks,'')='' 
	and e.pause_flg='Y' and f.pause_flag='Y' 
	and coalesce(f.pause_modification_count,0) > COALESCE(a.pausecount,0)
	then 'Y' else 'N' End
	)::character varying as pause_flg,
	(CASE WHEN a.inv_plan_status_code = 2 and coalesce(a.remarks,'')=''  then 'Y' else 'N' End)::character varying as resume_flg,
--	'N'::character varying as pause_flg,
--	'N'::character varying as resume_flg,
'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.inv_plan_status_code= 4 then 'Pause'
when a.inv_plan_status_code =2 then 'Resume'
else 'Duplicate' end)::character varying as primary_cta
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
ON a.isincode=e.isincode
left join (
select exch.isincode,exch.frequency,exch.sipflag,exch.stpflag,exch.swpflag,
exch.switchflag,exch.pause_flag,
exch.pause_modification_count::int as pause_modification_count
from master.dim_mf_exchange_isin exch
where exch.txn_type='XSIP' and exch.isincode=v_isincode and exch.frequency=v_freq
) f
on a.isincode = f.isincode
left join(
select subs.trx_type_code,subs.order_no,subs.reg_no,subs.vendor_trx_id,
subs.orderdate,subs.amount,subs.reg_date,subs.status,subs.remarks,
row_number() over(partition by subs.reg_no order by subs.orderdate) as installment_number
from transactions.mf_subsequent_order subs
where orderedby='Exchange Triggered'
--and reg_no=227821	
)g on a.vendor_trx_id = g.vendor_trx_id
WHERE a.trx_type_code=1 
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;

Elsif (v_cta_tab=2)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  'N'::character varying AS Resend_Consent_request,
  'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
    'N'::character varying AS Place_Order_again,
	(CASE WHEN a.inv_plan_status_code=4 and coalesce(a.remarks,'')='' THEN 'Y' ELSE 'N' END)::character varying AS Cancel,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
    'Y'::character varying as purallowed_flg,
	coalesce(c.redemption_allowed,'N') ::character varying as redeem_allowed_flg,
    (CASE WHEN --a.inv_plan_status_code in (1) and 
	d.sip_flg='Y' THEN 'Y' 
	ELSE 'N' END)::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
	'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.inv_plan_status_code= 4 then 'Cancel'
else 'Duplicate' end)::character varying as primary_cta
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
	left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_type_code=2
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;

Elsif (v_cta_tab=3)
Then 
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,ord.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
  'N'::character varying AS Resend_Consent_request,
  'N'::character varying AS Resend_Payment_link,
    (CASE WHEN a.inv_plan_status_code in (1,7) THEN 'Y' ELSE 'N' END)::character varying AS Duplicate,
    'Y'::character varying AS View_Details,
    'N'::character varying AS View_all_SIPs,
    'N'::character varying AS View_all_STPs,
    'N'::character varying AS View_all_SWPs,
    'N'::character varying AS Place_Order_again,
	(CASE WHEN a.inv_plan_status_code=4 and coalesce(a.remarks,'')='' THEN 'Y' ELSE 'N' END)::character varying AS Cancel,
--	'N'::character varying AS Cancel,
	'N'::character varying AS Modify,
    'Y'::character varying as purallowed_flg,
--	coalesce(c.redemption_allowed,'N') ::character varying as redeem_allowed_flg,
	'N'::character varying AS redeem_allowed_flg,
    (CASE WHEN d.sip_flg='Y' THEN 'Y' 
	ELSE 'N' END)::character varying as sip_flg,
   -- coalesce(c.stp_flg,'N') as stp_flg,
   -- coalesce(c.swp_flg,'N') as swp_flg,
   -- coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
	'N'::character varying AS approve_order,
'N'::character varying AS pay_now,
'N'::character varying AS retry_payment,
'N'::character varying AS invest_again,
'N'::character varying AS my_holdings,
'N'::character varying AS reject,
(case 
when a.inv_plan_status_code= 4 then 'Cancel'
else 'Duplicate' end)::character varying as primary_cta
FROM transactions.mf_order_summary a
Inner Join transactions.mf_order_detail ord
on a.trx_id = ord.trx_id
INNER JOIN master.dim_ucc b ON ord.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
	left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
WHERE a.trx_type_code=3
and a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode;
END IF;

END IF;

IF (v_logintype='CLIENT')
Then

IF(v_cta_tab=0 and v_inv_action_code=1)
THEN
RETURN QUERY
SELECT distinct 
    a.display_trx_id,a.ac_code,a.ucccode,a.isincode,a.trx_type_code,a.trx_type,
	a.trx_final_status_code,a.final_status,
    'N'::character varying AS Resend_Consent_request,
    'N'::character varying AS Resend_Payment_link,
    'N'::character varying AS Duplicate,
	'Y'::character varying AS View_Details,
	'N'::character varying AS View_all_SIPs,
	'N'::character varying AS View_all_STPs,
	'N'::character varying AS View_all_SWPs,
	'N'::character varying AS Place_Order_again,
    'N'::character varying AS Cancel,
--    (CASE WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y' ELSE 'N' END)::character varying AS Modify,
--	'N'::character varying AS Cancel,
	(CASE 
	WHEN a.trx_final_status_code IN (7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS Modify, 
--	'N'::character varying AS Modify,
--  coalesce(d.purallowedflg,'N')::character varying as purallowed_flg,
    'N'::character varying as purallowed_flg,
    coalesce(c.redemption_allowed,'N') as redeem_allowed_flg,
  	coalesce(d.sip_flg,'N')::character varying as sip_flg,
--    'N'::character varying as sip_flg,
--   case when coalesce(c.stp_flg,'N') as stp_flg,
--	(case when a.ac_code='457742110' and c.switch_flg='Y' then 'Y'
--	when c.stp_flg='Y' then 'Y' else 'N' end)::character varying as stp_flg,
--   coalesce(c.swp_flg,'N') as swp_flg,
--   coalesce(c.switch_flg,'N') as switch_flg,
	'N'::character varying as stp_flg,
	'N'::character varying as swp_flg,
	'N'::character varying as switch_flg,
--	(case when a.trx_type_code=1 and a.trx_final_status_code =4 and e.pause_flg='Y' then 'Y' 
--	else 'N' end)::character varying as pause_flg,
	'N'::character varying as pause_flg,
	'N'::character varying as resume_flg,
--	(case when a.trx_type_code=1 and a.inv_plan_status_code=2 then 'Y' 
--	else 'N' end)::character varying as resume_flg
	    (CASE WHEN a.trx_final_status_code = 7 THEN 'Y' ELSE 'N' END)::character varying AS approve_order,
    (CASE WHEN a.trx_final_status_code =3 THEN 'Y' ELSE 'N' END)::character varying AS pay_now,
    (CASE WHEN a.trx_final_status_code =1 THEN 'Y' ELSE 'N' END)::character varying AS retry_payment,
   	(CASE 
        WHEN a.trx_type_code IN (1, 4, 5, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS invest_again,
	(CASE 
        WHEN a.trx_type_code IN (1, 4, 6) AND a.trx_final_status_code = 4 THEN 'Y'
        ELSE 'N'
    END)::character varying AS my_holdings,
	    (
	CASE 
--	WHEN coalesce(f.remarks,'')='' and a.trx_final_status_code =4 and a.trx_type_code = 1 then 'Y'
--	when a.trx_type_code in (2,3) and a.trx_final_status_code =4 THEN 'Y' 
	WHEN a.trx_final_status_code IN (1, 3, 7) THEN 'Y'
	ELSE 'N' END
	)::character varying AS reject,
'Explore_other_funds'::character varying as primary_cta
FROM transactions.mf_order_detail a
INNER JOIN master.dim_ucc b ON a.ucccode = b.ucccode
LEFT JOIN master.dim_mf_ucc_isin_holding_cta c 
ON a.ac_code = c.ac_code AND a.isincode = c.isincode
LEFT JOIN (
    SELECT 
        purchasetransactionmode AS trans_mode, 
        isin, purallowed as purallowedflg , sipflag as sip_flg
    FROM (
        SELECT  
            a.purchasetransactionmode,a.isin,a.purallowed,a.sipflag,
            ROW_NUMBER() OVER (
                PARTITION BY isin 
                ORDER BY 
                    CASE 
                        WHEN a.purchasetransactionmode = 'DP' THEN 1
                        WHEN a.purchasetransactionmode = 'D' THEN 2
                        WHEN a.purchasetransactionmode = 'P' THEN 3
                        ELSE 4 
                    END
            ) AS rnk
        FROM master.stg_dim_mf_schememaster a
        WHERE UPPER(a.settlementtype) NOT IN ('L1', 'L0')
--          AND a.isin IN ('INF174K01KB0', 'INF223J01AY0')
    ) ranked WHERE rnk = 1
) d ON a.isincode=d.isin
and  d.trans_mode=
		(case 
	when b.dp_flag = 'DP' then 'DP'
	when b.dp_flag in ('D','P') then 'DP'
	when b.dp_flag = 'D' then 'D'
	when b.dp_flag = 'P' then 'P'
	else '' end)
left join master.dim_mf_ucc_isin_order_cta e
	 ON a.isincode=e.isincode
left join transactions.mf_order_summary f
 on a.trx_id =f.trx_id
WHERE a.trx_id = v_trx_id
and	a.ac_code = v_ac_code
and a.isincode = v_isincode
and inv_action_code=v_inv_action_code;
END IF;
END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_cta_detail_bkp_14jul2025(varchar, int4, varchar, varchar, int8, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail_bkp_14jul2025(varchar, int4, varchar, varchar, int8, int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail_bkp_14jul2025(varchar, int4, varchar, varchar, int8, int4, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail_bkp_14jul2025(varchar, int4, varchar, varchar, int8, int4, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_detail_bkp_14jul2025(varchar, int4, varchar, varchar, int8, int4, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_cta_product(int8, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_cta_product(v_mf_schcode bigint, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(mf_schcode bigint, purallowed character varying, sipflag character varying, redeem_flg character varying, swpflag character varying, stpflag character varying, switchflag character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
	RETURN QUERY
SELECT 
a.mf_schcode,
MAX(a.purallowed)::character varying as purallowed,
MAX(a.sipflag)::character varying as sipflag,
MAX(a.redeem_flg)::character varying as redeem_flg,
MAX(a.swpflag)::character varying as swpflag,
MAX(a.stpflag)::character varying as stpflag,
MAX(a.switchflag)::character varying as switchflag
FROM (
select 
c.mf_schcode,--a.isincode,
'N'::character varying as purallowed,
'N'::character varying as sipflag,
'N'::character varying as redeem_flg,
'N'::character varying as swpflag,
(case 
when 
REGEXP_REPLACE(reg_in, '[\n\r\t]', '', 'g')::character varying ='Y' and 
REGEXP_REPLACE(reg_out, '[\n\r\t]', '', 'g')::character varying ='Y' 
then 'Y' 
else 'N' end)::character varying as stpflag,
'N'::character varying  as switchflag,
--(COALESCE(c.isincode, '') || ' ' || COALESCE(c.isinname, '') ) AS search_key
(COALESCE(c.isincode, '') || ' ' || COALESCE(d.sch_name, '') ) AS search_key
from master.dim_mf_sip_swp_stp a
inner join master.stg_dim_mf_schememaster b
ON b.isin = a.isincode
INNER JOIN master.dim_mf_isin c
ON a.isincode = c.isincode
INNER JOIN platform_db.mv_mf_details d
ON a.isincode = d.isincode
where UPPER(b.settlementtype) NOT IN ('L1','L0')
AND c.isactive = 1
and a.txn_type='STP'
--and a.isincode in ('INF109KC10X8','INF846K01164')
-----------
union all
-----------
SELECT 
b.mf_schcode,
a.purallowed,
a.sipflag,
a.redallowed AS redeem_flg,
a.swpflag,
a.stpflag,
a.switchflag,
--(COALESCE(b.isincode, '') || ' ' || COALESCE(b.isinname, '') ) AS search_key
(COALESCE(b.isincode, '') || ' ' || COALESCE(d.sch_name, '') ) AS search_key
FROM master.stg_dim_mf_schememaster a
INNER JOIN master.dim_mf_isin b
ON a.isin = b.isincode
INNER JOIN platform_db.mv_mf_details d
ON b.isincode = d.isincode
WHERE UPPER(a.settlementtype) NOT IN ('L1','L0')
AND b.isactive = 1
) a
WHERE a.mf_schcode =v_mf_schcode
and case when coalesce(v_search,'')='' then true else
upper(a.search_key) ~* upper(v_search) end
GROUP BY a.mf_schcode;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_cta_product(int8, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product(int8, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product(int8, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product(int8, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product(int8, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_cta_product_bkp_09may2025(int8, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_cta_product_bkp_09may2025(v_mf_schcode bigint, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(mf_schcode bigint, purallowed character varying, sipflag character varying, redeem_flg character varying, swpflag character varying, stpflag character varying, switchflag character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
	
Return Query
select 
b.mf_schcode,max(a.purallowed)::character varying as purallowed,
max(a.sipflag)::character varying as sipflag,
max(a.redallowed)::character varying as redeem_flg,
max(a.swpflag)::character varying as swpflag,
max(a.stpflag)::character varying as stpflag,
max(a.switchflag)::character varying as switchflag	
from master.stg_dim_mf_schememaster a
inner join master.dim_mf_isin b
on a.isin = b.isincode
where upper(a.settlementtype) not in ('L1','L0')
-- and (a.purallowed='Y' or a.sipflag='Y' )
and b.isactive=1
and b.mf_schcode=v_mf_schcode
group by b.mf_schcode;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_cta_product_bkp_09may2025(int8, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product_bkp_09may2025(int8, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product_bkp_09may2025(int8, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product_bkp_09may2025(int8, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product_bkp_09may2025(int8, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_cta_product_bkp_14jul2025(int8, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_cta_product_bkp_14jul2025(v_mf_schcode bigint, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(mf_schcode bigint, purallowed character varying, sipflag character varying, redeem_flg character varying, swpflag character varying, stpflag character varying, switchflag character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
	RETURN QUERY
SELECT 
a.mf_schcode,
MAX(a.purallowed)::character varying as purallowed,
MAX(a.sipflag)::character varying as sipflag,
MAX(a.redeem_flg)::character varying as redeem_flg,
MAX(a.swpflag)::character varying as swpflag,
MAX(a.stpflag)::character varying as stpflag,
MAX(a.switchflag)::character varying as switchflag
FROM (
select 
c.mf_schcode,--a.isincode,
'N'::character varying as purallowed,
'N'::character varying as sipflag,
'N'::character varying as redeem_flg,
'N'::character varying as swpflag,
(case 
when 
REGEXP_REPLACE(reg_in, '[\n\r\t]', '', 'g')::character varying ='Y' and 
REGEXP_REPLACE(reg_out, '[\n\r\t]', '', 'g')::character varying ='Y' 
then 'Y' 
else 'N' end)::character varying as stpflag,
'N'::character varying  as switchflag,
( COALESCE(c.isincode, '') || ' ' || COALESCE(c.isinname, '') ) AS search_key
from master.dim_mf_sip_swp_stp a
inner join master.stg_dim_mf_schememaster b
ON b.isin = a.isincode
INNER JOIN master.dim_mf_isin c
ON a.isincode = c.isincode
where UPPER(b.settlementtype) NOT IN ('L1','L0')
AND c.isactive = 1
and a.txn_type='STP'
--and a.isincode in ('INF109KC10X8','INF846K01164')
-----------
union all
-----------
SELECT 
b.mf_schcode,
a.purallowed,
a.sipflag,
a.redallowed AS redeem_flg,
a.swpflag,
a.stpflag,
a.switchflag,
( COALESCE(b.isincode, '') || ' ' || COALESCE(b.isinname, '') ) AS search_key
FROM master.stg_dim_mf_schememaster a
INNER JOIN master.dim_mf_isin b
ON a.isin = b.isincode
WHERE UPPER(a.settlementtype) NOT IN ('L1','L0')
AND b.isactive = 1
) a
WHERE a.mf_schcode =v_mf_schcode
and case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
GROUP BY a.mf_schcode;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_cta_product_bkp_14jul2025(int8, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product_bkp_14jul2025(int8, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product_bkp_14jul2025(int8, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product_bkp_14jul2025(int8, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_cta_product_bkp_14jul2025(int8, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_dionpending_details();

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_dionpending_details()
 RETURNS TABLE(trx_id bigint, ac_code character varying, isincode character varying, trx_type character varying, trx_amt numeric, trx_qty numeric, order_nav numeric, order_navdate date, delivery_mode character varying, mandate_id character varying, trx_status character varying, created_date timestamp without time zone, mf_schcode bigint, display_trx_id character varying, ac_name character varying, client_mobileno character varying, client_emailid character varying, advisor_code character varying, advisor_name character varying, advisor_mobile character varying, advisor_email character varying, helpdesk_number text, helpdesk_email text, transaction_type character varying, return_type character varying, divfrq character varying, vendor_req character varying, order_type character varying, consent_expire_date timestamp without time zone, isinname character varying, settlement_type character varying, inv_action_code integer, payment_trxid character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN QUERY
	SELECT DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,a.trx_qty, 
	a.order_nav,a.order_navdate,a.delivery_mode,a.mandate_id,a.trx_status,
	a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
	b.mobileno as client_mobileno,b.email as client_emailid,
	b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
	coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
	'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
	f.trx_type as transaction_type, 
	a.return_type,e.divfrq, a.vendor_req, a.order_type,con.consent_expire_date
	,INITCAP(a.isinname)::character varying as isinname
	,isin.settltement_type as settlement_type,a.inv_action_code,
	a.payment_trxid
	FROM transactions.mf_order_detail a
	INNER JOIN master.dim_ucc b on a.ucccode=b.ucccode
	LEFT JOIN platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
	INNER JOIN master.trx_type f on a.trx_type_code = f.trx_type_code AND f.category_code=261
	LEFT JOIN transactions.order_consent con ON a.trx_id = con.trx_id AND a.inv_action_code = con.inv_action_code
	LEFT JOIN master.dim_mf_isin isin on a.isincode = isin.isincode
	WHERE case when a.order_placed_by='CLIENT' and a.physicalflag='D' then true 
	else a.consent_status_code = 2 end
	AND a.trx_status_code not in (8,3) AND a.vendor_trx_id IS NULL
--	AND CASE WHEN (a.trx_type_code = 4 OR (a.trx_type_code = 1 AND is_generatetoday = TRUE)) 
--	and a.payment_method<>'eCollect'
--	THEN a.payment_status_code = 2 ELSE TRUE END
	AND CASE 
		WHEN a.trx_type_code = 4 and coalesce(a.payment_method,'')<>'eCollect' then a.payment_status_code = 2
		when a.trx_type_code = 1 AND a.is_generatetoday = true
		and coalesce(a.payment_method,'')<>'eCollect' then a.payment_status_code = 2
	ELSE TRUE END
--	and a.payment_trxid is not null
	AND a.vendor_res IS NULL;
--	and a.trx_id= 451750
	
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred: %', SQLERRM;
        RETURN;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_dionpending_details() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_dionpending_details() TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_dionpending_details() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_dionpending_details() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_dionpending_details() TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_dionpending_details_bkp_11sept2025();

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_dionpending_details_bkp_11sept2025()
 RETURNS TABLE(trx_id bigint, ac_code character varying, isincode character varying, trx_type character varying, trx_amt numeric, trx_qty numeric, order_nav numeric, order_navdate date, delivery_mode character varying, mandate_id character varying, trx_status character varying, created_date timestamp without time zone, mf_schcode bigint, display_trx_id character varying, ac_name character varying, client_mobileno character varying, client_emailid character varying, advisor_code character varying, advisor_name character varying, advisor_mobile character varying, advisor_email character varying, helpdesk_number text, helpdesk_email text, transaction_type character varying, return_type character varying, divfrq character varying, vendor_req character varying, order_type character varying, consent_expire_date timestamp without time zone, isinname character varying, settlement_type character varying, inv_action_code integer, payment_trxid character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN QUERY
	SELECT DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,a.trx_qty, 
	a.order_nav,a.order_navdate,a.delivery_mode,a.mandate_id,a.trx_status,
	a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
	b.mobileno as client_mobileno,b.email as client_emailid,
	b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
	coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
	'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
	f.trx_type as transaction_type, 
	a.return_type,e.divfrq, a.vendor_req, a.order_type,con.consent_expire_date
	,INITCAP(a.isinname)::character varying as isinname
	,isin.settltement_type as settlement_type,a.inv_action_code,
	a.payment_trxid
	FROM transactions.mf_order_detail a
	INNER JOIN master.dim_ucc b on a.ucccode=b.ucccode
	LEFT JOIN platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
	INNER JOIN master.trx_type f on a.trx_type_code = f.trx_type_code AND f.category_code=261
	LEFT JOIN transactions.order_consent con ON a.trx_id = con.trx_id AND a.inv_action_code = con.inv_action_code
	LEFT JOIN master.dim_mf_isin isin on a.isincode = isin.isincode
	WHERE a.consent_status_code = 2 AND a.trx_status_code <> 8 AND a.vendor_trx_id IS NULL
	AND CASE WHEN a.trx_type_code = 4 OR (a.trx_type_code = 1 AND is_generatetoday = TRUE) THEN a.payment_status_code = 2 ELSE TRUE END
	AND a.vendor_res IS NULL;
	

EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred: %', SQLERRM;
        RETURN;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_dionpending_details_bkp_11sept2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_dionpending_details_bkp_11sept2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_dionpending_details_bkp_11sept2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_dionpending_details_bkp_11sept2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_dionpending_details_bkp_11sept2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_foliodetail(varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_foliodetail(v_ac_code character varying, v_isincode character varying, v_folio character varying DEFAULT NULL::character varying)
 RETURNS TABLE(ac_code character varying, isincode character varying, folio_number character varying, foliotype character varying, is_ap_allowed character varying, folioemail character varying, foliomobile character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
BEGIN

RETURN QUERY
select b.ac_code,b.isincode,b.folio_number,b.foliotype, 
	CASE
            WHEN c.is_ap_allowed::text = 'N'::text THEN 'N'::text
            ELSE 'Y'::text
        END::character varying AS is_ap_allowed,
	b.folioemail,
b.foliomobile
	from (
select a.ac_code,a.isincode,a.folio_number:: Character varying,
a.foliotype,a.rnk, a.folioemail,a.foliomobile
from (
Select
ucc.priority_ac_code as ac_code,
a.isincode,a.folio_number,a.foliotype,
row_number() over(partition by ucc.priority_ac_code,a.isincode,a.foliotype,a.folio_number order by a.folio_number) as rnk,
a.folioemail,
a.foliomobile
from(
select distinct a.accountcode as ac_code,a.isin as isincode,
--replace(a.folionumber,'/','') as folio_number,
split_part(a.folionumber, '/', 1)::character varying AS folio_number,
a.foliotype,
b.ucccode,
a.folioemail,
--a.foliomobile
replace(a.foliomobile,'+91','')::character varying as foliomobile
from transactions.mf_holding a
left join master.dim_customer b
on a.accountcode=b.client_code
--where a.folionumber not in ('910180379146')
	)a
inner join master.dim_ucc ucc
on a.ucccode = ucc.ucccode
where ucc.priority_ac_code=v_ac_code
and a.isincode=v_isincode
)a
)B
LEFT JOIN master.dim_mf_check_ap_allowed c ON b.folio_number::text = c.foliono::text
where b.rnk=1
and case when coalesce(v_folio,'')='' then true else
b.folio_number ~* v_folio end ;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_foliodetail(varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_foliodetail(varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_foliodetail(varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_foliodetail(varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_foliodetail(varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_foliodetail_bkp_09may2025(varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_foliodetail_bkp_09may2025(v_ac_code character varying, v_isincode character varying)
 RETURNS TABLE(ac_code character varying, isincode character varying, folio_number character varying, foliotype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
BEGIN

RETURN QUERY
select a.ac_code,a.isincode,a.folio_number:: Character varying,
a.foliotype from (
Select
ucc.priority_ac_code as ac_code,
a.isincode,a.folio_number,a.foliotype,
row_number() over(partition by ucc.priority_ac_code,a.isincode,a.foliotype order by a.folio_number) as rnk		
from(
select a.accountcode as ac_code,a.isin as isincode,
replace(a.folionumber,'/','') as folio_number,
a.foliotype,
b.ucccode
from transactions.mf_holding a
left join master.dim_customer b
on a.accountcode=b.ac_code
--where accountcode='EB000456'
	)a
inner join master.dim_ucc ucc
on a.ucccode = ucc.ucccode
where ucc.priority_ac_code=v_ac_code
and a.isincode=v_isincode
)a
where rnk=1;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_foliodetail_bkp_09may2025(varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_foliodetail_bkp_09may2025(varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_foliodetail_bkp_09may2025(varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_foliodetail_bkp_09may2025(varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_foliodetail_bkp_09may2025(varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_int_ext_holdings(varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_int_ext_holdings(p_ucccode character varying)
 RETURNS TABLE(ac_code character varying, ucccode character varying, ac_name character varying, pan character varying, client_tier character varying, current_val_int numeric, folio_int integer, current_val_ext numeric, folio_ext integer, mf_provider integer, last_sync_date character varying, last_sync_source character varying, sch_count integer, is_transferin boolean, sync_id integer)
 LANGUAGE plpgsql
AS $function$
begin
	
	return query
	with tmp_pan
	as
	(
		select du.priority_ac_code as ac_code , 
			du.ucccode as ucccode,
			du.acname as ac_name, 
			du.pan as pan, 
			du.clienttier as client_tier 
			from master.dim_ucc du where du.ucccode = p_ucccode
	),
	tmp_hol_int
	as
	(
	select dc.ucccode ,sum(h.marketvalue) as current_val_int , 
						count(distinct mh.folionumber) as folio_int , 
						count(h.isin) as sch_count_int
	from platform_reporting.holdingsummary h join tmp_pan dc on h.accountcode = dc.ac_code 
			left join transactions.mf_holding mh on mh.investorpan = dc.pan and mh.isin = h.isin 
	where h.edelweissproductshortcode = 'MF'
	group by dc.ucccode
	),
	tmp_sync_history
	as
	(
		select syn.id as sync_id , syn.ucccode , syn.sync_end_datetime as last_sync_date, 
			syn.initiated_by as emp_code , 
			syn.status , syn."source" ,
			row_number()over(partition by syn.ucccode order by syn.id desc) as id  
		from transactions.mf_sync_history syn 
		where syn.status  = 'Completed'
		and syn.ucccode = p_ucccode
		
	),
	tmp_syn_data
	as
	(
		select a.sync_id , a.ucccode , a.last_sync_date , a.emp_code ,  a.status , a.source
		from tmp_sync_history a
		where a.id = 1
	),
	tmp_holding_ext
	as
	(
	select b.sync_id , 
			b.ucccode , 
			cast (sum(ext.avlunits * nav.nav) as numeric(18,2)) as current_val_ext, 
			count(distinct case when ext.avlunits > 0 then ext.folio else  null end) as folio_ext, 
			count(distinct case when ext.avlunits > 0 then ext.isin else  null end) as sch_count_ext,
			count(distinct case when ext.avlunits > 0 then ext.amcname else  null end) as mf_provider
	from tmp_syn_data b left join transactions.mf_client_holdings_external ext
		on b.sync_id = ext.sync_history_id
	--join master.dim_mf_isin dmi on ext.isin = dmi.isincode 
	join platform_db.mv_mf_details nav on ext.isin  = nav.isincode 	
	where ext.isexternal  = true
	group by b.sync_id , b.ucccode
	)
	select a.ac_code , 
			a.ucccode , 
			a.ac_name , 
			a.pan , 
			a.client_tier , 
			coalesce (holint.current_val_int,0) as current_val_int , 
			cast (coalesce (holint.folio_int,0) as int )as folio_int, 
			coalesce (holext.current_val_ext,0) as current_val_ext , 
			cast (coalesce (holext.folio_ext,0) as int ) as folio_ext,
			cast (coalesce (holext.mf_provider,0) as int ) as mf_provider,
			cast (TO_CHAR(syn.last_sync_date, 'FMMonth YYYY') as varchar) as last_sync_date ,
			syn.source as last_sync_source,
			cast ( (coalesce (holint.sch_count_int,0) + coalesce (holext.sch_count_ext,0)) as int ) as sch_count ,
			case when syn.status  = 'Completed' then true else false end as is_transferin,
			holext.sync_id 
	from tmp_pan a left join tmp_hol_int holint on a.ucccode = holint.ucccode 
			left join tmp_holding_ext holext on a.ucccode = holext.ucccode
			left join tmp_syn_data syn on syn.sync_id = holext.sync_id; 
	
end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_int_ext_holdings(varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_int_ext_holdings(varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_int_ext_holdings(varchar) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_mf_mandate_details(varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_mandate_details(v_logintype character varying, v_logincode character varying, v_ac_code character varying DEFAULT NULL::character varying, v_mandateid character varying DEFAULT NULL::character varying)
 RETURNS TABLE(mandateid character varying, ac_code character varying, client_name character varying, amount numeric, bankname character varying, mandate_type character varying, status character varying, bank_ac_number character varying, ifsc_code character varying, start_date date, end_date date, trx_source character varying, ucccode character varying, created_date timestamp without time zone, modified_date timestamp without time zone, remarks character varying, pan character varying, clienttier character varying, acctype character varying, kacctype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_logintype_new character varying;

BEGIN

/*	
-------------Create temp table
CREATE TEMP TABLE IF NOT EXISTS temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

INSERT INTO temp_mf_ucc(ucccode)
SELECT DISTINCT a.ucccode
FROM master.dim_ucc a
WHERE
	CASE
	WHEN upper(v_logintype) = 'CLIENT' THEN a.priority_ac_code = v_logincode
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') <> '' THEN a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') = '' THEN a.client_owner = v_logincode
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.partner_code = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.partner_code = v_logincode
	ELSE FALSE
END;
-----------------------------------------------------
*/

-----------------------------------------------------------------------
-- Determine effective login type
IF v_logintype = 'CLIENT' OR v_logintype = 'PARTNER' THEN
	v_logintype_new := v_logintype;

ELSIF v_logintype = 'RM' THEN
	IF EXISTS (
		SELECT 1 FROM master.map_emp_user_role a
		WHERE a.role_code = 467 
		  AND a.emp_id = (
			  SELECT b.emp_id FROM master.dim_employee b 
			  WHERE b.emp_code = v_logincode LIMIT 1
		  )
	) THEN
		v_logintype_new := 'ADMIN';

/*	ELSIF EXISTS (
		SELECT 1 FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'CXO' 
		  AND a.orderby = v_logincode LIMIT 1
	) THEN
		v_logintype_new := 'CXO';
*/

	ELSIF EXISTS (
		SELECT 1
		FROM master.DIM_ED_EMPL_Manager_Matrix 
		WHERE ltrim(managercode, '0') = v_logincode
		GROUP BY managercode
		HAVING COUNT(1) > 2
	) THEN
		v_logintype_new := 'Hrchy';

	ELSE
		v_logintype_new := 'RM';
	END IF;

ELSE
	RAISE NOTICE 'Invalid logintype for login_code: %', v_logincode;
END IF;

RAISE NOTICE 'Resolved login type: %', v_logintype_new;

-----------------------------------------------------------------------
-- Create and populate temp tables based on login type

IF v_logintype_new = 'CLIENT' OR v_logintype_new = 'PARTNER' 
THEN

DROP TABLE IF EXISTS temp_mf_ucc CASCADE;

CREATE TEMP TABLE temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

INSERT INTO temp_mf_ucc(ucccode)
SELECT DISTINCT a.ucccode
FROM master.dim_ucc a
WHERE CASE
	WHEN upper(v_logintype_new) = 'CLIENT' THEN a.priority_ac_code = v_logincode
	WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.partner_code = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.partner_code = v_logincode
	ELSE FALSE
END;

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'ADMIN' 
THEN

DROP TABLE IF EXISTS temp_mf_ucc CASCADE;

CREATE TEMP TABLE temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

INSERT INTO temp_mf_ucc(ucccode)
select distinct a.ucccode 
from (
select distinct a.ucccode from transactions.stg_mf_mandate a
union
select distinct a.ucccode from transactions.mf_mandate a
union
select distinct a.ucccode from transactions.mf_mandate_optimum a
)a;

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'Hrchy' 
THEN

DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
CREATE TEMP TABLE temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a
WHERE (
	coalesce(v_ac_code, '') <> '' AND
	a.client_owner IN (
		SELECT empcode
		FROM master.DIM_ED_EMPL_Manager_Matrix
		WHERE ltrim(managercode, '0') = v_logincode
	) AND a.priority_ac_code = v_ac_code
)
OR (
	coalesce(v_ac_code, '') = '' AND
	a.client_owner IN (
		SELECT empcode
		FROM master.DIM_ED_EMPL_Manager_Matrix
		WHERE ltrim(managercode, '0') = v_logincode
	)
);

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'RM' THEN

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM master.dim_ucc a
	WHERE (
		coalesce(v_ac_code, '') <> '' AND
		a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	)
	OR (
		coalesce(v_ac_code, '') = '' AND
		a.client_owner = v_logincode
	);

END IF;

-----------------------------------------------------------------------
-- Create indexes on temp table for performance
CREATE INDEX idx_temp_ucccode ON temp_mf_ucc (ucccode);

-----------------------------------------------------------------------
RAISE NOTICE 'temp_mf_ucc populated';
-----------------------------------------------------------------------

---- Get new mandate created list
DROP TABLE IF EXISTS temp_mf_new_mandate CASCADE;

CREATE TEMP TABLE temp_mf_new_mandate AS 
--CREATE TEMP TABLE IF NOT EXISTS temp_mf_new_mandate AS
select a.* from transactions.stg_mf_mandate a
left join transactions.mf_mandate b
on a.mandateid = b.mandateid
where a.ucccode in (select a.ucccode from temp_mf_ucc a)
and b.mandateid is null;

-----------------------------------------------------------------------
-- Create indexes on temp table for performance
CREATE INDEX idx_mandate_ucccode ON temp_mf_new_mandate (ucccode);

RAISE NOTICE 'temp_mf_new_mandate populated';
-----------------------------------------------------------------------

Return Query
select a.mandateid,a.ac_code,INITCAP(a.acname)::character varying as client_name,a.amount,
--a.bankname,
INITCAP(a.bankname)::character varying as bankname,
--a.mandate_type,
coalesce(d.internal_type,a.mandate_type) as mandate_type,
--coalesce(c.nuvama_status,a.status) as status,
(case when coalesce(c.nuvama_status,a.status) ='Active' and a.end_date::date<now()::date
then 'Inactive' else coalesce(c.nuvama_status,a.status) end)::character varying as status,	
a.bank_ac_number,a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,
--a.remarks,
(case when upper(a.remarks) in  ('ASSIGNED TO ICI','ASSIGNED TO RCB') then 'Your mandate is awaiting processing and verification from your bank'
else a.remarks end)::character varying as remarks,
e.pan,coalesce(e.clienttier,'Blue') as clienttier,
f.acctype,
(case 
when Upper(substr(e.pan, 4, 1))='H' then 'huf'
when Upper(substr(e.pan, 4, 1))='P' then 'individual'
when e.is_individual=true 
and extract(year from age(NOW(), e.birthdate))::numeric::int<18
then 'minor'
when e.is_individual=true then 'individual'
when e.is_individual=false then 'non-individual' end)::character varying as kacctype
from 
(
select a.mandateid,a.ac_code,acname,a.amount,
a.bankname,a.mandate_type,a.status,a.bank_ac_number,
a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,a.remarks
from transactions.mf_mandate a 
where a.ucccode in (select a.ucccode from temp_mf_ucc a)
union all
select a.mandateid,a.ac_code,acname,a.amount,
a.bankname,a.mandate_type,a.status,a.bank_ac_number,
a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,a.remarks
from temp_mf_new_mandate a
/*
union all
select a.mandateid,a.ac_code,acname,a.amount,
a.bankname,a.mandate_type,a.status,a.bank_ac_number,
a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,a.remarks
from transactions.mf_mandate_optimum a	
*/
)a	
--transactions.mf_mandate a 
inner join temp_mf_ucc b on a.ucccode=b.ucccode
left join master.mandate_status c
on upper(a.mandate_type)=upper(c.mandate_type)
and upper(a.status) = upper(c.dion_status)
left join master.mandate_type d
on a.mandate_type=d.mandate_type
inner join master.dim_ucc e
on b.ucccode=e.ucccode
left join (
select distinct a.bankaccno,a.acctype 
from master.map_ucc_bank a
)f
on a.bank_ac_number = f.bankaccno
where case when coalesce(v_mandateid,'')='' then true else
A.mandateid ~* v_mandateid end
order by a.created_date desc;

-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
DROP TABLE temp_mf_new_mandate;
-------------------------------------------------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_mandate_details(varchar, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details(varchar, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details(varchar, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details(varchar, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details(varchar, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_mandate_details_bkp_03nov2025(varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_mandate_details_bkp_03nov2025(v_logintype character varying, v_logincode character varying, v_ac_code character varying DEFAULT NULL::character varying, v_mandateid character varying DEFAULT NULL::character varying)
 RETURNS TABLE(mandateid character varying, ac_code character varying, client_name character varying, amount numeric, bankname character varying, mandate_type character varying, status character varying, bank_ac_number character varying, ifsc_code character varying, start_date date, end_date date, trx_source character varying, ucccode character varying, created_date timestamp without time zone, modified_date timestamp without time zone, remarks character varying, pan character varying, clienttier character varying, acctype character varying, kacctype character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
-------------Create temp table
CREATE TEMP TABLE IF NOT EXISTS temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

INSERT INTO temp_mf_ucc(ucccode)
SELECT DISTINCT a.ucccode
FROM master.dim_ucc a
WHERE
	CASE
	WHEN upper(v_logintype) = 'CLIENT' THEN a.priority_ac_code = v_logincode
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') <> '' THEN a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') = '' THEN a.client_owner = v_logincode
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.upccode = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.upccode = v_logincode
	ELSE FALSE
END;
-----------------------------------------------------

---- Get new mandate created list

CREATE TEMP TABLE IF NOT EXISTS temp_mf_new_mandate AS
select a.* from transactions.stg_mf_mandate a
left join transactions.mf_mandate b
on a.mandateid = b.mandateid
where a.ucccode in (select a.ucccode from temp_mf_ucc a)
and b.mandateid is null;

-----------------------------------------------------

Return Query
select a.mandateid,a.ac_code,INITCAP(a.acname)::character varying as client_name,a.amount,
--a.bankname,
INITCAP(a.bankname)::character varying as bankname,
--a.mandate_type,
coalesce(d.internal_type,a.mandate_type) as mandate_type,
coalesce(c.nuvama_status,a.status) as status,a.bank_ac_number,
a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,
--a.remarks,
(case when upper(a.remarks) in  ('ASSIGNED TO ICI','ASSIGNED TO RCB') then 'Your mandate is awaiting processing and verification from your bank'
else a.remarks end)::character varying as remarks,
e.pan,coalesce(e.clienttier,'Blue') as clienttier,
f.acctype,
(case 
when Upper(substr(e.pan, 4, 1))='H' then 'huf'
when Upper(substr(e.pan, 4, 1))='P' then 'individual'
when e.is_individual=true 
and extract(year from age(NOW(), e.birthdate))::numeric::int<18
then 'minor'
when e.is_individual=true then 'individual'
when e.is_individual=false then 'non-individual' end)::character varying as kacctype
from 
(
select a.mandateid,a.ac_code,acname,a.amount,
a.bankname,a.mandate_type,a.status,a.bank_ac_number,
a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,a.remarks
from transactions.mf_mandate a 
union all
select a.mandateid,a.ac_code,acname,a.amount,
a.bankname,a.mandate_type,a.status,a.bank_ac_number,
a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,a.remarks
from temp_mf_new_mandate a
)a	
--transactions.mf_mandate a 
inner join temp_mf_ucc b on a.ucccode=b.ucccode
left join master.mandate_status c
on upper(a.mandate_type)=upper(c.mandate_type)
and upper(a.status) = upper(c.dion_status)
left join master.mandate_type d
on a.mandate_type=d.mandate_type
inner join master.dim_ucc e
on b.ucccode=e.ucccode
left join (
select distinct a.bankaccno,a.acctype 
from master.map_ucc_bank a
)f
on a.bank_ac_number = f.bankaccno
where case when coalesce(v_mandateid,'')='' then true else
A.mandateid ~* v_mandateid end
order by a.created_date desc;

-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
-------------------------------------------------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_mandate_details_bkp_03nov2025(varchar, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details_bkp_03nov2025(varchar, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details_bkp_03nov2025(varchar, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details_bkp_03nov2025(varchar, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details_bkp_03nov2025(varchar, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_mandate_details_bkp_14jul2025(varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_mandate_details_bkp_14jul2025(v_logintype character varying, v_logincode character varying, v_ac_code character varying DEFAULT NULL::character varying, v_mandateid character varying DEFAULT NULL::character varying)
 RETURNS TABLE(mandateid character varying, ac_code character varying, client_name character varying, amount numeric, bankname character varying, mandate_type character varying, status character varying, bank_ac_number character varying, ifsc_code character varying, start_date date, end_date date, trx_source character varying, ucccode character varying, created_date timestamp without time zone, modified_date timestamp without time zone, remarks character varying, pan character varying, clienttier character varying, acctype character varying, kacctype character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
-------------Create temp table
CREATE TEMP TABLE IF NOT EXISTS temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

INSERT INTO temp_mf_ucc(ucccode)
SELECT DISTINCT a.ucccode
FROM master.dim_ucc a
WHERE
	CASE
	WHEN upper(v_logintype) = 'CLIENT' THEN a.priority_ac_code = v_logincode
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') <> '' THEN a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') = '' THEN a.client_owner = v_logincode
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.partner_code = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.partner_code = v_logincode
	ELSE FALSE
END;
-----------------------------------------------------

---- Get new mandate created list

CREATE TEMP TABLE IF NOT EXISTS temp_mf_new_mandate AS
select a.* from transactions.stg_mf_mandate a
left join transactions.mf_mandate b
on a.mandateid = b.mandateid
where a.ucccode in (select a.ucccode from temp_mf_ucc a)
and b.mandateid is null;

-----------------------------------------------------

Return Query
select a.mandateid,a.ac_code,INITCAP(a.acname)::character varying as client_name,a.amount,
--a.bankname,
INITCAP(a.bankname)::character varying as bankname,
--a.mandate_type,
coalesce(d.internal_type,a.mandate_type) as mandate_type,
coalesce(c.nuvama_status,a.status) as status,a.bank_ac_number,
a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,
--a.remarks,
(case when upper(a.remarks) in  ('ASSIGNED TO ICI','ASSIGNED TO RCB') then 'Your mandate is awaiting processing and verification from your bank'
else a.remarks end)::character varying as remarks,
e.pan,coalesce(e.clienttier,'Blue') as clienttier,
f.acctype,
(case 
when Upper(substr(e.pan, 4, 1))='H' then 'huf'
when Upper(substr(e.pan, 4, 1))='P' then 'individual'
when e.is_individual=true 
and extract(year from age(NOW(), e.birthdate))::numeric::int<18
then 'minor'
when e.is_individual=true then 'individual'
when e.is_individual=false then 'non-individual' end)::character varying as kacctype
from 
(
select a.mandateid,a.ac_code,acname,a.amount,
a.bankname,a.mandate_type,a.status,a.bank_ac_number,
a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,a.remarks
from transactions.mf_mandate a 
union all
select a.mandateid,a.ac_code,acname,a.amount,
a.bankname,a.mandate_type,a.status,a.bank_ac_number,
a.ifsc_code,a.start_date,a.end_date,a.trx_source,a.ucccode,
a.created_date,a.modified_date,a.remarks
from temp_mf_new_mandate a
)a	
--transactions.mf_mandate a 
inner join temp_mf_ucc b on a.ucccode=b.ucccode
left join master.mandate_status c
on upper(a.mandate_type)=upper(c.mandate_type)
and upper(a.status) = upper(c.dion_status)
left join master.mandate_type d
on a.mandate_type=d.mandate_type
inner join master.dim_ucc e
on b.ucccode=e.ucccode
left join (
select distinct a.bankaccno,a.acctype 
from master.map_ucc_bank a
)f
on a.bank_ac_number = f.bankaccno
where case when coalesce(v_mandateid,'')='' then true else
A.mandateid ~* v_mandateid end
order by a.created_date desc;

-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
-------------------------------------------------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_mandate_details_bkp_14jul2025(varchar, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details_bkp_14jul2025(varchar, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details_bkp_14jul2025(varchar, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details_bkp_14jul2025(varchar, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_details_bkp_14jul2025(varchar, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_mandate_linked_sips(varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_mandate_linked_sips(v_mandate_id character varying)
 RETURNS TABLE(vendor_trx_id bigint, mandate_id character varying, ac_code character varying, isincode character varying, trx_datetime timestamp without time zone, trx_status character varying, trx_amt numeric, mf_schcode bigint, final_status character varying, display_trx_id character varying, isinname character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN QUERY
select
a.vendor_trx_id,a.mandate_id,a.ac_code,a.isincode,
b.start_date::timestamp without time zone as trx_datetime,
a.trx_status,a.trx_amt,a.mf_schcode,a.final_status,a.display_trx_id,
INITCAP(a.isinname)::character varying isinname
from transactions.mf_order_detail a
inner join transactions.mf_order_summary b
on a.trx_id=b.trx_id
where (upper(a.trx_status) not like '%CANCELLED%'
or upper(a.trx_status) not like '%REJECTED%')
and a.inv_plan_status_code=4
and b.trx_type_code=1
and a.mandate_id=v_mandate_id--'619021'
order by a.trx_datetime;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_mandate_linked_sips(varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_linked_sips(varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_linked_sips(varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_linked_sips(varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_linked_sips(varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_mandate_timeline(varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_mandate_timeline(v_logintype character varying, v_ac_code character varying, v_mandateid character varying)
 RETURNS TABLE(ucccode character varying, ac_code character varying, mandateid character varying, mandatetype character varying, mandate_status character varying, remarks character varying, process_date character varying, displayid integer)
 LANGUAGE plpgsql
AS $function$
DECLARE 
    v_exists character varying; v_mandatetype character varying;
BEGIN
    -- Step 1: Create Temporary Table for Data Processing
    CREATE TEMP TABLE IF NOT EXISTS temp_mandate_timeline AS 
    SELECT 
        a.ucccode,
        a.ac_code,
        a.mandateid,
        c.internal_type AS mandatetype,
        b.nuvama_status AS mandate_status,
        a.status AS remarks,
        COALESCE(a.modified_date, a.created_date)::character varying AS process_date,
		a.hist_id
    FROM transactions.mf_mandate_history a
    LEFT JOIN master.mandate_status b
        ON UPPER(a.status) = UPPER(b.dion_status)
        AND a.mandate_type = b.mandate_type
    INNER JOIN master.mandate_type c
        ON a.mandate_type = c.mandate_type
    WHERE a.ac_code = v_ac_code
    AND a.mandateid = v_mandateid
    ORDER BY a.hist_id;
    

-- Step 2: Determine the Mandate Type

SELECT 
CASE 
WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.mandatetype ~* 'Digital') THEN 'Digital'
WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.mandatetype ~* 'Physical') THEN 'Physical'
ELSE 'Unknown'
END 
INTO v_mandatetype;

-- Step 3: Create temp_mf_mandate (Outside IF Block to Ensure Existence)
CREATE TEMP TABLE IF NOT EXISTS temp_mf_mandate (
	ucccode character varying, 
	ac_code character varying, 
	mandateid character varying, 
	mandatetype character varying, 
	mandate_status character varying, 
	remarks character varying, 
	process_date character varying, 
	displayid int
);

-- Step 4: Determine the Mandate Status
  IF v_mandatetype = 'Digital'
	  THEN

    SELECT 
        CASE 
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Approved') THEN 'Approved'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Cancelled') THEN 'Cancelled'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Rejected') THEN 'Rejected'
		    WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Under Processing') THEN 'Under Processing'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Registered by Member') THEN 'Registered by Member'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Waiting for client') THEN 'Waiting'
            ELSE 'Unknown'
        END 
    INTO v_exists;

    -- Step 5: Insert Data into temp_mf_mandate Based on Conditions
    IF v_exists = 'Approved' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'under' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Verification Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Cancelled' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration pending' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Cancelled' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'under' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'cancelled'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Rejected' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   

            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'rejected'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Under Processing' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   
			SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Under Processing' 

            UNION ALL
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Verification In Progress' as mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Under Processing'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Registered by Member' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Registered by Member'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Waiting' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Waiting'  
        ) a
        ORDER BY a.displayid;
    END IF;

-----------------------------------------------------
ELSIF v_mandatetype = 'Physical'
	  THEN
SELECT 
CASE 
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Approved') THEN 'Approved'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Cancelled') THEN 'Cancelled'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE (temp_mandate_timeline.remarks ~* 'Reject' 
	or temp_mandate_timeline.remarks ~* 'Return')) THEN 'Rejected'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
	or temp_mandate_timeline.remarks ~* 'received by exchange' 
	or temp_mandate_timeline.remarks ~* 'registered by member')) THEN 'Processing'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE (temp_mandate_timeline.remarks ~* 'scan' 
	or temp_mandate_timeline.remarks ~* 'waiting') ) THEN 'Document not uploaded'
	ELSE 'Unknown'
END 
INTO v_exists;

-- Step 5: Insert Data into temp_mf_mandate Based on Conditions
    IF v_exists = 'Approved' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved'

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Verification Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 

		UNION ALL
		
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Cancelled' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

		UNION ALL
		
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Cancelled' 
        ) a
        ORDER BY a.displayid;
    END IF;

	IF v_exists = 'Rejected' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

		UNION ALL
		
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'Reject' 
			or temp_mandate_timeline.remarks ~* 'Return')
        ) a
        ORDER BY a.displayid;
    END IF;

	IF v_exists = 'Processing' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')
        ) a
        ORDER BY a.displayid;
    END IF;

	IF v_exists = 'Document not uploaded' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document not uploaded' AS mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'scan' 
            UNION ALL
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document not uploaded' AS mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'waiting' 
        ) a
        ORDER BY a.displayid;
    END IF;

----------------------------------------------------------------------------
END IF;
----------------------------------------------------------------------------
-- Step 6: Return the Results

IF EXISTS (
	SELECT * FROM temp_mf_mandate
) THEN

RETURN QUERY
select  
a.ucccode,a.ac_code,a.mandateid,a.mandatetype, 
a.mandate_status,a.remarks,a.process_date,a.displayid	
from (
SELECT 
a.ucccode,a.ac_code,a.mandateid,a.mandatetype, 
a.mandate_status,a.remarks,a.process_date,a.displayid,
row_number()over(partition by a.displayid order by a.process_date) rnk
FROM temp_mf_mandate a
	)a
where a.rnk=1
ORDER BY a.displayid;
-----
ELSE
-----
RETURN QUERY
select 
a.ucccode,a.ac_code,a.mandateid,b.internal_type as mandatetype, 
--'Authentication Pending'::character varying as mandate_status,
(case when a.mandate_type='X' then 'Document not uploaded' 
else 'Authentication Pending' end )::character varying as mandate_status,
a.remarks,a.created_date::character varying as process_date,1::int as displayid
from transactions.stg_mf_mandate a
inner join master.mandate_type b
on a.mandate_type = b.mandate_type
where a.mandateid=v_mandateid
and a.ac_code=v_ac_code;
	
END IF;

-- Step 7: No Need to Drop Temporary Tables (They Auto-Drop at Session End)
------------------------------------------------
drop table temp_mandate_timeline;
drop table temp_mf_mandate;
------------------------------------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_mandate_timeline(varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline(varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline(varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline(varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline(varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_09may2025(varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_09may2025(v_logintype character varying, v_ac_code character varying, v_mandateid character varying)
 RETURNS TABLE(ucccode character varying, ac_code character varying, mandateid character varying, mandatetype character varying, mandate_status character varying, remarks character varying, process_date character varying, displayid integer)
 LANGUAGE plpgsql
AS $function$
DECLARE 
    v_exists character varying; v_mandatetype character varying;
BEGIN
    -- Step 1: Create Temporary Table for Data Processing
    CREATE TEMP TABLE IF NOT EXISTS temp_mandate_timeline AS 
    SELECT 
        a.ucccode,
        a.ac_code,
        a.mandateid,
        c.internal_type AS mandatetype,
        b.nuvama_status AS mandate_status,
        a.status AS remarks,
        COALESCE(a.modified_date, a.created_date)::character varying AS process_date,
		a.hist_id
    FROM transactions.mf_mandate_history a
    LEFT JOIN master.mandate_status b
        ON UPPER(a.status) = UPPER(b.dion_status)
        AND a.mandate_type = b.mandate_type
    INNER JOIN master.mandate_type c
        ON a.mandate_type = c.mandate_type
    WHERE a.ac_code = v_ac_code
    AND a.mandateid = v_mandateid
    ORDER BY a.hist_id;
    

-- Step 2: Determine the Mandate Type

SELECT 
CASE 
WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.mandatetype ~* 'Digital') THEN 'Digital'
WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.mandatetype ~* 'Physical') THEN 'Physical'
ELSE 'Unknown'
END 
INTO v_mandatetype;

-- Step 3: Create temp_mf_mandate (Outside IF Block to Ensure Existence)
CREATE TEMP TABLE IF NOT EXISTS temp_mf_mandate (
	ucccode character varying, 
	ac_code character varying, 
	mandateid character varying, 
	mandatetype character varying, 
	mandate_status character varying, 
	remarks character varying, 
	process_date character varying, 
	displayid int
);

-- Step 4: Determine the Mandate Status
  IF v_mandatetype = 'Digital'
	  THEN

    SELECT 
        CASE 
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Approved') THEN 'Approved'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Cancelled') THEN 'Cancelled'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Rejected') THEN 'Rejected'
		    WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Under Processing') THEN 'Under Processing'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Registered by Member') THEN 'Registered by Member'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Waiting for client') THEN 'Waiting'
            ELSE 'Unknown'
        END 
    INTO v_exists;

    -- Step 5: Insert Data into temp_mf_mandate Based on Conditions
    IF v_exists = 'Approved' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'under' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Verification Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Cancelled' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration pending' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Cancelled' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'under' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'cancelled'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Rejected' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   

            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'rejected'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Under Processing' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   
			SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Under Processing' 

            UNION ALL
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Verification In Progress' as mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Under Processing'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Registered by Member' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Registered by Member'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Waiting' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Waiting'  
        ) a
        ORDER BY a.displayid;
    END IF;

-----------------------------------------------------
ELSIF v_mandatetype = 'Physical'
	  THEN
SELECT 
CASE 
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Approved') THEN 'Approved'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Cancelled') THEN 'Cancelled'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE (temp_mandate_timeline.remarks ~* 'Reject' 
	or temp_mandate_timeline.remarks ~* 'Return')) THEN 'Rejected'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
	or temp_mandate_timeline.remarks ~* 'received by exchange' 
	or temp_mandate_timeline.remarks ~* 'registered by member')) THEN 'Processing'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE (temp_mandate_timeline.remarks ~* 'scan' 
	or temp_mandate_timeline.remarks ~* 'waiting') ) THEN 'Document not uploaded'
	ELSE 'Unknown'
END 
INTO v_exists;

-- Step 5: Insert Data into temp_mf_mandate Based on Conditions
    IF v_exists = 'Approved' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved'

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Verification Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 

		UNION ALL
		
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Cancelled' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

		UNION ALL
		
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Cancelled' 
        ) a
        ORDER BY a.displayid;
    END IF;

	IF v_exists = 'Rejected' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

		UNION ALL
		
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'Reject' 
			or temp_mandate_timeline.remarks ~* 'Return')
        ) a
        ORDER BY a.displayid;
    END IF;

	IF v_exists = 'Processing' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')
        ) a
        ORDER BY a.displayid;
    END IF;

	IF v_exists = 'Document not uploaded' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document not uploaded' AS mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'scan' 
            UNION ALL
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document not uploaded' AS mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'waiting' 
        ) a
        ORDER BY a.displayid;
    END IF;

----------------------------------------------------------------------------
END IF;
----------------------------------------------------------------------------
-- Step 6: Return the Results
RETURN QUERY
SELECT 
a.ucccode,a.ac_code,a.mandateid,a.mandatetype, 
a.mandate_status,a.remarks,a.process_date,a.displayid
FROM temp_mf_mandate a
ORDER BY a.displayid;

-- Step 7: No Need to Drop Temporary Tables (They Auto-Drop at Session End)
------------------------------------------------
drop table temp_mandate_timeline;
drop table temp_mf_mandate;
------------------------------------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_09may2025(varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_09may2025(varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_09may2025(varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_09may2025(varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_09may2025(varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_14jul2025(varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_14jul2025(v_logintype character varying, v_ac_code character varying, v_mandateid character varying)
 RETURNS TABLE(ucccode character varying, ac_code character varying, mandateid character varying, mandatetype character varying, mandate_status character varying, remarks character varying, process_date character varying, displayid integer)
 LANGUAGE plpgsql
AS $function$
DECLARE 
    v_exists character varying; v_mandatetype character varying;
BEGIN
    -- Step 1: Create Temporary Table for Data Processing
    CREATE TEMP TABLE IF NOT EXISTS temp_mandate_timeline AS 
    SELECT 
        a.ucccode,
        a.ac_code,
        a.mandateid,
        c.internal_type AS mandatetype,
        b.nuvama_status AS mandate_status,
        a.status AS remarks,
        COALESCE(a.modified_date, a.created_date)::character varying AS process_date,
		a.hist_id
    FROM transactions.mf_mandate_history a
    LEFT JOIN master.mandate_status b
        ON UPPER(a.status) = UPPER(b.dion_status)
        AND a.mandate_type = b.mandate_type
    INNER JOIN master.mandate_type c
        ON a.mandate_type = c.mandate_type
    WHERE a.ac_code = v_ac_code
    AND a.mandateid = v_mandateid
    ORDER BY a.hist_id;
    

-- Step 2: Determine the Mandate Type

SELECT 
CASE 
WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.mandatetype ~* 'Digital') THEN 'Digital'
WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.mandatetype ~* 'Physical') THEN 'Physical'
ELSE 'Unknown'
END 
INTO v_mandatetype;

-- Step 3: Create temp_mf_mandate (Outside IF Block to Ensure Existence)
CREATE TEMP TABLE IF NOT EXISTS temp_mf_mandate (
	ucccode character varying, 
	ac_code character varying, 
	mandateid character varying, 
	mandatetype character varying, 
	mandate_status character varying, 
	remarks character varying, 
	process_date character varying, 
	displayid int
);

-- Step 4: Determine the Mandate Status
  IF v_mandatetype = 'Digital'
	  THEN

    SELECT 
        CASE 
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Approved') THEN 'Approved'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Cancelled') THEN 'Cancelled'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Rejected') THEN 'Rejected'
		    WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Under Processing') THEN 'Under Processing'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Registered by Member') THEN 'Registered by Member'
            WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Waiting for client') THEN 'Waiting'
            ELSE 'Unknown'
        END 
    INTO v_exists;

    -- Step 5: Insert Data into temp_mf_mandate Based on Conditions
    IF v_exists = 'Approved' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'under' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Verification Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Cancelled' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration pending' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Cancelled' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'under' 

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'cancelled'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Rejected' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   

            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'rejected'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Under Processing' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   
			SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Registration Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Under Processing' 

            UNION ALL
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Verification In Progress' as mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Under Processing'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Registered by Member' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Registered by Member'  
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Waiting' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (   
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Waiting'  
        ) a
        ORDER BY a.displayid;
    END IF;

-----------------------------------------------------
ELSIF v_mandatetype = 'Physical'
	  THEN
SELECT 
CASE 
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Approved') THEN 'Approved'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE temp_mandate_timeline.remarks ~* 'Cancelled') THEN 'Cancelled'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE (temp_mandate_timeline.remarks ~* 'Reject' 
	or temp_mandate_timeline.remarks ~* 'Return')) THEN 'Rejected'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
	or temp_mandate_timeline.remarks ~* 'received by exchange' 
	or temp_mandate_timeline.remarks ~* 'registered by member')) THEN 'Processing'
	WHEN EXISTS (SELECT 1 FROM temp_mandate_timeline WHERE (temp_mandate_timeline.remarks ~* 'scan' 
	or temp_mandate_timeline.remarks ~* 'waiting') ) THEN 'Document not uploaded'
	ELSE 'Unknown'
END 
INTO v_exists;

-- Step 5: Insert Data into temp_mf_mandate Based on Conditions
    IF v_exists = 'Approved' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved'

            UNION ALL
            
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Verification Completed' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 

		UNION ALL
		
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'approved' 
        ) a
        ORDER BY a.displayid;
    END IF;

    IF v_exists = 'Cancelled' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

		UNION ALL
		
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'Cancelled' 
        ) a
        ORDER BY a.displayid;
    END IF;

	IF v_exists = 'Rejected' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

		UNION ALL
		
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                temp_mandate_timeline.mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                3 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'Reject' 
			or temp_mandate_timeline.remarks ~* 'Return')
        ) a
        ORDER BY a.displayid;
    END IF;

	IF v_exists = 'Processing' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document uploaded' AS mandate_status, 
                '' AS remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')

            UNION ALL

		            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Processing' AS mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                2 AS displayid
            FROM temp_mandate_timeline 
            WHERE (temp_mandate_timeline.remarks ~* 'under processing' 
			or temp_mandate_timeline.remarks ~* 'received by exchange' 
			or temp_mandate_timeline.remarks ~* 'registered by member')
        ) a
        ORDER BY a.displayid;
    END IF;

	IF v_exists = 'Document not uploaded' THEN
        INSERT INTO temp_mf_mandate
        SELECT DISTINCT 
            a.ucccode, 
            a.ac_code, 
            a.mandateid, 
            a.mandatetype, 
            a.mandate_status, 
            a.remarks, 
            a.process_date, 
            a.displayid
        FROM (    
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document not uploaded' AS mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'scan' 
            UNION ALL
            SELECT 
                temp_mandate_timeline.ucccode, 
                temp_mandate_timeline.ac_code, 
                temp_mandate_timeline.mandateid, 
                temp_mandate_timeline.mandatetype, 
                'Document not uploaded' AS mandate_status, 
                temp_mandate_timeline.remarks, 
                temp_mandate_timeline.process_date, 
                1 AS displayid
            FROM temp_mandate_timeline 
            WHERE temp_mandate_timeline.remarks ~* 'waiting' 
        ) a
        ORDER BY a.displayid;
    END IF;

----------------------------------------------------------------------------
END IF;
----------------------------------------------------------------------------
-- Step 6: Return the Results

IF EXISTS (
	SELECT * FROM temp_mf_mandate
) THEN

RETURN QUERY
select  
a.ucccode,a.ac_code,a.mandateid,a.mandatetype, 
a.mandate_status,a.remarks,a.process_date,a.displayid	
from (
SELECT 
a.ucccode,a.ac_code,a.mandateid,a.mandatetype, 
a.mandate_status,a.remarks,a.process_date,a.displayid,
row_number()over(partition by a.displayid order by a.process_date) rnk
FROM temp_mf_mandate a
	)a
where a.rnk=1
ORDER BY a.displayid;
-----
ELSE
-----
RETURN QUERY
select 
a.ucccode,a.ac_code,a.mandateid,b.internal_type as mandatetype, 
'Authentication Pending'::character varying as mandate_status,a.remarks,
a.created_date::character varying as process_date,1::int as displayid
from transactions.stg_mf_mandate a
inner join master.mandate_type b
on a.mandate_type = b.mandate_type
where a.mandateid=v_mandateid
and a.ac_code=v_ac_code;
	
END IF;

-- Step 7: No Need to Drop Temporary Tables (They Auto-Drop at Session End)
------------------------------------------------
drop table temp_mandate_timeline;
drop table temp_mf_mandate;
------------------------------------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_14jul2025(varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_14jul2025(varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_14jul2025(varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_14jul2025(varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_mandate_timeline_bkp_14jul2025(varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_detail(varchar, varchar, date, date, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_detail(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_ac_code character varying DEFAULT NULL::character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, ac_code character varying, ac_name character varying, ucccode character varying, isincode character varying, trx_type character varying, trx_datetime timestamp without time zone, trx_amt numeric, delivery_mode character varying, mandate_id character varying, trx_status character varying, payment_trxid character varying, payment_status character varying, switch_isin character varying, nav numeric, navdate date, order_nav numeric, order_navdate date, order_type character varying, order_remarks character varying, vendor_exchg_refno character varying, created_date timestamp without time zone, mf_schcode bigint, switch_mf_schcode bigint, final_status character varying, display_trx_id character varying, totalinstallment_paid integer, mandate_type character varying, bankname character varying, bank_ac_number character varying, next_installment_date date, quantity numeric, frequency character varying, first_installment_date date, start_day character varying, totalinstallmentamtpaid integer, schemegroup character varying, pausecount integer, datasource character varying, lead_id character varying, isinname character varying, is_generatetoday boolean, client_bank_name character varying, client_bank_ac_number character varying, payment_method character varying, reg_no bigint, inv_action_code integer, inv_type_code integer, inv_type character varying, pan character varying, sch_plan character varying, end_date date, grpcode character varying, search_key character varying, clienttier character varying, typeoforder character varying, tokenno bigint, switch_isin_name character varying, installment_number integer, tenure integer, folio_no character varying, user_type character varying, client_owner character varying, client_owner_name character varying, kacctype character varying, dp_flag character varying, direct_plan_enabled_flg character varying, start_date date, sub_broker_code character varying, sub_broker_name character varying, arn_code character varying, sub_broker_pass_pct numeric, krafolio_status character varying, order_placed_by character varying, created_for character varying, created_for_name character varying, krastatus character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_logintype_new character varying;
--Declare v_fromdate DATE:= v_fromdate;
--Declare v_todate   DATE := v_todate ;

BEGIN

IF v_fromdate IS NULL OR v_todate IS NULL THEN
RAISE EXCEPTION 'Invalid date range provided';
END IF;

-----------------------------------------------------------------------
-----------------------------------------------------------------------
    -----------------------------------------------------------------------
    -- Determine effective login type
    IF v_logintype = 'CLIENT' OR v_logintype = 'PARTNER' THEN
        v_logintype_new := v_logintype;

    ELSIF v_logintype = 'RM' THEN
        IF EXISTS (
            SELECT 1 FROM master.map_emp_user_role a
            WHERE a.role_code = 467 
              AND a.emp_id = (
                  SELECT b.emp_id FROM master.dim_employee b 
                  WHERE b.emp_code = v_logincode LIMIT 1
              )
        ) THEN
            v_logintype_new := 'ADMIN';

        ELSIF EXISTS (
            SELECT 1 FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'CXO' 
              AND a.orderby = v_logincode LIMIT 1
        ) THEN
            v_logintype_new := 'CXO';

        ELSIF EXISTS (
            SELECT 1
            FROM master.DIM_ED_EMPL_Manager_Matrix 
            WHERE ltrim(managercode, '0') = v_logincode
            GROUP BY managercode
            HAVING COUNT(1) > 2
        ) THEN
            v_logintype_new := 'Hrchy';

		ELSIF EXISTS (
		SELECT 1 from master.dim_ucc
		where owner_code in (	
		select distinct owner_code from master.partner
		where owner_code = v_logincode
		)
	) THEN
		v_logintype_new := 'FRM';

        ELSE
            v_logintype_new := 'RM';
        END IF;

    ELSE
        RAISE NOTICE 'Invalid logintype for login_code: %', v_logincode;
    END IF;

    RAISE NOTICE 'Resolved login type: %', v_logintype_new;

    -----------------------------------------------------------------------
    -- Create and populate temp tables based on login type
    IF v_logintype_new = 'CLIENT' OR v_logintype_new = 'PARTNER' THEN

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;

        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

        INSERT INTO temp_mf_ucc(ucccode)
        SELECT DISTINCT a.ucccode
        FROM master.dim_ucc a
        WHERE CASE
            WHEN upper(v_logintype_new) = 'CLIENT' THEN a.priority_ac_code = v_logincode
            WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.upccode = v_logincode AND a.priority_ac_code = v_ac_code
            WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.upccode = v_logincode
            ELSE FALSE
        END;

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT a.*
        FROM transactions.mf_order_detail a
        INNER JOIN temp_mf_ucc b ON a.ucccode = b.ucccode
        WHERE a.created_date::date BETWEEN v_fromdate AND v_todate;
 --     AND a.final_status IS NOT NULL;

    -----------------------------------------------------------------------
    ELSIF v_logintype_new = 'ADMIN' THEN
		
		 -- Set default date range for last 15 days
  --      v_fromdate := CURRENT_DATE - INTERVAL '15 days';
  --     v_todate   := CURRENT_DATE;

		RAISE NOTICE 'Resolved ADMIN from date: %', v_fromdate;
		RAISE NOTICE 'Resolved ADMIN to date: %', v_todate;

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT a.*
        FROM transactions.mf_order_detail a
        WHERE a.created_date::date BETWEEN v_fromdate AND v_todate;
     --     AND a.final_status IS NOT NULL;

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM temp_mf_order_detail a;

    -----------------------------------------------------------------------
    ELSIF v_logintype_new = 'CXO' THEN

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT a.*
        FROM transactions.mf_order_detail a
        WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
          AND a.natureoforder = 'CXO'
          AND a.orderby = v_logincode
          AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code);
--          AND a.final_status IS NOT NULL;

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM temp_mf_order_detail a;

    -----------------------------------------------------------------------
    ELSIF v_logintype_new = 'Hrchy' THEN

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM master.dim_ucc a
        WHERE (
            coalesce(v_ac_code, '') <> '' AND
            a.client_owner IN (
                SELECT ltrim(empcode, '0') as empcode
                FROM master.DIM_ED_EMPL_Manager_Matrix
                WHERE ltrim(managercode, '0') = v_logincode
            ) AND a.priority_ac_code = v_ac_code
        )
        OR (
            coalesce(v_ac_code, '') = '' AND
            a.client_owner IN (
                SELECT ltrim(empcode, '0') as empcode
                FROM master.DIM_ED_EMPL_Manager_Matrix
                WHERE ltrim(managercode, '0') = v_logincode
            )
        );

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT DISTINCT a.* FROM (
            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
            --  AND coalesce(a.natureoforder, 'Normal') = 'Normal'
			AND (a.natureoforder = 'Normal' OR a.natureoforder IS NULL)
        --      AND a.final_status IS NOT NULL

            UNION ALL

            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'CXO'
              AND a.created_for IN (
                  SELECT ltrim(empcode, '0') as empcode
                  FROM master.DIM_ED_EMPL_Manager_Matrix
                  WHERE ltrim(managercode, '0') = v_logincode
              )
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
        --      AND a.final_status IS NOT NULL

			 UNION ALL

            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'OpenArch'
              AND a.created_for IN (
                  SELECT ltrim(empcode, '0') as empcode
                  FROM master.DIM_ED_EMPL_Manager_Matrix
                  WHERE ltrim(managercode, '0') = v_logincode
              )
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
        --      AND a.final_status IS NOT NULL
        ) a
        WHERE a.trx_id NOT IN (
            SELECT a.trx_id FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'OpenArch'
              AND a.created_for NOT IN (
                  SELECT empcode
                  FROM master.DIM_ED_EMPL_Manager_Matrix
                  WHERE ltrim(managercode, '0') = v_logincode
              )
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
         --     AND a.final_status IS NOT NULL
        );

	-----------------------------------------------------------------------

	ELSIF v_logintype_new = 'FRM' THEN

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT a.ucccode
	FROM master.dim_ucc a
	WHERE a.owner_code IN (
	        SELECT DISTINCT owner_code
	        FROM master.partner
	        WHERE owner_code = v_logincode
	    );
		/*
	AND (
	        (COALESCE(v_ac_code, '') <> '' 
	            AND a.client_owner = v_logincode 
	            AND a.priority_ac_code = v_ac_code)
	     OR 
	        (COALESCE(v_ac_code, '') = '' 
	            AND a.client_owner = v_logincode)
	    );
*/

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT DISTINCT a.* FROM (
		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
)a;

    -----------------------------------------------------------------------
    ELSIF v_logintype_new = 'RM' THEN

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM master.dim_ucc a
        WHERE (
            coalesce(v_ac_code, '') <> '' AND
            a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
        )
        OR (
            coalesce(v_ac_code, '') = '' AND
            a.client_owner = v_logincode
        );

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT DISTINCT a.* FROM (
            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
           --   AND coalesce(a.natureoforder, 'Normal') = 'Normal'
			AND (a.natureoforder = 'Normal' OR a.natureoforder IS NULL)
         --     AND a.final_status IS NOT NULL

            UNION ALL

            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'CXO'
              AND a.created_for = v_logincode
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
          --    AND a.final_status IS NOT NULL

			UNION ALL

            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'OpenArch'
              AND a.created_for = v_logincode
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
       --       AND a.final_status IS NOT NULL
        ) a
        WHERE a.trx_id NOT IN (
            SELECT a.trx_id FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'OpenArch'
			AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
              AND a.created_for <> v_logincode
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
         --     AND a.final_status IS NOT NULL
        );

    END IF;

-----------------------------------------------------------------------
DROP TABLE IF EXISTS temp_bank_detail CASCADE;
CREATE TEMP TABLE temp_bank_detail AS

SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
	(SELECT bn.ucccode, bn.bankname, bn.bankaccno, 
	ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
	 FROM master.map_ucc_bank bn 
	WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
	) bk WHERE bk.rn = 1;

-----------------------------------------------------------------------
-- Create indexes on temp table for performance
CREATE INDEX idx_temp_created_date ON temp_mf_order_detail (created_date);
CREATE INDEX idx_temp_trx_id ON temp_mf_order_detail (trx_id);
CREATE INDEX idx_temp_ucccode ON temp_bank_detail (ucccode);
-----------------------------------------------------------------------

RAISE NOTICE 'temp_mf_order_detail populated';

-----------------------------------------------------------------------

----------------Final Output

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,a.ucccode,a.isincode,
a.trx_type,a.trx_datetime,a.trx_amt,INITCAP(a.delivery_mode)::character varying as delivery_mode,a.mandate_id,
a.trx_status,a.payment_trxid,a.payment_status,a.switch_isin,
a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
--a.order_remarks,
/*(
case when a.final_status='Consent Pending' then 'The order is awaiting '+INITCAP(a.ac_name)::character varying+' approval.'
when a.final_status='Consent Rejected' then 'This order was rejected by the client '+INITCAP(a.ac_name)::character varying+'.'
else coalesce(b.internal_order_remarks,a.order_remarks) end
):: character varying as order_remarks,
*/
(
  CASE 
WHEN a.vendor_trx_id is null and a.vendor_res is not null then a.order_remarks
    WHEN v_logintype_new not in ('CLIENT') and a.final_status = 'Consent Pending' 
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN v_logintype_new not in ('CLIENT') and a.final_status = 'Consent Rejected' 
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
	WHEN v_logintype_new = 'CLIENT' and a.final_status = 'Consent Pending'  
      THEN 'The order is awaiting your approval.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=1 and a.final_status = 'Order Rejected'
	and a.vendor_trx_id is null
	THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by='CLIENT' and a.inv_action_code=1 and a.final_status = 'Consent Rejected'
      THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by='RM' and a.inv_action_code=1 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the order. Please contact your RM for assistance if needed.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by='PARTNER' and a.inv_action_code=1 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the order. Please contact your Partner for assistance if needed.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=2 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the pause request.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=3 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the modification request.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=4 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the cancellation request.'
	WHEN v_logintype_new = 'CLIENT' and a.vendor_trx_id is not null and a.final_status = 'Order Rejected'
      THEN 'Your order was rejected by the Exchange. You may try again later.'
	WHEN v_logintype_new = 'CLIENT' and a.final_status = 'Payment Failed'
      THEN 'Your payment failed. Please retry to complete the order.'
	WHEN v_logintype_new = 'CLIENT' and a.final_status = 'Payment Pending'
      THEN 'Please complete the payment to proceed with the transaction'
 --   ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
	when trx_type_code=5 and a.order_remarks ~* 'OrderStatus -ALLOTMENT DONE' then 'Redemption completed successfully.'
when trx_type_code=5 and a.order_remarks ~* 'OrderStatus -' then 'Order placed successfully.'
when trx_type_code=5 and a.order_remarks ~* 'AMO Order placed successfully' then 'Order placed outside market hours submitted successfully.'
when trx_type_code=5 and a.order_remarks ~* 'ORD CONF: Your Request for FRESH REDEMPTION' then 'Order received and is being processed.'

when trx_type_code=4 and a.order_remarks ~* 'OrderStatus -ALLOTMENT DONE' then 'Allotment completed successfully.'
when trx_type_code=4 and a.order_remarks ~* 'ORD CONF: Your Request for ADDITIONAL PURCHASE' then 'Order received and is being processed.'
when trx_type_code=4 and a.order_remarks ~* 'ORD CONF: Your Request for FRESH PURCHASE' then 'Purchase request is being processed.'
when trx_type_code=4 and a.order_remarks ~* 'OrderStatus -SENT TO RTA FOR VALIDATION' then 'Order sent for validation.'

when trx_type_code=1 and a.order_remarks ~* 'REGISTRATION ENTRY NOT EXISTS' then 'Request cannot be processed as order details were not found.'
when trx_type_code=1 and a.order_remarks ~* 'Order Lapsed' then 'Order couldnt be processed. Please place a new request.'
when trx_type_code=1 and a.order_remarks ~* 'X-SIP HAS BEEN REGISTERED, REG NO IS' then 'SIP registered successfully.'
when trx_type_code=1 and a.order_remarks ~* 'X-SIP OR I-SIP CAN BE CANCELLED ONLY PRIOR TO 2 WORKING DAYS OF TRIGGER DATE' 
	then 'SIP can be cancelled only up to 2 working days before trigger.'
when trx_type_code=1 and a.order_remarks ~* 'X-SIP OR I-SIP HAS BEEN ALREADY CANCELLED OR NOT EXISTS' 
	then 'SIP already cancelled. No further action needed.'
when trx_type_code=1 and vendor_trx_status='CANCELLED' and a.order_remarks ~* 'X-SIP OR I-SIP WITH REGN NO' 
	then 'SIP cancelled successfully.'

when trx_type_code=2 and a.order_remarks ~* 'STP CANCELLATION INITIATED. KINDLY CONFIRM' 
	then 'STP cancellation initiated. Please confirm.'	
when trx_type_code=2 and a.order_remarks ~* 'FAILED: STP ALREADY CANCELLED' 
	then 'STP is already cancelled.'
	
when trx_type_code=3 and a.order_remarks ~* 'SWP CANCELLATION INITIATED. KINDLY CONFIRM' 
	then 'SWP cancellation initiated. Please confirm.'
when trx_type_code=3 and a.order_remarks ~* 'FAILED: SWP ALREADY CANCELLED' 
	then 'SWP is already cancelled.'
when a.order_remarks ~* b.dion_order_remarks then INITCAP(b.internal_order_remarks)::character varying
else INITCAP(a.order_remarks)::character varying
  END
)::character varying AS order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
a.vendor_exchg_refno,a.created_date,a.mf_schcode,
a.switch_mf_schcode,
--a.final_status,
case when a.final_status is null or a.final_status='' then 'Updating Soon'
else a.final_status end as final_status,
a.display_trx_id,a.noofinstallmentspaid,
a.mandate_type,a.bankname,a.bank_ac_number,a.next_installment_date,a.quantity,
a.frequency,a.first_installment_date,a.start_day,a.totalinstallmentamtpaid,
a.schemegroup,a.pausecount,
--a.datasource,
(case when a.datasource='DION' then 'One Platform'
when a.datasource='optimum' then 'Partner Portal'
else 'One Platform' end):: character varying as datasource,
a.lead_id,a.isinname,a.is_generatetoday,
a.client_bank_name,a.client_bank_ac_number,a.payment_method,a.reg_no,a.inv_action_code,
a.inv_type_code,a.inv_type,a.pan,a.sch_plan,a.end_date,a.grpcode,
a.search_key,a.clienttier,a.typeoforder, a.tokenno, a.switch_isin_name, a.installment_number,
a.tenure,a.folio_no,c.user_type,c.client_owner,c.client_owner_name,c.kacctype,
c.dp_flag,c.direct_plan_enabled_flg,a.start_date
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.krafolio_status,
a.order_placed_by,a.created_for,a.created_for_name,c.krastatus
from (
SELECT 
a.trx_id,a.vendor_trx_id,a.ac_code,b.acname as ac_name,a.ucccode,a.isincode, 
f.trx_type,date_trunc('second',a.trx_datetime) as trx_datetime,a.trx_amt, 
case when a.physicalflag='D' then 'DEMAT'
when a.physicalflag='P' then 'PHYSICAL'
else a.physicalflag end delivery_mode,	
c.mandate_id,a.trx_status,a.payment_trxid,a.payment_status,
a.switch_isin,a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
a.order_remarks, a.vendor_exchg_refno, 
date_trunc('second',a.created_date) as created_date,a.mf_schcode,
a.switch_mf_schcode,a.final_status,a.display_trx_id,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,d.bankname,d.bank_ac_number,
c.upcoming_due_date as next_installment_date,a.trx_qty as quantity,
c.frequency,c.start_date as first_installment_date,
--c.start_day,
(CASE 
    WHEN c.trx_type_code IN (1, 2, 3) AND c.start_day IS NOT NULL 
        THEN LPAD(c.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(c.start_day, '') = '' 
                THEN TO_CHAR(c.start_date, 'DD')
            ELSE LPAD(c.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
c.totalinstallmentamt_paid as totalinstallmentamtpaid,
a.schemegroup,
c.pausecount,a.datasource,a.lead_id,INITCAP(a.isinname)::character varying isinname,a.is_generatetoday
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,a.payment_method,c.reg_no,a.inv_action_code,a.inv_type_code,a.inv_type,b.pan,sch.sch_plan
,c.end_date,isin.schemecode as grpcode--,sch.sch_type
,(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.final_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Main'::character varying as typeoforder, a.tokenno,
(
case when a.trx_type_code in (2,6) then INITCAP(isin_switch.isinname) 
else NULL end
)::character varying as switch_isin_name,
null::int as installment_number,
c.no_of_installment as tenure,
a.folio_no,c.start_date
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,
NULL:: character varying as krafolio_status,a.order_placed_by
,a.trx_type_code,a.vendor_trx_status,a.created_for,a.created_for_name
,a.vendor_res	
from --transactions.mf_order_detail a
temp_mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left join transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
left join temp_bank_detail bnk ON a.ucccode = bnk.ucccode
/*
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
*/
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
left join master.dim_mf_isin isin_switch on a.switch_isin=isin_switch.isincode
WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and a.final_status is not null
------------
union all
------------
select 
g.order_no::bigint as trx_id,
--floor(random() * 1000000 +1)::bigint as trx_id,
a.vendor_trx_id,a.ac_code,
b.acname as ac_name,a.ucccode,a.isincode, 
cast(f.trx_type ||' Installment' as character varying) as trx_type,
date_trunc('second', g.orderdate::timestamp without time zone) as trx_datetime,
case when g.amount ='0.00' and f.trx_type='SWP' then c.trx_amt else g.amount end as trx_amt,
case when a.physicalflag='D' then 'DEMAT'
when a.physicalflag='P' then 'PHYSICAL'
else a.physicalflag end delivery_mode,	
a.mandate_id, 
case when g.status='VALID' then 'Success'
when g.status='INVALID' then 'Failed' else g.status end as trx_status, 
null as payment_trxid,null as payment_status,a.switch_isin, 
null as nav,null as navdate,null as order_nav,null as order_navdate,
null as order_type,g.remarks as order_remarks,a.vendor_exchg_refno, 
date_trunc('second', g.orderdate::timestamp without time zone) created_date,
a.mf_schcode,a.switch_mf_schcode,
case when g.status='VALID' then 'Completed'
when g.status='INVALID' then 'Order Rejected' else a.final_status end as final_status,
--null as display_trx_id,
a.display_trx_id,
--null as noofinstallmentspaid,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,
d.bankname,d.bank_ac_number,null as next_installment_date,null as quantity,
c.frequency,null as first_installment_date,
--null as start_day,
(TO_CHAR(g.orderdate,'DD')):: character varying as start_day,
null as totalinstallmentamtpaid, 
a.schemegroup,
null as pausecount,'Exchange' as datasource,
null as lead_id,INITCAP(a.isinname)::character varying isinname,
null::boolean as is_generatetoday,--null as client_bank_name,null as client_bank_ac_number,
CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name,
CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number,
null as payment_method,c.reg_no,null as inv_action_code, null as inv_type_code,null as inv_type
,b.pan,null as sch_plan ,c.end_date, null as grpcode--,null as sch_type
,(((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(
case when g.status='VALID' then 'Completed'
when g.status='INVALID' then 'Order Rejected' else a.final_status end	
, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Child'::character varying as typeoforder, a.tokenno,
NULL::character varying as switch_isin_name, 
g.installment_number:: int as installment_number,
c.no_of_installment as tenure,
a.folio_no,c.start_date
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,
NULL:: character varying as krafolio_status,a.order_placed_by
,a.trx_type_code,a.vendor_trx_status,a.created_for,a.created_for_name
,NULL::character varying as vendor_res
from transactions.mf_order_detail a
inner join master.dim_ucc b on a.ucccode=b.ucccode
inner join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left JOIN transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
left join temp_bank_detail bnk ON a.ucccode = bnk.ucccode
/*
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
*/
inner join --transactions.mf_subsequent_order g on a.vendor_trx_id = g.vendor_trx_id
(
select subs.trx_type_code,subs.order_no,subs.reg_no,subs.vendor_trx_id,
subs.orderdate,subs.amount,subs.reg_date,subs.status,subs.remarks,
row_number() over(partition by subs.reg_no order by subs.orderdate) as installment_number
from transactions.mf_subsequent_order subs
--where reg_no=227821	
)g on a.vendor_trx_id = g.vendor_trx_id
WHERE g.orderdate::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and g.orderedby='Exchange Triggered'
--and a.final_status is not null
--order by trx_datetime desc
------------
union all
------------
SELECT 
g.trx_id,g.vendor_trx_id,g.ac_code,b.acname as ac_name,a.ucccode,g.isincode, 
case when g.inv_action_code=2 then cast(f.trx_type ||' Pause' as character varying)
when g.inv_action_code=3 then cast(f.trx_type ||' Modify' as character varying)
when g.inv_action_code=4 then cast(f.trx_type ||' Cancel' as character varying)
when g.inv_action_code=0 then cast(f.trx_type ||' Resume' as character varying)
else f.trx_type end as trx_type,	
date_trunc('second',g.trx_datetime) as trx_datetime,
case when g.inv_action_code in (2,4) then a.trx_amt else g.trx_amt end trx_amt,
case when a.physicalflag='D' then 'DEMAT'
when a.physicalflag='P' then 'PHYSICAL'
else a.physicalflag end delivery_mode,	
coalesce(g.mandate_id,a.mandate_id) as mandate_id,
	g.trx_status,a.payment_trxid,g.payment_status,
a.switch_isin,a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
--case when g.vendor_trx_status is null then '' else g.order_remarks end as order_remarks,
g.order_remarks,
a.vendor_exchg_refno, 
date_trunc('second',g.created_date) as created_date,a.mf_schcode,
a.switch_mf_schcode,g.final_status,
cast(g.display_trx_id ||'-'||g.trx_id as character varying) as display_trx_id,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,d.bankname,d.bank_ac_number,
coalesce(g.installment_date_post_pause_resume,c.upcoming_due_date) as next_installment_date,a.trx_qty as quantity,
coalesce(g.frequency, c.frequency) frequency,c.start_date as first_installment_date,
CASE WHEN g.inv_action_code = 3 AND g.start_day IS NOT NULL 
THEN (EXTRACT('Days' FROM g.start_day::date))::character varying
ELSE (
--case when coalesce(c.start_day,'')='' then (TO_CHAR(coalesce(installment_date_post_pause_resume,sip_date), 'DD'))
case when coalesce((LPAD(TO_CHAR(c.start_date ::date, 'DD'), 2, '0')::int)::character varying,'')='' then (TO_CHAR(coalesce(installment_date_post_pause_resume,sip_date), 'DD'))
else 
--c.start_day 
(LPAD(TO_CHAR(c.start_date ::date, 'DD'), 2, '0')::int)::character varying
end) 
END:: character varying as start_day,
c.totalinstallmentamt_paid as totalinstallmentamtpaid,
a.schemegroup,
g.no_of_inst_paused as pausecount,g.datasource,null as lead_id,INITCAP(g.isinname)::character varying isinname,
a.is_generatetoday
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number,
null as payment_method,c.reg_no,g.inv_action_code,g.inv_type_code,g.inv_type,b.pan,
sch.sch_plan,c.end_date,isin.schemecode as grpcode--,sch.sch_type
,(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(g.final_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Child'::character varying as typeoforder, a.tokenno,
NULL::character varying as switch_isin_name,null::int as installment_number,
c.no_of_installment as tenure,
a.folio_no,c.start_date
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,
NULL:: character varying as krafolio_status,g.order_placed_by
,g.trx_type_code,g.vendor_trx_status,g.created_for,g.created_for_name
,NULL::character varying as vendor_res
from transactions.mf_order_detail a
--temp_mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left join transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
inner join transactions.mf_order_detail_modification g on a.trx_id=g.org_trx_id
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode	
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
left join temp_bank_detail bnk ON a.ucccode = bnk.ucccode
/*
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
*/
WHERE g.created_date::date BETWEEN v_fromdate AND v_todate
and g.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and g.final_status is not null
)A
left join master.dim_mf_order_remarks B
on upper(a.order_remarks) = upper(b.dion_order_remarks)
left join (
select 
a.ucccode,a.priority_ac_code,a.user_type,
case when a.user_type='E' then a.client_owner
when a.user_type='P' then a.partner_code end as client_owner,
case when a.user_type='E' then a.client_owner_name
when a.user_type='P' then a.partner_name end as client_owner_name,
(case 
when a.is_individual=true 
and extract(year from age(NOW(), a.birthdate))::numeric::int<18
then 'minor'
when Upper(substr(a.pan, 4, 1))='H' then 'huf'
when Upper(substr(a.pan, 4, 1))='P' then 'individual'
when a.is_individual=true then 'individual'
when a.is_individual=false then 'non-individual' end)::character varying kacctype,
a.dp_flag,a.direct_plan_enabled_flg,a.krastatus
from master.dim_ucc a
--where a.ucccode in (select ucc.ucccode from temp_mf_ucc ucc)
)C
on A.ucccode=C.ucccode
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by created_date desc;
-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
DROP TABLE temp_mf_order_detail;
-------------------------------------------------------------

END;

$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_detail(varchar, varchar, date, date, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail(varchar, varchar, date, date, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail(varchar, varchar, date, date, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail(varchar, varchar, date, date, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail(varchar, varchar, date, date, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_09may2025(varchar, varchar, date, date, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_09may2025(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_ac_code character varying DEFAULT NULL::character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, ac_code character varying, ac_name character varying, ucccode character varying, isincode character varying, trx_type character varying, trx_datetime timestamp without time zone, trx_amt numeric, delivery_mode character varying, mandate_id character varying, trx_status character varying, payment_trxid character varying, payment_status character varying, switch_isin character varying, nav numeric, navdate date, order_nav numeric, order_navdate date, order_type character varying, order_remarks character varying, vendor_exchg_refno character varying, created_date timestamp without time zone, mf_schcode bigint, switch_mf_schcode bigint, final_status character varying, display_trx_id character varying, totalinstallment_paid integer, mandate_type character varying, bankname character varying, bank_ac_number character varying, next_installment_date date, quantity numeric, frequency character varying, first_installment_date date, start_day character varying, totalinstallmentamtpaid integer, schemegroup character varying, pausecount integer, datasource character varying, lead_id character varying, isinname character varying, is_generatetoday boolean, client_bank_name character varying, client_bank_ac_number character varying, payment_method character varying, reg_no bigint, inv_action_code integer, inv_type_code integer, inv_type character varying, pan character varying, sch_plan character varying, end_date date, grpcode character varying, search_key character varying, clienttier character varying, typeoforder character varying, tokenno bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_fromdate IS NULL OR v_todate IS NULL THEN
RAISE EXCEPTION 'Invalid date range provided';
END IF;

-------------Create temp table
CREATE TEMP TABLE IF NOT EXISTS temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

INSERT INTO temp_mf_ucc(ucccode)
SELECT DISTINCT a.ucccode
FROM master.dim_ucc a
WHERE
	CASE
	WHEN upper(v_logintype) = 'CLIENT' THEN a.priority_ac_code = v_logincode
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') <> '' THEN a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') = '' THEN a.client_owner = v_logincode
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.partnerowner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.partnerowner = v_logincode
	ELSE FALSE
END;

-------------Create temp table
drop table if exists temp_mf_order_detail CASCADE;

create temp table temp_mf_order_detail 
as 
select a.* 
from (
select a.* from transactions.mf_order_detail a
where a.order_placed_by in ('RM','PARTNER')
union all
select a.* from transactions.mf_order_detail a
where(a.trx_datetime <= NOW() - interval '5 days' 
and a.order_placed_by not in ('RM','PARTNER'))
and a.trx_type_code in (1,4)
union all
select a.* from transactions.mf_order_detail a
where a.order_placed_by not in ('RM','PARTNER')
and a.trx_type_code in (2,3,5,6)
)a
WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null;

----------------------------------------
CREATE INDEX idx_temp_created_date
ON temp_mf_order_detail (created_date);

CREATE INDEX idx_temp_trx_id
ON temp_mf_order_detail (trx_id);
----------------------------------------

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,a.ucccode,a.isincode,
a.trx_type,a.trx_datetime,a.trx_amt,INITCAP(a.delivery_mode)::character varying as delivery_mode,a.mandate_id,
a.trx_status,a.payment_trxid,a.payment_status,a.switch_isin,
a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
--a.order_remarks,
coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
a.vendor_exchg_refno,a.created_date,a.mf_schcode,
a.switch_mf_schcode,a.final_status,a.display_trx_id,a.noofinstallmentspaid,
a.mandate_type,a.bankname,a.bank_ac_number,a.next_installment_date,a.quantity,
a.frequency,a.first_installment_date,a.start_day,a.totalinstallmentamtpaid,
a.schemegroup,a.pausecount,a.datasource,a.lead_id,a.isinname,a.is_generatetoday,
a.client_bank_name,a.client_bank_ac_number,a.payment_method,a.reg_no,a.inv_action_code,
a.inv_type_code,a.inv_type,a.pan,a.sch_plan,a.end_date,a.grpcode,
a.search_key,a.clienttier,a.typeoforder, a.tokenno
from (
SELECT 
a.trx_id,a.vendor_trx_id,a.ac_code,b.acname as ac_name,a.ucccode,a.isincode, 
f.trx_type,date_trunc('second',a.trx_datetime) as trx_datetime,a.trx_amt, 
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id,a.trx_status,a.payment_trxid,a.payment_status,
a.switch_isin,a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
a.order_remarks, a.vendor_exchg_refno, 
date_trunc('second',a.created_date) as created_date,a.mf_schcode,
a.switch_mf_schcode,a.final_status,a.display_trx_id,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,d.bankname,d.bank_ac_number,
c.upcoming_due_date as next_installment_date,a.trx_qty as quantity,
c.frequency,c.start_date as first_installment_date,c.start_day,
c.totalinstallmentamt_paid as totalinstallmentamtpaid,
a.schemegroup,
c.pausecount,a.datasource,a.lead_id,INITCAP(a.isinname)::character varying isinname,a.is_generatetoday
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,a.payment_method,c.reg_no,a.inv_action_code,a.inv_type_code,a.inv_type,b.pan,sch.sch_plan
,c.end_date,isin.schemecode as grpcode--,sch.sch_type
,(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.final_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Main'::character varying as typeoforder, a.tokenno
from --transactions.mf_order_detail a
temp_mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left join transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null
------------
union all
------------
select 
floor(random() * 1000000 +1)::bigint as trx_id,a.vendor_trx_id,a.ac_code,
b.acname as ac_name,a.ucccode,a.isincode, 
cast(f.trx_type ||' Installment' as character varying) as trx_type,
date_trunc('second', g.orderdate::timestamp without time zone) as trx_datetime,
case when g.amount ='0.00' and f.trx_type='SWP' then c.trx_amt else g.amount end as trx_amt,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id, 
case when g.status='VALID' then 'Success'
when g.status='INVALID' then 'Failed' else g.status end as trx_status, 
null as payment_trxid,null as payment_status,a.switch_isin, 
null as nav,null as navdate,null as order_nav,null as order_navdate,
null as order_type,g.remarks as order_remarks,a.vendor_exchg_refno, 
date_trunc('second', g.orderdate::timestamp without time zone) created_date,
a.mf_schcode,a.switch_mf_schcode,
case when g.status='VALID' then 'Completed'
when g.status='INVALID' then 'Order Rejected' else a.final_status end as final_status,
null as display_trx_id,null as noofinstallmentspaid,e.internal_type as mandate_type,
d.bankname,d.bank_ac_number,null as next_installment_date,null as quantity,
c.frequency,null as first_installment_date,
--null as start_day,
(TO_CHAR(g.orderdate,'DD')):: character varying as start_day,
null as totalinstallmentamtpaid, 
a.schemegroup,
null as pausecount,'Exchange' as datasource,
null as lead_id,INITCAP(a.isinname)::character varying isinname,
null::boolean as is_generatetoday,--null as client_bank_name,null as client_bank_ac_number,
CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name,
CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number,
null as payment_method,c.reg_no,null as inv_action_code, null as inv_type_code,null as inv_type
,b.pan,null as sch_plan, null as end_date, null as grpcode--,null as sch_type
,(((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(
case when g.status='VALID' then 'Completed'
when g.status='INVALID' then 'Order Rejected' else a.final_status end	
, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Child'::character varying as typeoforder, a.tokenno
from transactions.mf_order_detail a
inner join master.dim_ucc b on a.ucccode=b.ucccode
inner join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left JOIN transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
inner join transactions.mf_subsequent_order g on a.vendor_trx_id = g.vendor_trx_id
WHERE g.orderdate::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and g.orderedby='Exchange Triggered'
and a.final_status is not null
--order by trx_datetime desc
------------
union all
------------
SELECT 
g.trx_id,g.vendor_trx_id,g.ac_code,b.acname as ac_name,a.ucccode,g.isincode, 
case when g.inv_action_code=2 then cast(f.trx_type ||' Pause' as character varying)
when g.inv_action_code=3 then cast(f.trx_type ||' Modify' as character varying)
when g.inv_action_code=4 then cast(f.trx_type ||' Cancel' as character varying)
when g.inv_action_code=0 then cast(f.trx_type ||' Resume' as character varying)
else f.trx_type end as trx_type,	
date_trunc('second',g.trx_datetime) as trx_datetime,
case when g.inv_action_code in (2,4) then a.trx_amt else g.trx_amt end trx_amt,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id,g.trx_status,a.payment_trxid,g.payment_status,
a.switch_isin,a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
--case when g.vendor_trx_status is null then '' else g.order_remarks end as order_remarks,
g.order_remarks,
a.vendor_exchg_refno, 
date_trunc('second',g.created_date) as created_date,a.mf_schcode,
a.switch_mf_schcode,g.final_status,
cast(g.display_trx_id ||'-'||g.trx_id as character varying) as display_trx_id,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,d.bankname,d.bank_ac_number,
c.upcoming_due_date as next_installment_date,a.trx_qty as quantity,
coalesce(g.frequency, c.frequency) frequency,c.start_date as first_installment_date,
CASE WHEN g.inv_action_code = 3 AND g.start_day IS NOT NULL THEN (EXTRACT('Days' FROM g.start_day::date))::character varying
ELSE (case when coalesce(c.start_day,'')='' then (TO_CHAR(installment_date_post_pause_resume, 'DD'))
else c.start_day end) END:: character varying as start_day,
c.totalinstallmentamt_paid as totalinstallmentamtpaid,
a.schemegroup,
c.pausecount,g.datasource,null as lead_id,INITCAP(g.isinname)::character varying isinname,
null::boolean as is_generatetoday,null as client_bank_name,null as client_bank_ac_number,
null as payment_method,c.reg_no,g.inv_action_code,g.inv_type_code,g.inv_type,b.pan,
sch.sch_plan,c.end_date,isin.schemecode as grpcode--,sch.sch_type
,(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(g.final_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Child'::character varying as typeoforder, a.tokenno
from transactions.mf_order_detail a
--temp_mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left join transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
inner join transactions.mf_order_detail_modification g on a.trx_id=g.org_trx_id
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode	
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
WHERE g.created_date::date BETWEEN v_fromdate AND v_todate
and g.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null
)A
left join master.dim_mf_order_remarks B
on upper(a.order_remarks) = upper(b.dion_order_remarks)
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by created_date desc;
-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
DROP TABLE temp_mf_order_detail;
-------------------------------------------------------------

END;

$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_09may2025(varchar, varchar, date, date, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_09may2025(varchar, varchar, date, date, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_09may2025(varchar, varchar, date, date, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_09may2025(varchar, varchar, date, date, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_09may2025(varchar, varchar, date, date, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_14jul2025(varchar, varchar, date, date, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_14jul2025(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_ac_code character varying DEFAULT NULL::character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, ac_code character varying, ac_name character varying, ucccode character varying, isincode character varying, trx_type character varying, trx_datetime timestamp without time zone, trx_amt numeric, delivery_mode character varying, mandate_id character varying, trx_status character varying, payment_trxid character varying, payment_status character varying, switch_isin character varying, nav numeric, navdate date, order_nav numeric, order_navdate date, order_type character varying, order_remarks character varying, vendor_exchg_refno character varying, created_date timestamp without time zone, mf_schcode bigint, switch_mf_schcode bigint, final_status character varying, display_trx_id character varying, totalinstallment_paid integer, mandate_type character varying, bankname character varying, bank_ac_number character varying, next_installment_date date, quantity numeric, frequency character varying, first_installment_date date, start_day character varying, totalinstallmentamtpaid integer, schemegroup character varying, pausecount integer, datasource character varying, lead_id character varying, isinname character varying, is_generatetoday boolean, client_bank_name character varying, client_bank_ac_number character varying, payment_method character varying, reg_no bigint, inv_action_code integer, inv_type_code integer, inv_type character varying, pan character varying, sch_plan character varying, end_date date, grpcode character varying, search_key character varying, clienttier character varying, typeoforder character varying, tokenno bigint, switch_isin_name character varying, installment_number integer, tenure integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_fromdate IS NULL OR v_todate IS NULL THEN
RAISE EXCEPTION 'Invalid date range provided';
END IF;

-------------Create temp table
CREATE TEMP TABLE IF NOT EXISTS temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

INSERT INTO temp_mf_ucc(ucccode)
SELECT DISTINCT a.ucccode
FROM master.dim_ucc a
WHERE
	CASE
	WHEN upper(v_logintype) = 'CLIENT' THEN a.priority_ac_code = v_logincode
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') <> '' THEN a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') = '' THEN a.client_owner = v_logincode
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.partnerowner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.partnerowner = v_logincode
	ELSE FALSE
END;

---------------------------------------
----to handle open architecture flow -RM
IF(v_logintype='RM' or v_logintype='PARTNER')
THEN 
drop table if exists temp_mf_order_detail_extra CASCADE;
create temp table temp_mf_order_detail_extra
as 
--actual RM
select a.* from transactions.mf_order_detail a
left join master.dim_ucc b
on a.ucccode = b.ucccode and b.client_owner=v_logincode
where a.order_placed_by in ('RM','PARTNER')
and a.created_date::date between v_fromdate and v_todate
and a.final_status is not null
and a.orderby<>b.client_owner;
--and a.orderby=v_logincode
--and b.ucccode is null

elsif (v_logintype='CLIENT')
THEN 
drop table if exists temp_mf_order_detail_extra CASCADE;
create temp table temp_mf_order_detail_extra
as 
select a.* from transactions.mf_order_detail a
where a.order_placed_by ='client'
and a.created_date::date BETWEEN v_fromdate AND v_todate
and a.ucccode not in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null
and a.orderby=v_logincode;
END IF;

----to handle open architecture flow -NON-RM
IF(v_logintype='RM' or v_logintype='PARTNER')
THEN 
drop table if exists temp_mf_order_detail_extra_nonrm CASCADE;
create temp table temp_mf_order_detail_extra_nonrm
as 
select a.* from transactions.mf_order_detail a
left join master.dim_ucc b
on a.ucccode = b.ucccode and b.client_owner=v_logincode
where a.order_placed_by in ('RM','PARTNER')
and a.created_date::date between v_fromdate and v_todate
and a.final_status is not null
and a.orderby=v_logincode
--and a.trx_id='385886'
and b.ucccode is null;

elsif (v_logintype='CLIENT')
THEN 
drop table if exists temp_mf_order_detail_extra_nonrm CASCADE;
create temp table temp_mf_order_detail_extra_nonrm
as 
select a.* from transactions.mf_order_detail a
left join master.dim_ucc b
on a.ucccode = b.ucccode and b.client_owner=v_logincode
where a.order_placed_by ='client'
and a.created_date::date between  v_fromdate AND v_todate
and a.final_status is not null
and a.orderby=v_logincode
--and a.trx_id='385886'
and b.ucccode is null;
END IF;

---------------------------------------
IF(v_logintype='RM' or v_logintype='PARTNER')
THEN 
-------------Create temp table
drop table if exists temp_mf_order_detail CASCADE;

create temp table temp_mf_order_detail 
as 
select a.* 
from (
select a.* from transactions.mf_order_detail a
where a.order_placed_by in ('RM','PARTNER')
union all
select a.* from transactions.mf_order_detail a
where(a.trx_datetime <= NOW() - interval '5 days' 
and a.order_placed_by not in ('RM','PARTNER'))
and a.trx_type_code in (1,4)
union all
select a.* from transactions.mf_order_detail a
where a.order_placed_by not in ('RM','PARTNER')
and a.trx_type_code in (2,3,5,6)
)a
WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null
and a.trx_id not in (select a.trx_id from temp_mf_order_detail_extra a)
union all
select * from temp_mf_order_detail_extra_nonrm;

elsif (v_logintype='CLIENT')
THEN 
-------------Create temp table
drop table if exists temp_mf_order_detail CASCADE;

create temp table temp_mf_order_detail 
as 
select a.* from transactions.mf_order_detail a
WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null;
	
END IF;

----------------------------------------
CREATE INDEX idx_temp_created_date
ON temp_mf_order_detail (created_date);

CREATE INDEX idx_temp_trx_id
ON temp_mf_order_detail (trx_id);
----------------------------------------

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,a.ucccode,a.isincode,
a.trx_type,a.trx_datetime,a.trx_amt,INITCAP(a.delivery_mode)::character varying as delivery_mode,a.mandate_id,
a.trx_status,a.payment_trxid,a.payment_status,a.switch_isin,
a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
--a.order_remarks,
/*(
case when a.final_status='Consent Pending' then 'The order is awaiting '+INITCAP(a.ac_name)::character varying+' approval.'
when a.final_status='Consent Rejected' then 'This order was rejected by the client '+INITCAP(a.ac_name)::character varying+'.'
else coalesce(b.internal_order_remarks,a.order_remarks) end
):: character varying as order_remarks,
*/
(
  CASE 
    WHEN a.final_status = 'Consent Pending' 
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN a.final_status = 'Consent Rejected' 
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
  END
)::character varying AS order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
a.vendor_exchg_refno,a.created_date,a.mf_schcode,
a.switch_mf_schcode,a.final_status,a.display_trx_id,a.noofinstallmentspaid,
a.mandate_type,a.bankname,a.bank_ac_number,a.next_installment_date,a.quantity,
a.frequency,a.first_installment_date,a.start_day,a.totalinstallmentamtpaid,
a.schemegroup,a.pausecount,a.datasource,a.lead_id,a.isinname,a.is_generatetoday,
a.client_bank_name,a.client_bank_ac_number,a.payment_method,a.reg_no,a.inv_action_code,
a.inv_type_code,a.inv_type,a.pan,a.sch_plan,a.end_date,a.grpcode,
a.search_key,a.clienttier,a.typeoforder, a.tokenno, a.switch_isin_name, a.installment_number,
a.tenure
from (
SELECT 
a.trx_id,a.vendor_trx_id,a.ac_code,b.acname as ac_name,a.ucccode,a.isincode, 
f.trx_type,date_trunc('second',a.trx_datetime) as trx_datetime,a.trx_amt, 
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id,a.trx_status,a.payment_trxid,a.payment_status,
a.switch_isin,a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
a.order_remarks, a.vendor_exchg_refno, 
date_trunc('second',a.created_date) as created_date,a.mf_schcode,
a.switch_mf_schcode,a.final_status,a.display_trx_id,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,d.bankname,d.bank_ac_number,
c.upcoming_due_date as next_installment_date,a.trx_qty as quantity,
c.frequency,c.start_date as first_installment_date,
--c.start_day,
(CASE 
    WHEN c.trx_type_code IN (1, 2, 3) AND c.start_day IS NOT NULL 
        THEN LPAD(c.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(c.start_day, '') = '' 
                THEN TO_CHAR(c.start_date, 'DD')
            ELSE LPAD(c.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
c.totalinstallmentamt_paid as totalinstallmentamtpaid,
a.schemegroup,
c.pausecount,a.datasource,a.lead_id,INITCAP(a.isinname)::character varying isinname,a.is_generatetoday
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,a.payment_method,c.reg_no,a.inv_action_code,a.inv_type_code,a.inv_type,b.pan,sch.sch_plan
,c.end_date,isin.schemecode as grpcode--,sch.sch_type
,(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.final_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Main'::character varying as typeoforder, a.tokenno,
(
case when a.trx_type_code in (2,6) then INITCAP(isin_switch.isinname) 
else NULL end
)::character varying as switch_isin_name,
null::int as installment_number,
c.no_of_installment as tenure
from --transactions.mf_order_detail a
temp_mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left join transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
left join master.dim_mf_isin isin_switch on a.switch_isin=isin_switch.isincode
WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null
------------
union all
------------
select 
g.order_no::bigint as trx_id,
--floor(random() * 1000000 +1)::bigint as trx_id,
a.vendor_trx_id,a.ac_code,
b.acname as ac_name,a.ucccode,a.isincode, 
cast(f.trx_type ||' Installment' as character varying) as trx_type,
date_trunc('second', g.orderdate::timestamp without time zone) as trx_datetime,
case when g.amount ='0.00' and f.trx_type='SWP' then c.trx_amt else g.amount end as trx_amt,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id, 
case when g.status='VALID' then 'Success'
when g.status='INVALID' then 'Failed' else g.status end as trx_status, 
null as payment_trxid,null as payment_status,a.switch_isin, 
null as nav,null as navdate,null as order_nav,null as order_navdate,
null as order_type,g.remarks as order_remarks,a.vendor_exchg_refno, 
date_trunc('second', g.orderdate::timestamp without time zone) created_date,
a.mf_schcode,a.switch_mf_schcode,
case when g.status='VALID' then 'Completed'
when g.status='INVALID' then 'Order Rejected' else a.final_status end as final_status,
--null as display_trx_id,
a.display_trx_id,
null as noofinstallmentspaid,e.internal_type as mandate_type,
d.bankname,d.bank_ac_number,null as next_installment_date,null as quantity,
c.frequency,null as first_installment_date,
--null as start_day,
(TO_CHAR(g.orderdate,'DD')):: character varying as start_day,
null as totalinstallmentamtpaid, 
a.schemegroup,
null as pausecount,'Exchange' as datasource,
null as lead_id,INITCAP(a.isinname)::character varying isinname,
null::boolean as is_generatetoday,--null as client_bank_name,null as client_bank_ac_number,
CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name,
CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number,
null as payment_method,c.reg_no,null as inv_action_code, null as inv_type_code,null as inv_type
,b.pan,null as sch_plan, null as end_date, null as grpcode--,null as sch_type
,(((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(
case when g.status='VALID' then 'Completed'
when g.status='INVALID' then 'Order Rejected' else a.final_status end	
, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Child'::character varying as typeoforder, a.tokenno,
NULL::character varying as switch_isin_name, 
g.installment_number:: int as installment_number,
NULL:: int as tenure	
from transactions.mf_order_detail a
inner join master.dim_ucc b on a.ucccode=b.ucccode
inner join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left JOIN transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
inner join --transactions.mf_subsequent_order g on a.vendor_trx_id = g.vendor_trx_id
(
select subs.trx_type_code,subs.order_no,subs.reg_no,subs.vendor_trx_id,
subs.orderdate,subs.amount,subs.reg_date,subs.status,subs.remarks,
row_number() over(partition by subs.reg_no order by subs.orderdate) as installment_number
from transactions.mf_subsequent_order subs
--where reg_no=227821	
)g on a.vendor_trx_id = g.vendor_trx_id
WHERE g.orderdate::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and g.orderedby='Exchange Triggered'
and a.final_status is not null
--order by trx_datetime desc
------------
union all
------------
SELECT 
g.trx_id,g.vendor_trx_id,g.ac_code,b.acname as ac_name,a.ucccode,g.isincode, 
case when g.inv_action_code=2 then cast(f.trx_type ||' Pause' as character varying)
when g.inv_action_code=3 then cast(f.trx_type ||' Modify' as character varying)
when g.inv_action_code=4 then cast(f.trx_type ||' Cancel' as character varying)
when g.inv_action_code=0 then cast(f.trx_type ||' Resume' as character varying)
else f.trx_type end as trx_type,	
date_trunc('second',g.trx_datetime) as trx_datetime,
case when g.inv_action_code in (2,4) then a.trx_amt else g.trx_amt end trx_amt,
case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end delivery_mode,	
a.mandate_id,g.trx_status,a.payment_trxid,g.payment_status,
a.switch_isin,a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
--case when g.vendor_trx_status is null then '' else g.order_remarks end as order_remarks,
g.order_remarks,
a.vendor_exchg_refno, 
date_trunc('second',g.created_date) as created_date,a.mf_schcode,
a.switch_mf_schcode,g.final_status,
cast(g.display_trx_id ||'-'||g.trx_id as character varying) as display_trx_id,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,d.bankname,d.bank_ac_number,
c.upcoming_due_date as next_installment_date,a.trx_qty as quantity,
coalesce(g.frequency, c.frequency) frequency,c.start_date as first_installment_date,

CASE WHEN g.inv_action_code = 3 AND g.start_day IS NOT NULL 
THEN (EXTRACT('Days' FROM g.start_day::date))::character varying
ELSE (
--case when coalesce(c.start_day,'')='' then (TO_CHAR(coalesce(installment_date_post_pause_resume,sip_date), 'DD'))
case when coalesce((LPAD(TO_CHAR(c.start_date ::date, 'DD'), 2, '0')::int)::character varying,'')='' then (TO_CHAR(coalesce(installment_date_post_pause_resume,sip_date), 'DD'))
else 
--c.start_day 
(LPAD(TO_CHAR(c.start_date ::date, 'DD'), 2, '0')::int)::character varying
end) 
END:: character varying as start_day,

c.totalinstallmentamt_paid as totalinstallmentamtpaid,
a.schemegroup,
c.pausecount,g.datasource,null as lead_id,INITCAP(g.isinname)::character varying isinname,
null::boolean as is_generatetoday
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number,
null as payment_method,c.reg_no,g.inv_action_code,g.inv_type_code,g.inv_type,b.pan,
sch.sch_plan,c.end_date,isin.schemecode as grpcode--,sch.sch_type
,(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(g.final_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Child'::character varying as typeoforder, a.tokenno,
NULL::character varying as switch_isin_name,null::int as installment_number,
c.no_of_installment as tenure
from transactions.mf_order_detail a
--temp_mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left join transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
inner join transactions.mf_order_detail_modification g on a.trx_id=g.org_trx_id
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode	
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
WHERE g.created_date::date BETWEEN v_fromdate AND v_todate
and g.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and g.final_status is not null
)A
left join master.dim_mf_order_remarks B
on upper(a.order_remarks) = upper(b.dion_order_remarks)
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by created_date desc;
-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
DROP TABLE temp_mf_order_detail;
DROP TABLE temp_mf_order_detail_extra;
-------------------------------------------------------------

END;

$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_14jul2025(varchar, varchar, date, date, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_14jul2025(varchar, varchar, date, date, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_14jul2025(varchar, varchar, date, date, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_14jul2025(varchar, varchar, date, date, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_14jul2025(varchar, varchar, date, date, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_16sept2025(varchar, varchar, date, date, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_16sept2025(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_ac_code character varying DEFAULT NULL::character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, ac_code character varying, ac_name character varying, ucccode character varying, isincode character varying, trx_type character varying, trx_datetime timestamp without time zone, trx_amt numeric, delivery_mode character varying, mandate_id character varying, trx_status character varying, payment_trxid character varying, payment_status character varying, switch_isin character varying, nav numeric, navdate date, order_nav numeric, order_navdate date, order_type character varying, order_remarks character varying, vendor_exchg_refno character varying, created_date timestamp without time zone, mf_schcode bigint, switch_mf_schcode bigint, final_status character varying, display_trx_id character varying, totalinstallment_paid integer, mandate_type character varying, bankname character varying, bank_ac_number character varying, next_installment_date date, quantity numeric, frequency character varying, first_installment_date date, start_day character varying, totalinstallmentamtpaid integer, schemegroup character varying, pausecount integer, datasource character varying, lead_id character varying, isinname character varying, is_generatetoday boolean, client_bank_name character varying, client_bank_ac_number character varying, payment_method character varying, reg_no bigint, inv_action_code integer, inv_type_code integer, inv_type character varying, pan character varying, sch_plan character varying, end_date date, grpcode character varying, search_key character varying, clienttier character varying, typeoforder character varying, tokenno bigint, switch_isin_name character varying, installment_number integer, tenure integer, folio_no character varying, user_type character varying, client_owner character varying, client_owner_name character varying, kacctype character varying, dp_flag character varying, direct_plan_enabled_flg character varying, start_date date, sub_broker_code character varying, sub_broker_name character varying, arn_code character varying, sub_broker_pass_pct numeric, krafolio_status character varying, order_placed_by character varying, created_for character varying, created_for_name character varying, krastatus character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_logintype_new character varying;
--Declare v_fromdate DATE:= v_fromdate;
--Declare v_todate   DATE := v_todate ;

BEGIN

IF v_fromdate IS NULL OR v_todate IS NULL THEN
RAISE EXCEPTION 'Invalid date range provided';
END IF;

-----------------------------------------------------------------------
-----------------------------------------------------------------------
    -----------------------------------------------------------------------
    -- Determine effective login type
    IF v_logintype = 'CLIENT' OR v_logintype = 'PARTNER' THEN
        v_logintype_new := v_logintype;

    ELSIF v_logintype = 'RM' THEN
        IF EXISTS (
            SELECT 1 FROM master.map_emp_user_role a
            WHERE a.role_code = 467 
              AND a.emp_id = (
                  SELECT b.emp_id FROM master.dim_employee b 
                  WHERE b.emp_code = v_logincode LIMIT 1
              )
        ) THEN
            v_logintype_new := 'ADMIN';

        ELSIF EXISTS (
            SELECT 1 FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'CXO' 
              AND a.orderby = v_logincode LIMIT 1
        ) THEN
            v_logintype_new := 'CXO';

        ELSIF EXISTS (
            SELECT 1
            FROM master.DIM_ED_EMPL_Manager_Matrix 
            WHERE ltrim(managercode, '0') = v_logincode
            GROUP BY managercode
            HAVING COUNT(1) > 2
        ) THEN
            v_logintype_new := 'Hrchy';

        ELSE
            v_logintype_new := 'RM';
        END IF;

    ELSE
        RAISE NOTICE 'Invalid logintype for login_code: %', v_logincode;
    END IF;

    RAISE NOTICE 'Resolved login type: %', v_logintype_new;

    -----------------------------------------------------------------------
    -- Create and populate temp tables based on login type
    IF v_logintype_new = 'CLIENT' OR v_logintype_new = 'PARTNER' THEN

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;

        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

        INSERT INTO temp_mf_ucc(ucccode)
        SELECT DISTINCT a.ucccode
        FROM master.dim_ucc a
        WHERE CASE
            WHEN upper(v_logintype_new) = 'CLIENT' THEN a.priority_ac_code = v_logincode
            WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.upccode = v_logincode AND a.priority_ac_code = v_ac_code
            WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.upccode = v_logincode
            ELSE FALSE
        END;

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT a.*
        FROM transactions.mf_order_detail a
        INNER JOIN temp_mf_ucc b ON a.ucccode = b.ucccode
        WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
          AND a.final_status IS NOT NULL;

    -----------------------------------------------------------------------
    ELSIF v_logintype_new = 'ADMIN' THEN
		
		 -- Set default date range for last 15 days
        v_fromdate := CURRENT_DATE - INTERVAL '15 days';
        v_todate   := CURRENT_DATE;

		RAISE NOTICE 'Resolved ADMIN from date: %', v_fromdate;
		RAISE NOTICE 'Resolved ADMIN to date: %', v_todate;

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT a.*
        FROM transactions.mf_order_detail a
        WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
          AND a.final_status IS NOT NULL;

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM temp_mf_order_detail a;

    -----------------------------------------------------------------------
    ELSIF v_logintype_new = 'CXO' THEN

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT a.*
        FROM transactions.mf_order_detail a
        WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
          AND a.natureoforder = 'CXO'
          AND a.orderby = v_logincode
          AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
          AND a.final_status IS NOT NULL;

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM temp_mf_order_detail a;

    -----------------------------------------------------------------------
    ELSIF v_logintype_new = 'Hrchy' THEN

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM master.dim_ucc a
        WHERE (
            coalesce(v_ac_code, '') <> '' AND
            a.client_owner IN (
                SELECT ltrim(empcode, '0') as empcode
                FROM master.DIM_ED_EMPL_Manager_Matrix
                WHERE ltrim(managercode, '0') = v_logincode
            ) AND a.priority_ac_code = v_ac_code
        )
        OR (
            coalesce(v_ac_code, '') = '' AND
            a.client_owner IN (
                SELECT ltrim(empcode, '0') as empcode
                FROM master.DIM_ED_EMPL_Manager_Matrix
                WHERE ltrim(managercode, '0') = v_logincode
            )
        );

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT DISTINCT a.* FROM (
            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
            --  AND coalesce(a.natureoforder, 'Normal') = 'Normal'
			AND (a.natureoforder = 'Normal' OR a.natureoforder IS NULL)
              AND a.final_status IS NOT NULL

            UNION ALL

            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'CXO'
              AND a.created_for IN (
                  SELECT ltrim(empcode, '0') as empcode
                  FROM master.DIM_ED_EMPL_Manager_Matrix
                  WHERE ltrim(managercode, '0') = v_logincode
              )
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
              AND a.final_status IS NOT NULL

			 UNION ALL

            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'OpenArch'
              AND a.created_for IN (
                  SELECT ltrim(empcode, '0') as empcode
                  FROM master.DIM_ED_EMPL_Manager_Matrix
                  WHERE ltrim(managercode, '0') = v_logincode
              )
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
              AND a.final_status IS NOT NULL
        ) a
        WHERE a.trx_id NOT IN (
            SELECT a.trx_id FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'OpenArch'
              AND a.created_for NOT IN (
                  SELECT empcode
                  FROM master.DIM_ED_EMPL_Manager_Matrix
                  WHERE ltrim(managercode, '0') = v_logincode
              )
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
              AND a.final_status IS NOT NULL
        );

    -----------------------------------------------------------------------
    ELSIF v_logintype_new = 'RM' THEN

        DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
        CREATE TEMP TABLE temp_mf_ucc AS 
        SELECT DISTINCT a.ucccode FROM master.dim_ucc a
        WHERE (
            coalesce(v_ac_code, '') <> '' AND
            a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
        )
        OR (
            coalesce(v_ac_code, '') = '' AND
            a.client_owner = v_logincode
        );

        DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
        CREATE TEMP TABLE temp_mf_order_detail AS
        SELECT DISTINCT a.* FROM (
            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
           --   AND coalesce(a.natureoforder, 'Normal') = 'Normal'
			AND (a.natureoforder = 'Normal' OR a.natureoforder IS NULL)
              AND a.final_status IS NOT NULL

            UNION ALL

            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'CXO'
              AND a.created_for = v_logincode
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
              AND a.final_status IS NOT NULL

			UNION ALL

            SELECT a.* FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'OpenArch'
              AND a.created_for = v_logincode
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
              AND a.final_status IS NOT NULL
        ) a
        WHERE a.trx_id NOT IN (
            SELECT a.trx_id FROM transactions.mf_order_detail a
            WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
              AND a.natureoforder = 'OpenArch'
              AND a.created_for = v_logincode
              AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
              AND a.final_status IS NOT NULL
        );

    END IF;

-----------------------------------------------------------------------
-- Create indexes on temp table for performance
CREATE INDEX idx_temp_created_date ON temp_mf_order_detail (created_date);
CREATE INDEX idx_temp_trx_id ON temp_mf_order_detail (trx_id);
-----------------------------------------------------------------------

RAISE NOTICE 'temp_mf_order_detail populated';

-----------------------------------------------------------------------

----------------Final Output

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,a.ucccode,a.isincode,
a.trx_type,a.trx_datetime,a.trx_amt,INITCAP(a.delivery_mode)::character varying as delivery_mode,a.mandate_id,
a.trx_status,a.payment_trxid,a.payment_status,a.switch_isin,
a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
--a.order_remarks,
/*(
case when a.final_status='Consent Pending' then 'The order is awaiting '+INITCAP(a.ac_name)::character varying+' approval.'
when a.final_status='Consent Rejected' then 'This order was rejected by the client '+INITCAP(a.ac_name)::character varying+'.'
else coalesce(b.internal_order_remarks,a.order_remarks) end
):: character varying as order_remarks,
*/
(
  CASE 
    WHEN v_logintype_new not in ('CLIENT') and a.final_status = 'Consent Pending' 
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN v_logintype_new not in ('CLIENT') and a.final_status = 'Consent Rejected' 
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
	WHEN v_logintype_new = 'CLIENT' and a.final_status = 'Consent Pending'  
      THEN 'The order is awaiting your approval.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=1 and a.final_status = 'Order Rejected'
	and a.vendor_trx_id is null
	THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by='CLIENT' and a.inv_action_code=1 and a.final_status = 'Consent Rejected'
      THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by='RM' and a.inv_action_code=1 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the order. Please contact your RM for assistance if needed.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by='PARTNER' and a.inv_action_code=1 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the order. Please contact your Partner for assistance if needed.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=2 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the pause request.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=3 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the modification request.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=4 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the cancellation request.'
	WHEN v_logintype_new = 'CLIENT' and a.vendor_trx_id is not null and a.final_status = 'Order Rejected'
      THEN 'Your order was rejected by the Exchange. You may try again later.'
	WHEN v_logintype_new = 'CLIENT' and a.final_status = 'Payment Failed'
      THEN 'Your payment failed. Please retry to complete the order.'
	WHEN v_logintype_new = 'CLIENT' and a.final_status = 'Payment Pending'
      THEN 'Please complete the payment to proceed with the transaction'
 --   ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
	when trx_type_code=5 and a.order_remarks ~* 'OrderStatus -ALLOTMENT DONE' then 'Redemption completed successfully.'
when trx_type_code=5 and a.order_remarks ~* 'OrderStatus -' then 'Order placed successfully.'
when trx_type_code=5 and a.order_remarks ~* 'AMO Order placed successfully' then 'Order placed outside market hours submitted successfully.'
when trx_type_code=5 and a.order_remarks ~* 'ORD CONF: Your Request for FRESH REDEMPTION' then 'Order received and is being processed.'

when trx_type_code=4 and a.order_remarks ~* 'OrderStatus -ALLOTMENT DONE' then 'Allotment completed successfully.'
when trx_type_code=4 and a.order_remarks ~* 'ORD CONF: Your Request for ADDITIONAL PURCHASE' then 'Order received and is being processed.'
when trx_type_code=4 and a.order_remarks ~* 'ORD CONF: Your Request for FRESH PURCHASE' then 'Purchase request is being processed.'
when trx_type_code=4 and a.order_remarks ~* 'OrderStatus -SENT TO RTA FOR VALIDATION' then 'Order sent for validation.'

when trx_type_code=1 and a.order_remarks ~* 'REGISTRATION ENTRY NOT EXISTS' then 'Request cannot be processed as order details were not found.'
when trx_type_code=1 and a.order_remarks ~* 'Order Lapsed' then 'Order couldnt be processed. Please place a new request.'
when trx_type_code=1 and a.order_remarks ~* 'X-SIP HAS BEEN REGISTERED, REG NO IS' then 'SIP registered successfully.'
when trx_type_code=1 and a.order_remarks ~* 'X-SIP OR I-SIP CAN BE CANCELLED ONLY PRIOR TO 2 WORKING DAYS OF TRIGGER DATE' 
	then 'SIP can be cancelled only up to 2 working days before trigger.'
when trx_type_code=1 and a.order_remarks ~* 'X-SIP OR I-SIP HAS BEEN ALREADY CANCELLED OR NOT EXISTS' 
	then 'SIP already cancelled. No further action needed.'
when trx_type_code=1 and vendor_trx_status='CANCELLED' and a.order_remarks ~* 'X-SIP OR I-SIP WITH REGN NO' 
	then 'SIP cancelled successfully.'

when trx_type_code=2 and a.order_remarks ~* 'STP CANCELLATION INITIATED. KINDLY CONFIRM' 
	then 'STP cancellation initiated. Please confirm.'	
when trx_type_code=2 and a.order_remarks ~* 'FAILED: STP ALREADY CANCELLED' 
	then 'STP is already cancelled.'
	
when trx_type_code=3 and a.order_remarks ~* 'SWP CANCELLATION INITIATED. KINDLY CONFIRM' 
	then 'SWP cancellation initiated. Please confirm.'
when trx_type_code=3 and a.order_remarks ~* 'FAILED: SWP ALREADY CANCELLED' 
	then 'SWP is already cancelled.'
when a.order_remarks ~* b.dion_order_remarks then INITCAP(b.internal_order_remarks)::character varying
else INITCAP(a.order_remarks)::character varying
  END
)::character varying AS order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
a.vendor_exchg_refno,a.created_date,a.mf_schcode,
a.switch_mf_schcode,a.final_status,a.display_trx_id,a.noofinstallmentspaid,
a.mandate_type,a.bankname,a.bank_ac_number,a.next_installment_date,a.quantity,
a.frequency,a.first_installment_date,a.start_day,a.totalinstallmentamtpaid,
a.schemegroup,a.pausecount,
--a.datasource,
(case when a.datasource='DION' then 'One Platform'
when a.datasource='optimum' then 'Partner Portal'
else 'One Platform' end):: character varying as datasource,
a.lead_id,a.isinname,a.is_generatetoday,
a.client_bank_name,a.client_bank_ac_number,a.payment_method,a.reg_no,a.inv_action_code,
a.inv_type_code,a.inv_type,a.pan,a.sch_plan,a.end_date,a.grpcode,
a.search_key,a.clienttier,a.typeoforder, a.tokenno, a.switch_isin_name, a.installment_number,
a.tenure,a.folio_no,c.user_type,c.client_owner,c.client_owner_name,c.kacctype,
c.dp_flag,c.direct_plan_enabled_flg,a.start_date
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.krafolio_status,
a.order_placed_by,a.created_for,a.created_for_name,c.krastatus
from (
SELECT 
a.trx_id,a.vendor_trx_id,a.ac_code,b.acname as ac_name,a.ucccode,a.isincode, 
f.trx_type,date_trunc('second',a.trx_datetime) as trx_datetime,a.trx_amt, 
case when a.physicalflag='D' then 'DEMAT'
when a.physicalflag='P' then 'PHYSICAL'
else a.physicalflag end delivery_mode,	
c.mandate_id,a.trx_status,a.payment_trxid,a.payment_status,
a.switch_isin,a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
a.order_remarks, a.vendor_exchg_refno, 
date_trunc('second',a.created_date) as created_date,a.mf_schcode,
a.switch_mf_schcode,a.final_status,a.display_trx_id,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,d.bankname,d.bank_ac_number,
c.upcoming_due_date as next_installment_date,a.trx_qty as quantity,
c.frequency,c.start_date as first_installment_date,
--c.start_day,
(CASE 
    WHEN c.trx_type_code IN (1, 2, 3) AND c.start_day IS NOT NULL 
        THEN LPAD(c.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(c.start_day, '') = '' 
                THEN TO_CHAR(c.start_date, 'DD')
            ELSE LPAD(c.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
c.totalinstallmentamt_paid as totalinstallmentamtpaid,
a.schemegroup,
c.pausecount,a.datasource,a.lead_id,INITCAP(a.isinname)::character varying isinname,a.is_generatetoday
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,a.payment_method,c.reg_no,a.inv_action_code,a.inv_type_code,a.inv_type,b.pan,sch.sch_plan
,c.end_date,isin.schemecode as grpcode--,sch.sch_type
,(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.final_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Main'::character varying as typeoforder, a.tokenno,
(
case when a.trx_type_code in (2,6) then INITCAP(isin_switch.isinname) 
else NULL end
)::character varying as switch_isin_name,
null::int as installment_number,
c.no_of_installment as tenure,
a.folio_no,c.start_date
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,
NULL:: character varying as krafolio_status,a.order_placed_by
,a.trx_type_code,a.vendor_trx_status,a.created_for,a.created_for_name
from --transactions.mf_order_detail a
temp_mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left join transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
left join master.dim_mf_isin isin_switch on a.switch_isin=isin_switch.isincode
WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null
------------
union all
------------
select 
g.order_no::bigint as trx_id,
--floor(random() * 1000000 +1)::bigint as trx_id,
a.vendor_trx_id,a.ac_code,
b.acname as ac_name,a.ucccode,a.isincode, 
cast(f.trx_type ||' Installment' as character varying) as trx_type,
date_trunc('second', g.orderdate::timestamp without time zone) as trx_datetime,
case when g.amount ='0.00' and f.trx_type='SWP' then c.trx_amt else g.amount end as trx_amt,
case when a.physicalflag='D' then 'DEMAT'
when a.physicalflag='P' then 'PHYSICAL'
else a.physicalflag end delivery_mode,	
a.mandate_id, 
case when g.status='VALID' then 'Success'
when g.status='INVALID' then 'Failed' else g.status end as trx_status, 
null as payment_trxid,null as payment_status,a.switch_isin, 
null as nav,null as navdate,null as order_nav,null as order_navdate,
null as order_type,g.remarks as order_remarks,a.vendor_exchg_refno, 
date_trunc('second', g.orderdate::timestamp without time zone) created_date,
a.mf_schcode,a.switch_mf_schcode,
case when g.status='VALID' then 'Completed'
when g.status='INVALID' then 'Order Rejected' else a.final_status end as final_status,
--null as display_trx_id,
a.display_trx_id,
--null as noofinstallmentspaid,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,
d.bankname,d.bank_ac_number,null as next_installment_date,null as quantity,
c.frequency,null as first_installment_date,
--null as start_day,
(TO_CHAR(g.orderdate,'DD')):: character varying as start_day,
null as totalinstallmentamtpaid, 
a.schemegroup,
null as pausecount,'Exchange' as datasource,
null as lead_id,INITCAP(a.isinname)::character varying isinname,
null::boolean as is_generatetoday,--null as client_bank_name,null as client_bank_ac_number,
CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name,
CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number,
null as payment_method,c.reg_no,null as inv_action_code, null as inv_type_code,null as inv_type
,b.pan,null as sch_plan ,c.end_date, null as grpcode--,null as sch_type
,(((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(
case when g.status='VALID' then 'Completed'
when g.status='INVALID' then 'Order Rejected' else a.final_status end	
, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Child'::character varying as typeoforder, a.tokenno,
NULL::character varying as switch_isin_name, 
g.installment_number:: int as installment_number,
c.no_of_installment as tenure,
a.folio_no,c.start_date
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,
NULL:: character varying as krafolio_status,a.order_placed_by
,a.trx_type_code,a.vendor_trx_status,a.created_for,a.created_for_name
from transactions.mf_order_detail a
inner join master.dim_ucc b on a.ucccode=b.ucccode
inner join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left JOIN transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
inner join --transactions.mf_subsequent_order g on a.vendor_trx_id = g.vendor_trx_id
(
select subs.trx_type_code,subs.order_no,subs.reg_no,subs.vendor_trx_id,
subs.orderdate,subs.amount,subs.reg_date,subs.status,subs.remarks,
row_number() over(partition by subs.reg_no order by subs.orderdate) as installment_number
from transactions.mf_subsequent_order subs
--where reg_no=227821	
)g on a.vendor_trx_id = g.vendor_trx_id
WHERE g.orderdate::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and g.orderedby='Exchange Triggered'
and a.final_status is not null
--order by trx_datetime desc
------------
union all
------------
SELECT 
g.trx_id,g.vendor_trx_id,g.ac_code,b.acname as ac_name,a.ucccode,g.isincode, 
case when g.inv_action_code=2 then cast(f.trx_type ||' Pause' as character varying)
when g.inv_action_code=3 then cast(f.trx_type ||' Modify' as character varying)
when g.inv_action_code=4 then cast(f.trx_type ||' Cancel' as character varying)
when g.inv_action_code=0 then cast(f.trx_type ||' Resume' as character varying)
else f.trx_type end as trx_type,	
date_trunc('second',g.trx_datetime) as trx_datetime,
case when g.inv_action_code in (2,4) then a.trx_amt else g.trx_amt end trx_amt,
case when a.physicalflag='D' then 'DEMAT'
when a.physicalflag='P' then 'PHYSICAL'
else a.physicalflag end delivery_mode,	
coalesce(g.mandate_id,a.mandate_id) as mandate_id,
	g.trx_status,a.payment_trxid,g.payment_status,
a.switch_isin,a.nav,a.navdate,a.order_nav,a.order_navdate,a.order_type,
--case when g.vendor_trx_status is null then '' else g.order_remarks end as order_remarks,
g.order_remarks,
a.vendor_exchg_refno, 
date_trunc('second',g.created_date) as created_date,a.mf_schcode,
a.switch_mf_schcode,g.final_status,
cast(g.display_trx_id ||'-'||g.trx_id as character varying) as display_trx_id,
coalesce(c.totalinstallment_paid,0) as noofinstallmentspaid,
e.internal_type as mandate_type,d.bankname,d.bank_ac_number,
coalesce(g.installment_date_post_pause_resume,c.upcoming_due_date) as next_installment_date,a.trx_qty as quantity,
coalesce(g.frequency, c.frequency) frequency,c.start_date as first_installment_date,
CASE WHEN g.inv_action_code = 3 AND g.start_day IS NOT NULL 
THEN (EXTRACT('Days' FROM g.start_day::date))::character varying
ELSE (
--case when coalesce(c.start_day,'')='' then (TO_CHAR(coalesce(installment_date_post_pause_resume,sip_date), 'DD'))
case when coalesce((LPAD(TO_CHAR(c.start_date ::date, 'DD'), 2, '0')::int)::character varying,'')='' then (TO_CHAR(coalesce(installment_date_post_pause_resume,sip_date), 'DD'))
else 
--c.start_day 
(LPAD(TO_CHAR(c.start_date ::date, 'DD'), 2, '0')::int)::character varying
end) 
END:: character varying as start_day,
c.totalinstallmentamt_paid as totalinstallmentamtpaid,
a.schemegroup,
g.no_of_inst_paused as pausecount,g.datasource,null as lead_id,INITCAP(g.isinname)::character varying isinname,
null::boolean as is_generatetoday
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number,
null as payment_method,c.reg_no,g.inv_action_code,g.inv_type_code,g.inv_type,b.pan,
sch.sch_plan,c.end_date,isin.schemecode as grpcode--,sch.sch_type
,(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(b.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(g.final_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(b.clienttier,'Blue') as clienttier,
'Child'::character varying as typeoforder, a.tokenno,
NULL::character varying as switch_isin_name,null::int as installment_number,
c.no_of_installment as tenure,
a.folio_no,c.start_date
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,
NULL:: character varying as krafolio_status,g.order_placed_by
,g.trx_type_code,g.vendor_trx_status,g.created_for,g.created_for_name
from transactions.mf_order_detail a
--temp_mf_order_detail a
inner join master.dim_ucc b ON a.ucccode = b.ucccode
left join transactions.mf_order_summary c ON a.trx_id = c.trx_id
left join transactions.mf_mandate d on a.mandate_id =d.mandateid
left join master.mandate_type e on d.mandate_type=e.mandate_type
inner join master.trx_type f on a.trx_type_code = f.trx_type_code and f.category_code=261
inner join transactions.mf_order_detail_modification g on a.trx_id=g.org_trx_id
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode	
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
WHERE g.created_date::date BETWEEN v_fromdate AND v_todate
and g.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and g.final_status is not null
)A
left join master.dim_mf_order_remarks B
on upper(a.order_remarks) = upper(b.dion_order_remarks)
left join (
select 
a.ucccode,a.priority_ac_code,a.user_type,
case when a.user_type='E' then a.client_owner
when a.user_type='P' then a.partner_code end as client_owner,
case when a.user_type='E' then a.client_owner_name
when a.user_type='P' then a.partner_name end as client_owner_name,
(case 
when Upper(substr(a.pan, 4, 1))='H' then 'huf'
when Upper(substr(a.pan, 4, 1))='P' then 'individual'
when a.is_individual=true 
and extract(year from age(NOW(), a.birthdate))::numeric::int<18
then 'minor'
when a.is_individual=true then 'individual'
when a.is_individual=false then 'non-individual' end)::character varying kacctype,
a.dp_flag,a.direct_plan_enabled_flg,a.krastatus
from master.dim_ucc a
--where a.ucccode in (select ucc.ucccode from temp_mf_ucc ucc)
)C
on A.ucccode=C.ucccode
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by created_date desc;
-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
DROP TABLE temp_mf_order_detail;
-------------------------------------------------------------

END;

$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_16sept2025(varchar, varchar, date, date, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_16sept2025(varchar, varchar, date, date, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_16sept2025(varchar, varchar, date, date, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_16sept2025(varchar, varchar, date, date, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_detail_bkp_16sept2025(varchar, varchar, date, date, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_overview(int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_overview(v_trx_type_code integer, v_ac_code character varying)
 RETURNS TABLE(ac_code character varying, ac_name character varying, trx_type character varying, total_amount_paid bigint, active_count bigint, upcoming_count bigint, monthly_total numeric, paused_count bigint)
 LANGUAGE plpgsql
AS $function$

DECLARE
v_ucccode character varying;
	
BEGIN

	v_ucccode := (select distinct a.ucccode
    from master.dim_ucc a
    WHERE a.priority_ac_code = v_ac_code);

    IF v_trx_type_code = 1 THEN
        RETURN QUERY
        SELECT --a.ac_code,
				v_ac_code as ac_code,
               a.ac_name,
               a.trx_type,
               a.total_amount_paid,
               a.active_count,
               a.upcoming_count,
               COALESCE(b.monthly_total, 0) AS monthly_total,
               COALESCE(c.paused_count, 0) AS paused_count
        FROM (
            SELECT a.ucccode,
                   a.ac_name,
                   a.trx_type,
                   SUM(a.totalinstallmentamtpaid) AS total_amount_paid,
                   COUNT(1) AS active_count,
                   SUM(result) AS upcoming_count
            FROM (
                SELECT 
				a.ucccode,c.acname as ac_name,a.vendor_trx_id as internalrefno,
				b.reg_no as sipregnnumber,b.start_date as regndate,
				b.trx_amt as installmentamt,b.upcoming_due_date as duedate,
				b.previous_paid_date as prevpaiddate,
				b.totalinstallment_paid as noofinstallmentspaid,
				totalinstallmentamt_paid as totalinstallmentamtpaid,
				b.trx_type,
				CASE 
				WHEN EXTRACT(YEAR FROM upcoming_due_date) = EXTRACT(YEAR FROM CURRENT_DATE) 
				AND EXTRACT(MONTH FROM upcoming_due_date) = EXTRACT(MONTH FROM CURRENT_DATE) 
				THEN 1 ELSE 0
				END AS result
				from transactions.mf_order_detail a
				inner join transactions.mf_order_summary b on a.trx_id = b.trx_id
				inner join master.dim_ucc c on a.ucccode = c.ucccode
                WHERE a.ucccode=v_ucccode
				and upper(a.trx_type) ilike'%SIP%'
            ) A
            GROUP BY a.ucccode, a.ac_name, a.trx_type
        ) a
        LEFT JOIN (
            SELECT a.ucccode,
                   a.trx_type,
                   SUM(b.trx_amt) AS monthly_total
            FROM 
		transactions.mf_order_detail a
		inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
            WHERE (
                (CAST(upcoming_due_date AS date) BETWEEN date_trunc('month', CURRENT_DATE)::date AND 
                (date_trunc('month', CURRENT_DATE) + interval '1 month - 1 day')::date)
                OR 
                (CAST(previous_paid_date AS date) BETWEEN date_trunc('month', CURRENT_DATE)::date AND 
                (date_trunc('month', CURRENT_DATE) + interval '1 month - 1 day')::date)
            )
		and upper(a.trx_type) ilike'%SIP%'
            GROUP BY a.ucccode, a.trx_type
        ) b
        ON a.ucccode = b.ucccode
           AND a.trx_type = b.trx_type
        LEFT JOIN (
            SELECT a.ucccode,
                   a.trx_type,
                   COUNT(1) AS paused_count
            from transactions.mf_order_detail a
		inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
            WHERE a.trx_status = 'PAUSE'
			and a.ucccode=v_ucccode
            --AND ac_code='80054845'
            GROUP BY a.ucccode, a.trx_type
        ) c
        ON a.ucccode = c.ucccode
           AND a.trx_type = c.trx_type
        WHERE a.ucccode = v_ucccode
		and upper(a.trx_type) ilike'%SIP%';
    END IF;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_overview(int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_overview(int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_overview(int4, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_overview(int4, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_overview(int4, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_summary(varchar, varchar, date, date, int4, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_summary(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_trx_type_code integer, v_ac_code character varying DEFAULT NULL::character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, trx_datetime timestamp without time zone, ac_code character varying, ac_name character varying, ucccode character varying, trx_source character varying, delivery_mode character varying, mandate_id character varying, mandatetype character varying, bankname character varying, accountnumber character varying, mf_schcode bigint, isincode character varying, trx_type character varying, trx_status character varying, reg_no bigint, trx_amt numeric, start_date date, end_date date, frequency character varying, noofinstallmentspaid integer, totalinstallmentamtpaid integer, cancellation_date date, switch_mf_schcode bigint, display_trx_id character varying, start_day character varying, next_installment_date date, previousinstallmentdate date, order_nav numeric, schemegroup character varying, pausecount integer, datasource character varying, final_status character varying, isinname character varying, is_generatetoday boolean, client_bank_name character varying, client_bank_ac_number character varying, payment_method character varying, inv_action_code integer, created_date timestamp without time zone, pan character varying, sch_plan character varying, order_remarks character varying, grpcode character varying, remarks character varying, search_key character varying, clienttier character varying, tokenno bigint, switch_isin_name character varying, tenure integer, folio_no character varying, user_type character varying, client_owner character varying, client_owner_name character varying, kacctype character varying, dp_flag character varying, direct_plan_enabled_flg character varying, maturity_status character varying, sub_broker_code character varying, sub_broker_name character varying, arn_code character varying, sub_broker_pass_pct numeric, order_placed_by character varying, created_for character varying, created_for_name character varying, krastatus character varying)
 LANGUAGE plpgsql
AS $function$
	
DECLARE v_logintype_new character varying;
	
BEGIN

IF v_fromdate IS NULL OR v_todate IS NULL THEN
RAISE EXCEPTION 'Invalid date range provided';
END IF;

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-- Determine effective login type
IF v_logintype = 'CLIENT' OR v_logintype = 'PARTNER' THEN
	v_logintype_new := v_logintype;

ELSIF v_logintype = 'RM' THEN
	IF EXISTS (
		SELECT 1 FROM master.map_emp_user_role a
		WHERE a.role_code = 467 
		  AND a.emp_id = (
			  SELECT b.emp_id FROM master.dim_employee b 
			  WHERE b.emp_code = v_logincode LIMIT 1
		  )
	) THEN
		v_logintype_new := 'ADMIN';

	ELSIF EXISTS (
		SELECT 1 FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'CXO' 
		  AND a.orderby = v_logincode LIMIT 1
	) THEN
		v_logintype_new := 'CXO';

	ELSIF EXISTS (
		SELECT 1
		FROM master.DIM_ED_EMPL_Manager_Matrix 
		WHERE ltrim(managercode, '0') = v_logincode
		GROUP BY managercode
		HAVING COUNT(1) > 2
	) THEN
		v_logintype_new := 'Hrchy';

		ELSIF EXISTS (
		SELECT 1 from master.dim_ucc
		where owner_code in (	
		select distinct owner_code from master.partner
		where owner_code = v_logincode
		)
	) THEN
		v_logintype_new := 'FRM';

	ELSE
		v_logintype_new := 'RM';
	END IF;

ELSE
	RAISE NOTICE 'Invalid logintype for login_code: %', v_logincode;
END IF;

RAISE NOTICE 'Resolved login type: %', v_logintype_new;

-----------------------------------------------------------------------
-- Create and populate temp tables based on login type
IF v_logintype_new = 'CLIENT' OR v_logintype_new = 'PARTNER' THEN

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;

	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

	INSERT INTO temp_mf_ucc(ucccode)
	SELECT DISTINCT a.ucccode
	FROM master.dim_ucc a
	WHERE CASE
		WHEN upper(v_logintype_new) = 'CLIENT' THEN a.priority_ac_code = v_logincode
		WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.upccode = v_logincode AND a.priority_ac_code = v_ac_code
		WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.upccode = v_logincode
		ELSE FALSE
	END;

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT a.*
	FROM transactions.mf_order_detail a
	INNER JOIN temp_mf_ucc b ON a.ucccode = b.ucccode
	WHERE a.created_date::date BETWEEN v_fromdate AND v_todate;
	--  AND a.final_status IS NOT NULL;

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'ADMIN' THEN

	 -- Set default date range for last 15 days
        v_fromdate := CURRENT_DATE - INTERVAL '15 days';
        v_todate   := CURRENT_DATE;

		RAISE NOTICE 'Resolved ADMIN from date: %', v_fromdate;
		RAISE NOTICE 'Resolved ADMIN to date: %', v_todate;

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT a.*
	FROM transactions.mf_order_detail a
	WHERE a.created_date::date BETWEEN v_fromdate AND v_todate;
	--  AND a.final_status IS NOT NULL;

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM temp_mf_order_detail a;

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'CXO' THEN

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT a.*
	FROM transactions.mf_order_detail a
	WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
	  AND a.natureoforder = 'CXO'
	  AND a.orderby = v_logincode
	  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code);
	--  AND a.final_status IS NOT NULL;

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM temp_mf_order_detail a;

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'Hrchy' THEN

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM master.dim_ucc a
	WHERE (
		coalesce(v_ac_code, '') <> '' AND
		a.client_owner IN (
			SELECT  ltrim(empcode, '0') as empcode
			FROM master.DIM_ED_EMPL_Manager_Matrix
			WHERE ltrim(managercode, '0') = v_logincode
		) AND a.priority_ac_code = v_ac_code
	)
	OR (
		coalesce(v_ac_code, '') = '' AND
		a.client_owner IN (
			SELECT  ltrim(empcode, '0') as empcode
			FROM master.DIM_ED_EMPL_Manager_Matrix
			WHERE ltrim(managercode, '0') = v_logincode
		)
	);

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT DISTINCT a.* FROM (
		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
		--  AND coalesce(a.natureoforder, 'Normal') = 'Normal'
		AND (a.natureoforder = 'Normal' OR a.natureoforder IS NULL)
		--  AND a.final_status IS NOT NULL

		UNION ALL

		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'CXO'
		  AND a.created_for IN (
			  SELECT  ltrim(empcode, '0') as empcode
			  FROM master.DIM_ED_EMPL_Manager_Matrix
			  WHERE ltrim(managercode, '0') = v_logincode
		  )
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
		--  AND a.final_status IS NOT NULL

		UNION ALL

		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'OpenArch'
		  AND a.created_for IN (
			  SELECT empcode
			  FROM master.DIM_ED_EMPL_Manager_Matrix
			  WHERE ltrim(managercode, '0') = v_logincode
		  )
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
		--  AND a.final_status IS NOT NULL
		
	) a
	WHERE a.trx_id NOT IN (
		SELECT a.trx_id FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'OpenArch'
		  AND a.created_for NOT IN (
			  SELECT empcode
			  FROM master.DIM_ED_EMPL_Manager_Matrix
			  WHERE ltrim(managercode, '0') = v_logincode
		  )
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
	--	  AND a.final_status IS NOT NULL
	);

-----------------------------------------------------------------------

ELSIF v_logintype_new = 'FRM' THEN

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT a.ucccode
	FROM master.dim_ucc a
	WHERE a.owner_code IN (
	        SELECT DISTINCT owner_code
	        FROM master.partner
	        WHERE owner_code = v_logincode
	    );
		/*
	AND (
	        (COALESCE(v_ac_code, '') <> '' 
	            AND a.client_owner = v_logincode 
	            AND a.priority_ac_code = v_ac_code)
	     OR 
	        (COALESCE(v_ac_code, '') = '' 
	            AND a.client_owner = v_logincode)
	    );
*/

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT DISTINCT a.* FROM (
		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
)a;

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'RM' THEN

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM master.dim_ucc a
	WHERE (
		coalesce(v_ac_code, '') <> '' AND
		a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	)
	OR (
		coalesce(v_ac_code, '') = '' AND
		a.client_owner = v_logincode
	);

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT DISTINCT a.* FROM (
		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
		--  AND coalesce(a.natureoforder, 'Normal') = 'Normal'
		AND (a.natureoforder = 'Normal' OR a.natureoforder IS NULL)
	--	  AND a.final_status IS NOT NULL

		UNION ALL

		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'CXO'
		  AND a.created_for = v_logincode
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
	--	  AND a.final_status IS NOT NULL

		UNION ALL

		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'OpenArch'
		  AND a.created_for = v_logincode
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
		--  AND a.final_status IS NOT NULL
		
	) a
	WHERE a.trx_id NOT IN (
		SELECT a.trx_id FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'OpenArch'
		  AND a.created_for = v_logincode
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
		--  AND a.final_status IS NOT NULL
	);

END IF;

-----------------------------------------------------------------------
-- Create indexes on temp table for performance
CREATE INDEX idx_temp_created_date ON temp_mf_order_detail (created_date);
CREATE INDEX idx_temp_trx_id ON temp_mf_order_detail (trx_id);

-----------------------------------------------------------------------
RAISE NOTICE 'temp_mf_order_detail populated';
----------------------------------------------------------------------------------
----------Get SIP Data
IF v_trx_type_code=1 THEN

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,
a.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,a.mandate_type,a.bankname,
a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,
-- a.next_installment_date,
(case when a.trx_final_status_code = 2 then null
else a.next_installment_date end)::date as next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,
--a.datasource,
(case when a.datasource='DION' then 'One Platform'
when a.datasource='optimum' then 'Partner Portal'
else 'One Platform' end):: character varying as datasource,
(CASE 
WHEN a.trx_id in ('419718','481782') then 'Matured'::character varying 
WHEN a.final_status is null or a.final_status='' then 'Updating Soon'
else a.final_status end
):: character varying as final_status,
--	a.final_status:: character varying as final_status,
	a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,
--a.order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
(
  CASE 
	WHEN a.trx_id in ('419718','481782') then 'This SIP is complete. You can view it in My holdings or place a new order'::character varying 
    WHEN v_logintype_new <> 'CLIENT' and a.trx_final_status_code = 7
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN v_logintype_new <> 'CLIENT' and a.trx_final_status_code = 6
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    WHEN v_logintype_new = 'CLIENT' and a.trx_final_status_code = 7
      THEN 'The order is awaiting your approval.'
		WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=1 and a.final_status = 'Order Rejected'
	and a.vendor_trx_id is null
	THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by='CLIENT' and a.inv_action_code=1 and a.trx_final_status_code = 6
      THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by<>'CLIENT' and a.inv_action_code=1 and a.trx_final_status_code = 6
      THEN 'You have rejected the order. Please contact your RM for assistance if needed.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=2 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the pause request.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=3 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the modification request.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=4 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the cancellation request.'
	WHEN v_logintype_new = 'CLIENT' and a.vendor_trx_id is not null and a.final_status = 'Order Rejected'
      THEN 'Your order was rejected by the Exchange. You may try again later.'
	WHEN v_logintype_new = 'CLIENT' and a.trx_final_status_code = 1
      THEN 'Your payment failed. Please retry to complete the order.'
	WHEN v_logintype_new = 'CLIENT' and a.trx_final_status_code = 3
      THEN 'Please complete the payment to proceed with the transaction'
	WHEN v_logintype_new = 'CLIENT' and a.final_status = 'Cancelled'
      THEN 'Your SIP has been cancelled. You can explore new investment opportunities.'
	WHEN v_logintype_new = 'CLIENT' and a.trx_final_status_code = 6 
      THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
when a.order_remarks ~* 'REGISTRATION ENTRY NOT EXISTS' then 'Request cannot be processed as order details were not found.'
	when a.order_remarks ~* 'Order Lapsed' then 'Order couldnt be processed. Please place a new request.'
	when a.order_remarks ~* 'X-SIP HAS BEEN REGISTERED, REG NO IS' then 'SIP registered successfully.'
	when a.order_remarks ~* 'X-SIP OR I-SIP CAN BE CANCELLED ONLY PRIOR TO 2 WORKING DAYS OF TRIGGER DATE' 
		then 'SIP can be cancelled only up to 2 working days before trigger.'
	when a.order_remarks ~* 'X-SIP OR I-SIP HAS BEEN ALREADY CANCELLED OR NOT EXISTS' 
		then 'SIP already cancelled. No further action needed.'
	when vendor_trx_status='CANCELLED' and a.order_remarks ~* 'X-SIP OR I-SIP WITH REGN NO' 
		then 'SIP Cancelled Successfully.'
	when vendor_trx_status='CANCELLED' and a.order_remarks ~* 'Xsip with Regn No' 
		then 'SIP Cancelled Successfully.'
		when vendor_trx_status='PAUSE' and a.order_remarks ~* 'DATA SAVED SUCCESSFULLY' 
		then 'SIP Paused Successfully.'
    when a.order_remarks ~* b.dion_order_remarks then INITCAP(b.internal_order_remarks)::character varying
	else INITCAP(a.order_remarks)::character varying
  END
)::character varying AS order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier, a.tokenno,
NULL::character varying as switch_isin_name,a.tenure,a.folio_no
,c.user_type,c.client_owner,c.client_owner_name,c.kacctype,c.dp_flag,c.direct_plan_enabled_flg
,(case when a.trx_id in (1,481685) then 'Maturing Soon' else NULL end)::character varying as maturity_status
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name,c.krastatus
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source,a.delivery_mode,b.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,
--b.start_day,
(CASE 
    WHEN b.trx_type_code IN (1, 2, 3) AND b.start_day IS NOT NULL 
        THEN LPAD(b.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(b.start_day, '') = '' 
                THEN TO_CHAR(b.start_date, 'DD')
            ELSE LPAD(b.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
a.schemegroup, 
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno,
NULL::character varying as switch_isin_name,
b.no_of_installment as tenure,
a.trx_final_status_code,a.folio_no
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.vendor_trx_status,a.created_for,a.created_for_name
from temp_mf_order_detail a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.trx_type_code=1
and b.inv_plan_status is not null
)a
left join master.dim_mf_order_remarks b
on upper(a.order_remarks) = upper(b.dion_order_remarks)
left join (
select 
a.ucccode,a.priority_ac_code,a.user_type,
case when a.user_type='E' then a.client_owner
when a.user_type='P' then a.partner_code end as client_owner,
case when a.user_type='E' then a.client_owner_name
when a.user_type='P' then a.partner_name end as client_owner_name,
(case when a.is_individual=true 
and extract(year from age(NOW(), a.birthdate))::numeric::int<18
then 'minor'
when a.is_individual=true then 'individual'
when a.is_individual=false then 'non-individual' end)::character varying kacctype,
a.dp_flag,a.direct_plan_enabled_flg,a.krastatus
from master.dim_ucc a
where a.ucccode in (select ucc.ucccode from temp_mf_ucc ucc)
)C
on A.ucccode=C.ucccode
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.created_date;

END IF;

----------Get STP Data
IF v_trx_type_code=2 THEN

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name 
,a.ucccode,a.trx_source,a.delivery_mode,a.mandate_id,a.mandate_type,
a.bankname,a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,
--a.next_installment_date,
(case when a.trx_final_status_code = 2 then null
else a.next_installment_date end)::date as next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,
--a.datasource,
(case when a.datasource='DION' then 'One Platform'
when a.datasource='optimum' then 'Partner Portal'
else 'One Platform' end):: character varying as datasource,
--a.final_status,
case when a.final_status is null or a.final_status='' then 'Updating Soon' 
else a.final_status end as final_status,
a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,
--a.order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
(
  CASE 
    WHEN a.trx_final_status_code = 7
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN a.trx_final_status_code = 6
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
  END
)::character varying AS order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier, a.tokenno,a.switch_isin_name,
a.tenure,a.folio_no,c.user_type,c.client_owner,c.client_owner_name,c.kacctype,
c.dp_flag,c.direct_plan_enabled_flg,NULL::character varying as maturity_status
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name,c.krastatus
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source
-- 	,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying as delivery_mode
	,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,	b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,
--b.start_day,
(CASE 
    WHEN b.trx_type_code IN (1, 2, 3) AND b.start_day IS NOT NULL 
        THEN LPAD(b.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(b.start_day, '') = '' 
                THEN TO_CHAR(b.start_date, 'DD')
            ELSE LPAD(b.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
a.schemegroup, 
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno,
(
case when a.trx_type_code =2 then INITCAP(isin_switch.isinname) 
else NULL end
)::character varying as switch_isin_name,
b.no_of_installment as tenure,
a.trx_final_status_code,a.folio_no
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name
from temp_mf_order_detail a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
left join master.dim_mf_isin isin_switch on a.switch_isin=isin_switch.isincode
where a.created_date::date between v_fromdate and v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.trx_type_code=2
and b.inv_plan_status is not null
)a
left join master.dim_mf_order_remarks b
on upper(a.order_remarks) = upper(b.dion_order_remarks)
left join (
select 
a.ucccode,a.priority_ac_code,a.user_type,
case when a.user_type='E' then a.client_owner
when a.user_type='P' then a.partner_code end as client_owner,
case when a.user_type='E' then a.client_owner_name
when a.user_type='P' then a.partner_name end as client_owner_name,
(case when a.is_individual=true 
and extract(year from age(NOW(), a.birthdate))::numeric::int<18
then 'minor'
when a.is_individual=true then 'individual'
when a.is_individual=false then 'non-individual' end)::character varying kacctype,
a.dp_flag,a.direct_plan_enabled_flg,a.krastatus
from master.dim_ucc a
where a.ucccode in (select ucc.ucccode from temp_mf_ucc ucc)
)C
on A.ucccode=C.ucccode
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.created_date;
END IF;

----------Get SWP Data
IF v_trx_type_code=3 THEN

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,
a.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,a.mandate_type,a.bankname,
a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,
--a.next_installment_date,
(case when a.trx_final_status_code = 2 then null
else a.next_installment_date end)::date as next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,
--a.datasource,
(case when a.datasource='DION' then 'One Platform'
when a.datasource='optimum' then 'Partner Portal'
else 'One Platform' end):: character varying as datasource,
--a.final_status,
case when a.final_status is null or a.final_status='' then 'Updating Soon' 
else a.final_status end as final_status,	
a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,
--a.order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
(
  CASE 
    WHEN a.trx_final_status_code = 7
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN a.trx_final_status_code = 6
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
  END
)::character varying AS order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier,a.tokenno,
NULL::character varying as switch_isin_name,a.tenure,a.folio_no
,c.user_type,c.client_owner,c.client_owner_name,c.kacctype,c.dp_flag,
c.direct_plan_enabled_flg,NULL::character varying as maturity_status
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name,c.krastatus
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source,a.delivery_mode,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,
--b.start_day,
(CASE 
    WHEN b.trx_type_code IN (1, 2, 3) AND b.start_day IS NOT NULL 
        THEN LPAD(b.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(b.start_day, '') = '' 
                THEN TO_CHAR(b.start_date, 'DD')
            ELSE LPAD(b.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
a.schemegroup, 
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday
--,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,
isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno,
NULL::character varying as switch_isin_name,
b.no_of_installment as tenure,
a.trx_final_status_code,a.folio_no
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name
from temp_mf_order_detail a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_order_detail a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.trx_type_code=3
and b.inv_plan_status is not null
)a
left join master.dim_mf_order_remarks b
on upper(a.order_remarks) = upper(b.dion_order_remarks)
left join (
select 
a.ucccode,a.priority_ac_code,a.user_type,
case when a.user_type='E' then a.client_owner
when a.user_type='P' then a.partner_code end as client_owner,
case when a.user_type='E' then a.client_owner_name
when a.user_type='P' then a.partner_name end as client_owner_name,
(case
when Upper(substr(a.pan, 4, 1))='H' then 'individual'
when Upper(substr(a.pan, 4, 1))='P' then 'individual'
when a.is_individual=true 
and extract(year from age(NOW(), a.birthdate))::numeric::int<18
then 'minor'
when a.is_individual=true then 'individual'
when a.is_individual=false then 'non-individual' end)::character varying kacctype,
a.dp_flag,a.direct_plan_enabled_flg,a.krastatus
from master.dim_ucc a
where a.ucccode in (select ucc.ucccode from temp_mf_ucc ucc)
)C
on A.ucccode=C.ucccode
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.created_date;
END IF;

-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
-------------------------------------------------------------
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_summary(varchar, varchar, date, date, int4, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary(varchar, varchar, date, date, int4, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary(varchar, varchar, date, date, int4, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary(varchar, varchar, date, date, int4, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary(varchar, varchar, date, date, int4, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_09may2025(varchar, varchar, date, date, int4, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_09may2025(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_trx_type_code integer, v_ac_code character varying DEFAULT NULL::character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, trx_datetime timestamp without time zone, ac_code character varying, ac_name character varying, ucccode character varying, trx_source character varying, delivery_mode character varying, mandate_id character varying, mandatetype character varying, bankname character varying, accountnumber character varying, mf_schcode bigint, isincode character varying, trx_type character varying, trx_status character varying, reg_no bigint, trx_amt numeric, start_date date, end_date date, frequency character varying, noofinstallmentspaid integer, totalinstallmentamtpaid integer, cancellation_date date, switch_mf_schcode bigint, display_trx_id character varying, start_day character varying, next_installment_date date, previousinstallmentdate date, order_nav numeric, schemegroup character varying, pausecount integer, datasource character varying, final_status character varying, isinname character varying, is_generatetoday boolean, client_bank_name character varying, client_bank_ac_number character varying, payment_method character varying, inv_action_code integer, created_date timestamp without time zone, pan character varying, sch_plan character varying, order_remarks character varying, grpcode character varying, remarks character varying, search_key character varying, clienttier character varying, tokenno bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_fromdate IS NULL OR v_todate IS NULL THEN
RAISE EXCEPTION 'Invalid date range provided';
END IF;

-------------Create temp table
CREATE TEMP TABLE IF NOT EXISTS temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

INSERT INTO temp_mf_ucc(ucccode)
SELECT DISTINCT a.ucccode
FROM master.dim_ucc a
WHERE
	CASE
	WHEN upper(v_logintype) = 'CLIENT' THEN a.priority_ac_code = v_logincode
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') <> '' THEN a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') = '' THEN a.client_owner = v_logincode
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.partnerowner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.partnerowner = v_logincode
	ELSE FALSE
END;

----------------------------------------------------------------------------------
----------Get SIP Data
IF v_trx_type_code=1 and v_search IS NULL THEN

RETURN QUERY
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(c.acname)::character varying as ac_name,
c.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,b.start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
----
--cast('N' as character varying)	as stpflag, 
--cast('N' as character varying)	as swpflag, 
--cast('N' as character varying)	as redallowed, 
--cast('N' as character varying)	as switchflag, 
a.schemegroup, 
--cast('N' as character varying)	as	pause_flag,
--cast('1' as character varying)	as pause_maximum_installments,
----
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno
from  --transactions.mf_order_detail a
(
select a.* from transactions.mf_order_detail a
where a.order_placed_by in ('RM','PARTNER')
union all
select a.* from transactions.mf_order_detail a
where (a.trx_datetime <= NOW() - interval '5 days' and a.order_placed_by not in ('RM','PARTNER'))
)a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and upper(a.trx_type) ilike'%SIP%'
and a.trx_type_code=1
and b.inv_plan_status is not null
order by a.created_date;

ELSIF v_trx_type_code=1 and v_search IS NOT NULL THEN
RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,
a.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,a.mandate_type,a.bankname,
a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,a.next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,a.datasource,
a.final_status,a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,a.order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier, a.tokenno
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source,a.delivery_mode,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,b.start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
----
--cast('N' as character varying)	as stpflag, 
--cast('N' as character varying)	as swpflag, 
--cast('N' as character varying)	as redallowed, 
--cast('N' as character varying)	as switchflag, 
a.schemegroup, 
--cast('N' as character varying)	as	pause_flag,
--cast('1' as character varying)	as pause_maximum_installments,
----
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno
from  --transactions.mf_order_detail a
(
select a.* from transactions.mf_order_detail a
where a.order_placed_by in ('RM','PARTNER')
union all
select a.* from transactions.mf_order_detail a
where (a.trx_datetime <= NOW() - interval '5 days' and a.order_placed_by not in ('RM','PARTNER'))
)a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and upper(a.trx_type) ilike'%SIP%'
and a.trx_type_code=1
and b.inv_plan_status is not null
)a
where a.search_key ~* v_search
order by a.created_date;

END IF;

----------Get STP Data
IF v_trx_type_code=2 and v_search IS NULL THEN

RETURN QUERY
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(c.acname)::character varying as ac_name,
c.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,	b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,b.start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
----
--cast('N' as character varying)	as stpflag, 
--cast('N' as character varying)	as swpflag, 
--cast('N' as character varying)	as redallowed, 
--cast('N' as character varying)	as switchflag, 
a.schemegroup, 
--cast('N' as character varying)	as	pause_flag,
--cast('1' as character varying)	as pause_maximum_installments,
----
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno
from  --transactions.mf_order_detail a
(
select a.* from transactions.mf_order_detail a
where a.order_placed_by in ('RM','PARTNER')
union all
select a.* from transactions.mf_order_detail a
where (a.trx_datetime <= NOW() - interval '5 days' and a.order_placed_by not in ('RM','PARTNER'))
)a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
inner join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and upper(a.trx_type) ilike'%STP%'
and a.trx_type_code=2
and b.inv_plan_status is not null
order by a.created_date;

ELSIF v_trx_type_code=2 and v_search IS NOT NULL THEN
RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name 
,a.ucccode,a.trx_source,INITCAP(a.delivery_mode) as delivery_mode,a.mandate_id,a.mandate_type,
a.bankname,a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,a.next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,a.datasource,
a.final_status,a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,a.order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier, a.tokenno
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source
-- 	,a.delivery_mode
	,case when a.delivery_mode='D' then 'DEMAT'
	when a.delivery_mode='P' then 'PHYSICAL'
	else a.delivery_mode end::character varying delivery_mode
	,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,	b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,b.start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
----
--cast('N' as character varying)	as stpflag, 
--cast('N' as character varying)	as swpflag, 
--cast('N' as character varying)	as redallowed, 
--cast('N' as character varying)	as switchflag, 
a.schemegroup, 
--cast('N' as character varying)	as	pause_flag,
--cast('1' as character varying)	as pause_maximum_installments,
----
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno
from  --transactions.mf_order_detail a
(
select a.* from transactions.mf_order_detail a
where a.order_placed_by in ('RM','PARTNER')
union all
select a.* from transactions.mf_order_detail a
where (a.trx_datetime <= NOW() - interval '5 days' and a.order_placed_by not in ('RM','PARTNER'))
)a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
inner join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and upper(a.trx_type) ilike'%STP%'
and a.trx_type_code=2
and b.inv_plan_status is not null
)a
where a.search_key ~* v_search
order by a.created_date;
END IF;

----------Get SWP Data
IF v_trx_type_code=3 and v_search IS NULL THEN

RETURN QUERY
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(c.acname)::character varying as ac_name,
c.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,b.start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
----
--cast('N' as character varying)	as stpflag, 
--cast('N' as character varying)	as swpflag, 
--cast('N' as character varying)	as redallowed, 
--cast('N' as character varying)	as switchflag, 
a.schemegroup, 
--cast('N' as character varying)	as	pause_flag,
--cast('1' as character varying)	as pause_maximum_installments,
----
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno
from  --transactions.mf_order_detail a
(
select a.* from transactions.mf_order_detail a
where a.order_placed_by in ('RM','PARTNER')
union all
select a.* from transactions.mf_order_detail a
where (a.trx_datetime <= NOW() - interval '5 days' and a.order_placed_by not in ('RM','PARTNER'))
)a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and upper(a.trx_type) ilike'%SWP%'
and a.trx_type_code=3
and b.inv_plan_status is not null
order by a.created_date;

ELSIF v_trx_type_code=3 and v_search IS NOT NULL THEN
RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,
a.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,a.mandate_type,a.bankname,
a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,a.next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,a.datasource,
a.final_status,a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,a.order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier, a.tokenno
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source,a.delivery_mode,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,b.start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
----
--cast('N' as character varying)	as stpflag, 
--cast('N' as character varying)	as swpflag, 
--cast('N' as character varying)	as redallowed, 
--cast('N' as character varying)	as switchflag, 
a.schemegroup, 
--cast('N' as character varying)	as	pause_flag,
--cast('1' as character varying)	as pause_maximum_installments,
----
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno
from  --transactions.mf_order_detail a
(
select a.* from transactions.mf_order_detail a
where a.order_placed_by in ('RM','PARTNER')
union all
select a.* from transactions.mf_order_detail a
where (a.trx_datetime <= NOW() - interval '5 days' and a.order_placed_by not in ('RM','PARTNER'))
)a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
--and upper(a.trx_type) ilike'%SWP%'
and a.trx_type_code=3
and b.inv_plan_status is not null
)a
where a.search_key ~* v_search
order by a.created_date;
END IF;

-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
-------------------------------------------------------------
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_09may2025(varchar, varchar, date, date, int4, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_09may2025(varchar, varchar, date, date, int4, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_09may2025(varchar, varchar, date, date, int4, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_09may2025(varchar, varchar, date, date, int4, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_09may2025(varchar, varchar, date, date, int4, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_14jul2025(varchar, varchar, date, date, int4, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_14jul2025(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_trx_type_code integer, v_ac_code character varying DEFAULT NULL::character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, trx_datetime timestamp without time zone, ac_code character varying, ac_name character varying, ucccode character varying, trx_source character varying, delivery_mode character varying, mandate_id character varying, mandatetype character varying, bankname character varying, accountnumber character varying, mf_schcode bigint, isincode character varying, trx_type character varying, trx_status character varying, reg_no bigint, trx_amt numeric, start_date date, end_date date, frequency character varying, noofinstallmentspaid integer, totalinstallmentamtpaid integer, cancellation_date date, switch_mf_schcode bigint, display_trx_id character varying, start_day character varying, next_installment_date date, previousinstallmentdate date, order_nav numeric, schemegroup character varying, pausecount integer, datasource character varying, final_status character varying, isinname character varying, is_generatetoday boolean, client_bank_name character varying, client_bank_ac_number character varying, payment_method character varying, inv_action_code integer, created_date timestamp without time zone, pan character varying, sch_plan character varying, order_remarks character varying, grpcode character varying, remarks character varying, search_key character varying, clienttier character varying, tokenno bigint, switch_isin_name character varying, tenure integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_fromdate IS NULL OR v_todate IS NULL THEN
RAISE EXCEPTION 'Invalid date range provided';
END IF;

-------------Create temp table
CREATE TEMP TABLE IF NOT EXISTS temp_mf_ucc AS 
SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

INSERT INTO temp_mf_ucc(ucccode)
SELECT DISTINCT a.ucccode
FROM master.dim_ucc a
WHERE
	CASE
	WHEN upper(v_logintype) = 'CLIENT' THEN a.priority_ac_code = v_logincode
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') <> '' THEN a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'RM' AND coalesce(v_ac_code, '') = '' THEN a.client_owner = v_logincode
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.partnerowner = v_logincode AND a.priority_ac_code = v_ac_code
	WHEN upper(v_logintype) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.partnerowner = v_logincode
	ELSE FALSE
END;

---------------------------------------
----to handle open architecture flow -RM
IF(v_logintype='RM' or v_logintype='PARTNER')
THEN 
drop table if exists temp_mf_order_detail_extra CASCADE;
create temp table temp_mf_order_detail_extra
as 
--actual RM
select a.* from transactions.mf_order_detail a
left join master.dim_ucc b
on a.ucccode = b.ucccode and b.client_owner=v_logincode
where a.order_placed_by in ('RM','PARTNER')
and a.created_date::date between v_fromdate and v_todate
and a.final_status is not null
and a.orderby<>b.client_owner;
--and a.orderby=v_logincode
--and b.ucccode is null

elsif (v_logintype='CLIENT')
THEN 
drop table if exists temp_mf_order_detail_extra CASCADE;
create temp table temp_mf_order_detail_extra
as 
select a.* from transactions.mf_order_detail a
where a.order_placed_by ='client'
and a.created_date::date BETWEEN v_fromdate AND v_todate
and a.ucccode not in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null
and a.orderby=v_logincode;
END IF;

----to handle open architecture flow -NON-RM
IF(v_logintype='RM' or v_logintype='PARTNER')
THEN 
drop table if exists temp_mf_order_detail_extra_nonrm CASCADE;
create temp table temp_mf_order_detail_extra_nonrm
as 
select a.* from transactions.mf_order_detail a
left join master.dim_ucc b
on a.ucccode = b.ucccode and b.client_owner=v_logincode
where a.order_placed_by in ('RM','PARTNER')
and a.created_date::date between v_fromdate and v_todate
and a.final_status is not null
and a.orderby=v_logincode
--and a.trx_id='385886'
and b.ucccode is null;

elsif (v_logintype='CLIENT')
THEN 
drop table if exists temp_mf_order_detail_extra_nonrm CASCADE;
create temp table temp_mf_order_detail_extra_nonrm
as 
select a.* from transactions.mf_order_detail a
left join master.dim_ucc b
on a.ucccode = b.ucccode and b.client_owner=v_logincode
where a.order_placed_by ='client'
and a.created_date::date between  v_fromdate AND v_todate
and a.final_status is not null
and a.orderby=v_logincode
--and a.trx_id='385886'
and b.ucccode is null;
END IF;

---------------------------------------
---------------------------------------
IF(v_logintype='RM' or v_logintype='PARTNER')
THEN 
-------------Create temp table
drop table if exists temp_mf_order_detail CASCADE;

create temp table temp_mf_order_detail 
as 
select a.* 
from (
select a.* from transactions.mf_order_detail a
where a.order_placed_by in ('RM','PARTNER')
union all
select a.* from transactions.mf_order_detail a
where (a.trx_datetime <= NOW() - interval '5 days' and a.order_placed_by not in ('RM','PARTNER'))
)a
WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null
and a.trx_id not in (select a.trx_id from temp_mf_order_detail_extra a)
union all
select * from temp_mf_order_detail_extra_nonrm;

elsif (v_logintype='CLIENT')
THEN 
-------------Create temp table
drop table if exists temp_mf_order_detail CASCADE;

create temp table temp_mf_order_detail 
as 
select a.* from transactions.mf_order_detail a
WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.final_status is not null;
	
END IF;

----------------------------------------
----------------------------------------------------------------------------------
----------Get SIP Data
IF v_trx_type_code=1 THEN

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,
a.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,a.mandate_type,a.bankname,
a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,
-- a.next_installment_date,
(case when a.trx_final_status_code = 2 then null
else a.next_installment_date end)::date as next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,a.datasource,
a.final_status,a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,
--a.order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
(
  CASE 
    WHEN a.trx_final_status_code = 7
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN a.trx_final_status_code = 6
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
  END
)::character varying AS order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier, a.tokenno,
NULL::character varying as switch_isin_name,a.tenure
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source,a.delivery_mode,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,
--b.start_day,
(CASE 
    WHEN b.trx_type_code IN (1, 2, 3) AND b.start_day IS NOT NULL 
        THEN LPAD(b.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(b.start_day, '') = '' 
                THEN TO_CHAR(b.start_date, 'DD')
            ELSE LPAD(b.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
a.schemegroup, 
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno,
NULL::character varying as switch_isin_name,
b.no_of_installment as tenure,
a.trx_final_status_code
from  temp_mf_order_detail a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.trx_type_code=1
and b.inv_plan_status is not null
)a
left join master.dim_mf_order_remarks b
on upper(a.order_remarks) = upper(b.dion_order_remarks)
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.created_date;

END IF;

----------Get STP Data
IF v_trx_type_code=2 THEN

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name 
,a.ucccode,a.trx_source,a.delivery_mode,a.mandate_id,a.mandate_type,
a.bankname,a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,
-- a.next_installment_date,
(case when a.trx_final_status_code = 2 then null
else a.next_installment_date end)::date as next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,a.datasource,
a.final_status,a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,
--a.order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
(
  CASE 
    WHEN a.trx_final_status_code = 7
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN a.trx_final_status_code = 6
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
  END
)::character varying AS order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier, a.tokenno,a.switch_isin_name,
a.tenure
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source
-- 	,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying as delivery_mode
	,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,	b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,
--b.start_day,
(CASE 
    WHEN b.trx_type_code IN (1, 2, 3) AND b.start_day IS NOT NULL 
        THEN LPAD(b.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(b.start_day, '') = '' 
                THEN TO_CHAR(b.start_date, 'DD')
            ELSE LPAD(b.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
a.schemegroup, 
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno,
(
case when a.trx_type_code =2 then INITCAP(isin_switch.isinname) 
else NULL end
)::character varying as switch_isin_name,
b.no_of_installment as tenure,
a.trx_final_status_code
from temp_mf_order_detail a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
left join master.dim_mf_isin isin_switch on a.switch_isin=isin_switch.isincode
where a.created_date::date between v_fromdate and v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.trx_type_code=2
and b.inv_plan_status is not null
)a
left join master.dim_mf_order_remarks b
on upper(a.order_remarks) = upper(b.dion_order_remarks)
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.created_date;
END IF;

----------Get SWP Data
IF v_trx_type_code=3 THEN

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,
a.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,a.mandate_type,a.bankname,
a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,
-- a.next_installment_date,
(case when a.trx_final_status_code = 2 then null
else a.next_installment_date end)::date as next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,a.datasource,
a.final_status,a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,
--a.order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
(
  CASE 
    WHEN a.trx_final_status_code = 7
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN a.trx_final_status_code = 6
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
  END
)::character varying AS order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier,a.tokenno,
NULL::character varying as switch_isin_name,a.tenure
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source,a.delivery_mode,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,
--b.start_day,
(CASE 
    WHEN b.trx_type_code IN (1, 2, 3) AND b.start_day IS NOT NULL 
        THEN LPAD(b.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(b.start_day, '') = '' 
                THEN TO_CHAR(b.start_date, 'DD')
            ELSE LPAD(b.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
a.schemegroup, 
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday
--,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,
isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno,
NULL::character varying as switch_isin_name,
b.no_of_installment as tenure,
a.trx_final_status_code
from temp_mf_order_detail a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_order_detail a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.trx_type_code=3
and b.inv_plan_status is not null
)a
left join master.dim_mf_order_remarks b
on upper(a.order_remarks) = upper(b.dion_order_remarks)
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.created_date;
END IF;

-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
-------------------------------------------------------------
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_14jul2025(varchar, varchar, date, date, int4, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_14jul2025(varchar, varchar, date, date, int4, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_14jul2025(varchar, varchar, date, date, int4, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_14jul2025(varchar, varchar, date, date, int4, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_14jul2025(varchar, varchar, date, date, int4, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_16nov2025(varchar, varchar, date, date, int4, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_16nov2025(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_trx_type_code integer, v_ac_code character varying DEFAULT NULL::character varying, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, trx_datetime timestamp without time zone, ac_code character varying, ac_name character varying, ucccode character varying, trx_source character varying, delivery_mode character varying, mandate_id character varying, mandatetype character varying, bankname character varying, accountnumber character varying, mf_schcode bigint, isincode character varying, trx_type character varying, trx_status character varying, reg_no bigint, trx_amt numeric, start_date date, end_date date, frequency character varying, noofinstallmentspaid integer, totalinstallmentamtpaid integer, cancellation_date date, switch_mf_schcode bigint, display_trx_id character varying, start_day character varying, next_installment_date date, previousinstallmentdate date, order_nav numeric, schemegroup character varying, pausecount integer, datasource character varying, final_status character varying, isinname character varying, is_generatetoday boolean, client_bank_name character varying, client_bank_ac_number character varying, payment_method character varying, inv_action_code integer, created_date timestamp without time zone, pan character varying, sch_plan character varying, order_remarks character varying, grpcode character varying, remarks character varying, search_key character varying, clienttier character varying, tokenno bigint, switch_isin_name character varying, tenure integer, folio_no character varying, user_type character varying, client_owner character varying, client_owner_name character varying, kacctype character varying, dp_flag character varying, direct_plan_enabled_flg character varying, maturity_status character varying, sub_broker_code character varying, sub_broker_name character varying, arn_code character varying, sub_broker_pass_pct numeric, order_placed_by character varying, created_for character varying, created_for_name character varying, krastatus character varying)
 LANGUAGE plpgsql
AS $function$
	
DECLARE v_logintype_new character varying;
	
BEGIN

IF v_fromdate IS NULL OR v_todate IS NULL THEN
RAISE EXCEPTION 'Invalid date range provided';
END IF;

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-- Determine effective login type
IF v_logintype = 'CLIENT' OR v_logintype = 'PARTNER' THEN
	v_logintype_new := v_logintype;

ELSIF v_logintype = 'RM' THEN
	IF EXISTS (
		SELECT 1 FROM master.map_emp_user_role a
		WHERE a.role_code = 467 
		  AND a.emp_id = (
			  SELECT b.emp_id FROM master.dim_employee b 
			  WHERE b.emp_code = v_logincode LIMIT 1
		  )
	) THEN
		v_logintype_new := 'ADMIN';

	ELSIF EXISTS (
		SELECT 1 FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'CXO' 
		  AND a.orderby = v_logincode LIMIT 1
	) THEN
		v_logintype_new := 'CXO';

	ELSIF EXISTS (
		SELECT 1
		FROM master.DIM_ED_EMPL_Manager_Matrix 
		WHERE ltrim(managercode, '0') = v_logincode
		GROUP BY managercode
		HAVING COUNT(1) > 2
	) THEN
		v_logintype_new := 'Hrchy';

	ELSE
		v_logintype_new := 'RM';
	END IF;

ELSE
	RAISE NOTICE 'Invalid logintype for login_code: %', v_logincode;
END IF;

RAISE NOTICE 'Resolved login type: %', v_logintype_new;

-----------------------------------------------------------------------
-- Create and populate temp tables based on login type
IF v_logintype_new = 'CLIENT' OR v_logintype_new = 'PARTNER' THEN

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;

	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM master.dim_ucc a WHERE 1=0;

	INSERT INTO temp_mf_ucc(ucccode)
	SELECT DISTINCT a.ucccode
	FROM master.dim_ucc a
	WHERE CASE
		WHEN upper(v_logintype_new) = 'CLIENT' THEN a.priority_ac_code = v_logincode
		WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') <> '' THEN a.upccode = v_logincode AND a.priority_ac_code = v_ac_code
		WHEN upper(v_logintype_new) = 'PARTNER' AND coalesce(v_ac_code, '') = '' THEN a.upccode = v_logincode
		ELSE FALSE
	END;

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT a.*
	FROM transactions.mf_order_detail a
	INNER JOIN temp_mf_ucc b ON a.ucccode = b.ucccode
	WHERE a.created_date::date BETWEEN v_fromdate AND v_todate;
	--  AND a.final_status IS NOT NULL;

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'ADMIN' THEN

	 -- Set default date range for last 15 days
        v_fromdate := CURRENT_DATE - INTERVAL '15 days';
        v_todate   := CURRENT_DATE;

		RAISE NOTICE 'Resolved ADMIN from date: %', v_fromdate;
		RAISE NOTICE 'Resolved ADMIN to date: %', v_todate;

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT a.*
	FROM transactions.mf_order_detail a
	WHERE a.created_date::date BETWEEN v_fromdate AND v_todate;
	--  AND a.final_status IS NOT NULL;

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM temp_mf_order_detail a;

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'CXO' THEN

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT a.*
	FROM transactions.mf_order_detail a
	WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
	  AND a.natureoforder = 'CXO'
	  AND a.orderby = v_logincode
	  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code);
	--  AND a.final_status IS NOT NULL;

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM temp_mf_order_detail a;

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'Hrchy' THEN

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM master.dim_ucc a
	WHERE (
		coalesce(v_ac_code, '') <> '' AND
		a.client_owner IN (
			SELECT  ltrim(empcode, '0') as empcode
			FROM master.DIM_ED_EMPL_Manager_Matrix
			WHERE ltrim(managercode, '0') = v_logincode
		) AND a.priority_ac_code = v_ac_code
	)
	OR (
		coalesce(v_ac_code, '') = '' AND
		a.client_owner IN (
			SELECT  ltrim(empcode, '0') as empcode
			FROM master.DIM_ED_EMPL_Manager_Matrix
			WHERE ltrim(managercode, '0') = v_logincode
		)
	);

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT DISTINCT a.* FROM (
		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
		--  AND coalesce(a.natureoforder, 'Normal') = 'Normal'
		AND (a.natureoforder = 'Normal' OR a.natureoforder IS NULL)
		--  AND a.final_status IS NOT NULL

		UNION ALL

		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'CXO'
		  AND a.created_for IN (
			  SELECT  ltrim(empcode, '0') as empcode
			  FROM master.DIM_ED_EMPL_Manager_Matrix
			  WHERE ltrim(managercode, '0') = v_logincode
		  )
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
		--  AND a.final_status IS NOT NULL

		UNION ALL

		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'OpenArch'
		  AND a.created_for IN (
			  SELECT empcode
			  FROM master.DIM_ED_EMPL_Manager_Matrix
			  WHERE ltrim(managercode, '0') = v_logincode
		  )
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
		--  AND a.final_status IS NOT NULL
		
	) a
	WHERE a.trx_id NOT IN (
		SELECT a.trx_id FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'OpenArch'
		  AND a.created_for NOT IN (
			  SELECT empcode
			  FROM master.DIM_ED_EMPL_Manager_Matrix
			  WHERE ltrim(managercode, '0') = v_logincode
		  )
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
	--	  AND a.final_status IS NOT NULL
	);

-----------------------------------------------------------------------
ELSIF v_logintype_new = 'RM' THEN

	DROP TABLE IF EXISTS temp_mf_ucc CASCADE;
	CREATE TEMP TABLE temp_mf_ucc AS 
	SELECT DISTINCT a.ucccode FROM master.dim_ucc a
	WHERE (
		coalesce(v_ac_code, '') <> '' AND
		a.client_owner = v_logincode AND a.priority_ac_code = v_ac_code
	)
	OR (
		coalesce(v_ac_code, '') = '' AND
		a.client_owner = v_logincode
	);

	DROP TABLE IF EXISTS temp_mf_order_detail CASCADE;
	CREATE TEMP TABLE temp_mf_order_detail AS
	SELECT DISTINCT a.* FROM (
		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.ucccode IN (SELECT a.ucccode FROM temp_mf_ucc a)
		--  AND coalesce(a.natureoforder, 'Normal') = 'Normal'
		AND (a.natureoforder = 'Normal' OR a.natureoforder IS NULL)
	--	  AND a.final_status IS NOT NULL

		UNION ALL

		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'CXO'
		  AND a.created_for = v_logincode
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
	--	  AND a.final_status IS NOT NULL

		UNION ALL

		SELECT a.* FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'OpenArch'
		  AND a.created_for = v_logincode
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
		--  AND a.final_status IS NOT NULL
		
	) a
	WHERE a.trx_id NOT IN (
		SELECT a.trx_id FROM transactions.mf_order_detail a
		WHERE a.created_date::date BETWEEN v_fromdate AND v_todate
		  AND a.natureoforder = 'OpenArch'
		  AND a.created_for = v_logincode
		  AND (coalesce(v_ac_code, '') = '' OR a.ac_code ~* v_ac_code)
		--  AND a.final_status IS NOT NULL
	);

END IF;

-----------------------------------------------------------------------
-- Create indexes on temp table for performance
CREATE INDEX idx_temp_created_date ON temp_mf_order_detail (created_date);
CREATE INDEX idx_temp_trx_id ON temp_mf_order_detail (trx_id);

-----------------------------------------------------------------------
RAISE NOTICE 'temp_mf_order_detail populated';
----------------------------------------------------------------------------------
----------Get SIP Data
IF v_trx_type_code=1 THEN

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,
a.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,a.mandate_type,a.bankname,
a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,
-- a.next_installment_date,
(case when a.trx_final_status_code = 2 then null
else a.next_installment_date end)::date as next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,
--a.datasource,
(case when a.datasource='DION' then 'One Platform'
when a.datasource='optimum' then 'Partner Portal'
else 'One Platform' end):: character varying as datasource,
(CASE 
WHEN a.trx_id in ('419718','481782') then 'Matured'::character varying 
WHEN a.final_status is null or a.final_status='' then 'Updating Soon'
else a.final_status end
):: character varying as final_status,
--	a.final_status:: character varying as final_status,
	a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,
--a.order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
(
  CASE 
	WHEN a.trx_id in ('419718','481782') then 'This SIP is complete. You can view it in My holdings or place a new order'::character varying 
    WHEN v_logintype_new <> 'CLIENT' and a.trx_final_status_code = 7
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN v_logintype_new <> 'CLIENT' and a.trx_final_status_code = 6
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    WHEN v_logintype_new = 'CLIENT' and a.trx_final_status_code = 7
      THEN 'The order is awaiting your approval.'
		WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=1 and a.final_status = 'Order Rejected'
	and a.vendor_trx_id is null
	THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by='CLIENT' and a.inv_action_code=1 and a.trx_final_status_code = 6
      THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
	WHEN v_logintype_new = 'CLIENT' and a.order_placed_by<>'CLIENT' and a.inv_action_code=1 and a.trx_final_status_code = 6
      THEN 'You have rejected the order. Please contact your RM for assistance if needed.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=2 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the pause request.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=3 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the modification request.'
	WHEN v_logintype_new = 'CLIENT' and a.inv_action_code=4 and a.final_status = 'Consent Rejected'
      THEN 'You have rejected the cancellation request.'
	WHEN v_logintype_new = 'CLIENT' and a.vendor_trx_id is not null and a.final_status = 'Order Rejected'
      THEN 'Your order was rejected by the Exchange. You may try again later.'
	WHEN v_logintype_new = 'CLIENT' and a.trx_final_status_code = 1
      THEN 'Your payment failed. Please retry to complete the order.'
	WHEN v_logintype_new = 'CLIENT' and a.trx_final_status_code = 3
      THEN 'Please complete the payment to proceed with the transaction'
	WHEN v_logintype_new = 'CLIENT' and a.final_status = 'Cancelled'
      THEN 'Your SIP has been cancelled. You can explore new investment opportunities.'
	WHEN v_logintype_new = 'CLIENT' and a.trx_final_status_code = 6 
      THEN 'Youve rejected the order. If this was a mistake, please connect with your RM.'
    ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
  END
)::character varying AS order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier, a.tokenno,
NULL::character varying as switch_isin_name,a.tenure,a.folio_no
,c.user_type,c.client_owner,c.client_owner_name,c.kacctype,c.dp_flag,c.direct_plan_enabled_flg
,(case when a.trx_id in (1,481685) then 'Maturing Soon' else NULL end)::character varying as maturity_status
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name,c.krastatus
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source,a.delivery_mode,b.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,
--b.start_day,
(CASE 
    WHEN b.trx_type_code IN (1, 2, 3) AND b.start_day IS NOT NULL 
        THEN LPAD(b.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(b.start_day, '') = '' 
                THEN TO_CHAR(b.start_date, 'DD')
            ELSE LPAD(b.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
a.schemegroup, 
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno,
NULL::character varying as switch_isin_name,
b.no_of_installment as tenure,
a.trx_final_status_code,a.folio_no
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.vendor_trx_status,a.created_for,a.created_for_name
from temp_mf_order_detail a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.trx_type_code=1
and b.inv_plan_status is not null
)a
left join master.dim_mf_order_remarks b
on upper(a.order_remarks) = upper(b.dion_order_remarks)
left join (
select 
a.ucccode,a.priority_ac_code,a.user_type,
case when a.user_type='E' then a.client_owner
when a.user_type='P' then a.partner_code end as client_owner,
case when a.user_type='E' then a.client_owner_name
when a.user_type='P' then a.partner_name end as client_owner_name,
(case when a.is_individual=true 
and extract(year from age(NOW(), a.birthdate))::numeric::int<18
then 'minor'
when a.is_individual=true then 'individual'
when a.is_individual=false then 'non-individual' end)::character varying kacctype,
a.dp_flag,a.direct_plan_enabled_flg,a.krastatus
from master.dim_ucc a
where a.ucccode in (select ucc.ucccode from temp_mf_ucc ucc)
)C
on A.ucccode=C.ucccode
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.created_date;

END IF;

----------Get STP Data
IF v_trx_type_code=2 THEN

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name 
,a.ucccode,a.trx_source,a.delivery_mode,a.mandate_id,a.mandate_type,
a.bankname,a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,
--a.next_installment_date,
(case when a.trx_final_status_code = 2 then null
else a.next_installment_date end)::date as next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,
--a.datasource,
(case when a.datasource='DION' then 'One Platform'
when a.datasource='optimum' then 'Partner Portal'
else 'One Platform' end):: character varying as datasource,
--a.final_status,
case when a.final_status is null or a.final_status='' then 'Updating Soon' 
else a.final_status end as final_status,
a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,
--a.order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
(
  CASE 
    WHEN a.trx_final_status_code = 7
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN a.trx_final_status_code = 6
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
  END
)::character varying AS order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier, a.tokenno,a.switch_isin_name,
a.tenure,a.folio_no,c.user_type,c.client_owner,c.client_owner_name,c.kacctype,
c.dp_flag,c.direct_plan_enabled_flg,NULL::character varying as maturity_status
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name,c.krastatus
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source
-- 	,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying as delivery_mode
	,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,	b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,
--b.start_day,
(CASE 
    WHEN b.trx_type_code IN (1, 2, 3) AND b.start_day IS NOT NULL 
        THEN LPAD(b.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(b.start_day, '') = '' 
                THEN TO_CHAR(b.start_date, 'DD')
            ELSE LPAD(b.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
a.schemegroup, 
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno,
(
case when a.trx_type_code =2 then INITCAP(isin_switch.isinname) 
else NULL end
)::character varying as switch_isin_name,
b.no_of_installment as tenure,
a.trx_final_status_code,a.folio_no
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name
from temp_mf_order_detail a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
left join master.dim_mf_isin isin_switch on a.switch_isin=isin_switch.isincode
where a.created_date::date between v_fromdate and v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.trx_type_code=2
and b.inv_plan_status is not null
)a
left join master.dim_mf_order_remarks b
on upper(a.order_remarks) = upper(b.dion_order_remarks)
left join (
select 
a.ucccode,a.priority_ac_code,a.user_type,
case when a.user_type='E' then a.client_owner
when a.user_type='P' then a.partner_code end as client_owner,
case when a.user_type='E' then a.client_owner_name
when a.user_type='P' then a.partner_name end as client_owner_name,
(case when a.is_individual=true 
and extract(year from age(NOW(), a.birthdate))::numeric::int<18
then 'minor'
when a.is_individual=true then 'individual'
when a.is_individual=false then 'non-individual' end)::character varying kacctype,
a.dp_flag,a.direct_plan_enabled_flg,a.krastatus
from master.dim_ucc a
where a.ucccode in (select ucc.ucccode from temp_mf_ucc ucc)
)C
on A.ucccode=C.ucccode
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.created_date;
END IF;

----------Get SWP Data
IF v_trx_type_code=3 THEN

RETURN QUERY
select
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,INITCAP(a.ac_name)::character varying as ac_name,
a.ucccode,a.trx_source
-- ,a.delivery_mode
,INITCAP(case when a.delivery_mode='D' then 'DEMAT'
when a.delivery_mode='P' then 'PHYSICAL'
else a.delivery_mode end)::character varying delivery_mode
,a.mandate_id,a.mandate_type,a.bankname,
a.accountnumber,a.mf_schcode,a.isincode,a.trx_type,a.trx_status,
a.reg_no,a.trx_amt,a.start_date,a.end_date,a.frequency,
a.noofinstallmentspaid,a.totalinstallmentamtpaid,a.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,a.start_day,
--a.next_installment_date,
(case when a.trx_final_status_code = 2 then null
else a.next_installment_date end)::date as next_installment_date,
a.previousinstallmentdate,a.order_nav,a.schemegroup,a.pausecount,
--a.datasource,
(case when a.datasource='DION' then 'One Platform'
when a.datasource='optimum' then 'Partner Portal'
else 'One Platform' end):: character varying as datasource,
--a.final_status,
case when a.final_status is null or a.final_status='' then 'Updating Soon' 
else a.final_status end as final_status,	
a.isinname,a.is_generatetoday,a.client_bank_name,a.client_bank_ac_number,
a.payment_method,a.inv_action_code,a.created_date,a.pan,a.sch_plan,
--a.order_remarks,
--coalesce(b.internal_order_remarks,a.order_remarks) as order_remarks,
(
  CASE 
    WHEN a.trx_final_status_code = 7
      THEN 'The order is awaiting ' || INITCAP(a.ac_name)::character varying || ' approval.'
    WHEN a.trx_final_status_code = 6
      THEN 'This order was rejected by the client ' || INITCAP(a.ac_name)::character varying || '.'
    ELSE COALESCE(b.internal_order_remarks, a.order_remarks) 
  END
)::character varying AS order_remarks,
a.grpcode,a.remarks,a.search_key,a.clienttier,a.tokenno,
NULL::character varying as switch_isin_name,a.tenure,a.folio_no
,c.user_type,c.client_owner,c.client_owner_name,c.kacctype,c.dp_flag,
c.direct_plan_enabled_flg,NULL::character varying as maturity_status
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name,c.krastatus
from (
select 
a.trx_id,a.vendor_trx_id,a.trx_datetime,a.ac_code,c.acname as ac_name,c.ucccode,
a.trx_source,a.delivery_mode,a.mandate_id,--e.mandate_type as mandatetype,
f.internal_type as mandate_type,
e.bankname,e.bank_ac_number as accountnumber,a.mf_schcode,b.isincode,
d.trx_type,b.trx_status,b.reg_no,b.trx_amt,b.start_date,b.end_date,
b.frequency,coalesce(b.totalinstallment_paid,0) as noofinstallmentspaid,
b.totalinstallmentamt_paid as totalinstallmentamtpaid,b.cancellation_date,
a.switch_mf_schcode,a.display_trx_id,
--b.start_day,
(CASE 
    WHEN b.trx_type_code IN (1, 2, 3) AND b.start_day IS NOT NULL 
        THEN LPAD(b.start_day::text, 2, '0')
    ELSE 
        CASE 
            WHEN COALESCE(b.start_day, '') = '' 
                THEN TO_CHAR(b.start_date, 'DD')
            ELSE LPAD(b.start_day::text, 2, '0') 
        END 
END)::character varying AS start_day,
b.upcoming_due_date as next_installment_date,
b.previous_paid_date as previousinstallmentdate,a.order_nav,
a.schemegroup, 
b.pausecount,a.datasource,b.inv_plan_status as final_status,INITCAP(a.isinname)::character varying isinname
,a.is_generatetoday
--,a.bank_name as client_bank_name,a.bank_ac_number as client_bank_ac_number
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankname ELSE a.bank_name END as client_bank_name
,CASE WHEN a.inv_type_code = 1 THEN bnk.bankaccno ELSE a.bank_ac_number END as client_bank_ac_number
,a.payment_method,a.inv_action_code,date_trunc('second',a.created_date) as created_date
,c.pan,sch.sch_plan,b.order_remarks,
isin.schemecode as grpcode,b.remarks,
(((((((((((((((
COALESCE(a.ac_code, ''::character varying)::text || ' '::text) 
|| COALESCE(c.acname, ''::character varying)::text) || ' '::text) 
|| COALESCE(c.pan, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isincode, ''::character varying)::text) || ' '::text) 
|| COALESCE(a.isinname, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_type, ''::character varying)::text) || ' '::text) 
|| COALESCE(sch.sch_plan, ''::character varying)::text) || ' '::text) 
|| COALESCE(b.inv_plan_status, ''::character varying)::text) || ' '::text) 
::character varying AS search_key,coalesce(c.clienttier,'Blue') as clienttier, a.tokenno,
NULL::character varying as switch_isin_name,
b.no_of_installment as tenure,
a.trx_final_status_code,a.folio_no
,a.sub_broker_code,a.sub_broker_name,a.arn_code,a.sub_broker_pass_pct,a.order_placed_by
,a.created_for,a.created_for_name
from temp_mf_order_detail a
inner JOIN transactions.mf_order_summary b on a.trx_id = b.trx_id
inner join master.dim_ucc c on a.ucccode = c.ucccode
inner join master.trx_type d on a.trx_type_code = d.trx_type_code
and d.category_code=261
left join transactions.mf_mandate e on a.mandate_id = e.mandateid
left join master.mandate_type f on e.mandate_type=f.mandate_type
left join (SELECT bk.ucccode, bk.bankname, bk.bankaccno FROM
				(SELECT bn.ucccode, bn.bankname, bn.bankaccno, ROW_NUMBER() OVER(PARTITION BY bn.ucccode ORDER BY "default" desc) rn
				 FROM master.map_ucc_bank bn 
				WHERE bn.ucccode in (select distinct a.ucccode from temp_mf_order_detail a)
				) bk WHERE bk.rn = 1
			) bnk ON a.ucccode = bnk.ucccode
inner join master.dim_mf_scheme sch on a.mf_schcode=sch.mf_schcode
inner join master.dim_mf_isin isin on a.isincode=isin.isincode
where a.created_date::date between v_fromdate and v_todate
--and a.ucccode in (select distinct a.ucccode from temp_mf_ucc a)
and a.trx_type_code=3
and b.inv_plan_status is not null
)a
left join master.dim_mf_order_remarks b
on upper(a.order_remarks) = upper(b.dion_order_remarks)
left join (
select 
a.ucccode,a.priority_ac_code,a.user_type,
case when a.user_type='E' then a.client_owner
when a.user_type='P' then a.partner_code end as client_owner,
case when a.user_type='E' then a.client_owner_name
when a.user_type='P' then a.partner_name end as client_owner_name,
(case
when Upper(substr(a.pan, 4, 1))='H' then 'individual'
when Upper(substr(a.pan, 4, 1))='P' then 'individual'
when a.is_individual=true 
and extract(year from age(NOW(), a.birthdate))::numeric::int<18
then 'minor'
when a.is_individual=true then 'individual'
when a.is_individual=false then 'non-individual' end)::character varying kacctype,
a.dp_flag,a.direct_plan_enabled_flg,a.krastatus
from master.dim_ucc a
where a.ucccode in (select ucc.ucccode from temp_mf_ucc ucc)
)C
on A.ucccode=C.ucccode
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.created_date;
END IF;

-------------------------------------------------------------
DROP TABLE temp_mf_ucc; 
-------------------------------------------------------------
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_16nov2025(varchar, varchar, date, date, int4, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_16nov2025(varchar, varchar, date, date, int4, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_16nov2025(varchar, varchar, date, date, int4, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_16nov2025(varchar, varchar, date, date, int4, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_summary_bkp_16nov2025(varchar, varchar, date, date, int4, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_transaction(int4, int8, _int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_transaction(v_inv_action_code integer, v_trx_id bigint, v_trx_ids bigint[] DEFAULT NULL::bigint[])
 RETURNS TABLE(trx_id bigint, ac_code character varying, isincode character varying, trx_type character varying, trx_amt numeric, trx_qty numeric, order_nav numeric, order_navdate date, delivery_mode character varying, mandate_id character varying, trx_status character varying, created_date timestamp without time zone, mf_schcode bigint, display_trx_id character varying, ac_name character varying, client_mobileno character varying, client_emailid character varying, advisor_code character varying, advisor_name character varying, advisor_mobile character varying, advisor_email character varying, helpdesk_number text, helpdesk_email text, transaction_type character varying, return_type character varying, divfrq character varying, vendor_req character varying, order_type character varying, consent_expire_date timestamp without time zone, isinname character varying, settlement_type character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF(v_inv_action_code=1)
Then
	IF(v_trx_ids IS NULL)
	THEN
		RETURN QUERY
		select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,a.trx_qty, 
		a.order_nav,a.order_navdate,a.delivery_mode,a.mandate_id,a.trx_status,
		a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
		b.mobileno as client_mobileno,b.email as client_emailid,
		b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
		coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
		'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
		f.trx_type as transaction_type, 
		a.return_type,e.divfrq, a.vendor_req, a.order_type
	--	,con.consent_expire_date
		,case when a.order_placed_by='CLIENT' and a.physicalflag='P'
		and con.consent_expire_date is null then 
		 (
            SELECT DATE_TRUNC('second', calendar_date) 
            FROM platform_db.fn_get_future_tradingdays(a.created_date, 4)
        )
		else con.consent_expire_date end as consent_expire_date
		,INITCAP(a.isinname)::character varying as isinname
		,isin.settltement_type as settlement_type
		from transactions.mf_order_detail a
		inner join master.dim_ucc b on a.ucccode=b.ucccode
		left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
		inner join master.trx_type f on a.trx_type_code = f.trx_type_code
		and f.category_code=261
		left join transactions.order_consent con ON a.trx_id = con.trx_id
		and a.inv_action_code = con.inv_action_code
		left join master.dim_mf_isin isin on a.isincode = isin.isincode
		where --a.consent_status_code=1
		a.trx_id = v_trx_id;
	
	ELSIF(v_trx_id IS NULL AND v_trx_ids IS NOT NULL)
	THEN
		RETURN QUERY
		select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,a.trx_qty, 
		a.order_nav,a.order_navdate,a.delivery_mode,a.mandate_id,a.trx_status,
		a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
		b.mobileno as client_mobileno,b.email as client_emailid,
		b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
		coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
		'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
		f.trx_type as transaction_type, 
		a.return_type,e.divfrq, a.vendor_req, a.order_type,con.consent_expire_date
		, INITCAP(a.isinname)::character varying as isinname
		,isin.settltement_type as settlement_type
		from transactions.mf_order_detail a
		inner join master.dim_ucc b on a.ucccode=b.ucccode
		left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
		inner join master.trx_type f on a.trx_type_code = f.trx_type_code
		and f.category_code=261
		left join transactions.order_consent con ON a.trx_id = con.trx_id
		and a.inv_action_code = con.inv_action_code
		left join master.dim_mf_isin isin on a.isincode = isin.isincode
		where --a.consent_status_code=1
		--a.trx_id = ANY($2);
		a.trx_id = ANY(v_trx_ids);
	END IF;
ELSE
	IF(v_trx_ids IS NULL)
	THEN
		RETURN QUERY
			select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,g.trx_qty, 
	g.order_nav,g.order_navdate,g.delivery_mode,a.mandate_id,a.trx_status,
	a.created_date,a.MF_schcode,
	cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
	b.acname as ac_name, 
	b.mobileno as client_mobileno,b.email as client_emailid,
	b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
	coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
	'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
	f.trx_type as transaction_type, 
	g.return_type,e.divfrq, a.vendor_req, g.order_type,con.consent_expire_date
	,INITCAP(a.isinname)::character varying as isinname
	,isin.settltement_type as settlement_type
	from transactions.mf_order_detail_modification a
	inner join master.dim_ucc b on a.ucccode=b.ucccode
	left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
	inner join master.trx_type f on a.trx_type_code = f.trx_type_code
	and f.category_code=261
	left join transactions.order_consent con ON a.trx_id = con.trx_id
	and a.inv_action_code = con.inv_action_code
	left join master.dim_mf_isin isin on a.isincode = isin.isincode
	inner join transactions.mf_order_detail g
	on a.org_trx_id=g.trx_id
	where --a.consent_status_code=1
	a.trx_id = v_trx_id;

	ELSIF(v_trx_id IS NULL AND v_trx_ids IS NOT NULL)
	THEN
	RETURN QUERY
	select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,g.trx_qty, 
	g.order_nav,g.order_navdate,g.delivery_mode,a.mandate_id,a.trx_status,
	a.created_date,a.MF_schcode,
	cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
	b.acname as ac_name, 
	b.mobileno as client_mobileno,b.email as client_emailid,
	b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
	coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
	'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
	f.trx_type as transaction_type, 
	g.return_type,e.divfrq, a.vendor_req, g.order_type,con.consent_expire_date
	,INITCAP(a.isinname)::character varying as isinname
	,isin.settltement_type as settlement_type
	from transactions.mf_order_detail_modification a
	inner join master.dim_ucc b on a.ucccode=b.ucccode
	left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
	inner join master.trx_type f on a.trx_type_code = f.trx_type_code
	and f.category_code=261
	left join transactions.order_consent con ON a.trx_id = con.trx_id
	and a.inv_action_code = con.inv_action_code
	left join master.dim_mf_isin isin on a.isincode = isin.isincode
	inner join transactions.mf_order_detail g
	on a.org_trx_id=g.trx_id
	where --a.consent_status_code=1
	a.trx_id = ANY(v_trx_ids);
	END IF;	
END IF;	
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred: %', SQLERRM;
        RETURN;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_transaction(int4, int8, _int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction(int4, int8, _int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction(int4, int8, _int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction(int4, int8, _int8) TO cmotsread;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction(int4, int8, _int8) TO appadmin;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_09may2025(int4, int8, _int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_09may2025(v_inv_action_code integer, v_trx_id bigint, v_trx_ids bigint[] DEFAULT NULL::bigint[])
 RETURNS TABLE(trx_id bigint, ac_code character varying, isincode character varying, trx_type character varying, trx_amt numeric, trx_qty numeric, order_nav numeric, order_navdate date, delivery_mode character varying, mandate_id character varying, trx_status character varying, created_date timestamp without time zone, mf_schcode bigint, display_trx_id character varying, ac_name character varying, client_mobileno character varying, client_emailid character varying, advisor_code character varying, advisor_name character varying, advisor_mobile character varying, advisor_email character varying, helpdesk_number text, helpdesk_email text, transaction_type character varying, return_type character varying, divfrq character varying, vendor_req character varying, order_type character varying, consent_expire_date timestamp without time zone, isinname character varying, settlement_type character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF(v_inv_action_code=1)
Then
	IF(v_trx_ids IS NULL)
	THEN
		RETURN QUERY
		select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,a.trx_qty, 
		a.order_nav,a.order_navdate,a.delivery_mode,a.mandate_id,a.trx_status,
		a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
		b.mobileno as client_mobileno,b.email as client_emailid,
		b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
		coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
		'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
		f.trx_type as transaction_type, 
		a.return_type,e.divfrq, a.vendor_req, a.order_type,con.consent_expire_date
		,INITCAP(a.isinname)::character varying as isinname
		,isin.settltement_type as settlement_type
		from transactions.mf_order_detail a
		inner join master.dim_ucc b on a.ucccode=b.ucccode
		left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
		inner join master.trx_type f on a.trx_type_code = f.trx_type_code
		and f.category_code=261
		left join transactions.order_consent con ON a.trx_id = con.trx_id
		and a.inv_action_code = con.inv_action_code
		left join master.dim_mf_isin isin on a.isincode = isin.isincode
		where --a.consent_status_code=1
		a.trx_id = v_trx_id;
	
	ELSIF(v_trx_id IS NULL AND v_trx_ids IS NOT NULL)
	THEN
		RETURN QUERY
		select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,a.trx_qty, 
		a.order_nav,a.order_navdate,a.delivery_mode,a.mandate_id,a.trx_status,
		a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
		b.mobileno as client_mobileno,b.email as client_emailid,
		b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
		coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
		'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
		f.trx_type as transaction_type, 
		a.return_type,e.divfrq, a.vendor_req, a.order_type,con.consent_expire_date
		, INITCAP(a.isinname)::character varying as isinname
		,isin.settltement_type as settlement_type
		from transactions.mf_order_detail a
		inner join master.dim_ucc b on a.ucccode=b.ucccode
		left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
		inner join master.trx_type f on a.trx_type_code = f.trx_type_code
		and f.category_code=261
		left join transactions.order_consent con ON a.trx_id = con.trx_id
		and a.inv_action_code = con.inv_action_code
		left join master.dim_mf_isin isin on a.isincode = isin.isincode
		where --a.consent_status_code=1
		--a.trx_id = ANY($2);
		a.trx_id = ANY(v_trx_ids);
	END IF;
ELSE
	IF(v_trx_ids IS NULL)
	THEN
		RETURN QUERY
			select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,g.trx_qty, 
	g.order_nav,g.order_navdate,g.delivery_mode,a.mandate_id,a.trx_status,
	a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
	b.mobileno as client_mobileno,b.email as client_emailid,
	b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
	coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
	'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
	f.trx_type as transaction_type, 
	g.return_type,e.divfrq, a.vendor_req, g.order_type,con.consent_expire_date
	,INITCAP(a.isinname)::character varying as isinname
	,isin.settltement_type as settlement_type
	from transactions.mf_order_detail_modification a
	inner join master.dim_ucc b on a.ucccode=b.ucccode
	left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
	inner join master.trx_type f on a.trx_type_code = f.trx_type_code
	and f.category_code=261
	left join transactions.order_consent con ON a.trx_id = con.trx_id
	and a.inv_action_code = con.inv_action_code
	left join master.dim_mf_isin isin on a.isincode = isin.isincode
	inner join transactions.mf_order_detail g
	on a.org_trx_id=g.trx_id
	where --a.consent_status_code=1
	a.trx_id = v_trx_id;

	ELSIF(v_trx_id IS NULL AND v_trx_ids IS NOT NULL)
	THEN
	RETURN QUERY
	select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,g.trx_qty, 
	g.order_nav,g.order_navdate,g.delivery_mode,a.mandate_id,a.trx_status,
	a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
	b.mobileno as client_mobileno,b.email as client_emailid,
	b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
	coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
	'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
	f.trx_type as transaction_type, 
	g.return_type,e.divfrq, a.vendor_req, g.order_type,con.consent_expire_date
	,INITCAP(a.isinname)::character varying as isinname
	,isin.settltement_type as settlement_type
	from transactions.mf_order_detail_modification a
	inner join master.dim_ucc b on a.ucccode=b.ucccode
	left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
	inner join master.trx_type f on a.trx_type_code = f.trx_type_code
	and f.category_code=261
	left join transactions.order_consent con ON a.trx_id = con.trx_id
	and a.inv_action_code = con.inv_action_code
	left join master.dim_mf_isin isin on a.isincode = isin.isincode
	inner join transactions.mf_order_detail g
	on a.org_trx_id=g.trx_id
	where --a.consent_status_code=1
	a.trx_id = ANY(v_trx_ids);
	END IF;	
END IF;	
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred: %', SQLERRM;
        RETURN;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_09may2025(int4, int8, _int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_09may2025(int4, int8, _int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_09may2025(int4, int8, _int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_09may2025(int4, int8, _int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_09may2025(int4, int8, _int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_28oct2025(int4, int8, _int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_28oct2025(v_inv_action_code integer, v_trx_id bigint, v_trx_ids bigint[] DEFAULT NULL::bigint[])
 RETURNS TABLE(trx_id bigint, ac_code character varying, isincode character varying, trx_type character varying, trx_amt numeric, trx_qty numeric, order_nav numeric, order_navdate date, delivery_mode character varying, mandate_id character varying, trx_status character varying, created_date timestamp without time zone, mf_schcode bigint, display_trx_id character varying, ac_name character varying, client_mobileno character varying, client_emailid character varying, advisor_code character varying, advisor_name character varying, advisor_mobile character varying, advisor_email character varying, helpdesk_number text, helpdesk_email text, transaction_type character varying, return_type character varying, divfrq character varying, vendor_req character varying, order_type character varying, consent_expire_date timestamp without time zone, isinname character varying, settlement_type character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF(v_inv_action_code=1)
Then
	IF(v_trx_ids IS NULL)
	THEN
		RETURN QUERY
		select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,a.trx_qty, 
		a.order_nav,a.order_navdate,a.delivery_mode,a.mandate_id,a.trx_status,
		a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
		b.mobileno as client_mobileno,b.email as client_emailid,
		b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
		coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
		'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
		f.trx_type as transaction_type, 
		a.return_type,e.divfrq, a.vendor_req, a.order_type,con.consent_expire_date
		,INITCAP(a.isinname)::character varying as isinname
		,isin.settltement_type as settlement_type
		from transactions.mf_order_detail a
		inner join master.dim_ucc b on a.ucccode=b.ucccode
		left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
		inner join master.trx_type f on a.trx_type_code = f.trx_type_code
		and f.category_code=261
		left join transactions.order_consent con ON a.trx_id = con.trx_id
		and a.inv_action_code = con.inv_action_code
		left join master.dim_mf_isin isin on a.isincode = isin.isincode
		where --a.consent_status_code=1
		a.trx_id = v_trx_id;
	
	ELSIF(v_trx_id IS NULL AND v_trx_ids IS NOT NULL)
	THEN
		RETURN QUERY
		select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,a.trx_qty, 
		a.order_nav,a.order_navdate,a.delivery_mode,a.mandate_id,a.trx_status,
		a.created_date,a.MF_schcode,a.display_trx_id,b.acname as ac_name, 
		b.mobileno as client_mobileno,b.email as client_emailid,
		b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
		coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
		'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
		f.trx_type as transaction_type, 
		a.return_type,e.divfrq, a.vendor_req, a.order_type,con.consent_expire_date
		, INITCAP(a.isinname)::character varying as isinname
		,isin.settltement_type as settlement_type
		from transactions.mf_order_detail a
		inner join master.dim_ucc b on a.ucccode=b.ucccode
		left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
		inner join master.trx_type f on a.trx_type_code = f.trx_type_code
		and f.category_code=261
		left join transactions.order_consent con ON a.trx_id = con.trx_id
		and a.inv_action_code = con.inv_action_code
		left join master.dim_mf_isin isin on a.isincode = isin.isincode
		where --a.consent_status_code=1
		--a.trx_id = ANY($2);
		a.trx_id = ANY(v_trx_ids);
	END IF;
ELSE
	IF(v_trx_ids IS NULL)
	THEN
		RETURN QUERY
			select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,g.trx_qty, 
	g.order_nav,g.order_navdate,g.delivery_mode,a.mandate_id,a.trx_status,
	a.created_date,a.MF_schcode,
	cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
	b.acname as ac_name, 
	b.mobileno as client_mobileno,b.email as client_emailid,
	b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
	coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
	'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
	f.trx_type as transaction_type, 
	g.return_type,e.divfrq, a.vendor_req, g.order_type,con.consent_expire_date
	,INITCAP(a.isinname)::character varying as isinname
	,isin.settltement_type as settlement_type
	from transactions.mf_order_detail_modification a
	inner join master.dim_ucc b on a.ucccode=b.ucccode
	left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
	inner join master.trx_type f on a.trx_type_code = f.trx_type_code
	and f.category_code=261
	left join transactions.order_consent con ON a.trx_id = con.trx_id
	and a.inv_action_code = con.inv_action_code
	left join master.dim_mf_isin isin on a.isincode = isin.isincode
	inner join transactions.mf_order_detail g
	on a.org_trx_id=g.trx_id
	where --a.consent_status_code=1
	a.trx_id = v_trx_id;

	ELSIF(v_trx_id IS NULL AND v_trx_ids IS NOT NULL)
	THEN
	RETURN QUERY
	select DISTINCT a.trx_id,a.ac_code,a.isincode,a.trx_type,a.trx_amt,g.trx_qty, 
	g.order_nav,g.order_navdate,g.delivery_mode,a.mandate_id,a.trx_status,
	a.created_date,a.MF_schcode,
	cast(a.display_trx_id ||'-'||a.trx_id as character varying) as display_trx_id,
	b.acname as ac_name, 
	b.mobileno as client_mobileno,b.email as client_emailid,
	b.client_owner as advisor_code,b.client_owner_name as advisor_name, 
	coalesce(b.rm_mobile,'') as advisor_mobile,b.rm_email as advisor_email,
	'1800-102-3335' as helpdesk_number, 'helpdesk@nuvama.com' as helpdesk_email,
	f.trx_type as transaction_type, 
	g.return_type,e.divfrq, a.vendor_req, g.order_type,con.consent_expire_date
	,INITCAP(a.isinname)::character varying as isinname
	,isin.settltement_type as settlement_type
	from transactions.mf_order_detail_modification a
	inner join master.dim_ucc b on a.ucccode=b.ucccode
	left join platform_db.mv_mf_details e on a.mf_schcode = e.mf_schcode
	inner join master.trx_type f on a.trx_type_code = f.trx_type_code
	and f.category_code=261
	left join transactions.order_consent con ON a.trx_id = con.trx_id
	and a.inv_action_code = con.inv_action_code
	left join master.dim_mf_isin isin on a.isincode = isin.isincode
	inner join transactions.mf_order_detail g
	on a.org_trx_id=g.trx_id
	where --a.consent_status_code=1
	a.trx_id = ANY(v_trx_ids);
	END IF;	
END IF;	
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error occurred: %', SQLERRM;
        RETURN;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_28oct2025(int4, int8, _int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_28oct2025(int4, int8, _int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_28oct2025(int4, int8, _int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_28oct2025(int4, int8, _int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_orderbook_transaction_bkp_28oct2025(int4, int8, _int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_reversal_detail(varchar, varchar, date, date, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_reversal_detail(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(logincode character varying, isin character varying, schemename character varying, ucccode character varying, clientname character varying, clientpan character varying, tradedate date, folionumber character varying, units numeric, amount numeric, transactiondescription character varying, search_key character varying, mf_schcode bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN QUERY

SELECT 
v_logincode AS logincode,
a.isin,a.schemename,
b.ucccode,b.acname as clientname,
a.clientpan,a.transactiondate::date as tradedate,
a.folionumber,(a.units*-1)::numeric(18,2) as units,
(a.amount*-1)::numeric(18,2) as amount,a.transactiondescription,
((COALESCE(a.schemename, '') || ' ' || COALESCE(a.isin, '')))::character varying AS search_key,
isin.mf_schcode
FROM transactions.rtatransactionreversal a
INNER JOIN (
SELECT a.ucccode, a.priority_ac_code, a.acname, a.pan 
FROM master.dim_ucc a
WHERE COALESCE(a.pan, '') <> '' 
AND a.client_owner = v_logincode
) b ON a.clientpan = b.pan
INNER JOIN master.dim_mf_isin isin on a.isin =isin.isincode
WHERE a.transactiondate BETWEEN v_fromdate AND v_todate
AND (
COALESCE(v_search, '') = '' 
OR ((COALESCE(a.schemename, '') || ' ' || COALESCE(a.isin, '')) ~* v_search));

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_reversal_detail(varchar, varchar, date, date, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_reversal_detail(varchar, varchar, date, date, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_reversal_detail(varchar, varchar, date, date, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_reversal_detail(varchar, varchar, date, date, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_reversal_detail(varchar, varchar, date, date, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_reversal_summary(varchar, varchar, date, date, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_reversal_summary(v_logintype character varying, v_logincode character varying, v_fromdate date, v_todate date, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(logincode character varying, total_orders integer, impacted_clients integer, total_reversal_amt numeric, description character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN QUERY
    SELECT 
        v_logincode AS logincode,
        SUM(summary.total_orders)::int AS total_orders,
        SUM(summary.impacted_clients)::int AS impacted_clients, 
    --  SUM(summary.total_reversal_amt)::decimal(18,2) AS total_reversal_amt,
	COALESCE(SUM(summary.total_reversal_amt), 0.00)::decimal(18,2) AS total_reversal_amt,
        (
            SUM(summary.total_orders)::text || ' reversal(s) affecting ' || 
            SUM(summary.impacted_clients)::text || ' user(s).'
        )::character varying AS description
    FROM (
        SELECT 
            COUNT(DISTINCT clientpan) AS impacted_clients,
            SUM(amount) AS total_reversal_amt,
            COUNT(*) AS total_orders
        FROM (
            SELECT 
                a.clientpan,
                (a.amount * -1) AS amount,
                ((COALESCE(a.schemename, '') || ' ' || COALESCE(a.isin, ''))) AS search_key
            FROM transactions.rtatransactionreversal a
            INNER JOIN (
                SELECT ucccode, priority_ac_code, acname, pan 
                FROM master.dim_ucc 
                WHERE COALESCE(pan, '') <> '' 
                  AND client_owner = v_logincode
            ) b ON a.clientpan = b.pan
            WHERE a.transactiondate BETWEEN v_fromdate AND v_todate
              AND (
                  COALESCE(v_search, '') = '' 
                  OR ((COALESCE(a.schemename, '') || ' ' || COALESCE(a.isin, '')) ~* v_search)
              )
        ) t
    ) summary;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_reversal_summary(varchar, varchar, date, date, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_reversal_summary(varchar, varchar, date, date, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_reversal_summary(varchar, varchar, date, date, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_reversal_summary(varchar, varchar, date, date, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_reversal_summary(varchar, varchar, date, date, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_subsequent_order(int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_subsequent_order(v_reg_no bigint)
 RETURNS TABLE(id bigint, order_no bigint, ac_code character varying, trx_type character varying, orderdate date, amount numeric, reg_date date, status character varying, orderedby character varying, sysrefno character varying, isincode character varying, mandate_id bigint, reg_no bigint, remarks character varying, paymentrejection integer, vendor_trx_id bigint, created_date timestamp without time zone, modified_date timestamp without time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN QUERY
select 
a.id,a.order_no,a.ac_code,
--b.trx_type,
cast(b.trx_type ||' Installment' as character varying) as trx_type,
a.orderdate,a.amount,a.reg_date,
case when a.status='VALID' then 'Success'
when a.status in ('INVALID','ACCEPTED') then 'Failed' else a.status end status,
a.orderedby,a.sysrefno,a.isincode,
a.mandate_id,a.reg_no,a.remarks,a.paymentrejection,a.vendor_trx_id,
date_trunc('second',a.created_date) as created_date,a.modified_date
from transactions.mf_subsequent_order a
inner join master.trx_type b on a.trx_type_code=b.trx_type_code
and b.category_code=261
where --upper(a.orderedby)<>upper('CHILDORDER')
--and 
a.reg_no=v_reg_no
order by a.orderdate desc;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_subsequent_order(int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_subsequent_order(int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_subsequent_order(int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_subsequent_order(int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_subsequent_order(int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_switchisin_details(varchar, int4, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_switchisin_details(v_isincode character varying, v_trx_type_code integer, v_search character varying DEFAULT NULL::character varying)
 RETURNS TABLE(mf_schcode bigint, isincode character varying, isinname character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF v_trx_type_code=2 THEN
RETURN QUERY
select a.mf_schcode,a.isincode,a.isinname 
from (
select distinct a.mf_schcode,a.isincode,INITCAP(a.isinname)::character varying isinname
,((
COALESCE(a.isincode, ''::character varying)::text || ' '::text) 
|| COALESCE(INITCAP(a.isinname), ''::character varying)::text)
::character varying AS search_key
from master.dim_mf_exchange_isin a
where a.amccode in (
select b.amccode from master.dim_mf_exchange_isin b
where b.isincode=v_isincode--'INF209K01BT5'
)
and a.stpflag='Y' and a.reg_in='Y' and a.status=1
and a.isincode<>v_isincode--'INF209K01BT5'
)a
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.mf_schcode;

ELSIF v_trx_type_code=6 THEN
RETURN QUERY
select a.mf_schcode,a.isincode,a.isinname 
from (
select distinct a.mf_schcode,a.isincode,INITCAP(a.isinname)::character varying isinname
,((
COALESCE(a.isincode, ''::character varying)::text || ' '::text) 
|| COALESCE(INITCAP(a.isinname), ''::character varying)::text)
::character varying AS search_key
from master.dim_mf_exchange_isin a
where a.amccode in (
select b.amccode from master.dim_mf_exchange_isin b
where b.redallowed='Y' and txn_type='LUMPSUM'
and	b.isincode=v_isincode--'INF209K01BT5'
)
--and a.switchflag='Y'
and a.purallowed='Y' and txn_type='LUMPSUM'
and a.status=1
and a.isincode<>v_isincode--'INF209K01BT5'
)a
where case when coalesce(v_search,'')='' then true else
a.search_key ~* v_search end
order by a.mf_schcode;

END IF;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_switchisin_details(varchar, int4, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_switchisin_details(varchar, int4, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_switchisin_details(varchar, int4, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_switchisin_details(varchar, int4, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_switchisin_details(varchar, int4, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_sync_client_detail(varchar, int4, text, varchar, bool, int4, int4);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_sync_client_detail(p_ucccode character varying, p_sync_id integer, p_search_text text DEFAULT NULL::text, p_orderby character varying DEFAULT NULL::character varying, p_orderbydesc boolean DEFAULT false, p_page_index integer DEFAULT 1, p_page_size integer DEFAULT 10)
 RETURNS TABLE(sync_id integer, ac_code character varying, ucccode character varying, ac_name character varying, pan character varying, client_tier character varying, isin_code character varying, sch_name character varying, folio_no character varying, aval_unit numeric, current_nav numeric, current_val numeric, amc_logo character varying, is_transferin boolean, rtaname character varying, total_pages integer, total_records integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_plsqltext TEXT;
    v_filter TEXT := '';
    v_count TEXT;
    v_total_records INTEGER;
    v_total_pages INTEGER;
   	v_order_clause text;
   
begin
	
	if coalesce(p_ucccode,'') <> ''
	then
		v_filter:= v_filter || ' and ext.ucccode = ' || quote_literal (p_ucccode) ;
	end if;

	if coalesce(p_sync_id,0) <> 0
	then
		v_filter:= v_filter || ' and ext.sync_id = ' || (p_sync_id) ;
	end if;

	if coalesce(p_search_text,'') <> ''
	then
		v_filter:= v_filter || ' and ext.search_text ilike ' || '''%' || p_search_text || '%''';
	end if;
	

	v_count := ' 
		with tmp_ext
		as
		(
			select 
			exthol.sync_history_id as sync_id,
			du.priority_ac_code as ac_code,
			exthol.ucccode as ucccode,
			concat(upper(exthol.isin),'' '', upper(nav.isinname) , '' '' , exthol.folio) as search_text 
			from transactions.mf_client_holdings_external exthol join master.dim_ucc du 
				on exthol.ucccode = du.ucccode
			join platform_db.mv_mf_details nav on exthol.isin = nav.isincode 
			where exthol.isexternal = true
			and exthol.avlunits > 0	
			and exthol.arn_transfer_status = ''To be Initiated''
		)
		select count(ext.ac_code) from tmp_ext ext where 1 = 1'|| v_filter;
	
	EXECUTE v_count INTO v_total_records;
	
    v_total_pages := CEIL(v_total_records::NUMERIC / COALESCE(p_page_size, 10))::INTEGER;
   
	v_plsqltext := '
		
		 
		with tmp_ext
		as
		(
			select 
			exthol.sync_history_id as sync_id,
			du.priority_ac_code as ac_code,
			exthol.ucccode as ucccode,
			du.acname as ac_name,
			du.pan as pan,
			du.clienttier as client_tier,
			exthol.isin as isin_code ,
			cast (initcap(nav.isinname) as varchar ) as sch_name,
			exthol.folio as folio_no,
			exthol.avlunits as aval_unit,
			nav.nav as current_nav,
			cast (exthol.avlunits * nav.nav as numeric(18,4)) as current_val,
			dmi.amc_logo as amc_logo,
			case when exthol.sync_status  = ''Completed'' then true else false end as is_transferin,
			exthol.rtaname as rtaname,
			concat(upper(exthol.isin),'' '', upper(nav.isinname) , '' '' , exthol.folio) as search_text 			
			from transactions.mf_client_holdings_external exthol join master.dim_ucc du on exthol.ucccode = du.ucccode 
				join platform_db.mv_mf_details nav on exthol.isin = nav.isincode
				join master.dim_mf_isin dmi on exthol.isin = dmi.isincode
			where exthol.isexternal = true
			and exthol.avlunits > 0
			and exthol.arn_transfer_status = ''To be Initiated'' 
		)
		select ext.sync_id , 
				ext.ac_code , 
				ext.ucccode , 
				ext.ac_name , 
				ext.pan , 
				ext.client_tier , 
				ext.isin_code , 
				ext.sch_name , 
				ext.folio_no,
				ext.aval_unit,
				ext.current_nav,
				ext.current_val,
				ext.amc_logo,
				ext.is_transferin,
				ext.rtaname
				
		from tmp_ext ext where 1 = 1 ' || v_filter;
	
	IF coalesce(p_orderby,'') <> '' 
	THEN
        v_order_clause := ' ORDER BY ' || p_orderby || CASE WHEN p_orderbydesc = false THEN ' DESC nulls last' ELSE ' ASC nulls last' END;
    else
    	v_order_clause := ' ORDER BY ext.sch_name';
	END IF;

		v_plsqltext := v_plsqltext || v_order_clause;   
    
   
	v_plsqltext := v_plsqltext || format(' OFFSET %s ROWS FETCH NEXT %s ROWS ONLY', 
                                 COALESCE(p_page_size * (p_page_index - 1), 0), 
                                 COALESCE(p_page_size, 10));

    v_plsqltext := 'select sync_id , ac_code ,
			ucccode,
			ac_name,
			pan,
			client_tier,
			isin_code,
			sch_name,
			folio_no ,
			aval_unit,
			current_nav,
			current_val,
			amc_logo,
			is_transferin,
			rtaname,
			' || v_total_pages || ' AS total_pages, ' || v_total_records || ' AS total_records FROM (' || v_plsqltext || ') subquery';
	
   	--RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
	RETURN QUERY EXECUTE v_plsqltext;


end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_sync_client_detail(varchar, int4, text, varchar, bool, int4, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_sync_client_detail(varchar, int4, text, varchar, bool, int4, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_sync_client_detail(varchar, int4, text, varchar, bool, int4, int4) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_mf_sync_history(varchar, varchar, bool, int4, int4);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_sync_history(p_ucccode character varying, p_orderby character varying DEFAULT NULL::character varying, p_orderbydesc boolean DEFAULT false, p_page_index integer DEFAULT 1, p_page_size integer DEFAULT 10)
 RETURNS TABLE(sync_id integer, updated_on character varying, source character varying, mobileno character varying, doc_name character varying, status character varying, action character varying, total_pages integer, total_records integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_plsqltext TEXT;
    v_filter TEXT := '';
    v_count TEXT;
    v_total_records INTEGER;
    v_total_pages INTEGER;
   	v_order_clause text;
   
begin
	
	if coalesce(p_ucccode,'') <> ''
	then
		v_filter:= v_filter || ' and sync.ucccode = ' || quote_literal (p_ucccode) ;
	end if;
	
	v_count := ' 
	
				select count(sync.ucccode)
				from transactions.mf_sync_history sync join master.dim_ucc du 
				on sync.ucccode = du.ucccode
				where 1 = 1'|| v_filter;
	
	EXECUTE v_count INTO v_total_records;
	v_total_pages := CEIL(v_total_records::NUMERIC / COALESCE(p_page_size, 10))::INTEGER;
	
	v_plsqltext := '
	
				select 
					sync.id as sync_id,
					cast (TO_CHAR(sync.sync_end_datetime, ''YYYY-MM-DD HH24:MI:SS'') as varchar) as updated_on ,
					sync."source" as source,
					du.mobileno as mobileno,
					cast ('''' as varchar) as doc_name,
					sync.status as status,
					cast (case when sync.status = ''Consent Pending'' then ''Resend Consent'' else '''' end as varchar)as action
				from transactions.mf_sync_history sync join master.dim_ucc du 
				on sync.ucccode = du.ucccode 
				where 1 = 1 ' || v_filter;
	
	IF coalesce(p_orderby,'') <> '' 
	THEN
        v_order_clause := ' ORDER BY ' || p_orderby || CASE WHEN p_orderbydesc = false THEN ' DESC nulls last' ELSE ' ASC nulls last' END;
    else
    	v_order_clause := ' ORDER BY sync.sync_end_datetime desc';
	END IF;

	v_plsqltext := v_plsqltext || v_order_clause;   
       
	v_plsqltext := v_plsqltext || format(' OFFSET %s ROWS FETCH NEXT %s ROWS ONLY', 
                                 COALESCE(p_page_size * (p_page_index - 1), 0), 
                                 COALESCE(p_page_size, 10));
                                
--    IF coalesce(p_orderby,'') <> '' 
--	THEN
--        v_order_clause := ' ORDER BY ' || p_orderby || CASE WHEN p_orderbydesc = false THEN ' DESC nulls last' ELSE ' ASC nulls last' END;
--    else
--    	v_order_clause := ' ORDER BY updated_on';
--	END IF;
   
    v_plsqltext := 'select 
			sync_id,
			updated_on , 
			source ,
			mobileno,
			doc_name,
			status,
			action,	' || v_total_pages || ' AS total_pages, ' || v_total_records || ' AS total_records FROM (' || v_plsqltext || ') subquery';
	
   	RAISE NOTICE 'v_plsqltext :%',v_plsqltext;
	RETURN QUERY EXECUTE v_plsqltext;                            
	
	
	
end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_sync_history(varchar, varchar, bool, int4, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_sync_history(varchar, varchar, bool, int4, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_sync_history(varchar, varchar, bool, int4, int4) TO cmotswrite;

-- DROP FUNCTION transactions.fn_get_mf_timeline_details(varchar, varchar, int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_timeline_details(v_logintype character varying, v_logincode character varying, v_trx_id bigint)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, ac_code character varying, trx_type character varying, trx_datetime timestamp without time zone, trx_status character varying, status character varying, status_time timestamp without time zone, status_type text)
 LANGUAGE plpgsql
AS $function$

DECLARE v_order_placed_by character varying;
DECLARE v_payment_method character varying;
DECLARE v_is_generatetoday boolean;

BEGIN

v_order_placed_by :=(select (case when a.order_placed_by='CLIENT' and a.physicalflag='D' 
then 'CLIENT' else 'OTHER' end)::character varying  as order_placed_by
from transactions.mf_order_detail a where a.trx_id=v_trx_id);	

RAISE NOTICE 'Order Placed By: %', v_order_placed_by;

v_is_generatetoday :=(
select (case 
when a.order_placed_by='CLIENT' and a.physicalflag='D' 
and trx_type_code=1 and a.is_generatetoday=true then true 
when a.order_placed_by='CLIENT' and a.physicalflag='D' 
and trx_type_code=4 then true 
else false end )::boolean as is_generatetoday
from transactions.mf_order_detail a where a.trx_id=v_trx_id
);	

RAISE NOTICE 'Order Pay Today: %', v_is_generatetoday;

v_payment_method :=(select (case when a.payment_method='eCollect'  
then 'eCollect' else 'normal' end)::character varying  as payment_method
from transactions.mf_order_detail a where a.trx_id=v_trx_id);	

RAISE NOTICE 'payment method: %', v_payment_method;

------------------------------------------------------------------------------------
IF v_payment_method='eCollect'
THEN
--/* Start of eCollect
	If v_order_placed_by<>'CLIENT'
	THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_timeline AS 
	select
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
	date_trunc('second',a.trx_datetime) as	trx_datetime,a.trx_status,a.status,
	date_trunc('second',a.status_time) as status_time,a.status_type
	,a.trx_history_id,a.displayID
	from (
	select  
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
	a.consent_status as status,a.valid_from as status_time,'consent_status' as status_type,
	ROW_NUMBER() OVER (PARTITION BY a.trx_id,a.consent_status_code ORDER BY a.trx_history_id) as rnk,
	1::int AS displayID,a.trx_history_id
	from transactions.mf_order_detail_history a
	where a.trx_id = v_trx_id
	and a.consent_status_code in (0, 1, 2, 3)
	union
	select 
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
	case 
	when a.final_status='Order Accepted' then 'Order Accepted by Exchange' 
	when a.final_status='Order In Progress' and a.vendor_trx_id is not null then 'Order Accepted by Exchange' 
	when a.final_status='Order In Progress' then 'Order in Progress'
	else a.final_status end as status,
	a.valid_from as status_time,'order_status' as status_type,
	row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
	,2::int as displayID,a.trx_history_id
	from transactions.mf_order_detail_history a
	where a.trx_final_status_code in (5,6)
	and a.trx_id=v_trx_id
	union
	select 
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
	case when b.trx_final_status_code=5 and b.vendor_paymentstatus in ('Unpaid','Processing','') 
	then 'Payment Pending'
	when b.trx_final_status_code=4 and b.vendor_paymentstatus ='Paid'
	then 'Payment Completed'
	else 'Payment Pending' end as status, 
	a.valid_from as status_time,'payment_status' as status_type,
	row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
	,3::int as displayID,01::bigint as trx_history_id
	from transactions.mf_order_detail_history a
	inner join transactions.mf_order_detail b
	on a.trx_id = b.trx_id
	where a.trx_final_status_code in (5,2,8)
	and coalesce(b.vendor_trx_status,'') in ('ACCEPTED','ORDERED','REJECTED','') 
	and a.trx_id=v_trx_id
	union
	---order Rejected
	select 
	c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
	e.final_status as status,c.valid_from as status_time,
	'order_status_final' as status_type,
	row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
	,4::int as displayID,c.trx_history_id
	from transactions.mf_order_detail_history c
	inner join transactions.mf_order_detail e
	on c.trx_id=e.trx_id
	where c.vendor_trx_id is null
	and c.trx_status_code in (8,3)
	--and c.consent_status_code=2
	and c.is_active='true'
	and c.trx_id=v_trx_id
	union
	---Order Exchange Status
	select 
	c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
	e.final_status as status,c.valid_from as status_time,
	'order_status_final' as status_type,
	row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
	,4::int as displayID,c.trx_history_id
	from transactions.mf_order_detail_history c
	inner join transactions.mf_order_detail e
	on c.trx_id=e.trx_id
	where c.vendor_trx_id is not null
	and c.is_active='true'
	and c.trx_id=v_trx_id
	)a 
	where rnk=1
	order by a.trx_history_id,displayID;
	------------------------------------------
	delete FROM temp_mf_timeline
	WHERE ctid IN (
	SELECT ctid FROM (
	SELECT ctid, ROW_NUMBER() OVER (PARTITION BY trx_history_id ) AS rn
	FROM temp_mf_timeline
	) sub
	WHERE sub.rn > 1
	);
	-------------------------Final Output
	RETURN QUERY
	select 
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
	a.trx_datetime,a.trx_status,a.status,
	a.status_time,a.status_type
	from temp_mf_timeline a
	join (
	select 
	b.status_type,max(b.trx_history_id) as max_histid
	from temp_mf_timeline b
	where b.status_type IN ('consent_status','order_status','payment_status','order_status_final')
	group by b.status_type
	) b on a.status_type = b.status_type 
	and a.trx_history_id = b.max_histid
	order by a.displayID;
	
	---------------------------------------------------------------------------------------------
	ELSIF v_order_placed_by='CLIENT'
	THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_timeline AS 
	select
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
	date_trunc('second',a.trx_datetime) as	trx_datetime,a.trx_status,a.status,
	date_trunc('second',a.status_time) as status_time,a.status_type
	,a.trx_history_id,a.displayID
	from (
	select 
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
	case 
	when a.final_status='Order Accepted' then 'Order Accepted by Exchange' 
	when a.final_status='Order In Progress' and a.vendor_trx_id is not null then 'Order Accepted by Exchange' 
	when a.final_status='Order In Progress' then 'Order in Progress'
	else a.final_status end as status,
	a.valid_from as status_time,'order_status' as status_type,
	row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
	,1::int as displayID,a.trx_history_id
	from transactions.mf_order_detail_history a
	where a.trx_final_status_code in (5,6)
	and a.trx_id=v_trx_id
	union
	select 
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
	case when b.trx_final_status_code=5 and b.vendor_paymentstatus in ('Unpaid','Processing','') 
	then 'Payment Pending'
	when b.trx_final_status_code=4 and b.vendor_paymentstatus ='Paid'
	then 'Payment Completed'
	else 'Payment Pending' end as status, 
	a.valid_from as status_time,'payment_status' as status_type,
	row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
	,2::int as displayID,01::bigint as trx_history_id
	from transactions.mf_order_detail_history a
	inner join transactions.mf_order_detail b
	on a.trx_id = b.trx_id
	where a.trx_final_status_code in (5,2,8)
--	and b.vendor_trx_status in ('ACCEPTED','ORDERED','REJECTED')
	and coalesce(b.vendor_trx_status,'') in ('ACCEPTED','ORDERED','REJECTED','') 
	and a.trx_id=v_trx_id
	union
	---order Rejected
	select 
	c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
	e.final_status as status,
	c.valid_from as status_time,'order_status_final' as status_type,
	row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
	,3::int as displayID,c.trx_history_id
	from transactions.mf_order_detail_history c
	inner join transactions.mf_order_detail e
	on c.trx_id=e.trx_id
	where c.vendor_trx_id is null
	and c.trx_status_code in (8,3)
	and c.is_active='true'
	and c.trx_id=v_trx_id
	union
	---Order Exchange Status
	select 
	c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
	e.final_status as status,
	c.valid_from as status_time,'order_status_final' as status_type,
	row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
	,3::int as displayID,c.trx_history_id
	from transactions.mf_order_detail_history c
	inner join transactions.mf_order_detail e
	on c.trx_id=e.trx_id
	where c.vendor_trx_id is not null
	and c.is_active='true'
	and c.trx_id=v_trx_id
	)a 
	where rnk=1
	order by a.trx_history_id,displayID;
	------------------------------------------
	delete FROM temp_mf_timeline
	WHERE ctid IN (
	SELECT ctid FROM (
	SELECT ctid, ROW_NUMBER() OVER (PARTITION BY trx_history_id ) AS rn
	FROM temp_mf_timeline
	) sub
	WHERE sub.rn > 1
	);
	-------------------------Final Output
	RETURN QUERY
	select 
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
	a.trx_datetime,a.trx_status,a.status,
	a.status_time,a.status_type
	from temp_mf_timeline a
	join (
	select 
	b.status_type,max(b.trx_history_id) as max_histid
	from temp_mf_timeline b
	where b.status_type IN ('order_status','payment_status','order_status_final')
	group by b.status_type
	) b on a.status_type = b.status_type 
	and a.trx_history_id = b.max_histid
	order by a.displayID;
	---------------------------------------------------------------------------------------------
	END IF;

----*/End of eCollect
ELSE
	If v_order_placed_by<>'CLIENT'
	Then
	--RETURN QUERY
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_timeline AS 
	select
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
	date_trunc('second',a.trx_datetime) as	trx_datetime,a.trx_status,a.status,
	date_trunc('second',a.status_time) as status_time,a.status_type
	,a.trx_history_id
	from (
	select  
	a.trx_id,a.vendor_trx_id,a.ac_code,
	a.trx_type,a.trx_datetime,a.trx_status,a.consent_status as status,
	a.valid_from as status_time,'consent_status' as status_type,
	ROW_NUMBER() OVER (PARTITION BY a.trx_id,a.consent_status_code ORDER BY a.trx_history_id) as rnk,
	1::int AS displayID,
	a.trx_history_id
	from transactions.mf_order_detail_history a
	where a.trx_id = v_trx_id
	and a.consent_status_code in (0, 1, 2, 3)
	union
	select  
	b.trx_id,b.vendor_trx_id,b.ac_code,b.trx_type,b.trx_datetime,b.trx_status,
	case b.payment_status_code
	when 1 then 'Payment Pending'
	when 0 then 'Payment Processed'
	when 2 then 'Payment Processed'
	when 3 then 'Payment Failed'
	else 'Unknown'
	end as status,
	b.valid_from as status_time,'payment_status' as status_type,
	ROW_NUMBER() OVER (PARTITION BY b.trx_id,b.payment_status_code ORDER BY b.trx_history_id) as rnk,
	2::int as displayID,b.trx_history_id
	from transactions.mf_order_detail_history b
	where b.trx_id = v_trx_id
	and b.payment_status_code in (0, 1, 2, 3)
	union
	---order Rejected
	select 
	c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
	e.final_status as status,
	c.valid_from as status_time,'order_status' as status_type,
	row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
	, 3::int as displayID,c.trx_history_id
	from transactions.mf_order_detail_history c
	inner join transactions.mf_order_detail e
	on c.trx_id=e.trx_id
	where c.vendor_trx_id is null
	and c.trx_status_code in (8,3)
	--and c.consent_status_code=2
	and c.is_active='true'
	and c.trx_id=v_trx_id
	union
	---Order Exchange Status
	select 
	c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
	e.final_status as status,
	c.valid_from as status_time,'order_status' as status_type,
	row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
	,3::int as displayID,c.trx_history_id
	from transactions.mf_order_detail_history c
	inner join transactions.mf_order_detail e
	on c.trx_id=e.trx_id
	where c.vendor_trx_id is not null
	and c.is_active='true'
	and c.trx_id=v_trx_id
	)a 
	where rnk=1
	order by a.trx_history_id,displayID;
	------------------------------------------
	delete FROM temp_mf_timeline
	WHERE ctid IN (
	SELECT ctid FROM (
	SELECT ctid, ROW_NUMBER() OVER (PARTITION BY trx_history_id ) AS rn
	FROM temp_mf_timeline
	) sub
	WHERE sub.rn > 1
	);
	-------------------------Final Output
	RETURN QUERY
	select 
	a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
	a.trx_datetime,a.trx_status,a.status,
	a.status_time,a.status_type
	from temp_mf_timeline a
	join (
	select 
	b.status_type,max(b.trx_history_id) as max_histid
	from temp_mf_timeline b
	where b.status_type IN ('consent_status','payment_status','order_status')
	group by b.status_type
	) b on a.status_type = b.status_type 
	and a.trx_history_id = b.max_histid;
	---------------------------------------------------------------------------------------------
	ELSIF v_order_placed_by = 'CLIENT'
	Then
		IF v_is_generatetoday = true
		THEN
		CREATE TEMP TABLE IF NOT EXISTS temp_mf_timeline AS 
		select
		a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
		date_trunc('second',a.trx_datetime) as	trx_datetime,a.trx_status,a.status,
		date_trunc('second',a.status_time) as status_time,a.status_type
		,a.trx_history_id
		from (
		select 
		b.trx_id, b.vendor_trx_id, b.ac_code, b.trx_type, b.trx_datetime, b.trx_status,
		CASE b.payment_status_code
		WHEN 1 THEN 'Payment Pending'
		WHEN 2 THEN 'Payment Processed'
		WHEN 3 THEN 'Payment Failed'
		WHEN 0 THEN 'Payment Processed'
		END AS status,
		b.valid_from AS status_time,'payment_status' AS status_type,
		ROW_NUMBER() OVER (PARTITION BY b.trx_id,b.payment_status_code ORDER BY b.trx_history_id) AS rnk
		,1::INT AS displayID, b.trx_history_id
		FROM transactions.mf_order_detail_history b
		WHERE b.payment_status_code IN (0,1,2,3)
		AND b.trx_id = v_trx_id
		union
		---order Rejected
		select 
		c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
		e.final_status as status,
		c.valid_from as status_time,'order_status' as status_type,
		row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
		,2::int as displayID,c.trx_history_id
		from transactions.mf_order_detail_history c
		inner join transactions.mf_order_detail e
		on c.trx_id=e.trx_id
		where c.vendor_trx_id is null
		and c.trx_status_code in (8,3)
		--and c.consent_status_code=2
		and c.is_active='true'
		and c.trx_id=v_trx_id
		union
		select 
		c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
		e.final_status as status,
		c.valid_from as status_time,'order_status' as status_type,
		row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
		,3::int as displayID,c.trx_history_id
		from transactions.mf_order_detail_history c
		inner join transactions.mf_order_detail e
		on c.trx_id=e.trx_id
		where c.vendor_trx_id is not null
		and c.is_active='true'
		and c.trx_id=v_trx_id
		)a 
		where rnk=1
		order by a.trx_history_id,displayID;
		---------------------------------------------
		Else
		CREATE TEMP TABLE IF NOT EXISTS temp_mf_timeline as 
		select
		a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
		date_trunc('second',a.trx_datetime) as	trx_datetime,a.trx_status,a.status,
		date_trunc('second',a.status_time) as status_time,a.status_type
		,a.trx_history_id
		from (
		---order Rejected
		select 
		c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
		e.final_status as status,
		c.valid_from as status_time,'order_status' as status_type,
		row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
		,1::int as displayID,c.trx_history_id
		from transactions.mf_order_detail_history c
		inner join transactions.mf_order_detail e
		on c.trx_id=e.trx_id
		where c.vendor_trx_id is null
		and c.trx_status_code in (8,3)
		--and c.consent_status_code=2
		and c.is_active='true'
		and c.trx_id=v_trx_id
		union
		select 
		c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
		e.final_status as status,
		c.valid_from as status_time,'order_status' as status_type,
		row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
		,1::int as displayID,c.trx_history_id
		from transactions.mf_order_detail_history c
		inner join transactions.mf_order_detail e
		on c.trx_id=e.trx_id
		where c.vendor_trx_id is not null
		and c.is_active='true'
		and c.trx_id=v_trx_id
		)a 
		where rnk=1
		order by a.trx_history_id,displayID;
		End if;
		------------------------------------------
		delete FROM temp_mf_timeline
		WHERE ctid IN (
		SELECT ctid FROM (
		SELECT ctid, ROW_NUMBER() OVER (PARTITION BY trx_history_id ) AS rn
		FROM temp_mf_timeline
		) sub
		WHERE sub.rn > 1
		);
		-------------------------Final Output
		RETURN QUERY
		select 
		a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
		a.trx_datetime,a.trx_status,a.status::character varying as status,
		a.status_time,a.status_type
		from temp_mf_timeline a
		join (
		select 
		b.status_type,max(b.trx_history_id) as max_histid
		from temp_mf_timeline b
		where b.status_type IN ('payment_status','order_status')
		group by b.status_type
		) b on a.status_type = b.status_type 
		and a.trx_history_id = b.max_histid;
		
		END IF;
	END IF;
------------------------------------------------
drop table temp_mf_timeline;
------------------------------------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_timeline_details(varchar, varchar, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details(varchar, varchar, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details(varchar, varchar, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details(varchar, varchar, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details(varchar, varchar, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_timeline_details_bkp_09may2025(varchar, varchar, int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_timeline_details_bkp_09may2025(v_logintype character varying, v_logincode character varying, v_trx_id bigint)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, ac_code character varying, trx_type character varying, trx_datetime timestamp without time zone, trx_status character varying, status character varying, status_time timestamp without time zone, status_type text)
 LANGUAGE plpgsql
AS $function$
BEGIN

--RETURN QUERY
CREATE TEMP TABLE IF NOT EXISTS temp_mf_timeline AS 
select
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
date_trunc('second',a.trx_datetime) as	trx_datetime,a.trx_status,a.status,
date_trunc('second',a.status_time) as status_time,a.status_type
,a.trx_history_id
from (
select 
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
a.consent_status as status,
a.valid_from as status_time,'consent_status' as status_type,
row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
, 1::int as displayID,a.trx_history_id
from transactions.mf_order_detail_history a
where a.consent_status_code=1
and a.trx_id=v_trx_id
union
select 
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
a.consent_status as status,
a.valid_from as status_time,'consent_status' as status_type,
row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
, 1::int as displayID,a.trx_history_id
from transactions.mf_order_detail_history a
where a.consent_status_code=3
and a.trx_id=v_trx_id
union
select 
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
a.consent_status as status,
a.valid_from as status_time,'consent_status' as status_type,
row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
, 1::int as displayID,a.trx_history_id
from transactions.mf_order_detail_history a
where a.consent_status_code=2
and a.trx_id=v_trx_id
union
select 
b.trx_id,b.vendor_trx_id,b.ac_code,b.trx_type,b.trx_datetime,b.trx_status,
'Payment Pending' as status,
b.valid_from as status_time,'payment_status' as status_type,
row_number() over(partition by b.trx_id order by b.trx_history_id) rnk
, 2::int as displayID,b.trx_history_id
from transactions.mf_order_detail_history b
where b.payment_status_code=1
and b.trx_id=v_trx_id
union
select 
b.trx_id,b.vendor_trx_id,b.ac_code,b.trx_type,b.trx_datetime,b.trx_status,
'Payment Failed' as status,
b.valid_from as status_time,'payment_status' as status_type,
row_number() over(partition by b.trx_id order by b.trx_history_id) rnk
, 2::int as displayID,b.trx_history_id
from transactions.mf_order_detail_history b
where b.payment_status_code=3
and b.trx_id=v_trx_id
union
select 
b.trx_id,b.vendor_trx_id,b.ac_code,b.trx_type,b.trx_datetime,b.trx_status,
'Payment Processed' as status,
b.valid_from as status_time,'payment_status' as status_type,
row_number() over(partition by b.trx_id order by b.trx_history_id) rnk
, 2::int as displayID,b.trx_history_id
from transactions.mf_order_detail_history b
where b.payment_status_code=2
and b.trx_id=v_trx_id

union
---order Rejected
select 
c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
e.final_status as status,
c.valid_from as status_time,'order_status' as status_type,
row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
, 3::int as displayID,c.trx_history_id
from transactions.mf_order_detail_history c
inner join transactions.mf_order_detail e
on c.trx_id=e.trx_id
where c.vendor_trx_id is null
and c.trx_status_code in (8,3)
--and c.consent_status_code=2
and c.is_active='true'
and c.trx_id=v_trx_id
union
select 
c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
e.final_status as status,
c.valid_from as status_time,'order_status' as status_type,
row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
, 3::int as displayID,c.trx_history_id
from transactions.mf_order_detail_history c
inner join transactions.mf_order_detail e
on c.trx_id=e.trx_id
where c.vendor_trx_id is not null
and c.is_active='true'
and c.trx_id=v_trx_id
)a 
where rnk=1
order by a.trx_history_id,displayID;

------------------------------------------
delete FROM temp_mf_timeline
WHERE ctid IN (
    SELECT ctid FROM (
        SELECT ctid, ROW_NUMBER() OVER (PARTITION BY trx_history_id ) AS rn
        FROM temp_mf_timeline
    ) sub
    WHERE sub.rn > 1
);

-------------------------Final Output
RETURN QUERY
select 
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
a.trx_datetime,a.trx_status,a.status,
a.status_time,a.status_type
from temp_mf_timeline a
join (
    select 
    b.status_type,max(b.trx_history_id) as max_histid
    from temp_mf_timeline b
    where b.status_type IN ('consent_status','payment_status','order_status')
    group by b.status_type
) b on a.status_type = b.status_type 
and a.trx_history_id = b.max_histid;

------------------------------------------------
drop table temp_mf_timeline;
------------------------------------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_timeline_details_bkp_09may2025(varchar, varchar, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details_bkp_09may2025(varchar, varchar, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details_bkp_09may2025(varchar, varchar, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details_bkp_09may2025(varchar, varchar, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details_bkp_09may2025(varchar, varchar, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_timeline_details_bkp_14jul2025(varchar, varchar, int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_timeline_details_bkp_14jul2025(v_logintype character varying, v_logincode character varying, v_trx_id bigint)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, ac_code character varying, trx_type character varying, trx_datetime timestamp without time zone, trx_status character varying, status character varying, status_time timestamp without time zone, status_type text)
 LANGUAGE plpgsql
AS $function$
BEGIN

--RETURN QUERY
CREATE TEMP TABLE IF NOT EXISTS temp_mf_timeline AS 
select
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
date_trunc('second',a.trx_datetime) as	trx_datetime,a.trx_status,a.status,
date_trunc('second',a.status_time) as status_time,a.status_type
,a.trx_history_id
from (
select 
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
a.consent_status as status,
a.valid_from as status_time,'consent_status' as status_type,
row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
, 1::int as displayID,a.trx_history_id
from transactions.mf_order_detail_history a
where a.consent_status_code=1
and a.trx_id=v_trx_id
union
select 
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
a.consent_status as status,
a.valid_from as status_time,'consent_status' as status_type,
row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
, 1::int as displayID,a.trx_history_id
from transactions.mf_order_detail_history a
where a.consent_status_code=3
and a.trx_id=v_trx_id
union
select 
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,a.trx_datetime,a.trx_status,
a.consent_status as status,
a.valid_from as status_time,'consent_status' as status_type,
row_number() over(partition by a.trx_id order by a.trx_history_id) rnk
, 1::int as displayID,a.trx_history_id
from transactions.mf_order_detail_history a
where a.consent_status_code=2
and a.trx_id=v_trx_id
union
select 
b.trx_id,b.vendor_trx_id,b.ac_code,b.trx_type,b.trx_datetime,b.trx_status,
'Payment Pending' as status,
b.valid_from as status_time,'payment_status' as status_type,
row_number() over(partition by b.trx_id order by b.trx_history_id) rnk
, 2::int as displayID,b.trx_history_id
from transactions.mf_order_detail_history b
where b.payment_status_code=1
and b.trx_id=v_trx_id
union
select 
b.trx_id,b.vendor_trx_id,b.ac_code,b.trx_type,b.trx_datetime,b.trx_status,
'Payment Failed' as status,
b.valid_from as status_time,'payment_status' as status_type,
row_number() over(partition by b.trx_id order by b.trx_history_id) rnk
, 2::int as displayID,b.trx_history_id
from transactions.mf_order_detail_history b
where b.payment_status_code=3
and b.trx_id=v_trx_id
union
select 
b.trx_id,b.vendor_trx_id,b.ac_code,b.trx_type,b.trx_datetime,b.trx_status,
'Payment Processed' as status,
b.valid_from as status_time,'payment_status' as status_type,
row_number() over(partition by b.trx_id order by b.trx_history_id) rnk
, 2::int as displayID,b.trx_history_id
from transactions.mf_order_detail_history b
where b.payment_status_code=2
and b.trx_id=v_trx_id

union
---order Rejected
select 
c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
e.final_status as status,
c.valid_from as status_time,'order_status' as status_type,
row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
, 3::int as displayID,c.trx_history_id
from transactions.mf_order_detail_history c
inner join transactions.mf_order_detail e
on c.trx_id=e.trx_id
where c.vendor_trx_id is null
and c.trx_status_code in (8,3)
--and c.consent_status_code=2
and c.is_active='true'
and c.trx_id=v_trx_id
union
select 
c.trx_id,c.vendor_trx_id,c.ac_code,c.trx_type,c.trx_datetime,c.trx_status,
e.final_status as status,
c.valid_from as status_time,'order_status' as status_type,
row_number() over(partition by c.trx_id order by c.trx_history_id desc) rnk
, 3::int as displayID,c.trx_history_id
from transactions.mf_order_detail_history c
inner join transactions.mf_order_detail e
on c.trx_id=e.trx_id
where c.vendor_trx_id is not null
and c.is_active='true'
and c.trx_id=v_trx_id
)a 
where rnk=1
order by a.trx_history_id,displayID;

------------------------------------------
delete FROM temp_mf_timeline
WHERE ctid IN (
    SELECT ctid FROM (
        SELECT ctid, ROW_NUMBER() OVER (PARTITION BY trx_history_id ) AS rn
        FROM temp_mf_timeline
    ) sub
    WHERE sub.rn > 1
);

-------------------------Final Output
RETURN QUERY
select 
a.trx_id,a.vendor_trx_id,a.ac_code,a.trx_type,
a.trx_datetime,a.trx_status,a.status,
a.status_time,a.status_type
from temp_mf_timeline a
join (
    select 
    b.status_type,max(b.trx_history_id) as max_histid
    from temp_mf_timeline b
    where b.status_type IN ('consent_status','payment_status','order_status')
    group by b.status_type
) b on a.status_type = b.status_type 
and a.trx_history_id = b.max_histid;

------------------------------------------------
drop table temp_mf_timeline;
------------------------------------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_timeline_details_bkp_14jul2025(varchar, varchar, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details_bkp_14jul2025(varchar, varchar, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details_bkp_14jul2025(varchar, varchar, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details_bkp_14jul2025(varchar, varchar, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_timeline_details_bkp_14jul2025(varchar, varchar, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_transactions(varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_transactions(v_ac_code character varying, v_trx_type character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, ucccode character varying, ac_code character varying, user_id character varying, isincode character varying, trx_type character varying, trx_datetime timestamp without time zone, trx_amt numeric, trx_qty numeric, sip_frequency character varying, mf_schcode bigint, first_installment_date timestamp without time zone, installment_type integer, no_of_installment integer, delivery_mode character varying, mandate_id character varying, trx_status character varying, payment_status character varying, modified_date timestamp without time zone, modified_by character varying, ispaused boolean, iscancancelled boolean, trx_source character varying, parent_trx_id character varying, created_date timestamp without time zone, nav numeric, navdate date, order_nav numeric, order_navdate date, folio_no character varying, order_type character varying, physicalflag character varying, order_remarks character varying, order_tenure character varying, tokenno bigint, switchtokenno bigint, payment_trxid character varying, vendor_exchg_refno character varying, euinnumber character varying, switch_isin character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF(v_ac_code IS NOT NULL AND v_ac_code <> '')
	THEN
		
		IF(v_trx_type IS NULL OR v_trx_type = '')
		THEN
		
			RETURN QUERY
			SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A."user_id", A.isincode, A.trx_type, A.trx_datetime, A.trx_amt, A.trx_qty
			, A.sip_frequency, A.mf_schcode, A.first_installment_date, A.installment_type, A.no_of_installment, A.delivery_mode, A.mandate_id
			, A.trx_status, A.payment_status, A.modified_date, A.modified_by, A.ispaused, A.iscancancelled, A.trx_source, A.parent_trx_id
			, A.created_date, A.nav, A.navdate, A.order_nav, A.order_navdate, A.folio_no, A.order_type, A.physicalflag, A.order_remarks
			, A.order_tenure, A.tokenno, A.switchtokenno, A.payment_trxid, A.vendor_exchg_refno, A.euinnumber, A.switch_isin
			FROM transactions.mf_order_detail A WHERE A.ac_code = v_ac_code;

		ELSIF(v_trx_type IS NOT NULL AND v_trx_type <> '')
		THEN

			RETURN QUERY
			SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A."user_id", A.isincode, A.trx_type, A.trx_datetime, A.trx_amt, A.trx_qty
			, A.sip_frequency, A.mf_schcode, A.first_installment_date, A.installment_type, A.no_of_installment, A.delivery_mode, A.mandate_id
			, A.trx_status, A.payment_status, A.modified_date, A.modified_by, A.ispaused, A.iscancancelled, A.trx_source, A.parent_trx_id
			, A.created_date, A.nav, A.navdate, A.order_nav, A.order_navdate, A.folio_no, A.order_type, A.physicalflag, A.order_remarks
			, A.order_tenure, A.tokenno, A.switchtokenno, A.payment_trxid, A.vendor_exchg_refno, A.euinnumber, A.switch_isin
			FROM transactions.mf_order_detail A WHERE A.ac_code = v_ac_code AND A.trx_type = v_trx_type;
		
		END IF;
		
	END IF;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_transactions(varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_transactions(varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_transactions(varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_transactions(varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_transactions(varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_transactions_bkp_09may2025(varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_transactions_bkp_09may2025(v_ac_code character varying, v_trx_type character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, vendor_trx_id bigint, ucccode character varying, ac_code character varying, user_id character varying, isincode character varying, trx_type character varying, trx_datetime timestamp without time zone, trx_amt numeric, trx_qty numeric, sip_frequency character varying, mf_schcode bigint, first_installment_date timestamp without time zone, installment_type integer, no_of_installment integer, delivery_mode character varying, mandate_id character varying, trx_status character varying, payment_status character varying, modified_date timestamp without time zone, modified_by character varying, ispaused boolean, iscancancelled boolean, trx_source character varying, parent_trx_id character varying, created_date timestamp without time zone, nav numeric, navdate date, order_nav numeric, order_navdate date, folio_no character varying, order_type character varying, physicalflag character varying, order_remarks character varying, order_tenure character varying, tokenno bigint, switchtokenno bigint, payment_trxid character varying, vendor_exchg_refno character varying, euinnumber character varying, switch_isin character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF(v_ac_code IS NOT NULL AND v_ac_code <> '')
	THEN
		
		IF(v_trx_type IS NULL OR v_trx_type = '')
		THEN
		
			RETURN QUERY
			SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A."user_id", A.isincode, A.trx_type, A.trx_datetime, A.trx_amt, A.trx_qty
			, A.sip_frequency, A.mf_schcode, A.first_installment_date, A.installment_type, A.no_of_installment, A.delivery_mode, A.mandate_id
			, A.trx_status, A.payment_status, A.modified_date, A.modified_by, A.ispaused, A.iscancancelled, A.trx_source, A.parent_trx_id
			, A.created_date, A.nav, A.navdate, A.order_nav, A.order_navdate, A.folio_no, A.order_type, A.physicalflag, A.order_remarks
			, A.order_tenure, A.tokenno, A.switchtokenno, A.payment_trxid, A.vendor_exchg_refno, A.euinnumber, A.switch_isin
			FROM transactions.mf_order_detail A WHERE A.ac_code = v_ac_code;

		ELSIF(v_trx_type IS NOT NULL AND v_trx_type <> '')
		THEN

			RETURN QUERY
			SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A."user_id", A.isincode, A.trx_type, A.trx_datetime, A.trx_amt, A.trx_qty
			, A.sip_frequency, A.mf_schcode, A.first_installment_date, A.installment_type, A.no_of_installment, A.delivery_mode, A.mandate_id
			, A.trx_status, A.payment_status, A.modified_date, A.modified_by, A.ispaused, A.iscancancelled, A.trx_source, A.parent_trx_id
			, A.created_date, A.nav, A.navdate, A.order_nav, A.order_navdate, A.folio_no, A.order_type, A.physicalflag, A.order_remarks
			, A.order_tenure, A.tokenno, A.switchtokenno, A.payment_trxid, A.vendor_exchg_refno, A.euinnumber, A.switch_isin
			FROM transactions.mf_order_detail A WHERE A.ac_code = v_ac_code AND A.trx_type = v_trx_type;
		
		END IF;
		
	END IF;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_transactions_bkp_09may2025(varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_transactions_bkp_09may2025(varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_transactions_bkp_09may2025(varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_transactions_bkp_09may2025(varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_transactions_bkp_09may2025(varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_mf_viewed_hist(varchar);

CREATE OR REPLACE FUNCTION transactions.fn_get_mf_viewed_hist(v_login_code character varying DEFAULT NULL::character varying)
 RETURNS TABLE(viewed_id bigint, login_code character varying, mf_schcode bigint, created_date timestamp without time zone)
 LANGUAGE plpgsql
AS $function$

BEGIN

	RETURN QUERY
	SELECT A.viewed_id, A.login_code, A.mf_schcode, A.created_date FROM transactions.mf_viewed_history A
	WHERE CASE WHEN v_login_code IS NOT NULL AND v_login_code <> '' THEN A.login_code = v_login_code ELSE TRUE END;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_mf_viewed_hist(varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_viewed_hist(varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_mf_viewed_hist(varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_mf_viewed_hist(varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_mf_viewed_hist(varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_scheme_client_holding(varchar, varchar, int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_scheme_client_holding(v_logintype character varying, v_ac_code character varying, v_mf_schcode bigint)
 RETURNS TABLE(holdingdate date, ucccode character varying, priority_ac_code character varying, dp_flag character varying, isincode character varying, isinname character varying, foliotype character varying, display_foliono character varying, nav numeric, marketvalue numeric, totalqty numeric, freeqty numeric, grpcode character varying, return_type character varying, redeem_allowed boolean, mf_schcode bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN	
RETURN QUERY
select 
a.holdingdate,a.ucccode,a.priority_ac_code,a.dp_flag,
	a.isincode,a.isinname,max(a.foliotype)::character varying as foliotype,
	max(a.display_foliono)::character varying as display_foliono, max(a.nav) as nav,
	sum(a.marketvalue) as marketvalue, sum(a.totalqty) as totalqty,
	sum(a.freeqty) as freeqty,a.grpcode,max(a.return_type)::character varying as return_type,
	a.redeem_allowed,a.mf_schcode
	from (
	select 
	a.holdingdate,a.ucccode,a.priority_ac_code,a.dp_flag,
	a.isincode,a.isinname,a.foliotype,a.display_foliono,a.nav,
	a.marketvalue,a.totalqty,
	coalesce(a.freeqty,a.totalqty) as freeqty,isin.schemecode as grpcode,
	replace(isin.return_type,'Dividend','IDCW')::character varying as return_type,
	a.redeem_allowed,a.mf_schcode
	from transactions.mv_client_holding a
	inner join(
		select isin.mf_schcode,isin.isincode,isin.schemecode,isin.return_type
		from master.dim_mf_isin isin
		where category_code=261	
		and isin.isactive = 1 
		and isin.mf_schcode is not null
		and isin.return_type_id is not null	
	)isin on isin.isincode=a.isincode
	where a.category_code=261
	--and a.remarks=''
	and	a.priority_ac_code=v_ac_code
	and a.mf_schcode in (
		select distinct sch.mf_schcode from master.dim_mf_scheme sch
		where sch.schemegroup in (
		select distinct sch.schemegroup from master.dim_mf_scheme sch
		where sch.mf_schcode=v_mf_schcode
		)
	and coalesce(a.nav,0.00)<>0.00 and a.redeem_allowed=true
	)
)a
group by a.holdingdate,a.ucccode,a.priority_ac_code,a.dp_flag,
	a.isincode,a.isinname,a.grpcode,a.redeem_allowed,a.mf_schcode;

END;

$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_scheme_client_holding(varchar, varchar, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_scheme_client_holding(varchar, varchar, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_scheme_client_holding(varchar, varchar, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_scheme_client_holding(varchar, varchar, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_scheme_client_holding(varchar, varchar, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_scheme_client_holding_bkp_09may2025(varchar, varchar, int8);

CREATE OR REPLACE FUNCTION transactions.fn_get_scheme_client_holding_bkp_09may2025(v_logintype character varying, v_ac_code character varying, v_mf_schcode bigint)
 RETURNS TABLE(holdingdate date, ucccode character varying, priority_ac_code character varying, dp_flag character varying, isincode character varying, isinname character varying, foliotype character varying, display_foliono character varying, nav numeric, marketvalue numeric, totalqty numeric, freeqty numeric, grpcode character varying, return_type character varying, redeem_allowed boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN	
RETURN QUERY
select 
a.holdingdate,a.ucccode,a.priority_ac_code,a.dp_flag,
	a.isincode,a.isinname,max(a.foliotype)::character varying as foliotype,
	max(a.display_foliono)::character varying as display_foliono, max(a.nav) as nav,
	sum(a.marketvalue) as marketvalue, sum(a.totalqty) as totalqty,
	sum(a.freeqty) as freeqty,a.grpcode,max(a.return_type)::character varying as return_type,
	a.redeem_allowed
	from (
	select 
	a.holdingdate,a.ucccode,a.priority_ac_code,a.dp_flag,
	a.isincode,a.isinname,a.foliotype,a.display_foliono,a.nav,
	a.marketvalue,a.totalqty,
	coalesce(a.freeqty,a.totalqty) as freeqty,isin.schemecode as grpcode,
	replace(isin.return_type,'Dividend','IDCW')::character varying as return_type,
	a.redeem_allowed
	from transactions.mv_client_holding a
	inner join(
		select isin.mf_schcode,isin.isincode,isin.schemecode,isin.return_type
		from master.dim_mf_isin isin
		where category_code=261	
		and isin.isactive = 1 
		and isin.mf_schcode is not null
		and isin.return_type_id is not null	
	)isin on isin.isincode=a.isincode
	where a.category_code=261
	--and a.remarks=''
	and	a.priority_ac_code=v_ac_code
	and a.mf_schcode in (
		select distinct mf_schcode from master.dim_mf_scheme
		where schemegroup in (
		select distinct schemegroup from master.dim_mf_scheme
		where mf_schcode=v_mf_schcode
		)
	and coalesce(a.nav,0.00)<>0.00 and a.redeem_allowed=true
	)
)a
group by a.holdingdate,a.ucccode,a.priority_ac_code,a.dp_flag,
	a.isincode,a.isinname,a.grpcode,a.redeem_allowed;
END;

$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_scheme_client_holding_bkp_09may2025(varchar, varchar, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_scheme_client_holding_bkp_09may2025(varchar, varchar, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_get_scheme_client_holding_bkp_09may2025(varchar, varchar, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_scheme_client_holding_bkp_09may2025(varchar, varchar, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_scheme_client_holding_bkp_09may2025(varchar, varchar, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_get_subsequent_sip_reminder();

CREATE OR REPLACE FUNCTION transactions.fn_get_subsequent_sip_reminder()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

BEGIN

--/*--communications

insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked
)
-----------SIP
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.ac_code as clientcode,INITCAP(ucc.acname)::character varying as clientname,
dest.trx_datetime::character varying as orderdate,
''::character varying as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
dest.isinname as fundname,
dest.trx_amt::character varying as amount,
''::character varying as units,
''::character varying as rejection_reason,
src.upcoming_due_date::character varying as next_due_date,
''::character varying as sip_start_date,
''::character varying as sip_end_date,
''::character varying as frequency,
''::character varying as installment_number,
mad.bankname::character varying as bankname,
mad.bank_ac_number::character varying as bankacno,
'82'::character varying as sourceid,
'3580'::character varying as subcategoryid,
'SUBSEQUENT_SIP_REMINDERS_INTERNAL'::character varying as subcategory,
false as is_picked
from transactions.mf_due_dates src
inner join transactions.mf_order_detail dest
on src.vendor_trx_id = dest.vendor_trx_id
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code and mst.category_code=261
join transactions.mf_mandate mad
on dest.mandate_id = mad.mandateid
join master.dim_ucc ucc
on ucc.priority_ac_code=src.ac_code
where (src.upcoming_due_date - INTERVAL '3 day')::date=(NOW() at time zone 'Asia/Kolkata')::date
and dest.trx_type_code=1 
and dest.inv_action_code=1
and dest.vendor_trx_status<>'CANCELLED'
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--and src.vendor_trx_id=1067703;
--*/

RETURN 'SUCCESS';

EXCEPTION
WHEN OTHERS THEN
BEGIN

RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_get_subsequent_sip_reminder() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_subsequent_sip_reminder() TO public;
GRANT ALL ON FUNCTION transactions.fn_get_subsequent_sip_reminder() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_get_subsequent_sip_reminder() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_get_subsequent_sip_reminder() TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_created_mandate(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_insert_created_mandate(v_mandateid character varying, v_ac_code character varying, v_amount numeric, v_mandate_type character varying, v_start_date date, v_bankname character varying, v_bank_ac_number character varying, v_ifsc_code character varying, v_source character varying, v_logintype character varying DEFAULT NULL::character varying, v_created_for character varying DEFAULT NULL::character varying)
 RETURNS TABLE(remarks character varying, advisor_name character varying, advisor_email character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_created_for_name character varying;
DECLARE v_created_for_type character varying;

DECLARE v_advisor_email character varying;

BEGIN

-------------------------------------------------------------------
SELECT 
	COALESCE(initcap(sub.created_for_name), '') AS created_for_name,
	COALESCE(sub.created_for_type, '') AS created_for_type,
	COALESCE(sub.advisor_email, '') AS advisor_email
INTO v_created_for_name, v_created_for_type,v_advisor_email
FROM (
	SELECT a.fullname AS created_for_name, 'E' AS created_for_type,
	a.businessemail as advisor_email
	FROM master.dim_ed_employee a
	WHERE ltrim(a.empcode, '0') = v_created_for

	UNION

	SELECT a.partner_name as created_for_name, 'P' as created_for_type,
	a.email_id as advisor_email
	FROM master.partner a
	WHERE a.upccode = v_created_for
	and upper(a.status)	='ACTIVE'
	--'PNW23054520' 
) sub
LIMIT 1;

-- Optional: use RAISE NOTICE to print the values
RAISE NOTICE 'Name: %, Type: %', v_created_for_name, v_created_for_type;

------------------------------------------------------------------------------------
INSERT INTO transactions.stg_mf_mandate(
mandateid,ac_code,mandate_type,amount,start_date,end_date,
bankname,bank_ac_number,ifsc_code,status,trx_source,created_date,
created_for,created_for_type,created_for_name
)
VALUES (
v_mandateid, v_ac_code, v_mandate_type, v_amount, v_start_date,
(v_start_date + INTERVAL '30 years')::date,
v_bankname, v_bank_ac_number, v_ifsc_code, 
(case when v_mandate_type='X' then 'Document not uploaded' 
else 'Authentication Pending' end)::character varying,
v_source,-- NOW() AT TIME ZONE 'Asia/Kolkata'
DATE_TRUNC('second', NOW() AT TIME ZONE 'Asia/Kolkata')
,v_created_for,v_created_for_type,v_created_for_name
);

-----Update details
	update transactions.stg_mf_mandate a
	set acname= b.acname,
	ucccode=b.ucccode
	from master.dim_ucc b
	where a.ac_code=b.priority_ac_code
	and a.ac_code=v_ac_code;

	RETURN QUERY 
		SELECT 'SUCCESS'::character varying as remarks, 
		v_created_for_name::character varying as advisor_name,
		v_advisor_email::character varying as advisor_email;
		
EXCEPTION
	WHEN OTHERS THEN
		RETURN QUERY 
	SELECT ('Failure Error :- ' || CAST(SQLERRM AS character varying))::character varying as remarks,
	NULL::character varying as advisor_name,
	NULL::character varying as advisor_email;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_created_mandate(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_created_mandate(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_created_mandate(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_created_mandate(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_insert_created_mandate(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_created_mandate_bkp_09sept2025(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_insert_created_mandate_bkp_09sept2025(v_mandateid character varying, v_ac_code character varying, v_amount numeric, v_mandate_type character varying, v_start_date date, v_bankname character varying, v_bank_ac_number character varying, v_ifsc_code character varying, v_source character varying)
 RETURNS TABLE(remarks character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
	INSERT INTO transactions.stg_mf_mandate (
		mandateid, ac_code, mandate_type, amount, start_date, end_date,
		bankname, bank_ac_number, ifsc_code, status, trx_source, created_date
	)
	VALUES (
		v_mandateid, v_ac_code, v_mandate_type, v_amount, v_start_date,
		(v_start_date + INTERVAL '30 years')::date,
		v_bankname, v_bank_ac_number, v_ifsc_code, 
 	(case when v_mandate_type='X' then 'Document not uploaded' 
	else 'Authentication Pending' end)::character varying,
		v_source,-- NOW() AT TIME ZONE 'Asia/Kolkata'
	DATE_TRUNC('second', NOW() AT TIME ZONE 'Asia/Kolkata')
	);

-----Update details
	update transactions.stg_mf_mandate a
	set acname= b.acname,
	ucccode=b.ucccode
	from master.dim_ucc b
	where a.ac_code=b.priority_ac_code
	and a.ac_code=v_ac_code;

	RETURN QUERY SELECT 'SUCCESS'::character varying;

EXCEPTION
	WHEN OTHERS THEN
		RETURN QUERY SELECT 'Failure Error :- ' || CAST(SQLERRM AS character varying);
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_created_mandate_bkp_09sept2025(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_created_mandate_bkp_09sept2025(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_created_mandate_bkp_09sept2025(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_created_mandate_bkp_09sept2025(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_insert_created_mandate_bkp_09sept2025(varchar, varchar, numeric, varchar, date, varchar, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_delete_mf_bookmark_data(varchar, _int8, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_insert_delete_mf_bookmark_data(v_login_code character varying, v_mf_schcode bigint[], v_type character varying)
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

	IF (v_type = 'I')
	THEN
	
		CREATE TEMP TABLE IF NOT EXISTS temp_mf_bm AS SELECT v_login_code userid, UNNEST(v_mf_schcode) mf_schcode;
			
		UPDATE transactions.mf_bookmark_history A SET created_date = NOW()
		FROM temp_mf_bm B WHERE A.login_code = B.userid AND A.mf_schcode = B.mf_schcode;
		
		INSERT INTO transactions.mf_bookmark_history (login_code, mf_schcode, created_date)
		SELECT B.userid, B.mf_schcode, NOW() FROM temp_mf_bm B
		LEFT JOIN transactions.mf_bookmark_history A ON A.login_code = B.userid AND A.mf_schcode = B.mf_schcode
		WHERE A.bookmark_id IS NULL;
		
		DROP TABLE temp_mf_bm; 

		RETURN QUERY
		SELECT 'SUCCESS'::character varying status;
		
	ELSIF (v_type = 'D')
	THEN
		
		DELETE FROM transactions.mf_bookmark_history WHERE login_code = v_login_code AND mf_schcode = ANY ($2);

		RETURN QUERY
		SELECT 'SUCCESS'::character varying status;
			
	END IF;
	
	EXCEPTION
		WHEN others THEN
		BEGIN
			RETURN QUERY
			SELECT ('FAILURE and Error :- '||CAST(SQLERRM as VARCHAR(4000)))::character varying status;
    END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_delete_mf_bookmark_data(varchar, _int8, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_delete_mf_bookmark_data(varchar, _int8, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_delete_mf_bookmark_data(varchar, _int8, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_delete_mf_bookmark_data(varchar, _int8, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_insert_delete_mf_bookmark_data(varchar, _int8, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_mf_consent(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_insert_mf_consent(v_trx_id bigint[], v_category_code integer, v_consent_status character varying, v_consent_expiry timestamp without time zone, v_consent_link text, v_consent_type character varying, v_issent integer, v_ac_code character varying, v_ac_name character varying, v_client_email_id character varying, v_client_mobile character varying, v_cc_email character varying, v_bcc_email character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, consent_id character varying, remarks character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_consent_id bigint;
DECLARE result_row RECORD;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code
			  AND A.inv_action_code = v_inv_action_code AND A.ac_code = v_ac_code
			  AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
					   WHEN UPPER(v_consent_type) = 'SMS' THEN 2
					   WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
					   WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type AND A.consent_status = v_consent_status)
	THEN

		IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code
				  AND A.inv_action_code = v_inv_action_code AND A.ac_code = v_ac_code
				  AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
						   WHEN UPPER(v_consent_type) = 'SMS' THEN 2
						   WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
						   WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type
				  AND (NOW() at time zone 'Asia/Kolkata') < A.consent_expire_date AND A.consent_status = v_consent_status AND A.issent = 1 AND v_issent = 1)
		THEN
			
			UPDATE transactions.order_consent A SET resent_count = A.resent_count+1
			WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code
			AND A.inv_action_code = v_inv_action_code AND A.ac_code = v_ac_code
			AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
					 WHEN UPPER(v_consent_type) = 'SMS' THEN 2
					 WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
					 WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type
			AND (NOW() at time zone 'Asia/Kolkata') < A.consent_expire_date AND A.consent_status = v_consent_status AND A.issent = 1 AND v_issent = 1;
			
			RETURN QUERY
			SELECT A.trx_id, A.consent_id
			, ('Consent resent sucessfully for account code '||v_ac_code||' with account name '||v_ac_name)::character varying as remarks FROM transactions.order_consent A
			WHERE A.trx_id = ANY($1) AND category_code = v_category_code
			AND A.inv_action_code = v_inv_action_code AND A.ac_code = v_ac_code
			AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
					 WHEN UPPER(v_consent_type) = 'SMS' THEN 2
					 WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
					 WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type
			AND (NOW() at time zone 'Asia/Kolkata') < A.consent_expire_date AND A.consent_status = v_consent_status AND A.issent = 1 AND v_issent = 1;

		END IF;
		
	ELSE
	
		FOR result_row IN
			(SELECT DISTINCT A.trx_id, A.category_code, A.consent_type
			 FROM (SELECT v_category_code category_code, v_consent_type consent_type, UNNEST(v_trx_id) trx_id) A
			 LEFT JOIN transactions.order_consent B ON A.category_code = B.category_code AND B.inv_action_code = v_inv_action_code AND B.consent_status = v_consent_status
													   AND A.trx_id = B.trx_id AND CASE WHEN UPPER(A.consent_type) = 'EMAIL' THEN 1
																						WHEN UPPER(A.consent_type) = 'SMS' THEN 2
																						WHEN UPPER(A.consent_type) = 'WHATSAPP' THEN 3
																						WHEN UPPER(A.consent_type) = 'PUSH' THEN 4 END = B.consent_type
			 WHERE B.trx_id IS NULL)
		LOOP 
		
		SELECT nextval('transactions.order_consent_id_seq'::regclass) INTO v_consent_id;
		
		INSERT INTO transactions.order_consent
		(id, consent_id, trx_id, category_code, consent_created_datetime, consent_status, consent_expire_date
		 , resent_count, consent_link, consent_type, issent, ac_code, ac_name, client_email_id, client_mobile, cc_email, bcc_email, inv_action_code)
		SELECT v_consent_id, ('C'||v_consent_id)::character varying consent_id, result_row.trx_id, result_row.category_code,
			(NOW() at time zone 'Asia/Kolkata'), v_consent_status, v_consent_expiry, 0, v_consent_link
		, CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
			   WHEN UPPER(v_consent_type) = 'SMS' THEN 2
			   WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
			   WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END as consent_type
		, v_issent, v_ac_code, v_ac_name, v_client_email_id, v_client_mobile, v_cc_email, v_bcc_email, v_inv_action_code;
			
		END LOOP;
	
		RETURN QUERY
		SELECT A.trx_id, A.consent_id, ('Consent Genrated sucessfully for account code '||A.ac_code||' with account name '||A.ac_name)::character varying as remarks
		FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
																			WHEN UPPER(v_consent_type) = 'SMS' THEN 2
																			WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
																			WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type
		AND A.inv_action_code = v_inv_action_code AND A.consent_status = v_consent_status;

	END IF;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_mf_consent(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_consent(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_consent(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_consent(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_consent(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_mf_consent_bkp_09may2025(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_insert_mf_consent_bkp_09may2025(v_trx_id bigint[], v_category_code integer, v_consent_status character varying, v_consent_expiry timestamp without time zone, v_consent_link text, v_consent_type character varying, v_issent integer, v_ac_code character varying, v_ac_name character varying, v_client_email_id character varying, v_client_mobile character varying, v_cc_email character varying, v_bcc_email character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, consent_id character varying, remarks character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_consent_id bigint;
DECLARE result_row RECORD;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code
			  AND A.inv_action_code = v_inv_action_code AND A.ac_code = v_ac_code
			  AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
					   WHEN UPPER(v_consent_type) = 'SMS' THEN 2
					   WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
					   WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type AND A.consent_status = v_consent_status)
	THEN

		IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code
				  AND A.inv_action_code = v_inv_action_code AND A.ac_code = v_ac_code
				  AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
						   WHEN UPPER(v_consent_type) = 'SMS' THEN 2
						   WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
						   WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type
				  AND NOW() < A.consent_expire_date AND A.consent_status = v_consent_status AND A.issent = 1 AND v_issent = 1)
		THEN
			
			UPDATE transactions.order_consent A SET resent_count = A.resent_count+1
			WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code
			AND A.inv_action_code = v_inv_action_code AND A.ac_code = v_ac_code
			AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
					 WHEN UPPER(v_consent_type) = 'SMS' THEN 2
					 WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
					 WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type
			AND NOW() < A.consent_expire_date AND A.consent_status = v_consent_status AND A.issent = 1 AND v_issent = 1;
			
			RETURN QUERY
			SELECT A.trx_id, A.consent_id
			, ('Consent resent sucessfully for account code '||v_ac_code||' with account name '||v_ac_name)::character varying as remarks FROM transactions.order_consent A
			WHERE A.trx_id = ANY($1) AND category_code = v_category_code
			AND A.inv_action_code = v_inv_action_code AND A.ac_code = v_ac_code
			AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
					 WHEN UPPER(v_consent_type) = 'SMS' THEN 2
					 WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
					 WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type
			AND NOW() < A.consent_expire_date AND A.consent_status = v_consent_status AND A.issent = 1 AND v_issent = 1;

		END IF;
		
	ELSE
	
		FOR result_row IN
			(SELECT DISTINCT A.trx_id, A.category_code, A.consent_type
			 FROM (SELECT v_category_code category_code, v_consent_type consent_type, UNNEST(v_trx_id) trx_id) A
			 LEFT JOIN transactions.order_consent B ON A.category_code = B.category_code AND B.inv_action_code = v_inv_action_code AND B.consent_status = v_consent_status
													   AND A.trx_id = B.trx_id AND CASE WHEN UPPER(A.consent_type) = 'EMAIL' THEN 1
																						WHEN UPPER(A.consent_type) = 'SMS' THEN 2
																						WHEN UPPER(A.consent_type) = 'WHATSAPP' THEN 3
																						WHEN UPPER(A.consent_type) = 'PUSH' THEN 4 END = B.consent_type
			 WHERE B.trx_id IS NULL)
		LOOP 
		
		SELECT nextval('transactions.order_consent_id_seq'::regclass) INTO v_consent_id;
		
		INSERT INTO transactions.order_consent
		(id, consent_id, trx_id, category_code, consent_created_datetime, consent_status, consent_expire_date
		 , resent_count, consent_link, consent_type, issent, ac_code, ac_name, client_email_id, client_mobile, cc_email, bcc_email, inv_action_code)
		SELECT v_consent_id, ('C'||v_consent_id)::character varying consent_id, result_row.trx_id, result_row.category_code, NOW(), v_consent_status, v_consent_expiry, 0, v_consent_link
		, CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
			   WHEN UPPER(v_consent_type) = 'SMS' THEN 2
			   WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
			   WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END as consent_type
		, v_issent, v_ac_code, v_ac_name, v_client_email_id, v_client_mobile, v_cc_email, v_bcc_email, v_inv_action_code;
			
		END LOOP;
	
		RETURN QUERY
		SELECT A.trx_id, A.consent_id, ('Consent Genrated sucessfully for account code '||A.ac_code||' with account name '||A.ac_name)::character varying as remarks
		FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND CASE WHEN UPPER(v_consent_type) = 'EMAIL' THEN 1
																			WHEN UPPER(v_consent_type) = 'SMS' THEN 2
																			WHEN UPPER(v_consent_type) = 'WHATSAPP' THEN 3
																			WHEN UPPER(v_consent_type) = 'PUSH' THEN 4 END = A.consent_type
		AND A.inv_action_code = v_inv_action_code AND A.consent_status = v_consent_status;

	END IF;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_mf_consent_bkp_09may2025(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_consent_bkp_09may2025(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_consent_bkp_09may2025(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_consent_bkp_09may2025(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_consent_bkp_09may2025(_int8, int4, varchar, timestamp, text, varchar, int4, varchar, varchar, varchar, varchar, varchar, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_mf_holding_external(int4);

CREATE OR REPLACE FUNCTION transactions.fn_insert_mf_holding_external(p_syncid integer)
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$
declare 
	v_status varchar:= 'Failed';
begin 

	
	drop table if exists tmp_update;

	create temp table tmp_update
	as
	with tmp_stg
	as
	(
	select 	stg.sync_id  as sync_id, 
			stg.pan as pan,
			null as ucccode,
			stg.mobile as mobileno,
			stg.amcname as amcname, 
			stg.folio as folio, 
			stg.schemecode as schemecode, 
			stg.schemename as schemename, 
			stg.schemeoption as schemeoption, 
			stg.assetype as assetype, 
			stg.schemetype as schemetype, 
			stg.nav as nav, 
			stg.navdate as navdate, 
			stg.closingbalance as closingbalance, 
			stg.avlunits  as avlunits, 
			stg.avlamt  as avlamt, 
			stg.currentmarketvalue  as currentmarketvalue, 
			stg.costvalue as costvalue, 
			stg.gainloss as gainloss, 
			stg.gainlosspercentage as gainlosspercentage, 
			stg.isin as isin, 
			stg.decimalunits  as decimalunits, 
			stg.decimalamt  as decimalamt, 
			stg.decimalnav as decimalnav, 
			stg.isdemat as isdemat, 
			stg.nomineestatus, 
			stg.brokercode, 
			stg.brokername, 
			stg.rtaname,
			current_timestamp at TIME ZONE'Asia/Kolkata' as created_date
	from transactions.stg_mf_client_holdings_external stg left outer join transactions.mf_client_holdings_external ext
	on stg.sync_id = ext.sync_history_id 
	where ext.sync_history_id is null
	),
	tmp_pan
	as
	(
	select distinct a.pan , dc.ucccode 
	from tmp_stg a join master.dim_customer dc 
	on a.pan = dc.pan 
	where coalesce (dc.ucccode,'') <> '' 
	)
	select a.sync_id as sync_history_id, a.pan, b.ucccode, a.mobileno, a.amcname, a.folio, a.schemecode, a.schemename, a.schemeoption, 
		a.assetype, a.schemetype, a.nav, a.navdate, a.closingbalance, a.avlunits, a.avlamt, a.currentmarketvalue, 
		a.costvalue, a.gainloss, a.gainlosspercentage, a.isin, a.decimalunits, a.decimalamt, a.decimalnav, a.isdemat, 
		null as planmode, a.nomineestatus, a.brokercode , a.brokername , a.rtaname , a.created_date , true as isexternal,
		'Completed' as sync_status 
	from tmp_stg a join tmp_pan b
	on a.pan = b.pan;
---------------------------------------------------------------------
	--update if it exists 
	update transactions.mf_client_holdings_external a 
	set sync_history_id = b.sync_history_id, 
		pan = b.pan, 
		ucccode = b.ucccode, 
		mobileno = b.mobileno, 
		amcname = b.amcname, 
		folio = b.folio, 
		schemecode = b.schemecode, 
		schemename = b.schemename, 
		schemeoption = b.schemeoption, 
		assetype = b.assetype, 
		schemetype = b.schemetype, 
		nav = b.nav, 
		navdate = b.navdate, 
		closingbalance = b.closingbalance, 
		avlunits = b.avlunits, 
		avlamt = b.avlamt, 
		currentmarketvalue = b.currentmarketvalue, 
		costvalue = b.costvalue, 
		gainloss = b.gainloss, 
		gainlosspercentage = b.gainlosspercentage, 
		isin = b.isin, 
		decimalunits = b.decimalunits, 
		decimalamt = b.decimalamt, 
		decimalnav = b.decimalnav, 
		isdemat = b.isdemat, 
		planmode = b.planmode, 
		nomineestatus = b.nomineestatus, 
		brokercode = b.brokercode , 
		brokername = b.brokername , 
		rtaname = b.rtaname ,	
		modified_date = current_timestamp at TIME ZONE'Asia/Kolkata' , 
		--isexternal = b.isexternal , 
		sync_status = b.sync_status 
	from tmp_update b
	where a.pan = b.pan 
	and a.folio = b.folio
	and a.isin = b.isin;
	
	update transactions.mf_client_holdings_external a 
	set isexternal = true , 
		arn_transfer_status = 'To be Initiated' 
	from tmp_update b
	where a.pan = b.pan 
	and a.folio = b.folio
	and a.isin = b.isin
	and a.arn_transfer_status = 'Expired';
---------------------------------------------------------------------
	/*
	--update if already exists , marking as rejected if it is in in-process status
	with tmp_updt_exists
	as
	(
	select a.id,a.pan , a.folio , a.isin , b.pan , b.folio , b.isin , a.arn_transfer_status 
	from transactions.mf_client_holdings_external a left outer join tmp_update b
	on a.pan = b.pan 
	and a.folio = b.folio
	and a.isin = b.isin
	where b.isin is null
	--and a.arn_transfer_status not in ('Completed','Rejected')
	)
	update transactions.mf_client_holdings_external a
	set arn_transfer_status = 'Rejected',
		updated_date = current_timestamp at TIME ZONE'Asia/Kolkata'
	from tmp_updt_exists b
	where a.id = b.id;
	*/
---------------------------------------------------------------------
	--insert fresh case
	INSERT INTO transactions.mf_client_holdings_external
	(sync_history_id, pan, ucccode, mobileno, amcname, folio, schemecode, schemename, schemeoption, assetype, schemetype, 
		nav, navdate, closingbalance, avlunits, avlamt, currentmarketvalue, costvalue, gainloss, gainlosspercentage, isin, 
		decimalunits, decimalamt, decimalnav, isdemat, planmode, nomineestatus, brokercode , brokername , rtaname ,	
		created_date , isexternal , sync_status , arn_transfer_status
	)
	select a.sync_history_id, a.pan, a.ucccode, a.mobileno, a.amcname, a.folio, a.schemecode, a.schemename, a.schemeoption, 
		a.assetype, a.schemetype, a.nav, a.navdate, a.closingbalance, a.avlunits, a.avlamt, a.currentmarketvalue, 
		a.costvalue, a.gainloss, a.gainlosspercentage, a.isin, a.decimalunits, a.decimalamt, a.decimalnav, a.isdemat, 
		a.planmode, a.nomineestatus, a.brokercode , a.brokername , a.rtaname , 
		current_timestamp at TIME ZONE'Asia/Kolkata' as created_date , 
		case when a.brokercode in ('ARN-70892','INZ000005231') then false else a.isexternal end as isexternal,
		'Completed' as sync_status , 
		case when a.brokercode in ('ARN-70892','INZ000005231') then '' else 'To be Initiated' end as arn_transfer_status 
	from tmp_update a left outer join transactions.mf_client_holdings_external b
	on a.pan = b.pan 
	and a.folio = b.folio
	and a.isin = b.isin
	where b.isin is null;
	
---------------------------------------------------------------------
	update transactions.mf_client_holdings_external ext
	set isexternal = false ,
		arn_transfer_status = ''
	from transactions.mv_client_holding mf
	where ext.ucccode  = mf.ucccode 
	and ext.isin = mf.isincode 
	and ext.folio = mf.foliono  
	and coalesce (arn_transfer_status,'') = 'To be Initiated';

	update transactions.mf_client_holdings_external ext
	set isexternal = false ,
		arn_transfer_status = 'Completed',
		updated_date = current_timestamp at TIME ZONE'Asia/Kolkata'
	from transactions.mv_client_holding mf
	where ext.ucccode  = mf.ucccode 
	and ext.isin = mf.isincode 
	and ext.folio = mf.foliono  
	and coalesce (arn_transfer_status,'') = 'In Progress';
	
	delete from transactions.stg_mf_client_holdings_external
	where sync_id  = p_syncid;
	
	v_status:= 'Success';

	return query
	select v_status as status; 

end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_mf_holding_external(int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_holding_external(int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_holding_external(int4) TO cmotswrite;

-- DROP FUNCTION transactions.fn_insert_mf_transactions(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar, varchar, varchar, varchar, numeric);

CREATE OR REPLACE FUNCTION transactions.fn_insert_mf_transactions(v_logintype character varying, v_ucccode character varying, v_ac_code character varying, v_orderby character varying, v_isincode character varying, v_mf_schcode bigint, v_trx_type character varying, v_trx_amt numeric, v_trx_source character varying, v_order_nav numeric, v_order_navdate date, v_order_type character varying, v_qty_or_amt_order character varying, v_physicalflag character varying, v_token bigint, v_vendor_req character varying, v_isinname character varying, v_return_type character varying, v_schemegroup character varying, v_euinnumber character varying DEFAULT NULL::character varying, v_mfimfdflag character varying DEFAULT NULL::character varying, v_trx_qty numeric DEFAULT (0)::numeric(15,4), v_reinvestmentflag character varying DEFAULT NULL::character varying, v_folio_no character varying DEFAULT NULL::character varying, v_frequency character varying DEFAULT NULL::character varying, v_start_day character varying DEFAULT NULL::character varying, v_start_date date DEFAULT NULL::date, v_end_date date DEFAULT NULL::date, v_no_of_installment integer DEFAULT NULL::integer, v_mandate_id character varying DEFAULT NULL::character varying, v_switch_isin character varying DEFAULT NULL::character varying, v_switch_grpcode character varying DEFAULT NULL::character varying, v_mandate_amt numeric DEFAULT NULL::numeric, v_is_generatetoday boolean DEFAULT false, v_mobileno character varying DEFAULT NULL::character varying, v_email character varying DEFAULT NULL::character varying, v_natureoforder character varying DEFAULT NULL::character varying, v_created_for character varying DEFAULT NULL::character varying, v_sub_broker_code character varying DEFAULT NULL::character varying, v_sub_broker_name character varying DEFAULT NULL::character varying, v_arn_code character varying DEFAULT NULL::character varying, v_sub_broker_pass_pct numeric DEFAULT NULL::numeric)
 RETURNS TABLE(status character varying, display_trx_id character varying, trx_id character varying, remarks character varying, token bigint, isinino character varying, pan character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, order_expiry timestamp without time zone, dob date, isinname character varying, settlementtype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;
DECLARE v_hist_id bigint;
DECLARE v_trx_status character varying;
DECLARE v_delivery_mode character varying(10);
DECLARE v_pan character varying(15);
DECLARE v_ac_name character varying;
DECLARE v_client_mobile character varying;
DECLARE v_client_email character varying;
DECLARE v_rm_name character varying;
DECLARE v_rm_mobile character varying;
DECLARE v_rm_email character varying;
DECLARE v_rm_partner_flag character varying;
DECLARE v_dob date;
DECLARE v_rm_partner_code character varying;

DECLARE v_advisor_name character varying;
DECLARE v_advisor_mobile character varying;
DECLARE v_advisor_email character varying;

BEGIN

IF (v_ucccode IS NOT NULL AND v_ucccode <> '' AND
v_ac_code IS NOT NULL AND v_ac_code <> '' AND
v_orderby IS NOT NULL AND v_orderby <> '' AND
v_isincode IS NOT NULL AND v_isincode <> '' AND
v_trx_type IS NOT NULL AND v_trx_type <> '')
THEN

SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

SELECT 'Order in Progress'::character varying, 
CASE WHEN UPPER(v_physicalflag) ~ 'D' THEN 'DEMAT' 
ELSE 'PHYSICAL' END INTO v_trx_status, v_delivery_mode;

SELECT DISTINCT A.pan, A.acname as ac_name, A.birthdate::date as dob, A.mobileno as client_mobile, A.email as client_email
, CASE WHEN COALESCE(A.upccode,'') <> '' THEN A.partner_name ELSE A.client_owner_name END as rm_name
, CASE WHEN COALESCE(A.upccode,'') <> '' THEN A.partner_mobile ELSE A.rm_mobile END as rm_mobile
, CASE WHEN COALESCE(A.upccode,'') <> '' THEN A.partner_email ELSE A.rm_email END as rm_email
, CASE WHEN COALESCE(A.upccode,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
, CASE WHEN UPPER(v_logintype) = 'CLIENT' THEN CASE WHEN COALESCE(A.upccode,'') <> '' THEN A.upccode ELSE A.client_owner END
WHEN UPPER(v_logintype) = 'RM' THEN A.client_owner
WHEN UPPER(v_logintype) = 'PARTNER' THEN A.upccode END
INTO v_pan, v_ac_name, v_dob, v_client_mobile, v_client_email, v_rm_name, v_rm_mobile, v_rm_email, v_rm_partner_flag, v_rm_partner_code
FROM master.dim_ucc A WHERE TRIM(v_ac_code) = A.priority_ac_code;

----------Inserting Data into Main transaction Table----------
INSERT INTO transactions.mf_order_detail
(trx_id, ucccode, ac_code, orderby, isincode, tokenno, trx_type, trx_amt, trx_qty, mf_schcode, delivery_mode, mandate_id, trx_status, modified_date, trx_source
, created_date, order_nav, order_navdate, order_type, physicalflag, euinnumber, switch_isin, switch_grpcode, trx_datetime, datasource, qty_or_amt_order
, nav, navdate, folio_no, trx_type_code, trx_status_code, display_trx_id, consent_status, consent_status_code,pan, switch_mf_schcode, vendor_req, order_placed_by
, isinname, return_type, schemegroup, rm_partner_code, is_generatetoday,inv_action_code, inv_action,inv_type_code, inv_type
,payment_status,payment_status_code,mobileno,email,natureoforder,created_for,sub_broker_code,sub_broker_name,arn_code,sub_broker_pass_pct
)

SELECT v_trx_id, v_ucccode, v_ac_code, v_orderby, v_isincode, v_token, v_trx_type
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'Q' THEN (v_trx_qty*v_order_nav)::numeric(15,4)
	   		ELSE v_trx_amt END
	   ELSE COALESCE(v_trx_amt,0)::numeric(15,4) END
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'A' THEN (v_trx_amt/v_order_nav)::numeric(15,4)
	   		ELSE v_trx_qty END
	   ELSE COALESCE(v_trx_qty,0)::numeric(15,4) END
, v_mf_schcode, v_delivery_mode, v_mandate_id, v_trx_status, NOW() at time zone 'Asia/Kolkata', 
v_trx_source, NOW() at time zone 'Asia/Kolkata', v_order_nav, v_order_navdate, v_order_type, v_physicalflag
, v_euinnumber, v_switch_isin, v_switch_grpcode, NOW() at time zone 'Asia/Kolkata', 'DION'::character varying, 
v_qty_or_amt_order, v_order_nav, v_order_navdate, v_folio_no
, 
(
SELECT trx_type_code from master.map_vendor_internal_trx_type trx 
where UPPER(v_trx_type) = trx.vendor_trx_type
and trx.category_code = 261 AND trx.isactive = true
)
, (
SELECT sts.trx_status_code FROM master.map_vendor_internal_trx_status sts
WHERE UPPER(sts.vendor_status) = UPPER(v_trx_status)
and sts.category_code = 261 AND sts.isactive = true
)
, ('MF'||LPAD(v_trx_id::character varying, 10, '0'))::character varying
, CASE WHEN UPPER(v_logintype) = 'RM' OR UPPER(v_logintype) = 'PARTNER' THEN (SELECT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 1)
ELSE CASE WHEN UPPER(v_physicalflag) = 'P' THEN (SELECT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 1) ELSE 'NA' END END AS consent_status
, CASE WHEN UPPER(v_logintype) = 'RM' OR UPPER(v_logintype) = 'PARTNER' THEN 1
ELSE CASE WHEN UPPER(v_physicalflag) = 'P' THEN 1 ELSE 0 END END AS consent_status_code, v_pan
, CASE WHEN v_switch_isin IS NOT NULL THEN (SELECT mf_schcode FROM master.dim_mf_isin WHERE isincode = v_switch_isin) ELSE NULL END, v_vendor_req, v_logintype
, v_isinname, v_return_type, v_schemegroup, v_rm_partner_code, v_is_generatetoday,
1 as inv_action_code, 'Transaction'::character varying as inv_action,
(
select b.inv_type_code from master.map_vendor_internal_trx_type a
join master.trx_type b on a.trx_type_code=b.trx_type_code and a.category_code = b.category_code
where UPPER(v_trx_type)=a.vendor_trx_type
and a.category_code = 261 AND a.isactive = true
),
(
select c.inv_type from master.map_vendor_internal_trx_type a
join master.trx_type b on a.trx_type_code=b.trx_type_code and a.category_code = b.category_code
join master.investment_type c on b.inv_type_code= c.inv_type_code
where UPPER(v_trx_type)=a.vendor_trx_type
and a.category_code = 261 AND a.isactive = true
),
CASE WHEN UPPER(v_logintype) = 'RM' OR UPPER(v_logintype) = 'PARTNER' THEN ''
ELSE 
CASE WHEN UPPER(v_physicalflag) = 'D' and v_is_generatetoday=true
and Upper(v_trx_type) in ('SIP','XSIP')
THEN (SELECT A.payment_status FROM master.dim_payment_status A WHERE A.payment_status_code = 1) 
when UPPER(v_physicalflag) = 'D' and Upper(v_trx_type) in ('AP','FP','LUMPSUM')
THEN (SELECT A.payment_status FROM master.dim_payment_status A WHERE A.payment_status_code = 1)
ELSE '' END END AS payment_status
,CASE WHEN UPPER(v_logintype) = 'RM' OR UPPER(v_logintype) = 'PARTNER' THEN 0
ELSE 
CASE WHEN UPPER(v_physicalflag) = 'D' and v_is_generatetoday=true
and Upper(v_trx_type) in ('SIP','XSIP')
THEN 1 
WHEN UPPER(v_physicalflag) = 'D' and Upper(v_trx_type) in ('AP','FP','LUMPSUM')
THEN 1 
ELSE 0 END END AS payment_status_code,
--0::int as payment_status_code,
v_mobileno,v_email,v_natureoforder,v_created_for,
v_sub_broker_code,v_sub_broker_name,v_arn_code,v_sub_broker_pass_pct;

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

----------Inserting Data into transaction History Table----------
INSERT INTO transactions.mf_order_detail_history
(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, 
NOW() at time zone 'Asia/Kolkata', true
,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status	
FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

----------Inserting Data into Summary transaction Table----------
IF(v_trx_type IN ('SIP','XSIP','ISIP','SWP','AMCSTP','STP'))
THEN

/* SELECT currval('transactions.mf_order_summary_id_seq'::regclass)+1 INTO v_hist_id; */
SELECT nextval('transactions.mf_order_summary_id_seq'::regclass) INTO v_hist_id;

INSERT INTO transactions.mf_order_summary
(id, trx_id, created_date, ac_code, trx_type, trx_amt, start_day, start_date, end_date, folio_no, orderby, mf_schcode, isincode, tokenno, frequency
, no_of_installment, switch_isin, mandate_id, reinvestmentflag, nav, mfimfdflag, trx_qty, delivery_mode, trx_source, order_nav, order_navdate
, mandate_amt, is_generatetoday, trx_status,display_trx_id, trx_datetime, pan, datasource, rm_partner_code
, euinnumber, dpc, firstordertoday, installment_type, installment_paid, installment_pending, totalinstallment_paid, totalinstallmentamt_paid
, upcoming_due_date)
SELECT v_hist_id, v_trx_id, NOW() at time zone 'Asia/Kolkata', v_ac_code, v_trx_type
/* , CASE WHEN v_qty_or_amt_order = 'Q' THEN (v_trx_qty*v_order_nav)::numeric(15,4) ELSE v_trx_amt END */
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'Q' THEN (v_trx_qty*v_order_nav)::numeric(15,4)
	   		ELSE v_trx_amt END
	   ELSE COALESCE(v_trx_amt,0)::numeric(15,4) END
, v_start_day, v_start_date, v_end_date, v_folio_no, v_orderby, v_mf_schcode, v_isincode, v_token
, v_frequency, v_no_of_installment, v_switch_isin, v_mandate_id, v_reinvestmentflag, v_order_nav, v_mfimfdflag
/* , CASE WHEN v_qty_or_amt_order = 'A' THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE v_trx_qty END */
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'A' THEN (v_trx_amt/v_order_nav)::numeric(15,4)
	   		ELSE v_trx_qty END
	   ELSE COALESCE(v_trx_qty,0)::numeric(15,4) END
, v_delivery_mode, v_trx_source, v_order_nav, v_order_navdate, v_mandate_amt, v_is_generatetoday, v_trx_status
, ('MF'||LPAD(v_trx_id::character varying, 10, '0'))::character varying, NOW() at time zone 'Asia/Kolkata', v_pan, 'DION'::character varying
, v_rm_partner_code, v_euinnumber, 'Y'::character varying
, CASE WHEN v_is_generatetoday = TRUE THEN 'Y' ELSE 'N' END::character varying, '1', 0, v_no_of_installment, 0, 0
/* , CASE WHEN v_is_generatetoday = TRUE
	   THEN CASE WHEN UPPER(v_frequency) ~ 'MONTHLY' THEN v_start_date + Interval '1 Month'
				 WHEN UPPER(v_frequency) ~ 'QUARTERLY' THEN v_start_date + Interval '3 Months'
				 WHEN UPPER(v_frequency) ~ 'YEARLY' THEN v_start_date + Interval '1 Year'
				 WHEN UPPER(v_frequency) ~ 'DAILY' THEN v_start_date + Interval '1 Day' END
	   ELSE v_start_date END::date */
, v_start_date;

-----------------------------------------------------------

update transactions.mf_order_summary a
set
final_status = B.final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
trx_type_code=b.trx_type_code,
trx_status_Code=b.trx_status_Code
from transactions.mf_order_detail b
where a.trx_id = B.trx_id
and b.trx_id=v_trx_id;

----------Inserting Data into Summary transaction History Table----------
/*
INSERT INTO transactions.mf_order_summary_history
(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active
,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A WHERE A.id = v_hist_id;

UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
*/

RETURN QUERY
SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'NA'::character varying as remarks--, B.*
,A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
,v_ucccode, v_ac_code, v_ac_name, v_client_mobile, v_client_email
--,v_rm_name,v_rm_mobile,v_rm_email
,coalesce(C.advisor_name,v_rm_name)
,coalesce(C.advisor_mobile,v_rm_mobile)
,coalesce(C.advisor_email, v_rm_email)
,v_logintype--v_rm_partner_flag
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, v_dob, INITCAP(v_isinname)::character varying isinname, B.settltement_type settlementtype
FROM transactions.mf_order_summary A
JOIN master.dim_mf_isin B ON A.isincode = B.isincode
left join transactions.fn_get_client_details(A.ac_code,A.trx_id,1) C on A.ac_code = C.ac_code
WHERE A.trx_id = v_trx_id; 

ELSE

RETURN QUERY
SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'NA'::character varying as remarks--, B.*
, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
, v_ucccode, v_ac_code, v_ac_name, v_client_mobile, v_client_email
--,v_rm_name, v_rm_mobile, v_rm_email
,coalesce(C.advisor_name,v_rm_name)
,coalesce(C.advisor_mobile,v_rm_mobile)
,coalesce(C.advisor_email, v_rm_email)
,v_logintype--v_rm_partner_flag
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, v_dob, INITCAP(v_isinname)::character varying isinname, B.settltement_type settlementtype
FROM transactions.mf_order_detail A
JOIN master.dim_mf_isin B ON A.isincode = B.isincode
left join transactions.fn_get_client_details(A.ac_code,A.trx_id,1) C on A.ac_code = C.ac_code
WHERE A.trx_id = v_trx_id; 

END IF;

ELSE

RETURN QUERY
SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying, 'Invalid Input Parameters'::character varying as remarks
, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, NULL::date, 'NA'::character varying, 'NA'::character varying;

END IF;

EXCEPTION
WHEN OTHERS THEN
BEGIN

RETURN QUERY
SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
, ('Error :- '||CAST(SQLERRM as VARCHAR(4000)))::character varying as remarks, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, NULL::date, 'NA'::character varying, 'NA'::character varying;

END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_mf_transactions(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar, varchar, varchar, varchar, numeric) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar, varchar, varchar, varchar, numeric) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar, varchar, varchar, varchar, numeric) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar, varchar, varchar, varchar, numeric) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar, varchar, varchar, varchar, numeric) TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_mf_transactions_bkp_09may2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool);

CREATE OR REPLACE FUNCTION transactions.fn_insert_mf_transactions_bkp_09may2025(v_logintype character varying, v_ucccode character varying, v_ac_code character varying, v_orderby character varying, v_isincode character varying, v_mf_schcode bigint, v_trx_type character varying, v_trx_amt numeric, v_trx_source character varying, v_order_nav numeric, v_order_navdate date, v_order_type character varying, v_qty_or_amt_order character varying, v_physicalflag character varying, v_token bigint, v_vendor_req character varying, v_isinname character varying, v_return_type character varying, v_schemegroup character varying, v_euinnumber character varying DEFAULT NULL::character varying, v_mfimfdflag character varying DEFAULT NULL::character varying, v_trx_qty numeric DEFAULT (0)::numeric(15,4), v_reinvestmentflag character varying DEFAULT NULL::character varying, v_folio_no character varying DEFAULT NULL::character varying, v_frequency character varying DEFAULT NULL::character varying, v_start_day character varying DEFAULT NULL::character varying, v_start_date date DEFAULT NULL::date, v_end_date date DEFAULT NULL::date, v_no_of_installment integer DEFAULT NULL::integer, v_mandate_id character varying DEFAULT NULL::character varying, v_switch_isin character varying DEFAULT NULL::character varying, v_switch_grpcode character varying DEFAULT NULL::character varying, v_mandate_amt numeric DEFAULT NULL::numeric, v_is_generatetoday boolean DEFAULT false)
 RETURNS TABLE(status character varying, display_trx_id character varying, trx_id character varying, remarks character varying, token bigint, isinino character varying, pan character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, order_expiry timestamp without time zone, dob date, isinname character varying, settlementtype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;
DECLARE v_hist_id bigint;
DECLARE v_trx_status character varying;
DECLARE v_delivery_mode character varying(10);
DECLARE v_pan character varying(15);
DECLARE v_ac_name character varying;
DECLARE v_client_mobile character varying;
DECLARE v_client_email character varying;
DECLARE v_rm_name character varying;
DECLARE v_rm_mobile character varying;
DECLARE v_rm_email character varying;
DECLARE v_rm_partner_flag character varying;
DECLARE v_dob date;
DECLARE v_rm_partner_code character varying;

BEGIN

IF (v_ucccode IS NOT NULL AND v_ucccode <> '' AND
v_ac_code IS NOT NULL AND v_ac_code <> '' AND
v_orderby IS NOT NULL AND v_orderby <> '' AND
v_isincode IS NOT NULL AND v_isincode <> '' AND
v_trx_type IS NOT NULL AND v_trx_type <> '')
THEN

SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

SELECT 'Order In Progress'::character varying, 
CASE WHEN UPPER(v_physicalflag) ~ 'D' THEN 'DEMAT' 
ELSE 'PHYSICAL' END INTO v_trx_status, v_delivery_mode;

SELECT DISTINCT A.pan, A.acname as ac_name, A.birthdate::date as dob, A.mobileno as client_mobile, A.email as client_email
, CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN A.partner_name ELSE A.client_owner_name END as rm_name
, CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN A.partner_mobile ELSE A.rm_mobile END as rm_mobile
, CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN A.partner_email ELSE A.rm_email END as rm_email
, CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
, CASE WHEN UPPER(v_logintype) = 'CLIENT' THEN CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN A.partner_code ELSE A.client_owner END
	   WHEN UPPER(v_logintype) = 'RM' THEN A.client_owner
	   WHEN UPPER(v_logintype) = 'PARTNER' THEN A.partner_code END
INTO v_pan, v_ac_name, v_dob, v_client_mobile, v_client_email, v_rm_name, v_rm_mobile, v_rm_email, v_rm_partner_flag, v_rm_partner_code
FROM master.dim_ucc A WHERE TRIM(v_ac_code) = A.priority_ac_code;

----------Inserting Data into Main transaction Table----------
INSERT INTO transactions.mf_order_detail
(trx_id, ucccode, ac_code, orderby, isincode, tokenno, trx_type, trx_amt, trx_qty, mf_schcode, delivery_mode, mandate_id, trx_status, modified_date, trx_source
, created_date, order_nav, order_navdate, order_type, physicalflag, euinnumber, switch_isin, switch_grpcode, trx_datetime, datasource, qty_or_amt_order
, nav, navdate, folio_no, trx_type_code, trx_status_code, display_trx_id, consent_status, consent_status_code,pan, switch_mf_schcode, vendor_req, order_placed_by
, isinname, return_type, schemegroup, rm_partner_code, is_generatetoday,inv_action_code, inv_action,inv_type_code, inv_type
,payment_status_code
	)

SELECT v_trx_id, v_ucccode, v_ac_code, v_orderby, v_isincode, v_token, v_trx_type
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'Q' THEN (v_trx_qty*v_order_nav)::numeric(15,4)
	   		ELSE v_trx_amt END
	   ELSE COALESCE(v_trx_amt,0)::numeric(15,4) END
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'A' THEN (v_trx_amt/v_order_nav)::numeric(15,4)
	   		ELSE v_trx_qty END
	   ELSE COALESCE(v_trx_qty,0)::numeric(15,4) END
, v_mf_schcode, v_delivery_mode, v_mandate_id, v_trx_status, NOW(), v_trx_source, NOW(), v_order_nav, v_order_navdate, v_order_type, v_physicalflag
, v_euinnumber, v_switch_isin, v_switch_grpcode, NOW(), 'DION'::character varying, v_qty_or_amt_order, v_order_nav, v_order_navdate, v_folio_no
, 
(
SELECT trx_type_code from master.map_vendor_internal_trx_type trx 
where UPPER(v_trx_type) = trx.vendor_trx_type
and trx.category_code = 261 AND trx.isactive = true
)
, (
SELECT sts.trx_status_code FROM master.map_vendor_internal_trx_status sts
WHERE UPPER(sts.vendor_status) = UPPER(v_trx_status)
and sts.category_code = 261 AND sts.isactive = true
)
, ('MF'||LPAD(v_trx_id::character varying, 10, '0'))::character varying
, CASE WHEN UPPER(v_logintype) = 'RM' OR UPPER(v_logintype) = 'PARTNER' THEN (SELECT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 1)
ELSE CASE WHEN UPPER(v_physicalflag) = 'P' THEN (SELECT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 1) ELSE 'NA' END END AS consent_status
, CASE WHEN UPPER(v_logintype) = 'RM' OR UPPER(v_logintype) = 'PARTNER' THEN 1
ELSE CASE WHEN UPPER(v_physicalflag) = 'P' THEN 1 ELSE 0 END END AS consent_status_code, v_pan
, CASE WHEN v_switch_isin IS NOT NULL THEN (SELECT mf_schcode FROM master.dim_mf_isin WHERE isincode = v_switch_isin) ELSE NULL END, v_vendor_req, v_logintype
, v_isinname, v_return_type, v_schemegroup, v_rm_partner_code, v_is_generatetoday,
1 as inv_action_code, 'Transaction'::character varying as inv_action,
(
select b.inv_type_code from master.map_vendor_internal_trx_type a
join master.trx_type b on a.trx_type_code=b.trx_type_code and a.category_code = b.category_code
where UPPER(v_trx_type)=a.vendor_trx_type
and a.category_code = 261 AND a.isactive = true
),
(
select c.inv_type from master.map_vendor_internal_trx_type a
join master.trx_type b on a.trx_type_code=b.trx_type_code and a.category_code = b.category_code
join master.investment_type c on b.inv_type_code= c.inv_type_code
where UPPER(v_trx_type)=a.vendor_trx_type
and a.category_code = 261 AND a.isactive = true
),
0::int as payment_status_code;

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

----------Inserting Data into transaction History Table----------
INSERT INTO transactions.mf_order_detail_history
(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status	
FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

----------Inserting Data into Summary transaction Table----------
IF(v_trx_type IN ('SIP','XSIP','ISIP','SWP','AMCSTP', 'STP'))
THEN

/* SELECT currval('transactions.mf_order_summary_id_seq'::regclass)+1 INTO v_hist_id; */
SELECT nextval('transactions.mf_order_summary_id_seq'::regclass) INTO v_hist_id;

INSERT INTO transactions.mf_order_summary
(id, trx_id, created_date, ac_code, trx_type, trx_amt, start_day, start_date, end_date, folio_no, orderby, mf_schcode, isincode, tokenno, frequency
, no_of_installment, switch_isin, mandate_id, reinvestmentflag, nav, mfimfdflag, trx_qty, delivery_mode, trx_source, order_nav, order_navdate
, mandate_amt, is_generatetoday, trx_status,display_trx_id, trx_datetime, pan, datasource, rm_partner_code
, euinnumber, dpc, firstordertoday, installment_type, installment_paid, installment_pending, totalinstallment_paid, totalinstallmentamt_paid
, upcoming_due_date)
SELECT v_hist_id, v_trx_id, NOW(), v_ac_code, v_trx_type
/* , CASE WHEN v_qty_or_amt_order = 'Q' THEN (v_trx_qty*v_order_nav)::numeric(15,4) ELSE v_trx_amt END */
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'Q' THEN (v_trx_qty*v_order_nav)::numeric(15,4)
	   		ELSE v_trx_amt END
	   ELSE COALESCE(v_trx_amt,0)::numeric(15,4) END
, v_start_day, v_start_date, v_end_date, v_folio_no, v_orderby, v_mf_schcode, v_isincode, v_token
, v_frequency, v_no_of_installment, v_switch_isin, v_mandate_id, v_reinvestmentflag, v_order_nav, v_mfimfdflag
/* , CASE WHEN v_qty_or_amt_order = 'A' THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE v_trx_qty END */
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'A' THEN (v_trx_amt/v_order_nav)::numeric(15,4)
	   		ELSE v_trx_qty END
	   ELSE COALESCE(v_trx_qty,0)::numeric(15,4) END
, v_delivery_mode, v_trx_source, v_order_nav, v_order_navdate, v_mandate_amt, v_is_generatetoday, v_trx_status
, ('MF'||LPAD(v_trx_id::character varying, 10, '0'))::character varying, NOW(), v_pan, 'DION'::character varying
, v_rm_partner_code, v_euinnumber, 'Y'::character varying
, CASE WHEN v_is_generatetoday = TRUE THEN 'Y' ELSE 'N' END::character varying, '1', 0, v_no_of_installment, 0, 0
/* , CASE WHEN v_is_generatetoday = TRUE
	   THEN CASE WHEN UPPER(v_frequency) ~ 'MONTHLY' THEN v_start_date + Interval '1 Month'
				 WHEN UPPER(v_frequency) ~ 'QUARTERLY' THEN v_start_date + Interval '3 Months'
				 WHEN UPPER(v_frequency) ~ 'YEARLY' THEN v_start_date + Interval '1 Year'
				 WHEN UPPER(v_frequency) ~ 'DAILY' THEN v_start_date + Interval '1 Day' END
	   ELSE v_start_date END::date */
, v_start_date;

-----------------------------------------------------------

update transactions.mf_order_summary a
set
final_status = B.final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
trx_type_code=b.trx_type_code,
trx_status_Code=b.trx_status_Code
from transactions.mf_order_detail b
where a.trx_id = B.trx_id
and b.trx_id=v_trx_id;

----------Inserting Data into Summary transaction History Table----------
INSERT INTO transactions.mf_order_summary_history
(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active
,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A WHERE A.id = v_hist_id;

UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

RETURN QUERY
SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'NA'::character varying as remarks--, B.*
, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
, v_ucccode, v_ac_code, v_ac_name, v_client_mobile, v_client_email, v_rm_name, v_rm_mobile, v_rm_email, v_rm_partner_flag
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, v_dob, INITCAP(v_isinname)::character varying isinname, B.settltement_type settlementtype
FROM transactions.mf_order_summary A
JOIN master.dim_mf_isin B ON A.isincode = B.isincode
WHERE A.trx_id = v_trx_id; 

ELSE

RETURN QUERY
SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'NA'::character varying as remarks--, B.*
, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
, v_ucccode, v_ac_code, v_ac_name, v_client_mobile, v_client_email, v_rm_name, v_rm_mobile, v_rm_email, v_rm_partner_flag
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, v_dob, INITCAP(v_isinname)::character varying isinname, B.settltement_type settlementtype
FROM transactions.mf_order_detail A
JOIN master.dim_mf_isin B ON A.isincode = B.isincode
WHERE A.trx_id = v_trx_id; 

END IF;

ELSE

RETURN QUERY
SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying, 'Invalid Input Parameters'::character varying as remarks
, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, NULL::date, 'NA'::character varying, 'NA'::character varying;

END IF;

EXCEPTION
WHEN OTHERS THEN
BEGIN

RETURN QUERY
SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
, ('Error :- '||CAST(SQLERRM as VARCHAR(4000)))::character varying as remarks, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, NULL::date, 'NA'::character varying, 'NA'::character varying;

END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_mf_transactions_bkp_09may2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions_bkp_09may2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions_bkp_09may2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions_bkp_09may2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions_bkp_09may2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool) TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_mf_transactions_bkp_14jul2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_insert_mf_transactions_bkp_14jul2025(v_logintype character varying, v_ucccode character varying, v_ac_code character varying, v_orderby character varying, v_isincode character varying, v_mf_schcode bigint, v_trx_type character varying, v_trx_amt numeric, v_trx_source character varying, v_order_nav numeric, v_order_navdate date, v_order_type character varying, v_qty_or_amt_order character varying, v_physicalflag character varying, v_token bigint, v_vendor_req character varying, v_isinname character varying, v_return_type character varying, v_schemegroup character varying, v_euinnumber character varying DEFAULT NULL::character varying, v_mfimfdflag character varying DEFAULT NULL::character varying, v_trx_qty numeric DEFAULT (0)::numeric(15,4), v_reinvestmentflag character varying DEFAULT NULL::character varying, v_folio_no character varying DEFAULT NULL::character varying, v_frequency character varying DEFAULT NULL::character varying, v_start_day character varying DEFAULT NULL::character varying, v_start_date date DEFAULT NULL::date, v_end_date date DEFAULT NULL::date, v_no_of_installment integer DEFAULT NULL::integer, v_mandate_id character varying DEFAULT NULL::character varying, v_switch_isin character varying DEFAULT NULL::character varying, v_switch_grpcode character varying DEFAULT NULL::character varying, v_mandate_amt numeric DEFAULT NULL::numeric, v_is_generatetoday boolean DEFAULT false, v_mobileno character varying DEFAULT NULL::character varying, v_email character varying DEFAULT NULL::character varying, v_natureoforder character varying DEFAULT NULL::character varying, v_created_for character varying DEFAULT NULL::character varying)
 RETURNS TABLE(status character varying, display_trx_id character varying, trx_id character varying, remarks character varying, token bigint, isinino character varying, pan character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, order_expiry timestamp without time zone, dob date, isinname character varying, settlementtype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;
DECLARE v_hist_id bigint;
DECLARE v_trx_status character varying;
DECLARE v_delivery_mode character varying(10);
DECLARE v_pan character varying(15);
DECLARE v_ac_name character varying;
DECLARE v_client_mobile character varying;
DECLARE v_client_email character varying;
DECLARE v_rm_name character varying;
DECLARE v_rm_mobile character varying;
DECLARE v_rm_email character varying;
DECLARE v_rm_partner_flag character varying;
DECLARE v_dob date;
DECLARE v_rm_partner_code character varying;

BEGIN

IF (v_ucccode IS NOT NULL AND v_ucccode <> '' AND
v_ac_code IS NOT NULL AND v_ac_code <> '' AND
v_orderby IS NOT NULL AND v_orderby <> '' AND
v_isincode IS NOT NULL AND v_isincode <> '' AND
v_trx_type IS NOT NULL AND v_trx_type <> '')
THEN

SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

SELECT 'Order in Progress'::character varying, 
CASE WHEN UPPER(v_physicalflag) ~ 'D' THEN 'DEMAT' 
ELSE 'PHYSICAL' END INTO v_trx_status, v_delivery_mode;

SELECT DISTINCT A.pan, A.acname as ac_name, A.birthdate::date as dob, A.mobileno as client_mobile, A.email as client_email
, CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN A.partner_name ELSE A.client_owner_name END as rm_name
, CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN A.partner_mobile ELSE A.rm_mobile END as rm_mobile
, CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN A.partner_email ELSE A.rm_email END as rm_email
, CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
, CASE WHEN UPPER(v_logintype) = 'CLIENT' THEN CASE WHEN COALESCE(A.partnerowner,'') <> '' THEN A.partnerowner ELSE A.client_owner END
WHEN UPPER(v_logintype) = 'RM' THEN A.client_owner
WHEN UPPER(v_logintype) = 'PARTNER' THEN A.partnerowner END
INTO v_pan, v_ac_name, v_dob, v_client_mobile, v_client_email, v_rm_name, v_rm_mobile, v_rm_email, v_rm_partner_flag, v_rm_partner_code
FROM master.dim_ucc A WHERE TRIM(v_ac_code) = A.priority_ac_code;

----------Inserting Data into Main transaction Table----------
INSERT INTO transactions.mf_order_detail
(trx_id, ucccode, ac_code, orderby, isincode, tokenno, trx_type, trx_amt, trx_qty, mf_schcode, delivery_mode, mandate_id, trx_status, modified_date, trx_source
, created_date, order_nav, order_navdate, order_type, physicalflag, euinnumber, switch_isin, switch_grpcode, trx_datetime, datasource, qty_or_amt_order
, nav, navdate, folio_no, trx_type_code, trx_status_code, display_trx_id, consent_status, consent_status_code,pan, switch_mf_schcode, vendor_req, order_placed_by
, isinname, return_type, schemegroup, rm_partner_code, is_generatetoday,inv_action_code, inv_action,inv_type_code, inv_type
,payment_status_code,mobileno,email,natureoforder,created_for
	)

SELECT v_trx_id, v_ucccode, v_ac_code, v_orderby, v_isincode, v_token, v_trx_type
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'Q' THEN (v_trx_qty*v_order_nav)::numeric(15,4)
	   		ELSE v_trx_amt END
	   ELSE COALESCE(v_trx_amt,0)::numeric(15,4) END
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'A' THEN (v_trx_amt/v_order_nav)::numeric(15,4)
	   		ELSE v_trx_qty END
	   ELSE COALESCE(v_trx_qty,0)::numeric(15,4) END
, v_mf_schcode, v_delivery_mode, v_mandate_id, v_trx_status, NOW(), v_trx_source, NOW(), v_order_nav, v_order_navdate, v_order_type, v_physicalflag
, v_euinnumber, v_switch_isin, v_switch_grpcode, NOW(), 'DION'::character varying, v_qty_or_amt_order, v_order_nav, v_order_navdate, v_folio_no
, 
(
SELECT trx_type_code from master.map_vendor_internal_trx_type trx 
where UPPER(v_trx_type) = trx.vendor_trx_type
and trx.category_code = 261 AND trx.isactive = true
)
, (
SELECT sts.trx_status_code FROM master.map_vendor_internal_trx_status sts
WHERE UPPER(sts.vendor_status) = UPPER(v_trx_status)
and sts.category_code = 261 AND sts.isactive = true
)
, ('MF'||LPAD(v_trx_id::character varying, 10, '0'))::character varying
, CASE WHEN UPPER(v_logintype) = 'RM' OR UPPER(v_logintype) = 'PARTNER' THEN (SELECT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 1)
ELSE CASE WHEN UPPER(v_physicalflag) = 'P' THEN (SELECT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 1) ELSE 'NA' END END AS consent_status
, CASE WHEN UPPER(v_logintype) = 'RM' OR UPPER(v_logintype) = 'PARTNER' THEN 1
ELSE CASE WHEN UPPER(v_physicalflag) = 'P' THEN 1 ELSE 0 END END AS consent_status_code, v_pan
, CASE WHEN v_switch_isin IS NOT NULL THEN (SELECT mf_schcode FROM master.dim_mf_isin WHERE isincode = v_switch_isin) ELSE NULL END, v_vendor_req, v_logintype
, v_isinname, v_return_type, v_schemegroup, v_rm_partner_code, v_is_generatetoday,
1 as inv_action_code, 'Transaction'::character varying as inv_action,
(
select b.inv_type_code from master.map_vendor_internal_trx_type a
join master.trx_type b on a.trx_type_code=b.trx_type_code and a.category_code = b.category_code
where UPPER(v_trx_type)=a.vendor_trx_type
and a.category_code = 261 AND a.isactive = true
),
(
select c.inv_type from master.map_vendor_internal_trx_type a
join master.trx_type b on a.trx_type_code=b.trx_type_code and a.category_code = b.category_code
join master.investment_type c on b.inv_type_code= c.inv_type_code
where UPPER(v_trx_type)=a.vendor_trx_type
and a.category_code = 261 AND a.isactive = true
),
0::int as payment_status_code,
v_mobileno,v_email,v_natureoforder,v_created_for;

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

----------Inserting Data into transaction History Table----------
INSERT INTO transactions.mf_order_detail_history
(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status	
FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

----------Inserting Data into Summary transaction Table----------
IF(v_trx_type IN ('SIP','XSIP','ISIP','SWP','AMCSTP','STP'))
THEN

/* SELECT currval('transactions.mf_order_summary_id_seq'::regclass)+1 INTO v_hist_id; */
SELECT nextval('transactions.mf_order_summary_id_seq'::regclass) INTO v_hist_id;

INSERT INTO transactions.mf_order_summary
(id, trx_id, created_date, ac_code, trx_type, trx_amt, start_day, start_date, end_date, folio_no, orderby, mf_schcode, isincode, tokenno, frequency
, no_of_installment, switch_isin, mandate_id, reinvestmentflag, nav, mfimfdflag, trx_qty, delivery_mode, trx_source, order_nav, order_navdate
, mandate_amt, is_generatetoday, trx_status,display_trx_id, trx_datetime, pan, datasource, rm_partner_code
, euinnumber, dpc, firstordertoday, installment_type, installment_paid, installment_pending, totalinstallment_paid, totalinstallmentamt_paid
, upcoming_due_date)
SELECT v_hist_id, v_trx_id, NOW(), v_ac_code, v_trx_type
/* , CASE WHEN v_qty_or_amt_order = 'Q' THEN (v_trx_qty*v_order_nav)::numeric(15,4) ELSE v_trx_amt END */
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'Q' THEN (v_trx_qty*v_order_nav)::numeric(15,4)
	   		ELSE v_trx_amt END
	   ELSE COALESCE(v_trx_amt,0)::numeric(15,4) END
, v_start_day, v_start_date, v_end_date, v_folio_no, v_orderby, v_mf_schcode, v_isincode, v_token
, v_frequency, v_no_of_installment, v_switch_isin, v_mandate_id, v_reinvestmentflag, v_order_nav, v_mfimfdflag
/* , CASE WHEN v_qty_or_amt_order = 'A' THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE v_trx_qty END */
, CASE WHEN v_order_nav <> 0 THEN
	   CASE WHEN v_qty_or_amt_order = 'A' THEN (v_trx_amt/v_order_nav)::numeric(15,4)
	   		ELSE v_trx_qty END
	   ELSE COALESCE(v_trx_qty,0)::numeric(15,4) END
, v_delivery_mode, v_trx_source, v_order_nav, v_order_navdate, v_mandate_amt, v_is_generatetoday, v_trx_status
, ('MF'||LPAD(v_trx_id::character varying, 10, '0'))::character varying, NOW(), v_pan, 'DION'::character varying
, v_rm_partner_code, v_euinnumber, 'Y'::character varying
, CASE WHEN v_is_generatetoday = TRUE THEN 'Y' ELSE 'N' END::character varying, '1', 0, v_no_of_installment, 0, 0
/* , CASE WHEN v_is_generatetoday = TRUE
	   THEN CASE WHEN UPPER(v_frequency) ~ 'MONTHLY' THEN v_start_date + Interval '1 Month'
				 WHEN UPPER(v_frequency) ~ 'QUARTERLY' THEN v_start_date + Interval '3 Months'
				 WHEN UPPER(v_frequency) ~ 'YEARLY' THEN v_start_date + Interval '1 Year'
				 WHEN UPPER(v_frequency) ~ 'DAILY' THEN v_start_date + Interval '1 Day' END
	   ELSE v_start_date END::date */
, v_start_date;

-----------------------------------------------------------

update transactions.mf_order_summary a
set
final_status = B.final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
trx_type_code=b.trx_type_code,
trx_status_Code=b.trx_status_Code
from transactions.mf_order_detail b
where a.trx_id = B.trx_id
and b.trx_id=v_trx_id;

----------Inserting Data into Summary transaction History Table----------
INSERT INTO transactions.mf_order_summary_history
(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active
,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A WHERE A.id = v_hist_id;

UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

RETURN QUERY
SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'NA'::character varying as remarks--, B.*
, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
, v_ucccode, v_ac_code, v_ac_name, v_client_mobile, v_client_email, v_rm_name, v_rm_mobile, v_rm_email, v_rm_partner_flag
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, v_dob, INITCAP(v_isinname)::character varying isinname, B.settltement_type settlementtype
FROM transactions.mf_order_summary A
JOIN master.dim_mf_isin B ON A.isincode = B.isincode
WHERE A.trx_id = v_trx_id; 

ELSE

RETURN QUERY
SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'NA'::character varying as remarks--, B.*
, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
, v_ucccode, v_ac_code, v_ac_name, v_client_mobile, v_client_email, v_rm_name, v_rm_mobile, v_rm_email, v_rm_partner_flag
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, v_dob, INITCAP(v_isinname)::character varying isinname, B.settltement_type settlementtype
FROM transactions.mf_order_detail A
JOIN master.dim_mf_isin B ON A.isincode = B.isincode
WHERE A.trx_id = v_trx_id; 

END IF;

ELSE

RETURN QUERY
SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying, 'Invalid Input Parameters'::character varying as remarks
, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, NULL::date, 'NA'::character varying, 'NA'::character varying;

END IF;

EXCEPTION
WHEN OTHERS THEN
BEGIN

RETURN QUERY
SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
, ('Error :- '||CAST(SQLERRM as VARCHAR(4000)))::character varying as remarks, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
, NULL::date, 'NA'::character varying, 'NA'::character varying;

END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_mf_transactions_bkp_14jul2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions_bkp_14jul2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions_bkp_14jul2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions_bkp_14jul2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_transactions_bkp_14jul2025(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, varchar, varchar, varchar, date, date, int4, varchar, varchar, varchar, numeric, bool, varchar, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_mf_viewed_hist(varchar, int8);

CREATE OR REPLACE FUNCTION transactions.fn_insert_mf_viewed_hist(v_login_code character varying, v_mf_schcode bigint)
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_cnt integer;

BEGIN

SELECT COUNT(*) INTO v_cnt FROM transactions.mf_viewed_history WHERE login_code = v_login_code;

	IF NOT EXISTS(SELECT 1 FROM transactions.mf_viewed_history WHERE login_code = v_login_code AND mf_schcode = v_mf_schcode)
	THEN
	
		IF (v_cnt < 50)
		THEN
		
			INSERT INTO transactions.mf_viewed_history(login_code, mf_schcode, created_date) SELECT v_login_code, v_mf_schcode, NOW();
			
			RETURN QUERY
			SELECT 'SUCCESS'::character varying status;
			
		ELSE
			
			DELETE FROM transactions.mf_viewed_history
			WHERE viewed_id = (SELECT viewed_id FROM transactions.mf_viewed_history
								WHERE login_code = v_login_code AND mf_schcode = v_mf_schcode ORDER BY created_date DESC limit 1);
			
			INSERT INTO transactions.mf_viewed_history(login_code, mf_schcode, created_date) SELECT v_login_code, v_mf_schcode, NOW();

			RETURN QUERY
			SELECT 'SUCCESS'::character varying status;

		END IF;
	
	ELSIF EXISTS(SELECT 1 FROM transactions.mf_viewed_history WHERE login_code = v_login_code AND mf_schcode = v_mf_schcode)
	THEN

			RETURN QUERY
			SELECT 'SUCCESS'::character varying status;

	END IF;
	
	EXCEPTION
		WHEN others THEN
		BEGIN
			RETURN QUERY
			SELECT ('FAILURE and Error :- '||CAST(SQLERRM as VARCHAR(4000)))::character varying status;
    END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_mf_viewed_hist(varchar, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_viewed_hist(varchar, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_viewed_hist(varchar, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_viewed_hist(varchar, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_insert_mf_viewed_hist(varchar, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_insert_stg_mf_order_detail(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, int4, varchar, varchar, bpchar, date, date, int4, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, bool, timestamp, timestamp, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_insert_stg_mf_order_detail(p_logintype character varying, p_ucccode character varying, p_ac_code character varying, p_orderby character varying, p_isincode character varying, p_mf_schcode bigint, p_trx_type character varying, p_trx_amt numeric, p_trx_qty numeric, p_trx_source character varying, p_order_nav numeric, p_order_navdate date, p_order_type character varying, p_qty_or_amt_order character varying, p_physicalflag character varying, p_token bigint, p_is_draft integer, p_folio_no character varying, p_frequency character varying, p_start_day character, p_start_date date, p_end_date date, p_no_of_installment integer, p_delivery_mode character varying, p_mandate_id character varying, p_trx_status character varying, p_modified_by character varying, p_euinnumber character varying, p_switch_isin character varying, p_switch_grpcode character varying, p_reinvestmentflag character varying, p_mfimfdflag character varying, p_mandate_amt numeric, p_installment_type character varying, p_is_generatetoday boolean, p_created_date timestamp without time zone, p_modified_date timestamp without time zone, p_rm_partner_code character varying, p_error_validation character varying)
 RETURNS TABLE(m_status character varying, m_remarks character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE
    m_rm_partner_code INT8;
BEGIN
    -- Fetch the count of rm_partner_code into a variable
    SELECT COUNT(*) INTO m_rm_partner_code
    FROM transactions.stg_mf_order_detail 
    WHERE rm_partner_code = p_rm_partner_code;
	
    -- Check if the count is <= 50
    IF m_rm_partner_code <= 50 THEN
        -- Insert a single record into the staging table
        INSERT INTO transactions.stg_mf_order_detail (
            logintype, ucccode, ac_code, orderby, isincode, mf_schcode, trx_type,
            trx_amt, trx_qty, trx_source, order_nav, order_navdate, order_type,
            qty_or_amt_order, physicalflag, token, is_draft, folio_no, frequency,
            start_day, start_date, end_date, no_of_installment, delivery_mode,
            mandate_id, trx_status, modified_by, euinnumber, switch_isin,
            switch_grpcode, reinvestmentflag, mfimfdflag, mandate_amt,
            installment_type, is_generatetoday, created_date, modified_date,
            rm_partner_code, error_validation
        )
        VALUES (
            p_logintype, p_ucccode, p_ac_code, p_orderby, p_isincode,
            p_mf_schcode, p_trx_type, p_trx_amt, p_trx_qty, p_trx_source,
            p_order_nav, p_order_navdate, p_order_type, p_qty_or_amt_order,
            p_physicalflag, p_token, p_is_draft, p_folio_no, p_frequency,
            p_start_day, p_start_date, p_end_date, p_no_of_installment,
            p_delivery_mode, p_mandate_id, p_trx_status, p_modified_by,
            p_euinnumber, p_switch_isin, p_switch_grpcode, p_reinvestmentflag,
            p_mfimfdflag, p_mandate_amt, p_installment_type, p_is_generatetoday,
            p_created_date, p_modified_date, p_rm_partner_code, p_error_validation
        );
       
        m_status := 'Success';
        m_remarks := 'Basket order saved successfully';
    ELSE
        m_status := 'Failed';
        m_remarks := 'Basket order limit is reached';
    END IF;
   
    RETURN NEXT;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_insert_stg_mf_order_detail(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, int4, varchar, varchar, bpchar, date, date, int4, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, bool, timestamp, timestamp, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_insert_stg_mf_order_detail(varchar, varchar, varchar, varchar, varchar, int8, varchar, numeric, numeric, varchar, numeric, date, varchar, varchar, varchar, int8, int4, varchar, varchar, bpchar, date, date, int4, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar, numeric, varchar, bool, timestamp, timestamp, varchar, varchar) TO cmotswrite;

-- DROP FUNCTION transactions.fn_modify_mf_transactions(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar, varchar, varchar, varchar, varchar, numeric);

CREATE OR REPLACE FUNCTION transactions.fn_modify_mf_transactions(v_logintype character varying, v_logincode character varying, v_trx_id bigint, v_trx_type_code integer, v_vendor_req character varying, v_mandate_id character varying DEFAULT NULL::character varying, v_frequency character varying DEFAULT NULL::character varying, v_trx_amt numeric DEFAULT NULL::numeric(15,4), v_start_day character varying DEFAULT NULL::character varying, v_is_generatetoday boolean DEFAULT NULL::boolean, v_no_of_installment integer DEFAULT NULL::integer, v_transfer_date date DEFAULT NULL::date, v_end_date date DEFAULT NULL::date, v_natureoforder character varying DEFAULT NULL::character varying, v_created_for character varying DEFAULT NULL::character varying, v_folio_no character varying DEFAULT NULL::character varying, v_sub_broker_code character varying DEFAULT NULL::character varying, v_sub_broker_name character varying DEFAULT NULL::character varying, v_arn_code character varying DEFAULT NULL::character varying, v_sub_broker_pass_pct numeric DEFAULT NULL::numeric)
 RETURNS TABLE(status character varying, display_trx_id character varying, trx_id character varying, remarks character varying, token bigint, isinino character varying, pan character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, order_expiry timestamp without time zone, dob date, isinname character varying, settlementtype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_order_nav numeric(15,4);
DECLARE v_order_navdate date;

BEGIN
	
/* SELECT * FROM master.trx_type WHERE category_code = 261;
"category_code"	"trx_type_code"	"trx_type"	"inv_type_code"	"display_order"	"isactive"
	261					1		"SIP"				3				1			true
	261					2		"STP"				2				2			true
	261					3		"SWP"				1				3			true
	261					4		"Lumpsum"			3				4			true
	261					5		"Redeem"			1				5			true
	261					6		"Switch"			2				6			true */

	/* Checking if the Transaction is valid with Consent Pending and then only allowing to Modify */
	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.consent_status_code = 1 AND A.trx_type_code = v_trx_type_code AND A.trx_id = v_trx_id)
	THEN
		
		SELECT COALESCE(B.nav, A.nav)::numeric(15,4) as nav, 
	COALESCE(B.navdate, A.navdate)::date as navdate
		INTO v_order_nav, v_order_navdate
		FROM transactions.mf_order_detail A
		JOIN master.dim_mf_scheme B ON A.mf_schcode = B.mf_schcode
		WHERE A.consent_status_code = 1 AND A.trx_type_code = v_trx_type_code AND A.trx_id = v_trx_id;
		
		/* Checking if Input Paramters of SIP Modification are valid i.e. mandate_id, frequency, trx_amt, start_day, is_generatetoday */
		IF (v_trx_type_code = 1 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(TRIM(v_mandate_id),'') <> '' OR
				  COALESCE(TRIM(v_frequency),'') <> '' OR
				  COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(TRIM(v_start_day),'') <> '' OR
				  v_is_generatetoday IS NOT NULL))
		THEN

			RAISE NOTICE 'updation for: %', v_trx_type_code;
			RAISE NOTICE 'sub_broker_pass_pct: %', v_sub_broker_pass_pct;
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			mandate_id = CASE WHEN COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id THEN v_mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			is_generatetoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday THEN v_is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW() at time zone 'Asia/Kolkata',
			folio_no= case when coalesce(v_folio_no,'')<>'' then v_folio_no else A.folio_no end,
		/*	sub_broker_code=case when coalesce(v_sub_broker_code,'')<>coalesce(A.sub_broker_code,'') 
				then v_sub_broker_code else A.sub_broker_code end,
			sub_broker_name=case when coalesce(v_sub_broker_name,'')<>coalesce(A.sub_broker_name,'') 
				then v_sub_broker_name else A.sub_broker_name end,
			arn_code=case when coalesce(v_arn_code,'')<>coalesce(A.arn_code,'') 
				then v_arn_code else A.arn_code end,
			sub_broker_pass_pct =case when coalesce(v_sub_broker_pass_pct,0.00)<>coalesce(A.sub_broker_pass_pct,0.00)
				then v_sub_broker_pass_pct else A.sub_broker_pass_pct end
*/			
				sub_broker_code=v_sub_broker_code,
				sub_broker_name=v_sub_broker_name,
				arn_code=v_arn_code,
				sub_broker_pass_pct=v_sub_broker_pass_pct
			WHERE A.trx_type_code = 1 AND A.trx_id = v_trx_id;
		/*	AND (
			--	(COALESCE(TRIM(v_mandate_id),'') <> '' and v_mandate_id <> A.mandate_id)
			--	OR 
				(COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				OR (v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday)
				OR (A.sub_broker_code <> v_sub_broker_code)
				OR (A.sub_broker_pass_pct <> v_sub_broker_pass_pct)
				);
*/
			/* Update Detail History table */
			UPDATE transactions.mf_order_detail_history A SET
			mandate_id = CASE WHEN B.mandate_id <> A.mandate_id THEN B.mandate_id ELSE A.mandate_id END/* Updating mandate_id only when there is modifcation from existing value */
			FROM transactions.mf_order_detail B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND (COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id);
			
			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			mandate_id = CASE WHEN COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id THEN v_mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			frequency = CASE WHEN COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency THEN v_frequency ELSE A.frequency END,/* Updating frequency only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			start_day = CASE WHEN COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day THEN v_start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			firstordertoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday
								   THEN CASE WHEN v_is_generatetoday = FALSE THEN 'N' ELSE 'Y' END::character varying
							  ELSE A.firstordertoday END,/* Updating firstordertoday only when there is modifcation in is_generatetoday */
			is_generatetoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday THEN v_is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			modified_date = NOW() at time zone 'Asia/Kolkata',
			start_date= case when COALESCE(v_transfer_date,'1900-01-01'::date) <> A.start_date then v_transfer_date else A.start_date end,
			end_date= Case when COALESCE(v_end_date,'1900-01-01'::date) <> A.end_date then v_end_date else A.end_date end,
			upcoming_due_date= Case when COALESCE(v_transfer_date,'1900-01-01'::date) <> A.upcoming_due_date then v_transfer_date else A.upcoming_due_date end
				WHERE A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency)
				 OR (COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day)
				 OR (v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			mandate_id = CASE WHEN B.mandate_id <> A.mandate_id THEN B.mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			start_day = CASE WHEN B.start_day <> A.start_day THEN B.start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			is_generatetoday = CASE WHEN B.is_generatetoday <> A.is_generatetoday THEN B.is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			upcoming_due_date= Case when COALESCE(v_transfer_date,'1900-01-01'::date) <> A.upcoming_due_date then v_transfer_date else A.upcoming_due_date end
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND (B.mandate_id <> A.mandate_id OR B.trx_qty <> A.trx_qty OR B.start_day <> A.start_day OR B.is_generatetoday <> A.is_generatetoday);
			
			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'SIP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of STP Modification are valid i.e. trx_amt, no_of_installment, start_date */
		ELSIF (v_trx_type_code = 2 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(v_no_of_installment,0) <> 0 OR
				  COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date))
		THEN

			RAISE NOTICE 'updation for: %', v_trx_type_code;
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			no_of_installment = CASE WHEN COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment THEN v_no_of_installment ELSE A.no_of_installment END,/* Updating no_of_installment only when there is modifcation from existing value */
			start_date = CASE WHEN COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date AND v_transfer_date <> A.start_date THEN v_transfer_date ELSE A.start_date END,/* Updating no_of_installment only when there is modifcation from existing value */
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND (((COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment)
				 OR (COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date) AND v_transfer_date <> A.start_date)
				);
					
			/* Update Summary History table */
			/*
			UPDATE transactions.mf_order_summary_history A SET
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END/* Updating trx_qty only when there is modifcation in trx_amt */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND B.trx_qty <> A.trx_qty;
			*/

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'STP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of SWP Modification are valid i.e. frequency, trx_amt, start_day, no_of_installment */
		ELSIF (v_trx_type_code = 3 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(TRIM(v_frequency),'') <> '' OR
				  COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(v_no_of_installment,0) <> 0 OR
				  COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date))
		THEN

			RAISE NOTICE 'updation for: %', v_trx_type_code;
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			frequency = CASE WHEN COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency THEN v_frequency ELSE A.frequency END,/* Updating frequency only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			start_day = CASE WHEN COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day THEN v_start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			no_of_installment = CASE WHEN COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment THEN v_no_of_installment ELSE A.no_of_installment END,/* Updating no_of_installment only when there is modifcation from existing value */
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day)
				 OR (COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment)
				);
					
			/* Update Summary History table */
			/*
			UPDATE transactions.mf_order_summary_history A SET
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			start_day = CASE WHEN B.start_day <> A.start_day THEN B.start_day ELSE A.start_day END/* Updating start_day only when there is modifcation from existing value */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND (B.trx_qty <> A.trx_qty OR B.start_day <> A.start_day);
			*/

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'SWP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of Lumpsum Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 4 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN

			RAISE NOTICE 'updation for: %', v_trx_type_code;
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW() at time zone 'Asia/Kolkata',
			folio_no = case when coalesce(v_folio_no,'')<>'' then v_folio_no else A.folio_no end,
			sub_broker_code=case when coalesce(v_sub_broker_code,'')<>A.sub_broker_code then v_sub_broker_code else A.sub_broker_code end,
			sub_broker_name=case when coalesce(v_sub_broker_name,'')<>A.sub_broker_name then v_sub_broker_name else A.sub_broker_name end,
			arn_code=case when coalesce(v_arn_code,'')<>A.arn_code then v_arn_code else A.arn_code end,
			sub_broker_pass_pct =case when coalesce(v_sub_broker_pass_pct,0.00)<>A.sub_broker_pass_pct then v_sub_broker_pass_pct else A.sub_broker_pass_pct end
			WHERE A.trx_type_code = 4 AND A.trx_id = v_trx_id ;
--			AND (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt
--				OR (A.sub_broker_pass_pct <> v_sub_broker_pass_pct)
--				);

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Lumpsum Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of Redeem Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 5 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN

			RAISE NOTICE 'updation for: %', v_trx_type_code;
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 5 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Redeem Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 

		/* Checking if Input Paramters of Switch Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 6 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN

			RAISE NOTICE 'updation for: %', v_trx_type_code;
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 6 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Switch Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 

		ELSE
		
			RETURN QUERY
			SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
			, ((SELECT T.trx_type FROM master.trx_type T WHERE T.category_code = 261 AND T.trx_type_code = v_trx_type_code)||' Cannot be modified due to bad input parameters')::character varying as remarks
			, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
			, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, NULL::date, 'NA'::character varying, 'NA'::character varying;

		END IF;

	ELSE
	
		RETURN QUERY
		SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying, 'Transaction Cannot be modified'::character varying as remarks
		, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, NULL::date, 'NA'::character varying, 'NA'::character varying;

	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
	BEGIN
		
		RETURN QUERY
		SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
		, ('Error :- '||CAST(SQLERRM as VARCHAR(4000)))::character varying as remarks, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, NULL::date, 'NA'::character varying, 'NA'::character varying;

    END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_modify_mf_transactions(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar, varchar, varchar, varchar, varchar, numeric) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar, varchar, varchar, varchar, varchar, numeric) TO public;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar, varchar, varchar, varchar, varchar, numeric) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar, varchar, varchar, varchar, varchar, numeric) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar, varchar, varchar, varchar, varchar, numeric) TO cmotsread;

-- DROP FUNCTION transactions.fn_modify_mf_transactions_bkp_05sept2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_modify_mf_transactions_bkp_05sept2025(v_logintype character varying, v_logincode character varying, v_trx_id bigint, v_trx_type_code integer, v_vendor_req character varying, v_mandate_id character varying DEFAULT NULL::character varying, v_frequency character varying DEFAULT NULL::character varying, v_trx_amt numeric DEFAULT NULL::numeric(15,4), v_start_day character varying DEFAULT NULL::character varying, v_is_generatetoday boolean DEFAULT NULL::boolean, v_no_of_installment integer DEFAULT NULL::integer, v_transfer_date date DEFAULT NULL::date, v_end_date date DEFAULT NULL::date, v_natureoforder character varying DEFAULT NULL::character varying, v_created_for character varying DEFAULT NULL::character varying)
 RETURNS TABLE(status character varying, display_trx_id character varying, trx_id character varying, remarks character varying, token bigint, isinino character varying, pan character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, order_expiry timestamp without time zone, dob date, isinname character varying, settlementtype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_order_nav numeric(15,4);
DECLARE v_order_navdate date;

BEGIN
	
/* SELECT * FROM master.trx_type WHERE category_code = 261;
"category_code"	"trx_type_code"	"trx_type"	"inv_type_code"	"display_order"	"isactive"
	261					1		"SIP"				3				1			true
	261					2		"STP"				2				2			true
	261					3		"SWP"				1				3			true
	261					4		"Lumpsum"			3				4			true
	261					5		"Redeem"			1				5			true
	261					6		"Switch"			2				6			true */

	/* Checking if the Transaction is valid with Consent Pending and then only allowing to Modify */
	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.consent_status_code = 1 AND A.trx_type_code = v_trx_type_code AND A.trx_id = v_trx_id)
	THEN
		
		SELECT COALESCE(B.nav, A.nav)::numeric(15,4) as nav, 
	COALESCE(B.navdate, A.navdate)::date as navdate
		INTO v_order_nav, v_order_navdate
		FROM transactions.mf_order_detail A
		JOIN master.dim_mf_scheme B ON A.mf_schcode = B.mf_schcode
		WHERE A.consent_status_code = 1 AND A.trx_type_code = v_trx_type_code AND A.trx_id = v_trx_id;
		
		/* Checking if Input Paramters of SIP Modification are valid i.e. mandate_id, frequency, trx_amt, start_day, is_generatetoday */
		IF (v_trx_type_code = 1 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(TRIM(v_mandate_id),'') <> '' OR
				  COALESCE(TRIM(v_frequency),'') <> '' OR
				  COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(TRIM(v_start_day),'') <> '' OR
				  v_is_generatetoday IS NOT NULL))
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			mandate_id = CASE WHEN COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id THEN v_mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			is_generatetoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday THEN v_is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday)
				);

			/* Update Detail History table */
			UPDATE transactions.mf_order_detail_history A SET
			mandate_id = CASE WHEN B.mandate_id <> A.mandate_id THEN B.mandate_id ELSE A.mandate_id END/* Updating mandate_id only when there is modifcation from existing value */
			FROM transactions.mf_order_detail B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND (COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id);
			
			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			mandate_id = CASE WHEN COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id THEN v_mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			frequency = CASE WHEN COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency THEN v_frequency ELSE A.frequency END,/* Updating frequency only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			start_day = CASE WHEN COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day THEN v_start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			firstordertoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday
								   THEN CASE WHEN v_is_generatetoday = FALSE THEN 'N' ELSE 'Y' END::character varying
							  ELSE A.firstordertoday END,/* Updating firstordertoday only when there is modifcation in is_generatetoday */
			is_generatetoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday THEN v_is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			modified_date = (NOW() at time zone 'Asia/Kolkata'),
			start_date= case when COALESCE(v_transfer_date,'1900-01-01'::date) <> A.start_date then v_transfer_date else A.start_date end,
			end_date= Case when COALESCE(v_end_date,'1900-01-01'::date) <> A.end_date then v_end_date else A.end_date end,
			upcoming_due_date= Case when COALESCE(v_transfer_date,'1900-01-01'::date) <> A.upcoming_due_date then v_transfer_date else A.upcoming_due_date end
				WHERE A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency)
				 OR (COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day)
				 OR (v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			mandate_id = CASE WHEN B.mandate_id <> A.mandate_id THEN B.mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			start_day = CASE WHEN B.start_day <> A.start_day THEN B.start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			is_generatetoday = CASE WHEN B.is_generatetoday <> A.is_generatetoday THEN B.is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			upcoming_due_date= Case when COALESCE(v_transfer_date,'1900-01-01'::date) <> A.upcoming_due_date then v_transfer_date else A.upcoming_due_date end
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND (B.mandate_id <> A.mandate_id OR B.trx_qty <> A.trx_qty OR B.start_day <> A.start_day OR B.is_generatetoday <> A.is_generatetoday);
			
			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'SIP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of STP Modification are valid i.e. trx_amt, no_of_installment, start_date */
		ELSIF (v_trx_type_code = 2 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(v_no_of_installment,0) <> 0 OR
				  COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date))
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			no_of_installment = CASE WHEN COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment THEN v_no_of_installment ELSE A.no_of_installment END,/* Updating no_of_installment only when there is modifcation from existing value */
			start_date = CASE WHEN COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date AND v_transfer_date <> A.start_date THEN v_transfer_date ELSE A.start_date END,/* Updating no_of_installment only when there is modifcation from existing value */
			modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND (((COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment)
				 OR (COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date) AND v_transfer_date <> A.start_date)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END/* Updating trx_qty only when there is modifcation in trx_amt */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND B.trx_qty <> A.trx_qty;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'STP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of SWP Modification are valid i.e. frequency, trx_amt, start_day, no_of_installment */
		ELSIF (v_trx_type_code = 3 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(TRIM(v_frequency),'') <> '' OR
				  COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(v_no_of_installment,0) <> 0 OR
				  COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date))
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			frequency = CASE WHEN COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency THEN v_frequency ELSE A.frequency END,/* Updating frequency only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			start_day = CASE WHEN COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day THEN v_start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			no_of_installment = CASE WHEN COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment THEN v_no_of_installment ELSE A.no_of_installment END,/* Updating no_of_installment only when there is modifcation from existing value */
			modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day)
				 OR (COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			start_day = CASE WHEN B.start_day <> A.start_day THEN B.start_day ELSE A.start_day END/* Updating start_day only when there is modifcation from existing value */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND (B.trx_qty <> A.trx_qty OR B.start_day <> A.start_day);
								
			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'SWP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of Lumpsum Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 4 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_type_code = 4 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Lumpsum Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of Redeem Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 5 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_type_code = 5 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Redeem Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 

		/* Checking if Input Paramters of Switch Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 6 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_type_code = 6 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Switch Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 

		ELSE
		
			RETURN QUERY
			SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
			, ((SELECT T.trx_type FROM master.trx_type T WHERE T.category_code = 261 AND T.trx_type_code = v_trx_type_code)||' Cannot be modified due to bad input parameters')::character varying as remarks
			, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
			, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, NULL::date, 'NA'::character varying, 'NA'::character varying;

		END IF;

	ELSE
	
		RETURN QUERY
		SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying, 'Transaction Cannot be modified'::character varying as remarks
		, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, NULL::date, 'NA'::character varying, 'NA'::character varying;

	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
	BEGIN
		
		RETURN QUERY
		SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
		, ('Error :- '||CAST(SQLERRM as VARCHAR(4000)))::character varying as remarks, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, NULL::date, 'NA'::character varying, 'NA'::character varying;

    END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_modify_mf_transactions_bkp_05sept2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_05sept2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_05sept2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_05sept2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_05sept2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date, date, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_modify_mf_transactions_bkp_09may2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date);

CREATE OR REPLACE FUNCTION transactions.fn_modify_mf_transactions_bkp_09may2025(v_logintype character varying, v_logincode character varying, v_trx_id bigint, v_trx_type_code integer, v_vendor_req character varying, v_mandate_id character varying DEFAULT NULL::character varying, v_frequency character varying DEFAULT NULL::character varying, v_trx_amt numeric DEFAULT NULL::numeric(15,4), v_start_day character varying DEFAULT NULL::character varying, v_is_generatetoday boolean DEFAULT NULL::boolean, v_no_of_installment integer DEFAULT NULL::integer, v_transfer_date date DEFAULT NULL::date)
 RETURNS TABLE(status character varying, display_trx_id character varying, trx_id character varying, remarks character varying, token bigint, isinino character varying, pan character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, order_expiry timestamp without time zone, dob date, isinname character varying, settlementtype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_order_nav numeric(15,4);
DECLARE v_order_navdate date;

BEGIN
	
/* SELECT * FROM master.trx_type WHERE category_code = 261;
"category_code"	"trx_type_code"	"trx_type"	"inv_type_code"	"display_order"	"isactive"
	261					1		"SIP"				3				1			true
	261					2		"STP"				2				2			true
	261					3		"SWP"				1				3			true
	261					4		"Lumpsum"			3				4			true
	261					5		"Redeem"			1				5			true
	261					6		"Switch"			2				6			true */

	/* Checking if the Transaction is valid with Consent Pending and then only allowing to Modify */
	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.consent_status_code = 1 AND A.trx_type_code = v_trx_type_code AND A.trx_id = v_trx_id)
	THEN
		
		SELECT COALESCE(B.nav, A.nav)::numeric(15,4) as nav, COALESCE(B.navdate, A.navdate)::date as navdate
		INTO v_order_nav, v_order_navdate
		FROM transactions.mf_order_detail A
		JOIN master.dim_mf_scheme B ON A.mf_schcode = B.mf_schcode
		WHERE A.consent_status_code = 1 AND A.trx_type_code = v_trx_type_code AND A.trx_id = v_trx_id;
		
		/* Checking if Input Paramters of SIP Modification are valid i.e. mandate_id, frequency, trx_amt, start_day, is_generatetoday */
		IF (v_trx_type_code = 1 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(TRIM(v_mandate_id),'') <> '' OR
				  COALESCE(TRIM(v_frequency),'') <> '' OR
				  COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(TRIM(v_start_day),'') <> '' OR
				  v_is_generatetoday IS NOT NULL))
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			mandate_id = CASE WHEN COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id THEN v_mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			is_generatetoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday THEN v_is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday)
				);

			/* Update Detail History table */
			UPDATE transactions.mf_order_detail_history A SET
			mandate_id = CASE WHEN B.mandate_id <> A.mandate_id THEN B.mandate_id ELSE A.mandate_id END/* Updating mandate_id only when there is modifcation from existing value */
			FROM transactions.mf_order_detail B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND (COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id);
			
			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			mandate_id = CASE WHEN COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id THEN v_mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			frequency = CASE WHEN COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency THEN v_frequency ELSE A.frequency END,/* Updating frequency only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			start_day = CASE WHEN COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day THEN v_start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			firstordertoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday
								   THEN CASE WHEN v_is_generatetoday = FALSE THEN 'N' ELSE 'Y' END::character varying
							  ELSE A.firstordertoday END,/* Updating firstordertoday only when there is modifcation in is_generatetoday */
			is_generatetoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday THEN v_is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			modified_date = NOW()
			WHERE A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency)
				 OR (COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day)
				 OR (v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			mandate_id = CASE WHEN B.mandate_id <> A.mandate_id THEN B.mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			start_day = CASE WHEN B.start_day <> A.start_day THEN B.start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			is_generatetoday = CASE WHEN B.is_generatetoday <> A.is_generatetoday THEN B.is_generatetoday ELSE A.is_generatetoday END/* Updating is_generatetoday only when there is modifcation from existing value */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND (B.mandate_id <> A.mandate_id OR B.trx_qty <> A.trx_qty OR B.start_day <> A.start_day OR B.is_generatetoday <> A.is_generatetoday);
			
			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'SIP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of STP Modification are valid i.e. trx_amt, no_of_installment, start_date */
		ELSIF (v_trx_type_code = 2 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(v_no_of_installment,0) <> 0 OR
				  COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date))
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			no_of_installment = CASE WHEN COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment THEN v_no_of_installment ELSE A.no_of_installment END,/* Updating no_of_installment only when there is modifcation from existing value */
			start_date = CASE WHEN COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date AND v_transfer_date <> A.start_date THEN v_no_of_installment ELSE A.start_date END,/* Updating no_of_installment only when there is modifcation from existing value */
			modified_date = NOW()
			WHERE A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND (((COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment)
				 OR (COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date) AND v_transfer_date <> A.start_date)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END/* Updating trx_qty only when there is modifcation in trx_amt */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND B.trx_qty <> A.trx_qty;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'STP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of SWP Modification are valid i.e. frequency, trx_amt, start_day, no_of_installment */
		ELSIF (v_trx_type_code = 3 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(TRIM(v_frequency),'') <> '' OR
				  COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(v_no_of_installment,0) <> 0 OR
				  COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date))
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			frequency = CASE WHEN COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency THEN v_frequency ELSE A.frequency END,/* Updating frequency only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			start_day = CASE WHEN COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day THEN v_start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			no_of_installment = CASE WHEN COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment THEN v_no_of_installment ELSE A.no_of_installment END,/* Updating no_of_installment only when there is modifcation from existing value */
			modified_date = NOW()
			WHERE A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day)
				 OR (COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			start_day = CASE WHEN B.start_day <> A.start_day THEN B.start_day ELSE A.start_day END/* Updating start_day only when there is modifcation from existing value */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND (B.trx_qty <> A.trx_qty OR B.start_day <> A.start_day);
								
			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'SWP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of Lumpsum Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 4 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 4 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Lumpsum Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of Redeem Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 5 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 5 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Redeem Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 

		/* Checking if Input Paramters of Switch Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 6 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 6 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Switch Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 

		ELSE
		
			RETURN QUERY
			SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
			, ((SELECT T.trx_type FROM master.trx_type T WHERE T.category_code = 261 AND T.trx_type_code = v_trx_type_code)||' Cannot be modified due to bad input parameters')::character varying as remarks
			, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
			, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, NULL::date, 'NA'::character varying, 'NA'::character varying;

		END IF;

	ELSE
	
		RETURN QUERY
		SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying, 'Transaction Cannot be modified'::character varying as remarks
		, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, NULL::date, 'NA'::character varying, 'NA'::character varying;

	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
	BEGIN
		
		RETURN QUERY
		SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
		, ('Error :- '||CAST(SQLERRM as VARCHAR(4000)))::character varying as remarks, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, NULL::date, 'NA'::character varying, 'NA'::character varying;

    END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_modify_mf_transactions_bkp_09may2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_09may2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) TO public;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_09may2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_09may2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_09may2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) TO cmotsread;

-- DROP FUNCTION transactions.fn_modify_mf_transactions_bkp_14jul2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date);

CREATE OR REPLACE FUNCTION transactions.fn_modify_mf_transactions_bkp_14jul2025(v_logintype character varying, v_logincode character varying, v_trx_id bigint, v_trx_type_code integer, v_vendor_req character varying, v_mandate_id character varying DEFAULT NULL::character varying, v_frequency character varying DEFAULT NULL::character varying, v_trx_amt numeric DEFAULT NULL::numeric(15,4), v_start_day character varying DEFAULT NULL::character varying, v_is_generatetoday boolean DEFAULT NULL::boolean, v_no_of_installment integer DEFAULT NULL::integer, v_transfer_date date DEFAULT NULL::date)
 RETURNS TABLE(status character varying, display_trx_id character varying, trx_id character varying, remarks character varying, token bigint, isinino character varying, pan character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, order_expiry timestamp without time zone, dob date, isinname character varying, settlementtype character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_order_nav numeric(15,4);
DECLARE v_order_navdate date;

BEGIN
	
/* SELECT * FROM master.trx_type WHERE category_code = 261;
"category_code"	"trx_type_code"	"trx_type"	"inv_type_code"	"display_order"	"isactive"
	261					1		"SIP"				3				1			true
	261					2		"STP"				2				2			true
	261					3		"SWP"				1				3			true
	261					4		"Lumpsum"			3				4			true
	261					5		"Redeem"			1				5			true
	261					6		"Switch"			2				6			true */

	/* Checking if the Transaction is valid with Consent Pending and then only allowing to Modify */
	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.consent_status_code = 1 AND A.trx_type_code = v_trx_type_code AND A.trx_id = v_trx_id)
	THEN
		
		SELECT COALESCE(B.nav, A.nav)::numeric(15,4) as nav, COALESCE(B.navdate, A.navdate)::date as navdate
		INTO v_order_nav, v_order_navdate
		FROM transactions.mf_order_detail A
		JOIN master.dim_mf_scheme B ON A.mf_schcode = B.mf_schcode
		WHERE A.consent_status_code = 1 AND A.trx_type_code = v_trx_type_code AND A.trx_id = v_trx_id;
		
		/* Checking if Input Paramters of SIP Modification are valid i.e. mandate_id, frequency, trx_amt, start_day, is_generatetoday */
		IF (v_trx_type_code = 1 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(TRIM(v_mandate_id),'') <> '' OR
				  COALESCE(TRIM(v_frequency),'') <> '' OR
				  COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(TRIM(v_start_day),'') <> '' OR
				  v_is_generatetoday IS NOT NULL))
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			mandate_id = CASE WHEN COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id THEN v_mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			is_generatetoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday THEN v_is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday)
				);

			/* Update Detail History table */
			UPDATE transactions.mf_order_detail_history A SET
			mandate_id = CASE WHEN B.mandate_id <> A.mandate_id THEN B.mandate_id ELSE A.mandate_id END/* Updating mandate_id only when there is modifcation from existing value */
			FROM transactions.mf_order_detail B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND (COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id);
			
			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			mandate_id = CASE WHEN COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id THEN v_mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			frequency = CASE WHEN COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency THEN v_frequency ELSE A.frequency END,/* Updating frequency only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			start_day = CASE WHEN COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day THEN v_start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			firstordertoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday
								   THEN CASE WHEN v_is_generatetoday = FALSE THEN 'N' ELSE 'Y' END::character varying
							  ELSE A.firstordertoday END,/* Updating firstordertoday only when there is modifcation in is_generatetoday */
			is_generatetoday = CASE WHEN v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday THEN v_is_generatetoday ELSE A.is_generatetoday END,/* Updating is_generatetoday only when there is modifcation from existing value */
			modified_date = NOW()
			WHERE A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_mandate_id),'') <> '' AND v_mandate_id <> A.mandate_id)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency)
				 OR (COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day)
				 OR (v_is_generatetoday IS NOT NULL AND A.is_generatetoday <> v_is_generatetoday)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			mandate_id = CASE WHEN B.mandate_id <> A.mandate_id THEN B.mandate_id ELSE A.mandate_id END,/* Updating mandate_id only when there is modifcation from existing value */
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			start_day = CASE WHEN B.start_day <> A.start_day THEN B.start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			is_generatetoday = CASE WHEN B.is_generatetoday <> A.is_generatetoday THEN B.is_generatetoday ELSE A.is_generatetoday END/* Updating is_generatetoday only when there is modifcation from existing value */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 1 AND A.trx_id = v_trx_id
			AND (B.mandate_id <> A.mandate_id OR B.trx_qty <> A.trx_qty OR B.start_day <> A.start_day OR B.is_generatetoday <> A.is_generatetoday);
			
			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'SIP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of STP Modification are valid i.e. trx_amt, no_of_installment, start_date */
		ELSIF (v_trx_type_code = 2 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(v_no_of_installment,0) <> 0 OR
				  COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date))
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			no_of_installment = CASE WHEN COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment THEN v_no_of_installment ELSE A.no_of_installment END,/* Updating no_of_installment only when there is modifcation from existing value */
			start_date = CASE WHEN COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date AND v_transfer_date <> A.start_date THEN v_no_of_installment ELSE A.start_date END,/* Updating no_of_installment only when there is modifcation from existing value */
			modified_date = NOW()
			WHERE A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND (((COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment)
				 OR (COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date) AND v_transfer_date <> A.start_date)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END/* Updating trx_qty only when there is modifcation in trx_amt */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 2 AND A.trx_id = v_trx_id
			AND B.trx_qty <> A.trx_qty;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'STP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of SWP Modification are valid i.e. frequency, trx_amt, start_day, no_of_installment */
		ELSIF (v_trx_type_code = 3 AND COALESCE(TRIM(v_vendor_req),'') <> ''
			 AND (COALESCE(TRIM(v_frequency),'') <> '' OR
				  COALESCE(v_trx_amt,0) <> 0 OR
				  COALESCE(v_no_of_installment,0) <> 0 OR
				  COALESCE(v_transfer_date,'1900-01-01'::date) <> '1900-01-01'::date))
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			/* Update Summary table */
			UPDATE transactions.mf_order_summary A SET
			frequency = CASE WHEN COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency THEN v_frequency ELSE A.frequency END,/* Updating frequency only when there is modifcation from existing value */
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			start_day = CASE WHEN COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day THEN v_start_day ELSE A.start_day END,/* Updating start_day only when there is modifcation from existing value */
			no_of_installment = CASE WHEN COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment THEN v_no_of_installment ELSE A.no_of_installment END,/* Updating no_of_installment only when there is modifcation from existing value */
			modified_date = NOW()
			WHERE A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND ((COALESCE(TRIM(v_frequency),'') <> '' AND  v_frequency <> A.frequency)
				 OR (COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt)
				 OR (COALESCE(TRIM(v_start_day),'') <> '' AND v_start_day <> A.start_day)
				 OR (COALESCE(v_no_of_installment,0) <> 0 AND v_no_of_installment <> A.no_of_installment)
				);
					
			/* Update Summary History table */
			UPDATE transactions.mf_order_summary_history A SET
			trx_qty = CASE WHEN B.trx_qty <> A.trx_qty THEN B.trx_qty ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			start_day = CASE WHEN B.start_day <> A.start_day THEN B.start_day ELSE A.start_day END/* Updating start_day only when there is modifcation from existing value */
			FROM transactions.mf_order_summary B
			WHERE A.trx_id = B.trx_id AND A.is_active = TRUE AND A.trx_type_code = 3 AND A.trx_id = v_trx_id
			AND (B.trx_qty <> A.trx_qty OR B.start_day <> A.start_day);
								
			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'SWP Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of Lumpsum Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 4 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 4 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Lumpsum Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 
			
		/* Checking if Input Paramters of Redeem Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 5 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 5 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Redeem Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 

		/* Checking if Input Paramters of Switch Modification is valid i.e. trx_amt */
		ELSIF (v_trx_type_code = 6 AND COALESCE(TRIM(v_vendor_req),'') <> '' AND COALESCE(v_trx_amt,0) <> 0)
		THEN
			
			/* Update Detail table */
			UPDATE transactions.mf_order_detail A SET
			order_nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating order_nav only when there is modifcation in trx_amt */
			order_navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating order_navdate only when there is modifcation in trx_amt */
			nav = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_nav ELSE A.order_nav END,/* Updating nav only when there is modifcation in trx_amt */
			navdate = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_order_navdate ELSE A.order_navdate END,/* Updating navdate only when there is modifcation in trx_amt */
			trx_qty = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN (v_trx_amt/v_order_nav)::numeric(15,4) ELSE A.trx_qty END,/* Updating trx_qty only when there is modifcation in trx_amt */
			trx_amt = CASE WHEN COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt THEN v_trx_amt ELSE A.trx_amt END,/* Updating trx_amt only when there is modifcation from existing value */
			modified_by = v_logincode,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			modified_date = NOW()
			WHERE A.trx_type_code = 6 AND A.trx_id = v_trx_id
			AND COALESCE(v_trx_amt,0) <> 0 AND v_trx_amt <> A.trx_amt;

			UPDATE transactions.order_consent A SET
			consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 4),
			consent_expire_date = NOW()
			WHERE A.category_code = 261
			AND A.trx_id = v_trx_id
			AND A.consent_status = (SELECT C.consent_status FROM master.dim_consent_status C WHERE C.category_code = '261' AND C.consent_status_code = 1);

			RETURN QUERY
			SELECT 'SUCCESS'::character varying as status, A.display_trx_id::character varying, A.trx_id::character varying, 'Switch Modification done successfully'::character varying as remarks
			, A.tokenno::bigint as "token", A.isincode AS isinino, A.pan
			, A.ucccode, A.ac_code, C.acname as ac_name, C.mobileno as client_mobile, C.email as client_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_name ELSE C.client_owner_name END as rm_name
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_mobile ELSE C.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN C.partner_email ELSE C.rm_email END as rm_email
			, CASE WHEN COALESCE(C.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, C.birthdate::date as dob, INITCAP(A.isinname)::character varying isinname, B.settltement_type settlementtype
			FROM transactions.mf_order_detail A
			JOIN master.dim_mf_isin B ON A.isincode = B.isincode
			JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = v_trx_id; 

		ELSE
		
			RETURN QUERY
			SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
			, ((SELECT T.trx_type FROM master.trx_type T WHERE T.category_code = 261 AND T.trx_type_code = v_trx_type_code)||' Cannot be modified due to bad input parameters')::character varying as remarks
			, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
			, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, NULL::date, 'NA'::character varying, 'NA'::character varying;

		END IF;

	ELSE
	
		RETURN QUERY
		SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying, 'Transaction Cannot be modified'::character varying as remarks
		, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, NULL::date, 'NA'::character varying, 'NA'::character varying;

	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
	BEGIN
		
		RETURN QUERY
		SELECT 'FAILURE'::character varying as status, 'NA'::character varying, 'NA'::character varying
		, ('Error :- '||CAST(SQLERRM as VARCHAR(4000)))::character varying as remarks, NULL::bigint, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, 'NA'::character varying, 'NA'::character varying, 'NA'::character varying
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, NULL::date, 'NA'::character varying, 'NA'::character varying;

    END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_modify_mf_transactions_bkp_14jul2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_14jul2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) TO public;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_14jul2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_14jul2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_modify_mf_transactions_bkp_14jul2025(varchar, varchar, int8, int4, varchar, varchar, varchar, numeric, varchar, bool, int4, date) TO cmotsread;

-- DROP FUNCTION transactions.fn_modify_sip_mf(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_modify_sip_mf(v_logintype character varying, v_logincode character varying, v_trx_source character varying, v_trx_id bigint, v_vendor_req character varying, v_frequency character varying DEFAULT NULL::character varying, v_mandate_id character varying DEFAULT NULL::character varying, v_trx_amt numeric DEFAULT NULL::numeric(24,6), v_start_day character varying DEFAULT NULL::character varying, v_natureoforder character varying DEFAULT NULL::character varying, v_created_for character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, display_trx_id character varying, status character varying, remarks character varying, order_expiry timestamp without time zone, vendor_req character varying, consent_flag boolean)
 LANGUAGE plpgsql
AS $function$

DECLARE v_id bigint;
DECLARE v_mod_type character varying;
DECLARE v_trx_type boolean;

BEGIN

/* SELECT * FROM master.investment_action
"category_code"	"inv_action_code"	"inv_action"	"isactive"
	261					1			"Transaction"		true
	261					2			"Pause"				true
	261					3			"Modify"			true
	261					4			"Cancel"			true */

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id)
	THEN
		
		IF EXISTS(SELECT 1 FROM transactions.mf_order_summary A WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NOT NULL
				  AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id AND COALESCE(A.modifycount, 0) < 2)
		THEN
		
			SELECT (CASE WHEN v_mandate_id IS NOT NULL AND B.mandate_id <> v_mandate_id THEN 'Mandate ID changed from ' || B.mandate_id || ' to '|| v_mandate_id || ', ' ELSE '' END ||
					CASE WHEN v_frequency IS NOT NULL AND B.frequency <> v_frequency THEN 'Frequency changed from ' || B.frequency || ' to '|| v_frequency || ', ' ELSE '' END ||
					CASE WHEN v_trx_amt IS NOT NULL AND B.trx_amt <> v_trx_amt THEN 'Transaction Amount changed from ' || B.trx_amt::character varying || ' to '|| v_trx_amt::character varying || ', ' ELSE '' END ||
					CASE WHEN v_start_day IS NOT NULL AND B.start_day <> v_start_day THEN 'Installment Day changed from ' || B.start_day || ' to '|| v_start_day || ', ' ELSE '' END
				   )::character varying INTO v_mod_type FROM transactions.mf_order_summary B WHERE B.trx_type_code = 1 AND B.inv_plan_status_code = 4 AND B.trx_id = v_trx_id;

			IF (NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7)) AND
				NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code IN (2, 3) AND A.trx_status_code = 7)
				AND LENGTH(v_mod_type) >= 2)
			THEN
			
				SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
								
				INSERT INTO transactions.mf_order_detail_modification
				(trx_id, orderby, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode, trx_type_code, trx_type
				 , consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action, physicalflag, mandate_id
				 , trx_source, rm_partner_code, vendor_req, order_placed_by, modifytype, modifycount, frequency, trx_amt, start_day, created_date, modified_date, 
					datasource,natureoforder,created_for)
				SELECT v_id, v_logincode, A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
				, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
				, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
				, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
				, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 3
				, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 3)
				, A.physicalflag, COALESCE(v_mandate_id, A.mandate_id), v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype
				, SUBSTRING(v_mod_type ,1, (LENGTH(v_mod_type) - 2)), COALESCE(B.modifycount, 0)+1
				, COALESCE(v_frequency, B.frequency), COALESCE(v_trx_amt, B.trx_amt), COALESCE(v_start_day, B.start_day), NOW() at time zone 'Asia/Kolkata'
				, NOW() at time zone 'Asia/Kolkata', 'DION'::character varying
				,v_natureoforder,v_created_for
				FROM transactions.mf_order_detail A
				JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
				WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

				UPDATE transactions.mf_order_detail_modification A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status
				FROM transactions.mf_order_detail_modification D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				/* AND D.is_generatetoday = B.is_generatetoday */
				AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
				AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
										
				/* UPDATE transactions.mf_order_summary B SET
				modifytype = CASE WHEN LENGTH(v_mod_type) >= 2 THEN SUBSTRING(v_mod_type ,1, (LENGTH(v_mod_type) - 2)) ELSE v_mod_type END,
				modifycount = modifycount+1
				WHERE B.trx_type_code = 1 AND B.inv_plan_status_code = 4 AND B.trx_id = v_trx_id; */

				UPDATE transactions.mf_order_summary A SET remarks = 'Modify Request in Progress'::character varying WHERE A.trx_id = v_trx_id;
				
				RETURN QUERY
				SELECT A.trx_id, A.display_trx_id, 'SUCCESS'::character varying as status, ('Modification for ' || A.display_trx_id || ' sucessful')::character varying as remarks
				, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
				, A.vendor_req, CASE WHEN A.consent_status_code = 1 THEN TRUE ELSE FALSE END::boolean as consent_flag
				FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
				
			ELSE
			
				RETURN QUERY
				SELECT A.trx_id, A.display_trx_id, 'FAILURE'::character varying as status, ('Modification for ' || A.display_trx_id || ' Failed')::character varying as remarks
				, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
				, A.vendor_req, FALSE as consent_flag FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

			END IF;
		
		ELSE

			RETURN QUERY
			SELECT A.trx_id, A.display_trx_id, 'FAILURE'::character varying as status, ('Modification limit for ' || A.display_trx_id || ' Reached')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, FALSE as consent_flag FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;
				
		END IF;

	ELSIF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NULL AND A.trx_id = v_trx_id)
	THEN
		
		SELECT COALESCE((SELECT CASE WHEN A.payment_status_code <> 2 THEN TRUE ELSE FALSE END
						 FROM transactions.mf_order_detail A
						 WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NULL AND A.trx_id = v_trx_id), FALSE) INTO v_trx_type;
		
		IF (v_trx_type = TRUE)
		THEN
			
			UPDATE transactions.mf_order_detail A SET
			mandate_id = COALESCE(v_mandate_id, A.mandate_id),
			trx_source = v_trx_source,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			trx_amt = COALESCE(v_trx_amt, B.trx_amt),
			consent_status_code = CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END,
			consent_status = CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END,
			modified_by = v_logincode,
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NULL AND A.trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_detail A SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			AND D.is_generatetoday = B.is_generatetoday
			AND D.consent_status_code = B.consent_status_code
			AND coalesce (D.payment_status_code,0) = coalesce (B.payment_status_code,0)
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
			
			IF EXISTS (SELECT 1 FROM transactions.mf_order_detail_history A JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.is_active = TRUE
					   WHERE A.trx_id = v_trx_id AND (A.mandate_id <>  B.mandate_id OR A.consent_status_code <> B.consent_status_code OR A.consent_status <> B.consent_status))
			
			THEN
			
				UPDATE transactions.mf_order_detail_history A SET
				valid_to = NOW() at time zone 'Asia/Kolkata',
				is_active = false
				FROM transactions.mf_order_detail B
				where A.trx_id = B.trx_id	
				AND A.trx_id = v_trx_id
				AND A.is_active = true
				AND (A.mandate_id <>  B.mandate_id OR A.consent_status_code <> B.consent_status_code OR A.consent_status <> B.consent_status);
				
				INSERT INTO transactions.mf_order_detail_history
				(trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime, is_active, trx_type_code, trx_type, consent_status_code, consent_status
				 , trx_status_code, trx_status, vendor_trx_status, payment_status_code, payment_status, inv_plan_status_code, inv_plan_status
				 , trx_final_status_code, final_status, mandate_id, order_remarks, trx_source, inserted_dt, valid_from)
				SELECT distinct A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime, true as is_active, a.trx_type_code, A.trx_type, A.consent_status_code, A.consent_status
				, A.trx_status_code, A.trx_status, A.vendor_trx_status, A.payment_status_code, A.payment_status, a.inv_plan_status_code, a.inv_plan_status
				, a.trx_final_status_code, a.final_status, a.mandate_id, A.order_remarks, A.trx_source, NOW() at time zone 'Asia/Kolkata' as inserted_dt
				, NOW() at time zone 'Asia/Kolkata' as valid_from
				FROM transactions.mf_order_detail A  WHERE A.trx_id = v_trx_id;
				
				UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
			
			END IF;
			
			UPDATE transactions.mf_order_summary A SET
			mandate_id = COALESCE(v_mandate_id, A.mandate_id),
			trx_source = v_trx_source,
			frequency = COALESCE(v_frequency, B.frequency),
			trx_amt = COALESCE(v_trx_amt, B.trx_amt),
			start_day = COALESCE(v_start_day, B.start_day),
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NULL AND A.trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET
			final_status = B.final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status,
			trx_type_code=b.trx_type_code,
			trx_status_Code=b.trx_status_Code
			from transactions.mf_order_detail B
			where A.trx_id = B.trx_id AND A.trx_id = v_trx_id;
			
			IF EXISTS (SELECT 1 FROM transactions.mf_order_summary_history A JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id AND A.is_active = TRUE
					   WHERE A.trx_id = v_trx_id AND (A.mandate_id <>  B.mandate_id OR A.start_day <> B.start_day OR A.trx_final_status_code <> B.trx_final_status_code OR A.final_status <> B.final_statuss))
			
			THEN
			
				UPDATE transactions.mf_order_summary_history A SET
				valid_to = NOW() at time zone 'Asia/Kolkata',
				is_active = false
				FROM transactions.mf_order_summary B
				where A.trx_id = B.trx_id	
				AND A.trx_id = v_trx_id
				AND A.is_active = true
				AND (A.mandate_id <>  B.mandate_id OR A.start_day <> B.start_day OR A.trx_final_status_code <> B.trx_final_status_code OR A.final_status <> B.final_status);
				
				
				INSERT INTO transactions.mf_order_summary_history
				(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
				, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
				, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
				, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active
				,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
				SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
				, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
				, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
				, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW() at time zone 'Asia/Kolkata', true
				,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
				FROM transactions.mf_order_summary A WHERE A.trx_id = v_trx_id;
				
				UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
			
			END IF;
			
		RETURN QUERY
		SELECT A.trx_id, A.display_trx_id, 'SUCCESS'::character varying as status, ('Modification for ' || A.display_trx_id || ' sucessful')::character varying as remarks
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, A.vendor_req, CASE WHEN A.consent_status_code = 1 THEN TRUE ELSE FALSE END::boolean as consent_flag
		FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		ELSE
		
			RETURN QUERY
			SELECT v_trx_id, ''::character varying as display_trx_id, 'FAILURE'::character varying as status, 'Transaction cannot be modified now'::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, ''::character varying as vendor_req, FALSE as consent_flag;	
		
		END IF;

	ELSE
	
		RETURN QUERY
		SELECT v_trx_id, ''::character varying as display_trx_id, 'FAILURE'::character varying as status, 'Invalid Input Parameters'::character varying as remarks
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, ''::character varying as vendor_req, FALSE as consent_flag;
		
	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_modify_sip_mf(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_sip_mf(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_modify_sip_mf(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_sip_mf(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_modify_sip_mf(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_modify_sip_mf_bkp_05sept2025(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_modify_sip_mf_bkp_05sept2025(v_logintype character varying, v_logincode character varying, v_trx_source character varying, v_trx_id bigint, v_vendor_req character varying, v_frequency character varying DEFAULT NULL::character varying, v_mandate_id character varying DEFAULT NULL::character varying, v_trx_amt numeric DEFAULT NULL::numeric(24,6), v_start_day character varying DEFAULT NULL::character varying, v_natureoforder character varying DEFAULT NULL::character varying, v_created_for character varying DEFAULT NULL::character varying)
 RETURNS TABLE(trx_id bigint, display_trx_id character varying, status character varying, remarks character varying, order_expiry timestamp without time zone, vendor_req character varying, consent_flag boolean)
 LANGUAGE plpgsql
AS $function$

DECLARE v_id bigint;
DECLARE v_mod_type character varying;
DECLARE v_trx_type boolean;

BEGIN

/* SELECT * FROM master.investment_action
"category_code"	"inv_action_code"	"inv_action"	"isactive"
	261					1			"Transaction"		true
	261					2			"Pause"				true
	261					3			"Modify"			true
	261					4			"Cancel"			true */

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id)
	THEN
		
		IF EXISTS(SELECT 1 FROM transactions.mf_order_summary A WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NOT NULL
				  AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id AND COALESCE(A.modifycount, 0) < 2)
		THEN
		
			SELECT (CASE WHEN v_mandate_id IS NOT NULL AND B.mandate_id <> v_mandate_id THEN 'Mandate ID changed from ' || B.mandate_id || ' to '|| v_mandate_id || ', ' ELSE '' END ||
					CASE WHEN v_frequency IS NOT NULL AND B.frequency <> v_frequency THEN 'Frequency changed from ' || B.frequency || ' to '|| v_frequency || ', ' ELSE '' END ||
					CASE WHEN v_trx_amt IS NOT NULL AND B.trx_amt <> v_trx_amt THEN 'Transaction Amount changed from ' || B.trx_amt::character varying || ' to '|| v_trx_amt::character varying || ', ' ELSE '' END ||
					CASE WHEN v_start_day IS NOT NULL AND B.start_day <> v_start_day THEN 'Installment Day changed from ' || B.start_day || ' to '|| v_start_day || ', ' ELSE '' END
				   )::character varying INTO v_mod_type FROM transactions.mf_order_summary B WHERE B.trx_type_code = 1 AND B.inv_plan_status_code = 4 AND B.trx_id = v_trx_id;

			IF (NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code = 4 AND A.trx_status_code IN (4, 7)) AND
				NOT EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.org_trx_id = v_trx_id AND A.inv_action_code IN (2, 3) AND A.trx_status_code = 7)
				AND LENGTH(v_mod_type) >= 2)
			THEN
			
				SELECT nextval('transactions.mf_order_detail_modification_trx_id_seq'::regclass) INTO v_id;
								
				INSERT INTO transactions.mf_order_detail_modification
				(trx_id, orderby, org_trx_id, vendor_trx_id, display_trx_id, ucccode, ac_code, isincode, isinname, trx_datetime, mf_schcode, trx_type_code, trx_type
				 , consent_status_code, consent_status, trx_status_code, trx_status, inv_type_code, inv_type, inv_action_code, inv_action, physicalflag, mandate_id
				 , trx_source, rm_partner_code, vendor_req, order_placed_by, modifytype, modifycount, frequency, trx_amt, start_day, created_date, modified_date, 
					datasource,natureoforder,created_for)
				SELECT v_id, v_logincode, A.trx_id, A.vendor_trx_id, A.display_trx_id, A.ucccode, A.ac_code, A.isincode, A.isinname
				, date_trunc('seconds', NOW()::timestamp without time zone), A.mf_schcode, A.trx_type_code, A.trx_type
				, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END
				, CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END, 7
				, (SELECT trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.isactive = true AND S.trx_status_code = 7), A.inv_type_code, A.inv_type, 3
				, (SELECT inv_action FROM master.investment_action N WHERE N.category_code = 261 AND N.isactive = true AND N.inv_action_code = 3)
				, A.physicalflag, COALESCE(v_mandate_id, A.mandate_id), v_trx_source, A.rm_partner_code, v_vendor_req, v_logintype
				, SUBSTRING(v_mod_type ,1, (LENGTH(v_mod_type) - 2)), COALESCE(B.modifycount, 0)+1
				, COALESCE(v_frequency, B.frequency), COALESCE(v_trx_amt, B.trx_amt), COALESCE(v_start_day, B.start_day), NOW() at time zone 'Asia/Kolkata'
				, NOW() at time zone 'Asia/Kolkata', 'DION'::character varying
				,v_natureoforder,v_created_for
				FROM transactions.mf_order_detail A
				JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
				WHERE A.trx_type_code = 1 AND A.inv_plan_status_code = 4 AND A.trx_id = v_trx_id;

				UPDATE transactions.mf_order_detail_modification A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status
				FROM transactions.mf_order_detail_modification D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				/* AND D.is_generatetoday = B.is_generatetoday */
				AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
				AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id AND A.trx_id = v_id AND A.org_trx_id = v_trx_id;
										
				/* UPDATE transactions.mf_order_summary B SET
				modifytype = CASE WHEN LENGTH(v_mod_type) >= 2 THEN SUBSTRING(v_mod_type ,1, (LENGTH(v_mod_type) - 2)) ELSE v_mod_type END,
				modifycount = modifycount+1
				WHERE B.trx_type_code = 1 AND B.inv_plan_status_code = 4 AND B.trx_id = v_trx_id; */

				UPDATE transactions.mf_order_summary A SET remarks = 'Modify Request in Progress'::character varying WHERE A.trx_id = v_trx_id;
				
				RETURN QUERY
				SELECT A.trx_id, A.display_trx_id, 'SUCCESS'::character varying as status, ('Modification for ' || A.display_trx_id || ' sucessful')::character varying as remarks
				, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
				, A.vendor_req, CASE WHEN A.consent_status_code = 1 THEN TRUE ELSE FALSE END::boolean as consent_flag
				FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_id;
				
			ELSE
			
				RETURN QUERY
				SELECT A.trx_id, A.display_trx_id, 'FAILURE'::character varying as status, ('Modification for ' || A.display_trx_id || ' Failed')::character varying as remarks
				, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
				, A.vendor_req, FALSE as consent_flag FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

			END IF;
		
		ELSE

			RETURN QUERY
			SELECT A.trx_id, A.display_trx_id, 'FAILURE'::character varying as status, ('Modification limit for ' || A.display_trx_id || ' Reached')::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, A.vendor_req, FALSE as consent_flag FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;
				
		END IF;

	ELSIF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NULL AND A.trx_id = v_trx_id)
	THEN
		
		SELECT COALESCE((SELECT CASE WHEN A.payment_status_code <> 2 THEN TRUE ELSE FALSE END
						 FROM transactions.mf_order_detail A
						 WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NULL AND A.trx_id = v_trx_id), FALSE) INTO v_trx_type;
		
		IF (v_trx_type = TRUE)
		THEN
			
			UPDATE transactions.mf_order_detail A SET
			mandate_id = COALESCE(v_mandate_id, A.mandate_id),
			trx_source = v_trx_source,
			vendor_req = v_vendor_req,
			order_placed_by = v_logintype,
			trx_amt = COALESCE(v_trx_amt, B.trx_amt),
			consent_status_code = CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 1 ELSE 0 END,
			consent_status = CASE WHEN UPPER(v_logintype) in ('RM','PARTNER') OR (UPPER(v_logintype) = 'CLIENT' AND A.physicalflag = 'P') THEN 'Consent Pending' ELSE NULL END,
			modified_by = v_logincode,
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NULL AND A.trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_detail A SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			AND D.is_generatetoday = B.is_generatetoday
			AND D.consent_status_code = B.consent_status_code
			AND coalesce (D.payment_status_code,0) = coalesce (B.payment_status_code,0)
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
			
			IF EXISTS (SELECT 1 FROM transactions.mf_order_detail_history A JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.is_active = TRUE
					   WHERE A.trx_id = v_trx_id AND (A.mandate_id <>  B.mandate_id OR A.consent_status_code <> B.consent_status_code OR A.consent_status <> B.consent_status))
			
			THEN
			
				UPDATE transactions.mf_order_detail_history A SET
				valid_to = NOW() at time zone 'Asia/Kolkata',
				is_active = false
				FROM transactions.mf_order_detail B
				where A.trx_id = B.trx_id	
				AND A.trx_id = v_trx_id
				AND A.is_active = true
				AND (A.mandate_id <>  B.mandate_id OR A.consent_status_code <> B.consent_status_code OR A.consent_status <> B.consent_status);
				
				INSERT INTO transactions.mf_order_detail_history
				(trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime, is_active, trx_type_code, trx_type, consent_status_code, consent_status
				 , trx_status_code, trx_status, vendor_trx_status, payment_status_code, payment_status, inv_plan_status_code, inv_plan_status
				 , trx_final_status_code, final_status, mandate_id, order_remarks, trx_source, inserted_dt, valid_from)
				SELECT distinct A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime, true as is_active, a.trx_type_code, A.trx_type, A.consent_status_code, A.consent_status
				, A.trx_status_code, A.trx_status, A.vendor_trx_status, A.payment_status_code, A.payment_status, a.inv_plan_status_code, a.inv_plan_status
				, a.trx_final_status_code, a.final_status, a.mandate_id, A.order_remarks, A.trx_source, NOW() at time zone 'Asia/Kolkata' as inserted_dt
				, NOW() at time zone 'Asia/Kolkata' as valid_from
				FROM transactions.mf_order_detail A  WHERE A.trx_id = v_trx_id;
				
				UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
			
			END IF;
			
			UPDATE transactions.mf_order_summary A SET
			mandate_id = COALESCE(v_mandate_id, A.mandate_id),
			trx_source = v_trx_source,
			frequency = COALESCE(v_frequency, B.frequency),
			trx_amt = COALESCE(v_trx_amt, B.trx_amt),
			start_day = COALESCE(v_start_day, B.start_day),
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_type_code = 1 AND A.vendor_trx_id IS NULL AND A.trx_id = v_trx_id;
			
			UPDATE transactions.mf_order_summary A SET
			final_status = B.final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status,
			trx_type_code=b.trx_type_code,
			trx_status_Code=b.trx_status_Code
			from transactions.mf_order_detail B
			where A.trx_id = B.trx_id AND A.trx_id = v_trx_id;
			
			IF EXISTS (SELECT 1 FROM transactions.mf_order_summary_history A JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id AND A.is_active = TRUE
					   WHERE A.trx_id = v_trx_id AND (A.mandate_id <>  B.mandate_id OR A.start_day <> B.start_day OR A.trx_final_status_code <> B.trx_final_status_code OR A.final_status <> B.final_statuss))
			
			THEN
			
				UPDATE transactions.mf_order_summary_history A SET
				valid_to = NOW() at time zone 'Asia/Kolkata',
				is_active = false
				FROM transactions.mf_order_summary B
				where A.trx_id = B.trx_id	
				AND A.trx_id = v_trx_id
				AND A.is_active = true
				AND (A.mandate_id <>  B.mandate_id OR A.start_day <> B.start_day OR A.trx_final_status_code <> B.trx_final_status_code OR A.final_status <> B.final_status);
				
				
				INSERT INTO transactions.mf_order_summary_history
				(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
				, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
				, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
				, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active
				,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
				SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
				, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
				, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
				, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW() at time zone 'Asia/Kolkata', true
				,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
				FROM transactions.mf_order_summary A WHERE A.trx_id = v_trx_id;
				
				UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
			
			END IF;
			
		RETURN QUERY
		SELECT A.trx_id, A.display_trx_id, 'SUCCESS'::character varying as status, ('Modification for ' || A.display_trx_id || ' sucessful')::character varying as remarks
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, A.vendor_req, CASE WHEN A.consent_status_code = 1 THEN TRUE ELSE FALSE END::boolean as consent_flag
		FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;

		ELSE
		
			RETURN QUERY
			SELECT v_trx_id, ''::character varying as display_trx_id, 'FAILURE'::character varying as status, 'Transaction cannot be modified now'::character varying as remarks
			, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
			, ''::character varying as vendor_req, FALSE as consent_flag;	
		
		END IF;

	ELSE
	
		RETURN QUERY
		SELECT v_trx_id, ''::character varying as display_trx_id, 'FAILURE'::character varying as status, 'Invalid Input Parameters'::character varying as remarks
		, (SELECT date_trunc('second', calendar_date) calendar_date FROM platform_db.fn_get_future_tradingdays(NOW()::timestamp without time zone, 4)) as order_expiry
		, ''::character varying as vendor_req, FALSE as consent_flag;
		
	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_modify_sip_mf_bkp_05sept2025(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_sip_mf_bkp_05sept2025(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_modify_sip_mf_bkp_05sept2025(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_modify_sip_mf_bkp_05sept2025(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_modify_sip_mf_bkp_05sept2025(varchar, varchar, varchar, int8, varchar, varchar, varchar, numeric, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_comm_log(int8, int4);

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_comm_log(v_trx_id bigint, v_temp_id integer)
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_values_placeholder character varying;

BEGIN

	IF NOT EXISTS(SELECT 1 FROM transactions.communication_log_details A WHERE A.categoryid = 261 AND A.trx_id = v_trx_id
					AND A.templateid = v_temp_id AND A.is_sent = 0 AND A.insert_date::date = current_date)
	THEN
	
		EXECUTE (CONCAT((SELECT comm.comm_sql_query FROM master.template_communication comm WHERE comm.templateid = v_temp_id)
				 ||v_trx_id))::character varying INTO v_values_placeholder;
		
		INSERT INTO transactions.communication_log_details
		(templateid, txn_type, trigger_point, trx_id, ac_code, is_sent, whatsappid, template_placeholders
		, values_placeholder, insert_date, modified_date, comm_mode, categoryid)
		SELECT v_temp_id, comm.txn_type, comm.trigger_point, v_trx_id, (SELECT trn.ac_code FROM transactions.mf_order_detail trn WHERE trn.trx_id = v_trx_id), 0
		, CASE WHEN UPPER(comm.comm_mode) = 'WHATSAPP' THEN comm.whatsapp_template_name ELSE NULL END::character varying
		, comm.comm_temp_headers, v_values_placeholder, NOW(), NOW(), comm.comm_mode, 261
		FROM master.template_communication comm WHERE comm.templateid = v_temp_id;
		
		RETURN 'SUCCESS';

	ELSE
		
		RETURN 'FAILURE Error :- Communiaction for trx_id already exists';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'FAILURE Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_comm_log(int8, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_comm_log(int8, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_comm_log(int8, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_comm_log(int8, int4) TO cmotsread;
GRANT ALL ON FUNCTION transactions.fn_post_mf_comm_log(int8, int4) TO appadmin;

-- DROP FUNCTION transactions.fn_post_mf_due_report();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_due_report()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

BEGIN

IF EXISTS(SELECT 1 FROM transactions.stg_dion_sip_due_report)
THEN

--DELETE FROM transactions.stg_dion_sip_due_report stg WHERE stg.internalrefno IS NULL;

DELETE FROM transactions.stg_dion_sip_due_report p1
WHERE EXISTS (SELECT 1 FROM transactions.stg_dion_sip_due_report p2
WHERE p2.internalrefno = p1.internalrefno AND p2.ctid < p1.ctid);

-- Check for rows with null values in mandatory columns
IF EXISTS (SELECT 1 FROM transactions.stg_dion_sip_due_report src 
LEFT JOIN master.dim_ucc du ON TRIM(src.clientcode) = du.priority_ac_code
WHERE du.priority_ac_code IS NULL OR src.duedate <= CURRENT_DATE) 
then

DELETE FROM transactions.mf_due_dates_error WHERE created_date >= NOW() - INTERVAL '7 days';

-- Insert into the error table
/*
INSERT INTO transactions.mf_due_dates_error(
ac_code,vendor_trx_id,reg_no,reg_date,upcoming_due_date, 
previous_paid_date,totalinstallmentamt_paid,totalinstallment_paid, 
mandate_id,created_date,error_message)
SELECT 
    src.clientcode AS ac_code, 
    --src.internalrefno::bigint AS vendor_trx_id, 
	NULL::bigint AS vendor_trx_id,
    src.sipregnnumber::bigint AS reg_no, 
    src.regndate AS reg_date,
    src.duedate AS upcoming_due_date, 
    src.prevpaiddate AS previous_paid_date, 
    src.totalinstallmentamtpaid AS totalinstallmentamt_paid,
    src.noofinstallmentspaid AS totalinstallment_paid, 
    src.mandateid AS mandate_id, 
    COALESCE(src.createdon, NOW()) AS created_date,
    CONCAT(
        COALESCE(CASE WHEN du.priority_ac_code IS NULL THEN 'priority_ac_code is NULL; ' ELSE NULL END, ''),
        COALESCE(CASE WHEN src.duedate < current_date THEN 'upcoming_due_date should be greater than current date; ' ELSE NULL END, ''),
        COALESCE(CASE WHEN src.duedate IS NULL THEN 'DUE_DATE is NULL; ' ELSE NULL END, '')
    ) AS error_message
FROM transactions.stg_dion_sip_due_report src
LEFT JOIN master.dim_ucc du ON src.clientcode = du.priority_ac_code 
WHERE (du.priority_ac_code IS NULL OR src.duedate IS NULL OR src.duedate < current_date)
  AND src.internalrefno IS NOT NULL
ON CONFLICT (vendor_trx_id) DO UPDATE SET 
    ac_code = EXCLUDED.ac_code,
    reg_no = EXCLUDED.reg_no,
    reg_date = EXCLUDED.reg_date,
    upcoming_due_date = EXCLUDED.upcoming_due_date,
    previous_paid_date = EXCLUDED.previous_paid_date,
    totalinstallmentamt_paid = EXCLUDED.totalinstallmentamt_paid,
    totalinstallment_paid = EXCLUDED.totalinstallment_paid,
    mandate_id = EXCLUDED.mandate_id,
    created_date = EXCLUDED.created_date,
    error_message = EXCLUDED.error_message;
*/

END IF;

TRUNCATE TABLE transactions.mf_due_dates RESTART IDENTITY;

INSERT INTO transactions.mf_due_dates
(ac_code,vendor_trx_id,reg_no,reg_date,upcoming_due_date,previous_paid_date, 
totalinstallmentamt_paid,totalinstallment_paid,mandate_id,created_date
,modified_date)

select 
ucc.priority_ac_code as ac_code, mf.vendor_trx_id, src.sipregnnumber::bigint as reg_no, 
src.regndate as reg_date,src.duedate as upcoming_due_date,
src.prevpaiddate as previous_paid_date, 
src.totalinstallmentamtpaid as totalinstallmentamt_paid, 
src.noofinstallmentspaid as totalinstallment_paid,
src.mandateid as mandate_id, src.createdon created_date
, (NOW() at time zone 'Asia/Kolkata') as modified_date
from transactions.stg_dion_sip_due_report src
JOIN master.dim_ucc ucc ON trim(src.clientcode) = ucc.priority_ac_code
join transactions.mf_order_summary mf on src.sipregnnumber:: bigint = mf.reg_no
WHERE src.duedate >= current_date;

/*
CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
SELECT destn.id FROM transactions.mf_order_summary destn JOIN transactions.mf_due_dates src ON src.vendor_trx_id = destn.vendor_trx_id AND src.reg_no = destn.reg_no
WHERE (COALESCE(src.upcoming_due_date,'1900-01-01') <> COALESCE(destn.upcoming_due_date,'1900-01-01') OR
COALESCE(src.previous_paid_date,'1900-01-01') <> COALESCE(destn.previous_paid_date,'1900-01-01') OR
COALESCE(src.totalinstallment_paid,0) <> COALESCE(destn.totalinstallment_paid,0) OR
COALESCE(src.totalinstallmentamt_paid,0) <> COALESCE(destn.totalinstallmentamt_paid,0));
*/
----------------Update Summary detail 
UPDATE transactions.mf_order_summary destn SET
upcoming_due_date = CASE WHEN COALESCE(src.upcoming_due_date,'1900-01-01') <> COALESCE(destn.upcoming_due_date,'1900-01-01') THEN src.upcoming_due_date ELSE destn.upcoming_due_date END
, previous_paid_date = CASE WHEN COALESCE(src.previous_paid_date,'1900-01-01') <> COALESCE(destn.previous_paid_date,'1900-01-01') THEN src.previous_paid_date ELSE destn.previous_paid_date END
, totalinstallmentamt_paid = CASE WHEN COALESCE(src.totalinstallmentamt_paid,0) <> COALESCE(destn.totalinstallmentamt_paid,0) THEN src.totalinstallmentamt_paid ELSE destn.totalinstallmentamt_paid END
, totalinstallment_paid = CASE WHEN COALESCE(src.totalinstallment_paid,0) <> COALESCE(destn.totalinstallment_paid,0) THEN src.totalinstallment_paid ELSE destn.totalinstallment_paid END
FROM transactions.mf_due_dates src
WHERE src.vendor_trx_id = destn.vendor_trx_id AND src.reg_no = destn.reg_no AND
(COALESCE(src.upcoming_due_date,'1900-01-01') <> COALESCE(destn.upcoming_due_date,'1900-01-01') OR
COALESCE(src.previous_paid_date,'1900-01-01') <> COALESCE(destn.previous_paid_date,'1900-01-01') OR
COALESCE(src.totalinstallment_paid,0) <> COALESCE(destn.totalinstallment_paid,0) OR
COALESCE(src.totalinstallmentamt_paid,0) <> COALESCE(destn.totalinstallmentamt_paid,0));

----------------Update Summary detail for paused orders
UPDATE transactions.mf_order_summary destn SET
upcoming_due_date = CASE WHEN COALESCE(src.installment_date_post_pause_resume,'1900-01-01') <> COALESCE(destn.upcoming_due_date,'1900-01-01') THEN src.installment_date_post_pause_resume ELSE destn.upcoming_due_date END
FROM transactions.mf_order_detail_modification src
WHERE src.org_trx_id = destn.trx_id AND src.inv_action_code = 2 AND destn.ispaused = 1 AND
COALESCE(src.installment_date_post_pause_resume,'1900-01-01') <> COALESCE(destn.upcoming_due_date,'1900-01-01');

/*
----------Inserting Data into transaction History Table----------
UPDATE transactions.mf_order_summary_history
SET valid_to = NOW(), is_active = false
WHERE id IN (SELECT id FROM temp_mf_trx) AND is_active = true;

INSERT INTO transactions.mf_order_summary_history
(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
, previous_paid_date, totalinstallmentamt_paid, totalinstallment_paid, switch_isin, trx_status_code, valid_from, is_active)		
SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
, A.previous_paid_date, A.totalinstallmentamt_paid, A.totalinstallment_paid, A.switch_isin, A.trx_status_code, NOW(), true
FROM transactions.mf_order_summary A WHERE A.id IN (SELECT id FROM temp_mf_trx);

UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
*/

--DROP TABLE temp_mf_trx; 

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;

EXCEPTION
WHEN OTHERS THEN
BEGIN

RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_due_report() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_due_report() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_due_report() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_due_report() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_due_report() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_due_report_bkp_13may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_due_report_bkp_13may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

BEGIN

IF EXISTS(SELECT 1 FROM transactions.stg_dion_sip_due_report)
THEN

DELETE FROM transactions.stg_dion_sip_due_report stg WHERE stg.internalrefno IS NULL;

DELETE FROM transactions.stg_dion_sip_due_report p1
WHERE EXISTS (SELECT 1 FROM transactions.stg_dion_sip_due_report p2
WHERE p2.internalrefno = p1.internalrefno AND p2.ctid < p1.ctid);

-- Check for rows with null values in mandatory columns
IF EXISTS (SELECT 1 FROM transactions.stg_dion_sip_due_report src 
LEFT JOIN master.dim_ucc du ON TRIM(src.clientcode) = du.priority_ac_code
WHERE du.priority_ac_code IS NULL OR src.duedate <= CURRENT_DATE) 
then

DELETE FROM transactions.mf_due_dates_error WHERE created_date >= NOW() - INTERVAL '7 days';

-- Insert into the error table
INSERT INTO transactions.mf_due_dates_error(
ac_code,vendor_trx_id,reg_no,reg_date,upcoming_due_date, 
previous_paid_date,totalinstallmentamt_paid,totalinstallment_paid, 
mandate_id,created_date,error_message)
SELECT 
    src.clientcode AS ac_code, 
    src.internalrefno::bigint AS vendor_trx_id, 
    src.sipregnnumber::bigint AS reg_no, 
    src.regndate AS reg_date,
    src.duedate AS upcoming_due_date, 
    src.prevpaiddate AS previous_paid_date, 
    src.totalinstallmentamtpaid AS totalinstallmentamt_paid,
    src.noofinstallmentspaid AS totalinstallment_paid, 
    src.mandateid AS mandate_id, 
    COALESCE(src.createdon, NOW()) AS created_date,
    CONCAT(
        COALESCE(CASE WHEN du.priority_ac_code IS NULL THEN 'priority_ac_code is NULL; ' ELSE NULL END, ''),
        COALESCE(CASE WHEN src.duedate < current_date THEN 'upcoming_due_date should be greater than current date; ' ELSE NULL END, ''),
        COALESCE(CASE WHEN src.duedate IS NULL THEN 'DUE_DATE is NULL; ' ELSE NULL END, '')
    ) AS error_message
FROM transactions.stg_dion_sip_due_report src
LEFT JOIN master.dim_ucc du ON src.clientcode = du.priority_ac_code 
WHERE (du.priority_ac_code IS NULL OR src.duedate IS NULL OR src.duedate < current_date)
  AND src.internalrefno IS NOT NULL
ON CONFLICT (vendor_trx_id) DO UPDATE SET 
    ac_code = EXCLUDED.ac_code,
    reg_no = EXCLUDED.reg_no,
    reg_date = EXCLUDED.reg_date,
    upcoming_due_date = EXCLUDED.upcoming_due_date,
    previous_paid_date = EXCLUDED.previous_paid_date,
    totalinstallmentamt_paid = EXCLUDED.totalinstallmentamt_paid,
    totalinstallment_paid = EXCLUDED.totalinstallment_paid,
    mandate_id = EXCLUDED.mandate_id,
    created_date = EXCLUDED.created_date,
    error_message = EXCLUDED.error_message;

END IF;

TRUNCATE TABLE transactions.mf_due_dates RESTART IDENTITY;

INSERT INTO transactions.mf_due_dates
(ac_code,vendor_trx_id,reg_no,reg_date,upcoming_due_date,previous_paid_date, 
totalinstallmentamt_paid,totalinstallment_paid,mandate_id,created_date
,modified_date)

select 
ucc.priority_ac_code as ac_code, mf.vendor_trx_id, src.sipregnnumber::bigint as reg_no, 
src.regndate as reg_date,src.duedate as upcoming_due_date,
src.prevpaiddate as previous_paid_date, 
src.totalinstallmentamtpaid as totalinstallmentamt_paid, 
src.noofinstallmentspaid as totalinstallment_paid,
src.mandateid as mandate_id, src.createdon created_date
, now() as modified_date
from transactions.stg_dion_sip_due_report src
JOIN master.dim_ucc ucc ON trim(src.clientcode) = ucc.priority_ac_code
join transactions.mf_order_summary mf on src.sipregnnumber:: bigint = mf.reg_no
WHERE src.duedate >= current_date;

/*
CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
SELECT destn.id FROM transactions.mf_order_summary destn JOIN transactions.mf_due_dates src ON src.vendor_trx_id = destn.vendor_trx_id AND src.reg_no = destn.reg_no
WHERE (COALESCE(src.upcoming_due_date,'1900-01-01') <> COALESCE(destn.upcoming_due_date,'1900-01-01') OR
COALESCE(src.previous_paid_date,'1900-01-01') <> COALESCE(destn.previous_paid_date,'1900-01-01') OR
COALESCE(src.totalinstallment_paid,0) <> COALESCE(destn.totalinstallment_paid,0) OR
COALESCE(src.totalinstallmentamt_paid,0) <> COALESCE(destn.totalinstallmentamt_paid,0));
*/
----------------Update Summary detail 
UPDATE transactions.mf_order_summary destn SET
upcoming_due_date = CASE WHEN COALESCE(src.upcoming_due_date,'1900-01-01') <> COALESCE(destn.upcoming_due_date,'1900-01-01') THEN src.upcoming_due_date ELSE destn.upcoming_due_date END
, previous_paid_date = CASE WHEN COALESCE(src.previous_paid_date,'1900-01-01') <> COALESCE(destn.previous_paid_date,'1900-01-01') THEN src.previous_paid_date ELSE destn.previous_paid_date END
, totalinstallmentamt_paid = CASE WHEN COALESCE(src.totalinstallmentamt_paid,0) <> COALESCE(destn.totalinstallmentamt_paid,0) THEN src.totalinstallmentamt_paid ELSE destn.totalinstallmentamt_paid END
, totalinstallment_paid = CASE WHEN COALESCE(src.totalinstallment_paid,0) <> COALESCE(destn.totalinstallment_paid,0) THEN src.totalinstallment_paid ELSE destn.totalinstallment_paid END
FROM transactions.mf_due_dates src
WHERE src.vendor_trx_id = destn.vendor_trx_id AND src.reg_no = destn.reg_no AND
(COALESCE(src.upcoming_due_date,'1900-01-01') <> COALESCE(destn.upcoming_due_date,'1900-01-01') OR
COALESCE(src.previous_paid_date,'1900-01-01') <> COALESCE(destn.previous_paid_date,'1900-01-01') OR
COALESCE(src.totalinstallment_paid,0) <> COALESCE(destn.totalinstallment_paid,0) OR
COALESCE(src.totalinstallmentamt_paid,0) <> COALESCE(destn.totalinstallmentamt_paid,0));

/*
----------Inserting Data into transaction History Table----------
UPDATE transactions.mf_order_summary_history
SET valid_to = NOW(), is_active = false
WHERE id IN (SELECT id FROM temp_mf_trx) AND is_active = true;

INSERT INTO transactions.mf_order_summary_history
(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
, previous_paid_date, totalinstallmentamt_paid, totalinstallment_paid, switch_isin, trx_status_code, valid_from, is_active)		
SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
, A.previous_paid_date, A.totalinstallmentamt_paid, A.totalinstallment_paid, A.switch_isin, A.trx_status_code, NOW(), true
FROM transactions.mf_order_summary A WHERE A.id IN (SELECT id FROM temp_mf_trx);

UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
*/

--DROP TABLE temp_mf_trx; 

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;

EXCEPTION
WHEN OTHERS THEN
BEGIN

RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_due_report_bkp_13may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_due_report_bkp_13may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_due_report_bkp_13may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_due_report_bkp_13may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_due_report_bkp_13may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_mandate();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_mandate()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

BEGIN

-- Check for rows with null values in mandatory columns
IF EXISTS (SELECT 1 FROM transactions.stg_dion_mandate) 
THEN

-- Delete Duplicates from existing stage table
DELETE FROM transactions.stg_dion_mandate t1
WHERE EXISTS (SELECT * FROM transactions.stg_dion_mandate t2
WHERE t1.mandateid = t2.mandateid AND t1.ctid > t2.ctid);

DELETE FROM transactions.mf_mandate_error WHERE created_date >= NOW() - INTERVAL '7 days';

-- Insert into the error table
INSERT INTO transactions.mf_mandate_error(
mandateid,ac_code,amount,bankname,mandate_type,status,created_date,
modified_date,bank_ac_number,ifsc_code,start_date,end_date,trx_source, 
ucccode,acname,client_owner,partner_code,upccode,error_message)

SELECT DISTINCT
src.mandateid,src.clientcode,src.amount,src.bankname,
cast(src.mandatetype as character varying(1)) as mandatetype ,src.status,
src.createdon::timestamp without time zone AS created_date,
src.updatedon::timestamp without time zone AS modified_date,
src.accountnumber,src.ifsccode,src.createdon, 
(src.createdon + INTERVAL '30 Years')::date AS end_date,'DION' AS trx_source,
du.ucccode,du.acname,du.client_owner,du.partner_code,du.upccode,
CONCAT(
CASE WHEN src.mandateid IS NULL THEN 'mandateid is NULL; ' ELSE '' END,
CASE WHEN src.accountnumber IS NULL THEN 'bank accountnumber is NULL; ' ELSE '' END,
CASE WHEN src.mandatetype IS NULL THEN 'mandatetype is NULL; ' ELSE '' end,
CASE WHEN du.priority_ac_code IS NULL THEN 'Not found in dim_ucc table; ' ELSE '' END,
CASE WHEN src.createdon IS NULL THEN 'Start date not available; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_mandate src
LEFT JOIN master.dim_ucc du ON TRIM(UPPER(src.clientcode)) = TRIM(UPPER(du.priority_ac_code))
WHERE src.accountnumber IS NULL OR src.mandatetype IS NULL OR du.priority_ac_code IS null OR src.createdon is  null
ON CONFLICT (mandateid) DO UPDATE
SET 
ac_code = EXCLUDED.ac_code,
amount = EXCLUDED.amount,
bankname = EXCLUDED.bankname,
mandate_type = EXCLUDED.mandate_type,
status = EXCLUDED.status,
created_date = EXCLUDED.created_date,
modified_date = EXCLUDED.modified_date,
bank_ac_number = EXCLUDED.bank_ac_number,
ifsc_code = EXCLUDED.ifsc_code,
start_date = EXCLUDED.start_date,
end_date = EXCLUDED.end_date,
trx_source = EXCLUDED.trx_source,
ucccode = EXCLUDED.ucccode,
acname = EXCLUDED.acname,
client_owner = EXCLUDED.client_owner,
partner_code = EXCLUDED.partner_code,
upccode = EXCLUDED.upccode,
error_message = EXCLUDED.error_message;

---------------------------------------------------------------------------  
------------------------------------------
--/* commuication
--Part-1
insert into transactions.communication_mailer_mst(
producttype,ordertype,clientcode,clientname,orderdate,amount,
rejection_reason,bankname,bankacno,sourceid,subcategoryid,
subcategory,is_picked,mandateid,mandate_mode
)
	
select 
'Mutual Fund'::character varying as producttype,
'Mandate'::character varying as ordertype,
src.clientcode,ucc.acname as clientname,dest.created_date as orderdate,
dest.amount,
src.remarks as rejection_reason,
dest.bankname,dest.bank_ac_number as bankacno,
'82'::character varying as sourceid,
(case 
when dest.mandate_type in ('E','N') and upper(src.status)='APPROVED' then '3554'
when dest.mandate_type in ('E','N') and upper(src.status)='REJECTED' then '3555'
when dest.mandate_type in ('X') and upper(src.status)='REGISTERED BY MEMBER' then '3566'
when dest.mandate_type in ('X') and upper(src.status)='APPROVED' then '3568'
when dest.mandate_type in ('X') and upper(src.status)='REJECTED' then '3570'
else '' end)::character varying as subcategoryid,
(case 
when dest.mandate_type in ('E','N') and upper(src.status)='APPROVED' then 'EMANDATE_APPROVED_INTERNAL'
when dest.mandate_type in ('E','N') and upper(src.status)='REJECTED' then 'EMANDATE_REJECTED_CLIENT_INTERNAL'
when dest.mandate_type in ('X') and upper(src.status)='REGISTERED BY MEMBER' then 'XSIP_PHYSCIAL_MANDATE_CREATION_CLIENT_NEW_INTERNAL'
when dest.mandate_type in ('X') and upper(src.status)='APPROVED' then 'XSIP_PHYSICAL_MANDATE_APPROVED_NOSIP_NEW_INTERNAL'
when dest.mandate_type in ('X') and upper(src.status)='REJECTED' then 'XSIP_PHYSICAL_MANDATE_REJECTED_CLIENT_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked,
dest.mandateid,
mst.internal_type as mandate_mode
from transactions.mf_mandate dest 
join transactions.stg_dion_mandate src 
on dest.mandateid = src.mandateid
and dest.ac_code = src.clientcode
--and dest.mandate_type=src.mandatetype
join master.mandate_type mst
on dest.mandate_type= mst.mandate_type
join master.dim_ucc ucc on ucc.priority_ac_code=src.clientcode
where coalesce(dest.status,'') <> coalesce(src.status,'')
and upper(src.status) in ('REJECTED','APPROVED','REGISTERED BY MEMBER');

----------------------Part-2
insert into transactions.communication_mailer_mst(
producttype,ordertype,clientcode,clientname,orderdate,amount,
rejection_reason,bankname,bankacno,sourceid,subcategoryid,
subcategory,is_picked,mandateid,mandate_mode
)
	
select 
'Mutual Fund'::character varying as producttype,
'Mandate'::character varying as ordertype,
src.clientcode,ucc.acname as clientname,dest.created_date as orderdate,
dest.amount,
src.remarks as rejection_reason,
dest.bankname,dest.bank_ac_number as bankacno,
'82'::character varying as sourceid,
(case 
when dest.mandate_type in ('X') and upper(src.status) in 
('SCAN IMAGE NOT UPLOADED','WAITING FOR CLIENT AUTHENTICATION') then '3562'
else '' end)::character varying as subcategoryid,
(case 
when dest.mandate_type in ('X') and upper(src.status) in 
('SCAN IMAGE NOT UPLOADED','WAITING FOR CLIENT AUTHENTICATION') 
then 'XSIP_MANDATE_DOC_NOT_SUBMITTED_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked,
dest.mandateid,
mst.internal_type as mandate_mode
from transactions.mf_mandate dest 
join transactions.stg_dion_mandate src 
on dest.mandateid = src.mandateid
and dest.ac_code = src.clientcode
--and dest.mandate_type=src.mandatetype
join master.mandate_type mst
on dest.mandate_type = mst.mandate_type
join master.dim_ucc ucc on ucc.priority_ac_code=src.clientcode
where src.createdon =CURRENT_DATE - INTERVAL '2 day'
and coalesce(dest.status,'') <> coalesce(src.status,'')
and upper(src.status) in ('SCAN IMAGE NOT UPLOADED','WAITING FOR CLIENT AUTHENTICATION')
and src.mandatetype::character varying(1) in ('X');

----------------------Part-3
insert into transactions.communication_mailer_mst(
producttype,ordertype,clientcode,clientname,orderdate,amount,
rejection_reason,bankname,bankacno,sourceid,subcategoryid,
subcategory,is_picked,mandateid,mandate_mode
)
	
select 
'Mutual Fund'::character varying as producttype,
'Mandate'::character varying as ordertype,
src.clientcode,ucc.acname as clientname,dest.created_date as orderdate,
dest.amount,src.remarks as rejection_reason,
dest.bankname,dest.bank_ac_number as bankacno,
'82'::character varying as sourceid,
(case 
when dest.mandate_type in ('E','N') and upper(src.status) in 
('REGISTERED BY MEMBER','WAITING FOR CLIENT AUTHENTICATION') then '3557'
else '' end)::character varying as subcategoryid,
(case 
when dest.mandate_type in ('E','N') and upper(src.status) in 
('REGISTERED BY MEMBER','WAITING FOR CLIENT AUTHENTICATION') 
then 'EMANDATE_TRANSACTIONAL_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked,dest.mandateid,
mst.internal_type as mandate_mode
from transactions.mf_mandate dest 
join transactions.stg_dion_mandate src 
on dest.mandateid = src.mandateid
and dest.ac_code = src.clientcode
--and dest.mandate_type=src.mandatetype
join master.mandate_type mst on dest.mandate_type = mst.mandate_type
join master.dim_ucc ucc on ucc.priority_ac_code=src.clientcode
left join transactions.communication_mailer_mst com
on com.mandateid = src.mandateid and com.clientcode = src.clientcode
--and com.subcategoryid = 2863
where (NOW() at time zone 'Asia/Kolkata')>= (src.createdon + INTERVAL '1 day')
and coalesce(dest.status,'') = coalesce(src.status,'')
and upper(src.status) in ('REGISTERED BY MEMBER','WAITING FOR CLIENT AUTHENTICATION')
and src.mandatetype::character varying(1) in ('E','N')
and src.remarks is null and com.mandateid is null 
and src.createdon>= (NOW() at time zone 'Asia/Kolkata' - INTERVAL '2 day');
--and src.mandateid='50384695'

--*/
------------------------------------------
----------------------------------------------------------------------------

-------Update existing Mandateid
UPDATE transactions.mf_mandate a
SET 
    status = src.status, 
    modified_date = src.updatedon::timestamp without time zone,
    start_date = src.createdon::timestamp without time zone, 
    end_date = (src.createdon + INTERVAL '30 Years')::date, 
    remarks = src.remarks
FROM transactions.stg_dion_mandate src
WHERE a.mandateid = src.mandateid;

-------Insert New Mandateid
INSERT INTO transactions.mf_mandate(
mandateid,ac_code,amount,bankname,mandate_type,status,created_date,
modified_date,bank_ac_number,ifsc_code,start_date,end_date,trx_source,
ucccode,acname,client_owner,partner_code,upccode,remarks)

SELECT DISTINCT
src.mandateid, src.clientcode as ac_code, src.amount, src.bankname, 
cast(src.mandatetype as character varying(1)) as mandatetype , src.status,
src.createdon::timestamp without time zone AS created_date,
src.updatedon::timestamp without time zone AS modified_date,
src.accountnumber,src.ifsccode,src.createdon, 
(src.createdon + INTERVAL '30 Years')::date AS end_date,
'DION' AS trx_source, du.ucccode,du.acname,du.client_owner,
du.partner_code,du.upccode,src.remarks
from transactions.stg_dion_mandate src
left join transactions.mf_mandate main on src.mandateid =  main.mandateid
join master.dim_ucc du ON  TRIM(UPPER(src.clientcode)) = TRIM(UPPER(du.priority_ac_code))
where main.mandateid is null
and src.mandateid IS NOT NULL AND src.accountnumber IS NOT NULL 
and src.mandatetype IS NOT NULL AND du.priority_ac_code IS NOT NULL
and src.createdon is not null;

------------------------------------------
--insert updation or new details in mandate history

insert into transactions.mf_mandate_history(
mandateid,ucccode,ac_code,mandate_type,status,remarks,
start_date,end_date,created_date,modified_date
)

select 
a.mandateid,a.ucccode,a.ac_code,a.mandate_type,a.status,a.remarks,
a.start_date,a.end_date,a.created_date,a.modified_date
from transactions.mf_mandate a
left join transactions.mf_mandate_history b
on a.mandateid = b.mandateid
where b.mandateid is null ;

----Chnage in mandate status
insert into transactions.mf_mandate_history(
mandateid,ucccode,ac_code,mandate_type,status,remarks,
start_date,end_date,created_date,modified_date
)
select 
a.mandateid,a.ucccode,a.ac_code,a.mandate_type,a.status,a.remarks,
a.start_date,a.end_date,a.created_date,a.modified_date
from transactions.mf_mandate a
left join 
(
--select * from transactions.mf_mandate_history
select mandateid,ac_code,mandate_type,status,remarks
from (
    select *, 
           row_number() over (partition by ac_code,mandateid,mandate_type order by hist_id desc) as rn
    FROM transactions.mf_mandate_history
--	where mandateid in('47767304','48210854')
) t
where rn = 1
)b
on a.mandateid = b.mandateid
where 
(
coalesce(a.mandate_type,'') <> coalesce(b.mandate_type,'')
or coalesce(a.status,'') <> coalesce(b.status,'')
or coalesce(a.remarks,'') <> coalesce(b.remarks,'')
);

----delete duplicate record
WITH cte AS (
    SELECT hist_id, -- Include the primary key or unique identifier
           ROW_NUMBER() OVER (
               PARTITION BY mandateid, ac_code, mandate_type, status, remarks 
               ORDER BY hist_id desc -- Keep the oldest record, delete newer duplicates
           ) AS rn
    FROM transactions.mf_mandate_history
--where mandateid='47767304'
)
DELETE FROM transactions.mf_mandate_history
WHERE hist_id IN (SELECT hist_id FROM cte WHERE rn > 1);

RETURN 'SUCCESS';
ELSE  
RETURN 'No Data in Staging Table';
END IF;

EXCEPTION
WHEN OTHERS THEN
BEGIN
RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_mandate() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_mandate_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_mandate_bkp_09may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

BEGIN

-- Check for rows with null values in mandatory columns
IF EXISTS (SELECT 1 FROM transactions.stg_dion_mandate) 
THEN

-- Delete Duplicates from existing stage table
DELETE FROM transactions.stg_dion_mandate t1
WHERE EXISTS (SELECT * FROM transactions.stg_dion_mandate t2
WHERE t1.mandateid = t2.mandateid AND t1.ctid > t2.ctid);

DELETE FROM transactions.mf_mandate_error WHERE created_date >= NOW() - INTERVAL '7 days';

-- Insert into the error table
INSERT INTO transactions.mf_mandate_error(
mandateid,ac_code,amount,bankname,mandate_type,status,created_date,
modified_date,bank_ac_number,ifsc_code,start_date,end_date,trx_source, 
ucccode,acname,client_owner,partner_code,upccode,error_message)

SELECT DISTINCT
src.mandateid,src.clientcode,src.amount,src.bankname,
cast(src.mandatetype as character varying(1)) as mandatetype ,src.status,
src.createdon::timestamp without time zone AS created_date,
src.updatedon::timestamp without time zone AS modified_date,
src.accountnumber,src.ifsccode,src.createdon, 
(src.createdon + INTERVAL '30 Years')::date AS end_date,'DION' AS trx_source,
du.ucccode,du.acname,du.client_owner,du.partner_code,du.upccode,
CONCAT(
CASE WHEN src.mandateid IS NULL THEN 'mandateid is NULL; ' ELSE '' END,
CASE WHEN src.accountnumber IS NULL THEN 'bank accountnumber is NULL; ' ELSE '' END,
CASE WHEN src.mandatetype IS NULL THEN 'mandatetype is NULL; ' ELSE '' end,
CASE WHEN du.priority_ac_code IS NULL THEN 'Not found in dim_ucc table; ' ELSE '' END,
CASE WHEN src.createdon IS NULL THEN 'Start date not available; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_mandate src
LEFT JOIN master.dim_ucc du ON TRIM(UPPER(src.clientcode)) = TRIM(UPPER(du.priority_ac_code))
WHERE src.accountnumber IS NULL OR src.mandatetype IS NULL OR du.priority_ac_code IS null OR src.createdon is  null
ON CONFLICT (mandateid) DO UPDATE
SET 
ac_code = EXCLUDED.ac_code,
amount = EXCLUDED.amount,
bankname = EXCLUDED.bankname,
mandate_type = EXCLUDED.mandate_type,
status = EXCLUDED.status,
created_date = EXCLUDED.created_date,
modified_date = EXCLUDED.modified_date,
bank_ac_number = EXCLUDED.bank_ac_number,
ifsc_code = EXCLUDED.ifsc_code,
start_date = EXCLUDED.start_date,
end_date = EXCLUDED.end_date,
trx_source = EXCLUDED.trx_source,
ucccode = EXCLUDED.ucccode,
acname = EXCLUDED.acname,
client_owner = EXCLUDED.client_owner,
partner_code = EXCLUDED.partner_code,
upccode = EXCLUDED.upccode,
error_message = EXCLUDED.error_message;

---------------------------------------------------------------------------  
------------------------------------------
--/* commuication
--Part-1
insert into transactions.communication_mailer_mst(
producttype,ordertype,clientcode,clientname,orderdate,amount,
rejection_reason,bankname,bankacno,sourceid,subcategoryid,
subcategory,is_picked,mandateid,mandate_mode
)
	
select 
'Mutual Fund'::character varying as producttype,
'Mandate'::character varying as ordertype,
src.clientcode,ucc.acname as clientname,dest.created_date as orderdate,
dest.amount,
src.remarks as rejection_reason,
dest.bankname,dest.bank_ac_number as bankacno,
'82'::character varying as sourceid,
(case 
when dest.mandate_type in ('E','N') and upper(src.status)='APPROVED' then '3554'
when dest.mandate_type in ('E','N') and upper(src.status)='REJECTED' then '3555'
when dest.mandate_type in ('X') and upper(src.status)='REGISTERED BY MEMBER' then '3566'
when dest.mandate_type in ('X') and upper(src.status)='APPROVED' then '3568'
when dest.mandate_type in ('X') and upper(src.status)='REJECTED' then '3570'
else '' end)::character varying as subcategoryid,
(case 
when dest.mandate_type in ('E','N') and upper(src.status)='APPROVED' then 'EMANDATE_APPROVED_INTERNAL'
when dest.mandate_type in ('E','N') and upper(src.status)='REJECTED' then 'EMANDATE_REJECTED_CLIENT_INTERNAL'
when dest.mandate_type in ('X') and upper(src.status)='REGISTERED BY MEMBER' then 'XSIP_PHYSCIAL_MANDATE_CREATION_CLIENT_NEW_INTERNAL'
when dest.mandate_type in ('X') and upper(src.status)='APPROVED' then 'XSIP_PHYSICAL_MANDATE_APPROVED_NOSIP_NEW_INTERNAL'
when dest.mandate_type in ('X') and upper(src.status)='REJECTED' then 'XSIP_PHYSICAL_MANDATE_REJECTED_CLIENT_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked,
dest.mandateid,
mst.internal_type as mandate_mode
from transactions.mf_mandate dest 
join transactions.stg_dion_mandate src 
on dest.mandateid = src.mandateid
and dest.ac_code = src.clientcode
--and dest.mandate_type=src.mandatetype
join master.mandate_type mst
on dest.mandate_type= mst.mandate_type
join master.dim_ucc ucc on ucc.priority_ac_code=src.clientcode
where coalesce(dest.status,'') <> coalesce(src.status,'')
and upper(src.status) in ('REJECTED','APPROVED','REGISTERED BY MEMBER');

----------------------Part-2
insert into transactions.communication_mailer_mst(
producttype,ordertype,clientcode,clientname,orderdate,amount,
rejection_reason,bankname,bankacno,sourceid,subcategoryid,
subcategory,is_picked,mandateid,mandate_mode
)
	
select 
'Mutual Fund'::character varying as producttype,
'Mandate'::character varying as ordertype,
src.clientcode,ucc.acname as clientname,dest.created_date as orderdate,
dest.amount,
src.remarks as rejection_reason,
dest.bankname,dest.bank_ac_number as bankacno,
'54'::character varying as sourceid,
(case 
when dest.mandate_type in ('X') and upper(src.status) in 
('SCAN IMAGE NOT UPLOADED','WAITING FOR CLIENT AUTHENTICATION') then '3562'
else '' end)::character varying as subcategoryid,
(case 
when dest.mandate_type in ('X') and upper(src.status) in 
('SCAN IMAGE NOT UPLOADED','WAITING FOR CLIENT AUTHENTICATION') 
then 'XSIP_MANDATE_DOC_NOT_SUBMITTED_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked,
dest.mandateid,
mst.internal_type as mandate_mode
from transactions.mf_mandate dest 
join transactions.stg_dion_mandate src 
on dest.mandateid = src.mandateid
and dest.ac_code = src.clientcode
--and dest.mandate_type=src.mandatetype
join master.mandate_type mst
on dest.mandate_type = mst.mandate_type
join master.dim_ucc ucc on ucc.priority_ac_code=src.clientcode
where src.createdon =CURRENT_DATE - INTERVAL '2 day'
and coalesce(dest.status,'') <> coalesce(src.status,'')
and upper(src.status) in ('SCAN IMAGE NOT UPLOADED','WAITING FOR CLIENT AUTHENTICATION')
and src.mandatetype::character varying(1) in ('X');
--*/
------------------------------------------
----------------------------------------------------------------------------

-------Update existing Mandateid
UPDATE transactions.mf_mandate a
SET 
    status = src.status, 
    modified_date = src.updatedon::timestamp without time zone,
    start_date = src.createdon::timestamp without time zone, 
    end_date = (src.createdon + INTERVAL '30 Years')::date, 
    remarks = src.remarks
FROM transactions.stg_dion_mandate src
WHERE a.mandateid = src.mandateid;

-------Insert New Mandateid
INSERT INTO transactions.mf_mandate(
mandateid,ac_code,amount,bankname,mandate_type,status,created_date,
modified_date,bank_ac_number,ifsc_code,start_date,end_date,trx_source,
ucccode,acname,client_owner,partner_code,upccode,remarks)

SELECT DISTINCT
src.mandateid, src.clientcode as ac_code, src.amount, src.bankname, 
cast(src.mandatetype as character varying(1)) as mandatetype , src.status,
src.createdon::timestamp without time zone AS created_date,
src.updatedon::timestamp without time zone AS modified_date,
src.accountnumber,src.ifsccode,src.createdon, 
(src.createdon + INTERVAL '30 Years')::date AS end_date,
'DION' AS trx_source, du.ucccode,du.acname,du.client_owner,
du.partner_code,du.upccode,src.remarks
from transactions.stg_dion_mandate src
left join transactions.mf_mandate main on src.mandateid =  main.mandateid
join master.dim_ucc du ON  TRIM(UPPER(src.clientcode)) = TRIM(UPPER(du.priority_ac_code))
where main.mandateid is null
and src.mandateid IS NOT NULL AND src.accountnumber IS NOT NULL 
and src.mandatetype IS NOT NULL AND du.priority_ac_code IS NOT NULL
and src.createdon is not null;

------------------------------------------
--insert updation or new details in mandate history

insert into transactions.mf_mandate_history(
mandateid,ucccode,ac_code,mandate_type,status,remarks,
start_date,end_date,created_date,modified_date
)

select 
a.mandateid,a.ucccode,a.ac_code,a.mandate_type,a.status,a.remarks,
a.start_date,a.end_date,a.created_date,a.modified_date
from transactions.mf_mandate a
left join transactions.mf_mandate_history b
on a.mandateid = b.mandateid
where b.mandateid is null ;

----Chnage in mandate status
insert into transactions.mf_mandate_history(
mandateid,ucccode,ac_code,mandate_type,status,remarks,
start_date,end_date,created_date,modified_date
)
select 
a.mandateid,a.ucccode,a.ac_code,a.mandate_type,a.status,a.remarks,
a.start_date,a.end_date,a.created_date,a.modified_date
from transactions.mf_mandate a
left join 
(
--select * from transactions.mf_mandate_history
select mandateid,ac_code,mandate_type,status,remarks
from (
    select *, 
           row_number() over (partition by ac_code,mandateid,mandate_type order by hist_id desc) as rn
    FROM transactions.mf_mandate_history
--	where mandateid in('47767304','48210854')
) t
where rn = 1
)b
on a.mandateid = b.mandateid
where 
(
coalesce(a.mandate_type,'') <> coalesce(b.mandate_type,'')
or coalesce(a.status,'') <> coalesce(b.status,'')
or coalesce(a.remarks,'') <> coalesce(b.remarks,'')
);

----delete duplicate record
WITH cte AS (
    SELECT hist_id, -- Include the primary key or unique identifier
           ROW_NUMBER() OVER (
               PARTITION BY mandateid, ac_code, mandate_type, status, remarks 
               ORDER BY hist_id desc -- Keep the oldest record, delete newer duplicates
           ) AS rn
    FROM transactions.mf_mandate_history
--where mandateid='47767304'
)
DELETE FROM transactions.mf_mandate_history
WHERE hist_id IN (SELECT hist_id FROM cte WHERE rn > 1);

RETURN 'SUCCESS';
ELSE  
RETURN 'No Data in Staging Table';
END IF;

EXCEPTION
WHEN OTHERS THEN
BEGIN
RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_mandate_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate_bkp_09may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate_bkp_09may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate_bkp_09may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate_bkp_09may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_mandate_full();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_mandate_full()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

BEGIN

    -- Check for rows with null values in mandatory columns
    IF EXISTS (SELECT 1 FROM transactions.stg_dion_mandate) 
    THEN

		-- Delete Duplicates from existing stage table
        DELETE FROM transactions.stg_dion_mandate t1
		WHERE EXISTS (SELECT * FROM transactions.stg_dion_mandate t2
					  WHERE t1.mandateid = t2.mandateid AND t1.ctid > t2.ctid);
					 
		DELETE FROM transactions.mf_mandate_error WHERE created_date >= NOW() - INTERVAL '7 days';

		-- Insert into the error table
        INSERT INTO transactions.mf_mandate_error (mandateid, ac_code, amount, bankname, mandate_type, status, created_date, modified_date, bank_ac_number, ifsc_code, start_date, end_date, trx_source, ucccode, acname ,client_owner,partner_code,upccode,error_message)
        SELECT DISTINCT
            src.mandateid, 
            src.clientcode, 
            src.amount, 
            src.bankname, 
            cast(src.mandatetype as character varying(1)) as mandatetype,
            src.status,
            src.createdon::timestamp without time zone AS created_date,
            src.updatedon::timestamp without time zone AS modified_date,
            src.accountnumber, 
            src.ifsccode, 
            src.createdon, 
            (src.createdon + INTERVAL '30 Years')::date AS end_date,
            'DION' AS trx_source, 
            du.ucccode,
            du.acname,
            du.client_owner,
            du.partner_code,
            du.upccode,
            CONCAT(
                CASE WHEN src.mandateid IS NULL THEN 'mandateid is NULL; ' ELSE '' END,
                CASE WHEN src.accountnumber IS NULL THEN 'bank accountnumber is NULL; ' ELSE '' END,
                CASE WHEN src.mandatetype IS NULL THEN 'mandatetype is NULL; ' ELSE '' end,
                CASE WHEN du.priority_ac_code IS NULL THEN 'Not found in dim_ucc table; ' ELSE '' END,
			CASE WHEN src.createdon IS NULL THEN 'Start date not available; ' ELSE '' END
            ) AS error_message
        FROM transactions.stg_dion_mandate src
        LEFT JOIN master.dim_ucc du ON TRIM(UPPER(src.clientcode)) =  TRIM(UPPER(du.priority_ac_code))
        WHERE src.accountnumber IS NULL OR src.mandatetype IS NULL OR du.priority_ac_code IS null or src.createdon is null
        ON CONFLICT (mandateid) DO UPDATE
        SET 
            ac_code = EXCLUDED.ac_code,
            amount = EXCLUDED.amount,
            bankname = EXCLUDED.bankname,
            mandate_type = EXCLUDED.mandate_type,
            status = EXCLUDED.status,
            created_date = EXCLUDED.created_date,
            modified_date = EXCLUDED.modified_date,
            bank_ac_number = EXCLUDED.bank_ac_number,
            ifsc_code = EXCLUDED.ifsc_code,
            start_date = EXCLUDED.start_date,
            end_date = EXCLUDED.end_date,
            trx_source = EXCLUDED.trx_source,
            ucccode = EXCLUDED.ucccode,
            acname = EXCLUDED.acname,
            client_owner = EXCLUDED.client_owner,
            partner_code = EXCLUDED.partner_code,
            upccode = EXCLUDED.upccode,
            error_message = EXCLUDED.error_message;
------------------------------------------------------------------------------------ 
        TRUNCATE TABLE transactions.mf_mandate;

        INSERT INTO transactions.mf_mandate(mandateid, ac_code, amount, bankname, mandate_type, status, 
			created_date, modified_date, bank_ac_number, ifsc_code, start_date, end_date, trx_source, ucccode, acname, client_owner, partner_code, upccode, remarks)
        SELECT DISTINCT
            src.mandateid, 
            src.clientcode as ac_code, 
            src.amount, 
            src.bankname, 
            cast(src.mandatetype as character varying(1)) as mandatetype, 
            src.status,
            src.createdon::timestamp without time zone AS created_date,
            src.updatedon::timestamp without time zone AS modified_date,
            src.accountnumber, 
            src.ifsccode, 
            src.createdon, 
            (src.createdon + INTERVAL '30 Years')::date AS end_date,
            'DION' AS trx_source, 
            du.ucccode,
            du.acname,
            du.client_owner,
            du.partner_code,
            du.upccode,
			src.remarks
        FROM transactions.stg_dion_mandate src
        JOIN master.dim_ucc du ON TRIM(UPPER(src.clientcode)) =  TRIM(UPPER(du.priority_ac_code))
        WHERE src.mandateid IS NOT NULL AND src.accountnumber IS NOT NULL 
		AND src.mandatetype IS NOT NULL AND du.priority_ac_code IS NOT NULL
		and src.createdon is not null;

------------------------------------------------------------------------------
---Truncate mandate history table for full load

 TRUNCATE TABLE transactions.mf_mandate_history RESTART IDENTITY;

insert into transactions.mf_mandate_history(
mandateid,ucccode,ac_code,mandate_type,status,remarks,
start_date,end_date,created_date,modified_date
)

select 
a.mandateid,a.ucccode,a.ac_code,a.mandate_type,a.status,a.remarks,
a.start_date,a.end_date,a.created_date,a.modified_date
from transactions.mf_mandate a
left join transactions.mf_mandate_history b
on a.mandateid = b.mandateid
where b.mandateid is null;

-------------------------------------------------------------------------------

        RETURN 'SUCCESS';
     ELSE  
           RETURN 'No Data in Staging Table';
    END IF;

	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_mandate_full() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate_full() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate_full() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate_full() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_mandate_full() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail()
 RETURNS text
 LANGUAGE plpgsql
AS $function$


DECLARE v_trx_id bigint;

BEGIN

---------------------------------------------------------------------	
	----delete duplicates
	WITH ranked_rows AS (
		SELECT
		ctid, -- Include ctid for later filtering
		txnid,
		ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
		FROM transactions.stg_dion_orderbook
		)
		delete FROM transactions.stg_dion_orderbook
		WHERE ctid IN (		SELECT ctid		
		FROM ranked_rows
		WHERE row_num > 1
		);

	
	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				--OR COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'')
				--OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
				--OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				--OR COALESCE(dest.tokenno,0) <> COALESCE(src.token,0)
				OR COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0)
				--OR COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
				--OR COALESCE(dest.is_generatedtoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
				
			  );
		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		, modified_date = NOW()
		
		FROM transactions.stg_dion_orderbook src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.vendor_trx_id in (select txnid from temp_exist_mf_trx);
		

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
			, modified_date = NOW()
			
		FROM transactions.stg_dion_orderbook src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		WHERE dest.vendor_trx_id = src.txnid
		and dest.vendor_trx_id in (select txnid from temp_exist_mf_trx);
		
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		AND D.is_generatetoday = B.is_generatetoday
		AND D.consent_status_code = B.consent_status_code
		AND coalesce (D.payment_status_code,0) = coalesce (B.payment_status_code,0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		

		/*
		 one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	
		
		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	 
		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
		*/
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = NOW(), 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		AND A.is_active = true
		and coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0);
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , cast ('2010-01-01' as date ) as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0); 
		 		

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		WHERE is_active = true 
		AND valid_to IS NULL;
		

-------------------------------------------------		
-- new trx insert
	
		SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

		INSERT INTO transactions.mf_order_detail
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
			
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 1 as inv_action_code, 'Transaction'::character varying as inv_action, UPPER(src.status)
		, 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup
		FROM transactions.stg_dion_orderbook src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		inner join master.dim_mf_isin isin on src.isin=isin.isincode
		JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		
		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
			
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		AND D.is_generatetoday = B.is_generatetoday
		AND D.consent_status_code = B.consent_status_code
		AND D.payment_status_code = B.payment_status_code
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , cast ('2010-01-01' as date ) as valid_from
		 FROM transactions.mf_order_detail A --
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;
------------------------------------------------------------------------------------------
-- Error Transaction
			
		INSERT INTO transactions.mf_order_detail_error
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
			
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 1 as inv_action_code, 'Transaction'::character varying as inv_action, UPPER(src.status)
		, 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup
		FROM transactions.stg_dion_orderbook src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		left JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		left join master.dim_mf_isin isin on src.isin=isin.isincode
		left JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		
		where ( mst.priority_ac_code is null --29449 
				or  isin.isincode is null--	13517
				or isin.mf_schcode is null --2
				); 
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail() TO cmotswrite;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_lumpsum();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_lumpsum()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;

BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_LUMPSUM
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
	FROM transactions.stg_dion_orderbook_LUMPSUM
	)
	delete FROM transactions.stg_dion_orderbook_LUMPSUM
	WHERE ctid IN (		SELECT ctid		
	FROM ranked_rows
	WHERE row_num > 1
	);

--/* commuication
insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked,emp_code,partner_code
)
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
src.schemename as fundname,
src.amount::character varying as amount,
src.units::character varying as units,
src.orderremarks as rejection_reason,
''::character varying as next_due_date,
''::character varying as sip_start_date,
''::character varying as sip_end_date,
''::character varying as frequency,
''::character varying as installment_number,
''::character varying as bankname,
''::character varying as bankacno,
'82'::character varying as sourceid,
(case 
when mst.trx_type_code=4 and upper(src.status)='ORDERED' then '3572'
when mst.trx_type_code=4 and upper(src.status)='REJECTED' then '3575'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=4 and upper(src.status)='ORDERED' then 'TRADE_CONFIRMATION_LUMPSUM_INTERNAL'
when mst.trx_type_code=4 and upper(src.status)='REJECTED' then 'MF_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
,(case when dest.order_placed_by='RM' then coalesce(dest.created_for,dest.orderby)
when dest.order_placed_by='CLIENT' and ucc.user_type='E' then dest.rm_partner_code end)::character varying as emp_code,
(case when dest.order_placed_by='PARTNER' then ucc.partnerowner
when dest.order_placed_by='CLIENT' and ucc.user_type='P' then ucc.partnerowner end)::character varying as partner_code
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_LUMPSUM src 
on dest.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code and mst.category_code=261
join master.dim_ucc ucc on ucc.ucccode= dest.ucccode
where dest.trx_type_code= 4 
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/

------------------------------------------
---to update lead status

insert into transactions.auto_leadstatus_reject(trx_id)
select dest.trx_id
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_LUMPSUM src 
on dest.vendor_trx_id = src.txnid
where dest.trx_type_code=4 
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and dest.order_placed_by='RM'
and dest.datasource='DION';
------------------------------------------
	
	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_LUMPSUM)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_LUMPSUM src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
			  );

		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
--		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		, modified_date =(NOW() at time zone 'Asia/Kolkata')
		
		FROM transactions.stg_dion_orderbook_LUMPSUM src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
			, modified_date = (NOW() at time zone 'Asia/Kolkata')
		FROM transactions.stg_dion_orderbook_LUMPSUM src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND D.consent_status_code = B.consent_status_code
		AND coalesce (D.payment_status_code,0) = coalesce (B.payment_status_code,0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

---to Handle eCollect
update transactions.mf_order_detail a
set 
final_status = 
case 
when a.vendor_trx_status='ORDERED' and b.paymentstatus in ('Unpaid','Processing') 
then 'Order Accepted'
when a.vendor_trx_status='ORDERED' and b.paymentstatus='Paid' then 'Completed'
when a.vendor_trx_status='REJECTED' then 'Order Rejected'
when a.vendor_trx_status='ACCEPTED' then 'Order Accepted' 
end,
trx_final_status_code = 
case 
when a.vendor_trx_status='ORDERED' 
and b.paymentstatus in ('Unpaid','Processing') then 6
when a.vendor_trx_status='ORDERED' 
and b.paymentstatus in ('Paid') then 4
when a.vendor_trx_status='REJECTED' then 2
when a.vendor_trx_status='ACCEPTED' then 5 
end
from transactions.stg_dion_orderbook_LUMPSUM b
where b.txnid = a.vendor_trx_id
and a.payment_method='eCollect'
and a.trx_type_code=4;

---to Handle ACCEPTED status
update transactions.mf_order_detail a
set 
trx_final_status_code = 5,
final_status = 'Order In Progress'
from transactions.stg_dion_orderbook_LUMPSUM b
where b.txnid = a.vendor_trx_id
and a.trx_type_code=4
and a.final_status is null
and a.vendor_trx_status ='ACCEPTED';

		/*
		 one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	 
		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		*/
/*
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
	*/
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = (NOW() at time zone 'Asia/Kolkata'), 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		and A.is_active = true
		and (
			coalesce (a.trx_final_status_code,0) <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0) <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0) <> coalesce (b.trx_status_code,0)
		or coalesce (a.payment_status_code,0) <> coalesce (b.payment_status_code,0)
		or coalesce (a.inv_plan_status_code,0) <> coalesce (b.inv_plan_status_code,0)
			); 
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT distinct
			A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			(NOW() at time zone 'Asia/Kolkata') as inserted_dt , (NOW() at time zone 'Asia/Kolkata') as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.payment_status_code,0)  <> coalesce (b.payment_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		WHERE is_active = true 
		AND valid_to IS NULL;
		
-------------------------------------------------		
-- new trx insert
	
		SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

		INSERT INTO transactions.mf_order_detail
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 1 as inv_action_code, 'Transaction'::character varying as inv_action, UPPER(src.status)
		, 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup
		FROM transactions.stg_dion_orderbook_LUMPSUM src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		inner join master.dim_mf_isin isin on src.isin=isin.isincode
		JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		
		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
			
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
	
----to be removed for incremental----
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = case 
			when order_placed_by <> 'CLIENT' then 2 
			when order_placed_by = 'CLIENT' and physicalflag='P' then 2
			else 0 end,
		consent_status = case 
			when order_placed_by <> 'CLIENT' then 'Consent Approved' 
			when order_placed_by = 'CLIENT' and physicalflag='P' then 'Consent Approved' 
			else '' end,
		payment_status_code =2,
		payment_status = 'Processed'
		WHERE A.trx_id >= v_trx_id
	--	AND order_placed_by <> 'CLIENT'
		AND consent_status_code IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
      --AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			(NOW() at time zone 'Asia/Kolkata') as inserted_dt ,  (NOW() at time zone 'Asia/Kolkata') as valid_from
		 FROM transactions.mf_order_detail A
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;
------------------------------------------------------------------------------------------
-- Error Transaction
	
-- 	     DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';
		DELETE FROM transactions.mf_order_detail_error A
		WHERE EXISTS (SELECT B.txnid FROM  transactions.stg_dion_orderbook_LUMPSUM B WHERE A.vendor_trx_id = B.txnid);

			
			INSERT INTO transactions.mf_order_detail_error (
		    vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby,
		    delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate,
		    order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks, tokenno, switchtokenno, vendor_exchg_refno,
		    ucccode, pan, euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday, inv_type_code,
		    inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code, qty_or_amt_order, mf_schcode, isinname,
		    schemegroup, error_message
		)
		SELECT 
		    src.txnid AS vendor_trx_id, src.clientcode AS ac_code, src.userid AS "user_id", src.isin AS isincode, txn.trx_type AS trx_type,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS trx_datetime, 
		    CASE WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) ELSE src.amount END AS trx_amt,
		    COALESCE(CASE WHEN COALESCE(src.units, 0) = 0 THEN CASE WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
		        ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) END END, 0) AS trx_qty,
		    'DION'::character varying,
		    CASE WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode ELSE src.orderedby END AS orderedby,
		    src.traxmode AS delivery_mode, src.mandateid AS mandate_id, trx_sts.trx_status,
		    CASE 
		        WHEN trim(upper(src.paymentstatus)) = 'PAID' THEN 'Processed'
		        WHEN trim(upper(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
		        WHEN trim(upper(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
		        ELSE dps.payment_status 
		    END AS payment_status,
		    src.lastmodifiedon AS modified_date, src.lastmodifiedby AS modified_by, src.ordersource AS trx_source,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS created_date, src.nav, src.navdate,
		    src.ordernav AS order_nav, src.ordernavdate AS order_navdate, src.foliono AS folio_no,
		    trim(upper(src.ordertype)) AS order_type, COALESCE(src.physicalflag, 'D') AS physicalflag, src.orderremarks AS order_remarks,
		    src.token AS tokenno, src.switchtoken AS switchtokenno, src.exchangerefno AS vendor_exchg_refno, mst.ucccode, mst.pan,
		    src.euinnumber, src.switchisin AS switch_isin, 1 AS internal_flag, trx.trx_type_code, sts.trx_status_code,
		    CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END AS is_generatetoday, txn.inv_type_code, inv.inv_type,
		    1 AS inv_action_code, 'Transaction'::character varying AS inv_action, upper(src.status) AS vendor_trx_status,
		    CASE 
		        WHEN trim(upper(src.paymentstatus)) = 'PAID' THEN 2
		        WHEN trim(upper(src.paymentstatus)) = 'UNPAID' THEN 1
		        WHEN trim(upper(src.paymentstatus)) = 'PROCESSING' THEN 1
		        WHEN trim(upper(COALESCE(src.paymentstatus, ''))) = '' THEN 0
		        ELSE PM.payment_status_code 
		    END AS payment_status_code,
		    CASE WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' ELSE 'Q' END AS qty_or_amt_order,
		    isin.mf_schcode, isin.isinname, sch.schemegroup,
		    CONCAT(
		        CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
		        CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
	        CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
	        CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
	        CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END		    ) AS error_message
		FROM transactions.stg_dion_orderbook_LUMPSUM src
-- 		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		LEFT JOIN master.map_vendor_internal_payment_status pm ON pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
		LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
		LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
		WHERE (
		    mst.priority_ac_code IS NULL 
		    OR isin.isincode IS NULL
		    OR isin.mf_schcode IS NULL
			OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL
		);
		
/*		
		ON CONFLICT (vendor_trx_id) DO UPDATE SET
		    ac_code = EXCLUDED.ac_code,
		    "user_id" = EXCLUDED."user_id",
		    isincode = EXCLUDED.isincode,
		    trx_type = EXCLUDED.trx_type,
		    trx_datetime = EXCLUDED.trx_datetime,
		    trx_amt = EXCLUDED.trx_amt,
		    trx_qty = EXCLUDED.trx_qty,
		    datasource = EXCLUDED.datasource,
		    orderby = EXCLUDED.orderby,
		    delivery_mode = EXCLUDED.delivery_mode,
		    mandate_id = EXCLUDED.mandate_id,
		    trx_status = EXCLUDED.trx_status,
		    payment_status = EXCLUDED.payment_status,
		    modified_date = EXCLUDED.modified_date,
		    modified_by = EXCLUDED.modified_by,
		    trx_source = EXCLUDED.trx_source,
		    created_date = EXCLUDED.created_date,
		    nav = EXCLUDED.nav,
		    navdate = EXCLUDED.navdate,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    folio_no = EXCLUDED.folio_no,
		    order_type = EXCLUDED.order_type,
		    physicalflag = EXCLUDED.physicalflag,
		    order_remarks = EXCLUDED.order_remarks,
		    tokenno = EXCLUDED.tokenno,
		    switchtokenno = EXCLUDED.switchtokenno,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    ucccode = EXCLUDED.ucccode,
		    pan = EXCLUDED.pan,
		    euinnumber = EXCLUDED.euinnumber,
		    switch_isin = EXCLUDED.switch_isin,
		    internal_flag = EXCLUDED.internal_flag,
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    is_generatetoday = EXCLUDED.is_generatetoday,
		    inv_type_code = EXCLUDED.inv_type_code,
		    inv_type = EXCLUDED.inv_type,
		    inv_action_code = EXCLUDED.inv_action_code,
		    inv_action = EXCLUDED.inv_action,
		    vendor_trx_status = EXCLUDED.vendor_trx_status,
		    payment_status_code = EXCLUDED.payment_status_code,
		    qty_or_amt_order = EXCLUDED.qty_or_amt_order,
		    mf_schcode = EXCLUDED.mf_schcode,
		    isinname = EXCLUDED.isinname,
		    schemegroup = EXCLUDED.schemegroup,
		    error_message = EXCLUDED.error_message;
*/
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_lumpsum() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_09may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;

BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_LUMPSUM
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
	FROM transactions.stg_dion_orderbook_LUMPSUM
	)
	delete FROM transactions.stg_dion_orderbook_LUMPSUM
	WHERE ctid IN (		SELECT ctid		
	FROM ranked_rows
	WHERE row_num > 1
	);

--/* commuication
insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked
)
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
src.schemename as fundname,
src.amount::character varying as amount,
src.units::character varying as units,
src.orderremarks as rejection_reason,
''::character varying as next_due_date,
''::character varying as sip_start_date,
''::character varying as sip_end_date,
''::character varying as frequency,
''::character varying as installment_number,
''::character varying as bankname,
''::character varying as bankacno,
'82'::character varying as sourceid,
(case 
when mst.trx_type_code=4 and upper(src.status)='ORDERED' then '3572'
when mst.trx_type_code=4 and upper(src.status)='REJECTED' then '3575'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=4 and upper(src.status)='ORDERED' then 'TRADE_CONFIRMATION_LUMPSUM_INTERNAL'
when mst.trx_type_code=4 and upper(src.status)='REJECTED' then 'MF_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_LUMPSUM src 
on dest.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code
where dest.trx_type_code= 4 
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/

------------------------------------------
---to update lead status

insert into transactions.auto_leadstatus_reject(trx_id)
select dest.trx_id
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_LUMPSUM src 
on dest.vendor_trx_id = src.txnid
where dest.trx_type_code=4 
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and dest.order_placed_by='RM'
and dest.datasource='DION';
------------------------------------------
	
	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_LUMPSUM)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_LUMPSUM src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
			  );

		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
--		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		, modified_date = NOW()
		
		FROM transactions.stg_dion_orderbook_LUMPSUM src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
			, modified_date = NOW()
		FROM transactions.stg_dion_orderbook_LUMPSUM src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND D.consent_status_code = B.consent_status_code
		AND coalesce (D.payment_status_code,0) = coalesce (B.payment_status_code,0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		

		/*
		 one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	
		
		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	 
		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		*/
/*
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
	*/
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = NOW(), 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		AND A.is_active = true
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.payment_status_code,0)  <> coalesce (b.payment_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT distinct
			A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.payment_status_code,0)  <> coalesce (b.payment_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		WHERE is_active = true 
		AND valid_to IS NULL;
		
-------------------------------------------------		
-- new trx insert
	
		SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

		INSERT INTO transactions.mf_order_detail
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 1 as inv_action_code, 'Transaction'::character varying as inv_action, UPPER(src.status)
		, 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup
		FROM transactions.stg_dion_orderbook_LUMPSUM src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		inner join master.dim_mf_isin isin on src.isin=isin.isincode
		JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		
		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
			
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
	
----to be removed for incremental----
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = case 
			when order_placed_by <> 'CLIENT' then 2 
			when order_placed_by = 'CLIENT' and physicalflag='P' then 2
			else 0 end,
		consent_status = case 
			when order_placed_by <> 'CLIENT' then 'Consent Approved' 
			when order_placed_by = 'CLIENT' and physicalflag='P' then 'Consent Approved' 
			else '' end,
		payment_status_code =2,
		payment_status = 'Processed'
		WHERE A.trx_id >= v_trx_id
	--	AND order_placed_by <> 'CLIENT'
		AND consent_status_code IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
      --AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt ,  now() as valid_from
		 FROM transactions.mf_order_detail A
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;
------------------------------------------------------------------------------------------
-- Error Transaction
	
-- 	     DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';
		DELETE FROM transactions.mf_order_detail_error A
		WHERE EXISTS (SELECT B.txnid FROM  transactions.stg_dion_orderbook_LUMPSUM B WHERE A.vendor_trx_id = B.txnid);

			
			INSERT INTO transactions.mf_order_detail_error (
		    vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby,
		    delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate,
		    order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks, tokenno, switchtokenno, vendor_exchg_refno,
		    ucccode, pan, euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday, inv_type_code,
		    inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code, qty_or_amt_order, mf_schcode, isinname,
		    schemegroup, error_message
		)
		SELECT 
		    src.txnid AS vendor_trx_id, src.clientcode AS ac_code, src.userid AS "user_id", src.isin AS isincode, txn.trx_type AS trx_type,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS trx_datetime, 
		    CASE WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) ELSE src.amount END AS trx_amt,
		    COALESCE(CASE WHEN COALESCE(src.units, 0) = 0 THEN CASE WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
		        ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) END END, 0) AS trx_qty,
		    'DION'::character varying,
		    CASE WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode ELSE src.orderedby END AS orderedby,
		    src.traxmode AS delivery_mode, src.mandateid AS mandate_id, trx_sts.trx_status,
		    CASE 
		        WHEN trim(upper(src.paymentstatus)) = 'PAID' THEN 'Processed'
		        WHEN trim(upper(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
		        WHEN trim(upper(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
		        ELSE dps.payment_status 
		    END AS payment_status,
		    src.lastmodifiedon AS modified_date, src.lastmodifiedby AS modified_by, src.ordersource AS trx_source,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS created_date, src.nav, src.navdate,
		    src.ordernav AS order_nav, src.ordernavdate AS order_navdate, src.foliono AS folio_no,
		    trim(upper(src.ordertype)) AS order_type, COALESCE(src.physicalflag, 'D') AS physicalflag, src.orderremarks AS order_remarks,
		    src.token AS tokenno, src.switchtoken AS switchtokenno, src.exchangerefno AS vendor_exchg_refno, mst.ucccode, mst.pan,
		    src.euinnumber, src.switchisin AS switch_isin, 1 AS internal_flag, trx.trx_type_code, sts.trx_status_code,
		    CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END AS is_generatetoday, txn.inv_type_code, inv.inv_type,
		    1 AS inv_action_code, 'Transaction'::character varying AS inv_action, upper(src.status) AS vendor_trx_status,
		    CASE 
		        WHEN trim(upper(src.paymentstatus)) = 'PAID' THEN 2
		        WHEN trim(upper(src.paymentstatus)) = 'UNPAID' THEN 1
		        WHEN trim(upper(src.paymentstatus)) = 'PROCESSING' THEN 1
		        WHEN trim(upper(COALESCE(src.paymentstatus, ''))) = '' THEN 0
		        ELSE PM.payment_status_code 
		    END AS payment_status_code,
		    CASE WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' ELSE 'Q' END AS qty_or_amt_order,
		    isin.mf_schcode, isin.isinname, sch.schemegroup,
		    CONCAT(
		        CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
		        CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
	        CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
	        CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
	        CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END		    ) AS error_message
		FROM transactions.stg_dion_orderbook_LUMPSUM src
-- 		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		LEFT JOIN master.map_vendor_internal_payment_status pm ON pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
		LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
		LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
		WHERE (
		    mst.priority_ac_code IS NULL 
		    OR isin.isincode IS NULL
		    OR isin.mf_schcode IS NULL
			OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL
		);
		
/*		
		ON CONFLICT (vendor_trx_id) DO UPDATE SET
		    ac_code = EXCLUDED.ac_code,
		    "user_id" = EXCLUDED."user_id",
		    isincode = EXCLUDED.isincode,
		    trx_type = EXCLUDED.trx_type,
		    trx_datetime = EXCLUDED.trx_datetime,
		    trx_amt = EXCLUDED.trx_amt,
		    trx_qty = EXCLUDED.trx_qty,
		    datasource = EXCLUDED.datasource,
		    orderby = EXCLUDED.orderby,
		    delivery_mode = EXCLUDED.delivery_mode,
		    mandate_id = EXCLUDED.mandate_id,
		    trx_status = EXCLUDED.trx_status,
		    payment_status = EXCLUDED.payment_status,
		    modified_date = EXCLUDED.modified_date,
		    modified_by = EXCLUDED.modified_by,
		    trx_source = EXCLUDED.trx_source,
		    created_date = EXCLUDED.created_date,
		    nav = EXCLUDED.nav,
		    navdate = EXCLUDED.navdate,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    folio_no = EXCLUDED.folio_no,
		    order_type = EXCLUDED.order_type,
		    physicalflag = EXCLUDED.physicalflag,
		    order_remarks = EXCLUDED.order_remarks,
		    tokenno = EXCLUDED.tokenno,
		    switchtokenno = EXCLUDED.switchtokenno,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    ucccode = EXCLUDED.ucccode,
		    pan = EXCLUDED.pan,
		    euinnumber = EXCLUDED.euinnumber,
		    switch_isin = EXCLUDED.switch_isin,
		    internal_flag = EXCLUDED.internal_flag,
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    is_generatetoday = EXCLUDED.is_generatetoday,
		    inv_type_code = EXCLUDED.inv_type_code,
		    inv_type = EXCLUDED.inv_type,
		    inv_action_code = EXCLUDED.inv_action_code,
		    inv_action = EXCLUDED.inv_action,
		    vendor_trx_status = EXCLUDED.vendor_trx_status,
		    payment_status_code = EXCLUDED.payment_status_code,
		    qty_or_amt_order = EXCLUDED.qty_or_amt_order,
		    mf_schcode = EXCLUDED.mf_schcode,
		    isinname = EXCLUDED.isinname,
		    schemegroup = EXCLUDED.schemegroup,
		    error_message = EXCLUDED.error_message;
*/
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_09may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_09may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_09may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_09may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_14jul2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_14jul2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;

BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_LUMPSUM
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
	FROM transactions.stg_dion_orderbook_LUMPSUM
	)
	delete FROM transactions.stg_dion_orderbook_LUMPSUM
	WHERE ctid IN (		SELECT ctid		
	FROM ranked_rows
	WHERE row_num > 1
	);

--/* commuication
insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked
)
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
src.schemename as fundname,
src.amount::character varying as amount,
src.units::character varying as units,
src.orderremarks as rejection_reason,
''::character varying as next_due_date,
''::character varying as sip_start_date,
''::character varying as sip_end_date,
''::character varying as frequency,
''::character varying as installment_number,
''::character varying as bankname,
''::character varying as bankacno,
'54'::character varying as sourceid,
(case 
when mst.trx_type_code=4 and upper(src.status)='ORDERED' then '3572'
when mst.trx_type_code=4 and upper(src.status)='REJECTED' then '3575'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=4 and upper(src.status)='ORDERED' then 'TRADE_CONFIRMATION_LUMPSUM_INTERNAL'
when mst.trx_type_code=4 and upper(src.status)='REJECTED' then 'MF_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_LUMPSUM src 
on dest.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code and mst.category_code=261
where dest.trx_type_code= 4 
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/

------------------------------------------
---to update lead status

insert into transactions.auto_leadstatus_reject(trx_id)
select dest.trx_id
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_LUMPSUM src 
on dest.vendor_trx_id = src.txnid
where dest.trx_type_code=4 
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and dest.order_placed_by='RM'
and dest.datasource='DION';
------------------------------------------
	
	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_LUMPSUM)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_LUMPSUM src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
			  );

		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
--		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		, modified_date = NOW()
		
		FROM transactions.stg_dion_orderbook_LUMPSUM src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
			, modified_date = NOW()
		FROM transactions.stg_dion_orderbook_LUMPSUM src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND D.consent_status_code = B.consent_status_code
		AND coalesce (D.payment_status_code,0) = coalesce (B.payment_status_code,0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

---to Handle eCollect

update transactions.mf_order_detail a
set 
final_status = 
case 
when a.vendor_trx_status='ORDERED' and b.paymentstatus in ('Unpaid','Processing') 
then 'Order Accepted'
when a.vendor_trx_status='ORDERED' and b.paymentstatus='Paid' then 'Completed'
when a.vendor_trx_status='REJECTED' then 'Order Rejected'
when a.vendor_trx_status='ACCEPTED' then 'Order Accepted' 
end,
trx_final_status_code = 
case 
when a.vendor_trx_status='ORDERED' 
and b.paymentstatus in ('Unpaid','Processing') then 6
when a.vendor_trx_status='ORDERED' 
and b.paymentstatus in ('Paid') then 4
when a.vendor_trx_status='REJECTED' then 8
when a.vendor_trx_status='ACCEPTED' then 6 
end
from transactions.stg_dion_orderbook_LUMPSUM b
where b.txnid = a.vendor_trx_id
and a.payment_method='eCollect'
and a.trx_type_code=4;

		/*
		 one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	 
		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		*/
/*
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
	*/
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = NOW(), 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		and A.is_active = true
		and (
			coalesce (a.trx_final_status_code,0) <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0) <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0) <> coalesce (b.trx_status_code,0)
		or coalesce (a.payment_status_code,0) <> coalesce (b.payment_status_code,0)
		or coalesce (a.inv_plan_status_code,0) <> coalesce (b.inv_plan_status_code,0)
			); 
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT distinct
			A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.payment_status_code,0)  <> coalesce (b.payment_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		WHERE is_active = true 
		AND valid_to IS NULL;
		
-------------------------------------------------		
-- new trx insert
	
		SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

		INSERT INTO transactions.mf_order_detail
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 1 as inv_action_code, 'Transaction'::character varying as inv_action, UPPER(src.status)
		, 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup
		FROM transactions.stg_dion_orderbook_LUMPSUM src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		inner join master.dim_mf_isin isin on src.isin=isin.isincode
		JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		
		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
			
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
	
----to be removed for incremental----
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = case 
			when order_placed_by <> 'CLIENT' then 2 
			when order_placed_by = 'CLIENT' and physicalflag='P' then 2
			else 0 end,
		consent_status = case 
			when order_placed_by <> 'CLIENT' then 'Consent Approved' 
			when order_placed_by = 'CLIENT' and physicalflag='P' then 'Consent Approved' 
			else '' end,
		payment_status_code =2,
		payment_status = 'Processed'
		WHERE A.trx_id >= v_trx_id
	--	AND order_placed_by <> 'CLIENT'
		AND consent_status_code IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
      --AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt ,  now() as valid_from
		 FROM transactions.mf_order_detail A
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;
------------------------------------------------------------------------------------------
-- Error Transaction
	
-- 	     DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';
		DELETE FROM transactions.mf_order_detail_error A
		WHERE EXISTS (SELECT B.txnid FROM  transactions.stg_dion_orderbook_LUMPSUM B WHERE A.vendor_trx_id = B.txnid);

			
			INSERT INTO transactions.mf_order_detail_error (
		    vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby,
		    delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate,
		    order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks, tokenno, switchtokenno, vendor_exchg_refno,
		    ucccode, pan, euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday, inv_type_code,
		    inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code, qty_or_amt_order, mf_schcode, isinname,
		    schemegroup, error_message
		)
		SELECT 
		    src.txnid AS vendor_trx_id, src.clientcode AS ac_code, src.userid AS "user_id", src.isin AS isincode, txn.trx_type AS trx_type,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS trx_datetime, 
		    CASE WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) ELSE src.amount END AS trx_amt,
		    COALESCE(CASE WHEN COALESCE(src.units, 0) = 0 THEN CASE WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
		        ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) END END, 0) AS trx_qty,
		    'DION'::character varying,
		    CASE WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode ELSE src.orderedby END AS orderedby,
		    src.traxmode AS delivery_mode, src.mandateid AS mandate_id, trx_sts.trx_status,
		    CASE 
		        WHEN trim(upper(src.paymentstatus)) = 'PAID' THEN 'Processed'
		        WHEN trim(upper(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
		        WHEN trim(upper(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
		        ELSE dps.payment_status 
		    END AS payment_status,
		    src.lastmodifiedon AS modified_date, src.lastmodifiedby AS modified_by, src.ordersource AS trx_source,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS created_date, src.nav, src.navdate,
		    src.ordernav AS order_nav, src.ordernavdate AS order_navdate, src.foliono AS folio_no,
		    trim(upper(src.ordertype)) AS order_type, COALESCE(src.physicalflag, 'D') AS physicalflag, src.orderremarks AS order_remarks,
		    src.token AS tokenno, src.switchtoken AS switchtokenno, src.exchangerefno AS vendor_exchg_refno, mst.ucccode, mst.pan,
		    src.euinnumber, src.switchisin AS switch_isin, 1 AS internal_flag, trx.trx_type_code, sts.trx_status_code,
		    CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END AS is_generatetoday, txn.inv_type_code, inv.inv_type,
		    1 AS inv_action_code, 'Transaction'::character varying AS inv_action, upper(src.status) AS vendor_trx_status,
		    CASE 
		        WHEN trim(upper(src.paymentstatus)) = 'PAID' THEN 2
		        WHEN trim(upper(src.paymentstatus)) = 'UNPAID' THEN 1
		        WHEN trim(upper(src.paymentstatus)) = 'PROCESSING' THEN 1
		        WHEN trim(upper(COALESCE(src.paymentstatus, ''))) = '' THEN 0
		        ELSE PM.payment_status_code 
		    END AS payment_status_code,
		    CASE WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' ELSE 'Q' END AS qty_or_amt_order,
		    isin.mf_schcode, isin.isinname, sch.schemegroup,
		    CONCAT(
		        CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
		        CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
	        CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
	        CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
	        CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END		    ) AS error_message
		FROM transactions.stg_dion_orderbook_LUMPSUM src
-- 		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		LEFT JOIN master.map_vendor_internal_payment_status pm ON pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
		LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
		LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
		WHERE (
		    mst.priority_ac_code IS NULL 
		    OR isin.isincode IS NULL
		    OR isin.mf_schcode IS NULL
			OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL
		);
		
/*		
		ON CONFLICT (vendor_trx_id) DO UPDATE SET
		    ac_code = EXCLUDED.ac_code,
		    "user_id" = EXCLUDED."user_id",
		    isincode = EXCLUDED.isincode,
		    trx_type = EXCLUDED.trx_type,
		    trx_datetime = EXCLUDED.trx_datetime,
		    trx_amt = EXCLUDED.trx_amt,
		    trx_qty = EXCLUDED.trx_qty,
		    datasource = EXCLUDED.datasource,
		    orderby = EXCLUDED.orderby,
		    delivery_mode = EXCLUDED.delivery_mode,
		    mandate_id = EXCLUDED.mandate_id,
		    trx_status = EXCLUDED.trx_status,
		    payment_status = EXCLUDED.payment_status,
		    modified_date = EXCLUDED.modified_date,
		    modified_by = EXCLUDED.modified_by,
		    trx_source = EXCLUDED.trx_source,
		    created_date = EXCLUDED.created_date,
		    nav = EXCLUDED.nav,
		    navdate = EXCLUDED.navdate,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    folio_no = EXCLUDED.folio_no,
		    order_type = EXCLUDED.order_type,
		    physicalflag = EXCLUDED.physicalflag,
		    order_remarks = EXCLUDED.order_remarks,
		    tokenno = EXCLUDED.tokenno,
		    switchtokenno = EXCLUDED.switchtokenno,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    ucccode = EXCLUDED.ucccode,
		    pan = EXCLUDED.pan,
		    euinnumber = EXCLUDED.euinnumber,
		    switch_isin = EXCLUDED.switch_isin,
		    internal_flag = EXCLUDED.internal_flag,
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    is_generatetoday = EXCLUDED.is_generatetoday,
		    inv_type_code = EXCLUDED.inv_type_code,
		    inv_type = EXCLUDED.inv_type,
		    inv_action_code = EXCLUDED.inv_action_code,
		    inv_action = EXCLUDED.inv_action,
		    vendor_trx_status = EXCLUDED.vendor_trx_status,
		    payment_status_code = EXCLUDED.payment_status_code,
		    qty_or_amt_order = EXCLUDED.qty_or_amt_order,
		    mf_schcode = EXCLUDED.mf_schcode,
		    isinname = EXCLUDED.isinname,
		    schemegroup = EXCLUDED.schemegroup,
		    error_message = EXCLUDED.error_message;
*/
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_14jul2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_14jul2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_14jul2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_14jul2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_lumpsum_bkp_14jul2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_sip();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_sip()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;
BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_SIP
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
	FROM transactions.stg_dion_orderbook_SIP
	)
	delete FROM transactions.stg_dion_orderbook_SIP
	WHERE ctid IN (	
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

------------------Start To Handle SIP Modify

---Check Active Modify Order Status
--drop table temp_mf_new_modify_order

CREATE TEMP TABLE IF NOT EXISTS temp_mf_new_modify_order AS
select 
a.clientcode,a.vcclientname as clientname,a.txntype,a.modifytype,a.mainsipregno,a.txnid,
a.sipregno,a.schemename,a.sipstartdate,a.sipenddate,a.amount,
a.frequency,a.mandateid,a.status,a.remarks,b.vendor_trx_id
from transactions.stg_dion_siporder a
left join transactions.mf_order_summary b
on a.mainsipregno = b.reg_no::character varying
left join transactions.mf_order_summary_modify_log c
on b.reg_no::character varying = c.reg_no::character varying
where a.mainsipregno is not null
and a.modifytype = 'ModifiedChildSIP'
and c.reg_no::character varying is null
and a.status = 'Running'; 
--and a.mainsipregno='135247570'

-----------------------------------------------------
---- Active SIP modification log (before modification)

insert into transactions.mf_order_summary_modify_log(
id,order_no,trx_id,vendor_trx_id,display_trx_id,
trx_datetime,reg_no,ac_code,pan,mf_schcode,isincode,
firstordertoday,is_generatetoday,trx_type_code,trx_type,
trx_status_code,trx_status,trx_final_status_code,final_status,
inv_plan_status_code,inv_plan_status,trx_amt,trx_qty,nav,
order_nav,order_navdate,no_of_installment,installment_paid,
installment_pending,start_date,end_date,folio_no,orderby,
frequency,reinvestmentflag,mfimfdflag,order_remarks,euinnumber,
rm_partner_code,dpc,delivery_mode,user_id,trx_source,childordernumber,
tokenno,mandate_id,mandate_amt,vendor_exchg_refno,mainsipregno,start_day,
installment_type,upcoming_due_date,previous_paid_date,totalinstallmentamt_paid,
totalinstallment_paid,switch_isin,modifytype,modifycount,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,ispaused,paused_date,no_of_installment_paused,
pausemodificationcount,pausecount,isresumed,resumed_date,isskip,skip_date,istopup,
topupdate,topupcount,iscancel,cancellation_date,datasource,modified_date,created_date,
remarks,inserted_date)

select 
a.id,a.order_no,a.trx_id,a.vendor_trx_id,a.display_trx_id,
a.trx_datetime,a.reg_no,a.ac_code,a.pan,a.mf_schcode,a.isincode,
a.firstordertoday,a.is_generatetoday,a.trx_type_code,a.trx_type,
a.trx_status_code,a.trx_status,a.trx_final_status_code,a.final_status,
a.inv_plan_status_code,a.inv_plan_status,a.trx_amt,a.trx_qty,a.nav,
a.order_nav,a.order_navdate,a.no_of_installment,a.installment_paid,
a.installment_pending,a.start_date,a.end_date,a.folio_no,a.orderby,
a.frequency,a.reinvestmentflag,a.mfimfdflag,a.order_remarks,a.euinnumber,
a.rm_partner_code,a.dpc,a.delivery_mode,a.user_id,a.trx_source,a.childordernumber,
a.tokenno,a.mandate_id,a.mandate_amt,a.vendor_exchg_refno,a.mainsipregno,a.start_day,
a.installment_type,a.upcoming_due_date,a.previous_paid_date,a.totalinstallmentamt_paid,
a.totalinstallment_paid,a.switch_isin,a.modifytype,a.modifycount,a.stepup_type,a.stepup_amount,
a.stepup_percent,a.stepup_start_date,a.ispaused,a.paused_date,a.no_of_installment_paused,
a.pausemodificationcount,a.pausecount,a.isresumed,a.resumed_date,a.isskip,a.skip_date,a.istopup,
a.topupdate,a.topupcount,a.iscancel,a.cancellation_date,a.datasource,a.modified_date,a.created_date,
a.remarks, NOW() AT TIME ZONE 'Asia/Kolkata' as inserted_date
from transactions.mf_order_summary a
left join transactions.mf_order_summary_modify_log b
on a.reg_no::character varying = b.reg_no::character varying
where a.reg_no::character varying in (
select mainsipregno
from temp_mf_new_modify_order
--where mainsipregno='135247570'
)
and b.reg_no is null;

----Active SIP modification (for post modification)
update transactions.mf_order_summary a
set
  vendor_trx_id = b.txnid,
  reg_no = b.sipregno,
--  start_date = b.sipstartdate,
  end_date = b.sipenddate,
  frequency = b.frequency,
  trx_amt = b.amount,
  mandate_id = b.mandateid,
  modified_date = NOW() AT TIME ZONE 'Asia/Kolkata',
--  modifiedtype = b.modifytype,
  mainsipregno = b.mainsipregno,
  remarks='',
	trx_status_code=4,
	trx_status='RUNNING',
	trx_final_status_code=4,
	final_status='Completed',
	inv_plan_status_code=4,
	inv_plan_status='Active'
from temp_mf_new_modify_order b
where a.reg_no::character varying = b.mainsipregno;

update transactions.mf_order_detail a
set
	vendor_trx_id = b.txnid,
	modified_date = NOW() AT TIME ZONE 'Asia/Kolkata',
	trx_status_code=4,
	trx_status='RUNNING',
	trx_final_status_code=4,
	final_status='Completed',
	inv_plan_status_code=4,
	inv_plan_status='Active'
from temp_mf_new_modify_order b
where a.vendor_trx_id = b.vendor_trx_id;
	
--------------------------------------------------------------------
---Update SIP Modify order
update transactions.mf_order_detail_modification
set trx_status_code=4,
trx_status='completed',
vendor_trx_status='Modify',
inv_plan_status_code= 4,
inv_plan_status='Active',
trx_final_status_code=4,
final_status='Completed',
order_remarks='Modification request successfully executed.'
where trx_id in (
select trx_id from (
select vendor_trx_id,org_trx_id,trx_id,inv_action_code,trx_status_code,created_date 
from (
	select vendor_trx_id,org_trx_id,trx_id,inv_action_code,trx_status_code,created_date,
	row_number() over(partition by org_trx_id order by trx_id desc) rnk
	from transactions.mf_order_detail_modification
	where inv_action_code=3
)a
where a.rnk=1 and a.trx_status_code in (6,7)
)a	
inner join temp_mf_new_modify_order b
on a.vendor_trx_id = b.vendor_trx_id
);
--------------------------------------------------------------------

--/*--communications (SIP Modify)

insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,
orderid,clientcode,clientname,orderdate,fundname,amount,
sip_start_date,sip_end_date,frequency,mandateid,sourceid,
subcategoryid,subcategory,is_picked,modify_order_type
,emp_code,partner_code
)
-----------SIP-Modify
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,c.inv_type,
b.trx_id,a.txnid as vendor_trx_id,
b.display_trx_id as orderid,
a.clientcode,INITCAP(a.clientname)::character varying as clientname,
(c.trx_datetime::date)::character varying as orderdate,
INITCAP(c.isinname) as fundname,
a.amount::character varying as amount,
a.sipstartdate::character varying as sip_start_date,
a.sipenddate::character varying as sip_end_date,
a.frequency::character varying as frequency,
a.mandateid::character varying as mandateid,
'82'::character varying as sourceid,
'3564'::character varying as subcategoryid,
'SIP_MODIFY_ORDER_CONFIMRATION_Internal'::character varying subcategory,
false as is_picked,
'Modification'::character varying as modify_order_type
,b.orderby as emp_code,
''::character varying as partner_code
from temp_mf_new_modify_order a
inner join transactions.mf_order_summary_modify_log b
on a.vendor_trx_id = b.vendor_trx_id
inner join transactions.mf_order_detail c
on a.txnid  = c.vendor_trx_id
inner join master.trx_type mst
on b.trx_type_code = mst.trx_type_code
and category_code=261;

------------------End To Handle SIP Modify
	
--------------------------------------------------------------
--/*--communications

insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked,count_installment_pause
,emp_code,partner_code
)
-----------SIP
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
src.schemename as fundname,
src.amount::character varying as amount,
src.units::character varying as units,
src.orderremarks as rejection_reason,
reg.upcoming_due_date::character varying as next_due_date,
src.startdate::character varying as sip_start_date,
src.enddate::character varying as sip_end_date,
src.sipfrequency::character varying as frequency,
coalesce(src.tenure,0)::character varying as installment_number,
mad.bankname::character varying as bankname,
mad.bank_ac_number::character varying as bankacno,
'82'::character varying as sourceid,
(case 
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='FRESH'  then '3573'
when mst.trx_type_code=1 and upper(src.status)='REJECTED' and upper(src.ordertype)='FRESH' then '3559'
when mst.trx_type_code=1 and upper(src.status)='CANCELLED' and upper(src.ordertype)='CANCEL' then '3576'
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='CANCEL' then '3577'
when mst.trx_type_code=1 and upper(src.status)='PAUSE' and upper(src.ordertype)='FRESH' then '3581'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='FRESH' then 'TRADE_CONFIRMATION_SIP_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='REJECTED' and upper(src.ordertype)='FRESH' then 'MF_SIP_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='CANCELLED' and upper(src.ordertype)='CANCEL' then 'SIP_CANCELLATION_CONFIRMATION_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='CANCEL'then 'SIP_CANCELLATION_REJECTION_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='PAUSE' and upper(src.ordertype)='FRESH' then 'SIP_PAUSE_ORDER_CONFIRMATION_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked,
reg.no_of_installment_paused::character varying as count_installment_pause
,(case when dest.order_placed_by='RM' then coalesce(dest.created_for,dest.orderby)
when dest.order_placed_by='CLIENT' and ucc.user_type='E' then dest.rm_partner_code end)::character varying as emp_code,
(case when dest.order_placed_by='PARTNER' then ucc.partnerowner
when dest.order_placed_by='CLIENT' and ucc.user_type='P' then ucc.partnerowner end)::character varying as partner_code
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_sip src 
on dest.vendor_trx_id = src.txnid
join transactions.mf_order_summary reg
on reg.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code and mst.category_code=261
join transactions.mf_mandate mad
on src.mandateid = mad.mandateid
join master.dim_ucc ucc on ucc.ucccode= dest.ucccode
where dest.trx_type_code= 1 --and src.txnid=1076398
and (
coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
or upper(dest.order_type) <> upper(src.ordertype)
)
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED','PAUSE')
--and dest.order_placed_by='RM'
and dest.datasource='DION'
and src.txnid not in (
	select a.txnid from (
	select a.txnid from temp_mf_new_modify_order a
	union
	select a.vendor_trx_id as txnid from temp_mf_new_modify_order a
	)a
);

	
--*/

------------------------------------------
---to update lead status

insert into transactions.auto_leadstatus_reject(trx_id)
select dest.trx_id
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_SIP src 
on dest.vendor_trx_id = src.txnid
where dest.trx_type_code= 1
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and dest.order_placed_by='RM'
and dest.datasource='DION';
------------------------------------------

IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_SIP)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
	SELECT dest.trx_id as txnid 
	FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_SIP src 
	ON dest.vendor_trx_id = src.txnid
	WHERE (
			COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
			OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
			OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
			OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
			OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
			OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
			OR COALESCE(dest.is_generatetoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
			OR COALESCE(dest.order_type,'')<>COALESCE(upper(src.ordertype),'')
			OR COALESCE(dest.vendor_paymentstatus,'') <> COALESCE(src.paymentstatus,'')::character varying 
	)
	and src.txnid not in (
		select a.txnid from (
		select a.txnid from temp_mf_new_modify_order a
		union
		select a.vendor_trx_id as txnid from temp_mf_new_modify_order a
		)a
	);
	
UPDATE transactions.mf_order_detail dest 
SET
	trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
	,modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
	,nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
	,navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
	,order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
	,tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
	,euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
	,vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
	,order_type= case when COALESCE(dest.order_type,'')<>COALESCE(upper(src.ordertype),'') then COALESCE(upper(src.ordertype),'') ELSE dest.order_type END
	,modified_date =  NOW() at time zone 'Asia/Kolkata'
	, vendor_paymentstatus = CASE WHEN COALESCE(dest.vendor_paymentstatus,'') <> COALESCE(src.paymentstatus,'') THEN src.paymentstatus ELSE dest.vendor_paymentstatus END
FROM transactions.stg_dion_orderbook_SIP src
WHERE dest.vendor_trx_id = src.txnid
and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
----------------------------------------------------------------------------
---Check Status change
CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx_status AS
SELECT dest.trx_id as txnid 
FROM transactions.mf_order_detail dest 
JOIN transactions.stg_dion_orderbook_SIP src
ON dest.vendor_trx_id = src.txnid
WHERE (COALESCE(dest.vendor_trx_status,'') <> UPPER(src.status))
	and src.txnid not in (
		select a.txnid from (
		select a.txnid from temp_mf_new_modify_order a
		union
		select a.vendor_trx_id as txnid from temp_mf_new_modify_order a
		)a
	);	
----------------------------------------------------------------------------
UPDATE transactions.mf_order_detail dest 
SET
vendor_trx_status = UPPER(src.status)
,trx_status = trx_sts.trx_status
,trx_status_code = sts.trx_status_code
,inv_action = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 4)
				   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 2)
				   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 1) ELSE dest.inv_action END
,inv_action_code = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN 4
						WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN 2
						WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN 1 ELSE dest.inv_action_code END
,modified_date = NOW() AT TIME ZONE 'Asia/Kolkata'
FROM transactions.stg_dion_orderbook_SIP src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and dest.trx_id in (select txnid from temp_exist_mf_trx_status);

-------Orders not placed by One Platform
UPDATE transactions.mf_order_detail dest 
SET
	vendor_trx_status = UPPER(src.status)
	,trx_status = trx_sts.trx_status
	,trx_status_code = sts.trx_status_code
	,inv_action_code = case when UPPER(src.status)='CANCELLED' then 4 
							when UPPER(src.status)='PAUSE' then 2 end
	,inv_action = case when UPPER(src.status)='CANCELLED' then 'CANCELLED'
							when UPPER(src.status)='PAUSE' then 'PAUSE' end
	,modified_date = NOW() at time zone 'Asia/Kolkata'
FROM transactions.stg_dion_orderbook_SIP src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and dest.trx_id in (select txnid from temp_exist_mf_trx_status)
and UPPER(src.status) in ('CANCELLED','PAUSE')	;

-----------------------------------------------
UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status ,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B -- master schema name added
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
--AND D.is_generatetoday = B.is_generatetoday
AND B.is_generatetoday = CASE WHEN D.inv_action_code <> 1 THEN false ELSE D.is_generatetoday END
AND D.consent_status_code = B.consent_status_code
--AND coalesce (D.payment_status_code,0) = coalesce (B.payment_status_code,0)
AND coalesce (B.payment_status_code,0) = CASE WHEN D.inv_action_code <> 1 THEN 0 ELSE coalesce (D.payment_status_code,0) END
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id 
AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status);

--To Handle eCollect
update transactions.mf_order_detail a
set 
final_status = case when a.vendor_trx_status='ORDERED' then 'Completed'
				when a.vendor_trx_status='REJECTED' then 'Order Rejected' end,
trx_final_status_code = case when a.vendor_trx_status='ORDERED' then 4
				when a.vendor_trx_status='REJECTED' then 2 end,
inv_plan_status_code = case when a.vendor_trx_status='ORDERED' then 4
				when a.vendor_trx_status='REJECTED' then 3 end,
inv_plan_status = case when a.vendor_trx_status='ORDERED' then 'Active'
				when a.vendor_trx_status='REJECTED' then 'Order Rejected' end
where a.trx_type_code=1
and	a.payment_method='eCollect' 
and a.final_status is null
and a.vendor_trx_status in ('ORDERED','REJECTED')
and a.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status);

---to Handle ACCEPTED status
update transactions.mf_order_detail
set 
trx_final_status_code = 5,
final_status = 'Order In Progress',
inv_plan_status_code = 6,
inv_plan_status = 'Order in Progress'
where trx_type_code=1
and final_status is null
and vendor_trx_status ='ACCEPTED'
and trx_id in (select txnid from temp_exist_mf_trx_status);

	/*
	 one time / full load 	
	UPDATE transactions.mf_order_detail org SET 
	isinname = B.isinname
	FROM transactions.mf_order_detail A 
	JOIN master.dim_mf_isin b on A.isincode=b.isincode 
	WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
	UPDATE transactions.mf_order_detail org SET 
	schemegroup = B.schemegroup
	FROM transactions.mf_order_detail A 
	JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
	WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
	UPDATE transactions.mf_order_detail org SET 
	return_type = B.return_type
	FROM transactions.mf_order_detail A 
	JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
		  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
	WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
	UPDATE transactions.mf_order_detail A 
	SET
	rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
								B.partner_code ELSE B.client_owner END,
	order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
							THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
							ELSE 'CLIENT' END::character varying
	FROM master.dim_ucc B 
	WHERE TRIM(A.ac_code) = B.priority_ac_code
	AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
	--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
	and A.trx_id > v_trx_id;
	
	update transactions.mf_order_detail a
	set consent_status_code =
		case when order_placed_by ='CLIENT' and physicalflag='D' then 0
		when order_placed_by ='CLIENT' and physicalflag='P' then 2
		when order_placed_by in ('RM','PARTNER') then 2 end,
		consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
		when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
		when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
	--where trx_id not in ( select txnid from temp_exist_mf_trx);
	where a.trx_id > v_trx_id;
	
	*/
	
----------Inserting Data into transaction History Table----------
UPDATE transactions.mf_order_detail_history A
SET valid_to = NOW() at time zone 'Asia/Kolkata', 
	is_active = false
FROM transactions.mf_order_detail b
where a.trx_id = b.trx_id	
and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status) 
AND A.is_active = true
and (
coalesce (a.trx_final_status_code,0) <> coalesce (b.trx_final_status_code,0)
or coalesce (a.consent_status_code,0) <> coalesce (b.consent_status_code,0)	
or coalesce (a.trx_status_code,0) <> coalesce (b.trx_status_code,0)
or coalesce (a.payment_status_code,0) <> coalesce (b.payment_status_code,0)
or coalesce (a.inv_plan_status_code,0) <> coalesce (b.inv_plan_status_code,0)
); 

INSERT INTO transactions.mf_order_detail_history
(
trx_id,vendor_trx_id,ucccode,ac_code,trx_datetime,is_active,trx_type_code,trx_type,
consent_status_code,consent_status,trx_status_code,trx_status,vendor_trx_status,
payment_status_code,payment_status,inv_plan_status_code,inv_plan_status,
trx_final_status_code,final_status,mandate_id,order_remarks,trx_source,
inserted_dt,valid_from
)
		
SELECT distinct 
a.trx_id,a.vendor_trx_id,a.ucccode,a.ac_code,a.trx_datetime,true as is_active,
a.trx_type_code,a.trx_type,a.consent_status_code,a.consent_status,a.trx_status_code,
a.trx_status,a.vendor_trx_status,a.payment_status_code,A.payment_status,
a.inv_plan_status_code,a.inv_plan_status,a.trx_final_status_code,a.final_status,
a.mandate_id,A.order_remarks,A.trx_source,NOW() at time zone 'Asia/Kolkata' as inserted_dt,
NOW() at time zone 'Asia/Kolkata' as valid_from		 
FROM transactions.mf_order_detail a join transactions.mf_order_detail_history b
on a.trx_id = b.trx_id 
WHERE a.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status)
and(
coalesce(a.trx_final_status_code,0) <> coalesce(b.trx_final_status_code,0)
or coalesce(a.consent_status_code,0) <> coalesce(b.consent_status_code,0)	
or coalesce(a.trx_status_code,0) <> coalesce(b.trx_status_code,0)
or coalesce(a.payment_status_code,0) <> coalesce(b.payment_status_code,0)
or coalesce(a.inv_plan_status_code,0) <> coalesce(b.inv_plan_status_code,0)
); 
	

UPDATE transactions.mf_order_detail_history 
SET 
valid_to = '9999-12-31'::timestamp without time zone 
WHERE trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status)
AND	is_active = true 
AND valid_to IS NULL;

----------Updating Data into Summary Table----------
UPDATE transactions.mf_order_summary A SET
trx_final_status_code = B.trx_final_status_code,
final_status = B.final_status,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
WHERE A.trx_id = B.trx_id
AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status);

---to Handle ACCEPTED status
update transactions.mf_order_summary
set 
trx_final_status_code = 5,
final_status = 'Order In Progress',
inv_plan_status_code = 4,
inv_plan_status = 'Active'
where trx_type_code=1
--and trx_final_status_code = 5
and final_status is null
and trx_status ='RUNNING'
and trx_id in (select txnid from temp_exist_mf_trx_status);

----------Updating Data into Order_modification Table----------
UPDATE transactions.mf_order_detail_modification org SET
trx_status =  sts.internal_status, trx_status_code = sts.trx_status_code, vendor_trx_status = UPPER(sts.vendor_status), 
	modified_date = NOW() AT TIME ZONE 'Asia/Kolkata'
--FROM transactions.mf_order_detail_modification mod
-- JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND mod.final_status <> 'Order Rejected'
AND sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
							   WHEN mod.inv_action_code = 2 THEN 5
							   WHEN mod.inv_action_code = 0 THEN 4 END;

UPDATE transactions.mf_order_detail_modification org SET
order_remarks = src.orderremarks
, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 8)
, trx_status_code = 8
, final_status = 'Order Rejected'
, trx_final_status_code = 2
, inv_plan_status_code = 7
, inv_plan_status = 'Order Rejected'
, modified_date = NOW() AT TIME ZONE 'Asia/Kolkata'
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND UPPER(mod.inv_action) = 'CANCEL' AND UPPER(src.status) = 'ORDERED';

UPDATE transactions.mf_order_detail_modification A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail_modification D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
/* AND D.is_generatetoday = B.is_generatetoday */
AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id IN
(SELECT mod.trx_id FROM transactions.mf_order_detail_modification mod
 JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
 JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
 JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
 WHERE sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
								  WHEN mod.inv_action_code = 2 THEN 5
								  WHEN mod.inv_action_code = 0 THEN 4 END
); 

---update the Resume status
update transactions.mf_order_detail_modification A set
trx_final_status_code = B.trx_final_status_code,
final_status = B.final_status,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
from transactions.mf_order_detail B
where A.org_trx_id=B.trx_id
and A.inv_action_code=0
and A.final_status is null;

-------------------------------------------------		
-- new trx insert
	
--SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

--drop table temp_mf_trx_new

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_new AS
SELECT src.txnid FROM transactions.stg_dion_orderbook_SIP src
left join transactions.mf_order_detail destn on src.txnid = destn.vendor_trx_id
where destn.vendor_trx_id is null
	and src.txnid not in (
		select a.txnid from (
		select a.txnid from temp_mf_new_modify_order a
		union
		select a.vendor_trx_id as txnid from temp_mf_new_modify_order a
		)a
	);	

--select * from temp_mf_trx_new
--where txnid=200266

INSERT INTO transactions.mf_order_detail(
vendor_trx_id,ac_code,"user_id",isincode,trx_type,trx_datetime,trx_amt,trx_qty,datasource,
orderby,delivery_mode,mandate_id,trx_status,payment_status,modified_date,modified_by,
trx_source,created_date,nav,navdate,order_nav,order_navdate,folio_no,order_type,
physicalflag,order_remarks,tokenno,switchtokenno,vendor_exchg_refno,ucccode,pan,
euinnumber,switch_isin,internal_flag,trx_type_code,trx_status_code,is_generatetoday,
inv_type_code,inv_type,inv_action_code,inv_action,vendor_trx_status,payment_status_code,
qty_or_amt_order,mf_schcode,isinname,schemegroup,vendor_paymentstatus)
		
SELECT 
src.txnid as vendor_trx_id,src.clientcode as ac_code,src.userid as "user_id",src.isin as isincode,
txn.trx_type as trx_type,(src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime,
case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) 
else src.amount end as trx_amt, 
coalesce(
case when coalesce(src.units,0) =0 then 
case when coalesce(src.ordernav,0)=0 then 0 
else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end 
end,0) as trx_qty,
'DION'::character varying as datasource, 
case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
src.traxmode as delivery_mode,src.mandateid as mandate_id,trx_sts.trx_status, 
case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
else dps.payment_status end payment_status,
src.lastmodifiedon as modified_date,src.lastmodifiedby as modified_by,
src.ordersource as trx_source,(src.txndate||' '||src.txntime)::timestamp without time zone as created_date,
src.nav,src.navdate,src.ordernav as order_nav,src.ordernavdate as order_navdate,src.foliono as folio_no, 
trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag,
src.orderremarks as order_remarks,src.token as tokenno,src.switchtoken as switchtokenno,
src.exchangerefno as vendor_exchg_refno,mst.ucccode,mst.pan,src.euinnumber, 
src.switchisin as switch_isin, 1 as internal_flag,trx.trx_type_code,sts.trx_status_code,
CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END as is_generatetoday,
txn.inv_type_code,inv.inv_type, 
case when trx_sts.trx_status_code=5 then 2 
when trx_sts.trx_status_code=3 then 4 else 1 end inv_action_code, 
(case when trx_sts.trx_status_code=5 then 'Pause'
when trx_sts.trx_status_code=3 then 'Cancel'
else 'Transaction' end ) ::character varying as inv_action,
UPPER(src.status) as vendor_trx_status, 
case when trim(upper(src.paymentstatus))='PAID' then 2
when trim(upper(src.paymentstatus))='UNPAID' then 1
when trim(upper(src.paymentstatus))='PROCESSING' then 1
when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
else PM.payment_status_code end payment_status_code,
case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
isin.mf_schcode,isin.isinname,sch.schemegroup,src.paymentstatus
FROM transactions.stg_dion_orderbook_SIP src
LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
inner join master.dim_mf_isin isin on src.isin=isin.isincode
JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
WHERE dest.trx_id IS NULL
and src.txnid not in (
	select a.txnid from (
	select a.txnid from temp_mf_new_modify_order a
	union
	select a.vendor_trx_id as txnid from temp_mf_new_modify_order a
	)a
);

UPDATE transactions.mf_order_detail A 
SET 
	display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
WHERE display_trx_id IS NULL;
			
UPDATE transactions.mf_order_detail A 
SET
	rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
								B.partner_code ELSE B.client_owner END,
	order_placed_by = CASE WHEN COALESCE(A.orderby,A.ac_code) <> A.ac_code
							THEN 
					CASE WHEN A.orderby = B.partner_code THEN 'PARTNER'
							ELSE 'RM' END
							ELSE 'CLIENT' END::character varying
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code
AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
--and A.trx_id > v_trx_id;
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);
		
UPDATE transactions.mf_order_detail org 
SET 
	return_type = B.return_type
	FROM transactions.mf_order_detail A 
	JOIN (
	SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
	FROM master.dim_mf_exchange_isin
	) B 
ON A.isincode = B.isincode AND A.tokenno = B."token"
WHERE A.trx_id = org.trx_id 
--AND org.trx_id >= v_trx_id;
and org.vendor_trx_id in (select txnid from temp_mf_trx_new);
	
----to be removed for incremental----
UPDATE transactions.mf_order_detail A 
SET consent_status_code = case 
	when inv_action_code in (2,4) and order_placed_by<>'CLIENT' then 2
	when physicalflag='P' and order_placed_by='CLIENT' then 2
	when order_placed_by<>'CLIENT' then 2 else 0 end,
	consent_status = case 
	when inv_action_code in (2,4) and order_placed_by<>'CLIENT' then 'Consent Approved'
	when physicalflag='P' and order_placed_by='CLIENT' then 'Consent Approved'
						when order_placed_by<>'CLIENT' then 'Consent Approved' else'' end,
	payment_status_code = case 
	when inv_action_code in (2,4) then 0
	when is_generatetoday=false then 0 
	when upper(vendor_paymentstatus) in ('UNPAID','PROCESSING') then 1 
	else 2 end,
	payment_status = case 
	when inv_action_code in (2,4) then ''
	when is_generatetoday=false then '' 
	when upper(vendor_paymentstatus) in ('UNPAID','PROCESSING') then 'Pending' 
	else 'Processed' end
WHERE --A.trx_id >= v_trx_id
A.vendor_trx_id in (select txnid from temp_mf_trx_new)
--	AND order_placed_by <> 'CLIENT'
AND consent_status_code IS NULL;

UPDATE transactions.mf_order_detail A 
set is_generatetoday= case when trx_status_code in (3,5) then false 
	else is_generatetoday end
--WHERE A.trx_id >= v_trx_id;
where A.vendor_trx_id in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_detail A 
SET
	final_status = B.trx_final_status,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
JOIN master.MV_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id 
--AND A.trx_id >= v_trx_id;
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);

------------For New Unpaid entries
update transactions.mf_order_detail 
set 
	vendor_trx_status='ACCEPTED',
	trx_status_code = 8,
	trx_status = 'Order Accepted',
	final_status = 'Order In Progress',
	trx_final_status_code = 5,
	inv_plan_status_code = 6,
	inv_plan_status = 'Order in Progress'
where vendor_trx_id in (select txnid from temp_mf_trx_new)
and payment_status_code=1;

update transactions.mf_order_summary a
set 
--	vendor_trx_status='ACCEPTED',
	trx_status_code = 8,
	trx_status = 'Order Accepted',
	final_status = 'Order In Progress',
	trx_final_status_code = 5,
	inv_plan_status_code = 6,
	inv_plan_status = 'Order in Progress'
	from transactions.mf_order_detail b
where a.vendor_trx_id in (select a.txnid from temp_mf_trx_new a)
and a.trx_id = b.trx_id
and b.payment_status_code=1;

----------Inserting Data into transaction History Table----------
INSERT INTO transactions.mf_order_detail_history(
trx_id,vendor_trx_id,ucccode,ac_code,trx_datetime,is_active,trx_type_code,trx_type,
consent_status_code,consent_status,trx_status_code,trx_status,vendor_trx_status,
payment_status_code,payment_status,inv_plan_status_code,inv_plan_status,
trx_final_status_code,final_status,mandate_id,order_remarks,trx_source,inserted_dt,
valid_from
)
SELECT 
A.trx_id,A.vendor_trx_id,A.ucccode,A.ac_code,A.trx_datetime,true as is_active,
a.trx_type_code,A.trx_type,A.consent_status_code,A.consent_status,A.trx_status_code,
A.trx_status,A.vendor_trx_status,A.payment_status_code,A.payment_status,
a.inv_plan_status_code,a.inv_plan_status,a.trx_final_status_code,a.final_status,
a.mandate_id,A.order_remarks,A.trx_source,NOW() at time zone 'Asia/Kolkata' as inserted_dt,
NOW() at time zone 'Asia/Kolkata' as valid_from
FROM transactions.mf_order_detail A 
WHERE --A.trx_id >= v_trx_id
A.vendor_trx_id in (select txnid from temp_mf_trx_new)
and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
WHERE A.trx_id = B.trx_id
);

UPDATE transactions.mf_order_detail_history 
SET 
	valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true 
AND valid_to IS NULL;
----------------------------------------------------
DROP TABLE temp_exist_mf_trx; 
DROP TABLE temp_exist_mf_trx_status;
DROP TABLE temp_mf_trx_new;
DROP TABLE temp_mf_new_modify_order;
----------------------------------------------------
------------------------------------------------------------------------------------------
-- Error Transaction
--truncate table transactions.mf_order_detail_error
--DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';

DELETE FROM transactions.mf_order_detail_error A
WHERE EXISTS (SELECT B.txnid FROM transactions.stg_dion_orderbook_SIP B 
WHERE A.vendor_trx_id = B.txnid);

INSERT INTO transactions.mf_order_detail_error(
vendor_trx_id,ac_code,"user_id",isincode,trx_type,trx_datetime,trx_amt,trx_qty,datasource, 
orderby,delivery_mode,mandate_id,trx_status,payment_status,modified_date,modified_by,
trx_source,created_date,nav,navdate,order_nav,order_navdate,folio_no,order_type,physicalflag, order_remarks,
tokenno,switchtokenno,vendor_exchg_refno,ucccode,pan,euinnumber,switch_isin,internal_flag,
trx_type_code,trx_status_code,is_generatetoday,inv_type_code,inv_type,inv_action_code,
inv_action,vendor_trx_status,payment_status_code,qty_or_amt_order,mf_schcode,isinname,
schemegroup,error_message)
SELECT 
src.txnid AS vendor_trx_id,src.clientcode AS ac_code,src.userid AS "user_id", 
src.isin AS isincode,txn.trx_type AS trx_type,
(src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS trx_datetime, 
CASE 
	WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) 
	ELSE src.amount 
END AS trx_amt, 
COALESCE(
	CASE 
		WHEN COALESCE(src.units, 0) = 0 THEN 
			CASE 
				WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
				ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) 
			END 
	END, 0
) AS trx_qty,
'DION'::character varying as datasource, 
CASE 
	WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode 
	ELSE src.orderedby 
END AS orderedby,
src.traxmode AS delivery_mode,src.mandateid AS mandate_id,trx_sts.trx_status, 
CASE 
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 'Processed'
	WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
	ELSE dps.payment_status 
END AS payment_status,
src.lastmodifiedon AS modified_date,src.lastmodifiedby AS modified_by,
src.ordersource AS trx_source, 
(src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS created_date, 
src.nav,src.navdate,src.ordernav AS order_nav,src.ordernavdate AS order_navdate, 
src.foliono AS folio_no,TRIM(UPPER(src.ordertype)) AS order_type, 
COALESCE(src.physicalflag,'D') AS physicalflag,src.orderremarks AS order_remarks,
src.token AS tokenno,src.switchtoken AS switchtokenno,
src.exchangerefno AS vendor_exchg_refno,mst.ucccode,mst.pan,src.euinnumber,
src.switchisin AS switch_isin,1 AS internal_flag,trx.trx_type_code,sts.trx_status_code,
CASE 
	WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE 
	ELSE FALSE 
END AS is_generatetoday,
txn.inv_type_code,inv.inv_type,1 AS inv_action_code, 
'Transaction'::character varying AS inv_action, 
UPPER(src.status) AS vendor_trx_status,
CASE 
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 2
	WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 1
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 1
	WHEN TRIM(UPPER(COALESCE(src.paymentstatus, ''))) = '' THEN 0
	ELSE pm.payment_status_code 
END AS payment_status_code,
CASE 
	WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' 
	ELSE 'Q' 
END AS qty_or_amt_order,
isin.mf_schcode,isin.isinname,sch.schemegroup,
CONCAT(
CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END) AS error_message
FROM transactions.stg_dion_orderbook_SIP src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.map_vendor_internal_payment_status pm ON pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (
mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL
);
/*
ON CONFLICT (vendor_trx_id) 
DO UPDATE SET 
	ac_code = EXCLUDED.ac_code,
	"user_id" = EXCLUDED."user_id",
	isincode = EXCLUDED.isincode,
	trx_type = EXCLUDED.trx_type,
	trx_datetime = EXCLUDED.trx_datetime,
	trx_amt = EXCLUDED.trx_amt,
	trx_qty = EXCLUDED.trx_qty,
	datasource = EXCLUDED.datasource,
	orderby = EXCLUDED.orderby,
	delivery_mode = EXCLUDED.delivery_mode,
	mandate_id = EXCLUDED.mandate_id,
	trx_status = EXCLUDED.trx_status,
	payment_status = EXCLUDED.payment_status,
	modified_date = EXCLUDED.modified_date,
	modified_by = EXCLUDED.modified_by,
	trx_source = EXCLUDED.trx_source,
	created_date = EXCLUDED.created_date,
	nav = EXCLUDED.nav,
	navdate = EXCLUDED.navdate,
	order_nav = EXCLUDED.order_nav,
	order_navdate = EXCLUDED.order_navdate,
	folio_no = EXCLUDED.folio_no,
	order_type = EXCLUDED.order_type,
	physicalflag = EXCLUDED.physicalflag,
	order_remarks = EXCLUDED.order_remarks,
	tokenno = EXCLUDED.tokenno,
	switchtokenno = EXCLUDED.switchtokenno,
	vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
	ucccode = EXCLUDED.ucccode,
	pan = EXCLUDED.pan,
	euinnumber = EXCLUDED.euinnumber,
	switch_isin = EXCLUDED.switch_isin,
	internal_flag = EXCLUDED.internal_flag,
	trx_type_code = EXCLUDED.trx_type_code,
	trx_status_code = EXCLUDED.trx_status_code,
	is_generatetoday = EXCLUDED.is_generatetoday,
	inv_type_code = EXCLUDED.inv_type_code,
	inv_type = EXCLUDED.inv_type,
	inv_action_code = EXCLUDED.inv_action_code,
	inv_action = EXCLUDED.inv_action,
	vendor_trx_status = EXCLUDED.vendor_trx_status,
	payment_status_code = EXCLUDED.payment_status_code,
	qty_or_amt_order = EXCLUDED.qty_or_amt_order,
	mf_schcode = EXCLUDED.mf_schcode,
	isinname = EXCLUDED.isinname,
	schemegroup = EXCLUDED.schemegroup,
	error_message = EXCLUDED.error_message;
*/
---------------------------------------------------------------------------------------------------	
				
	RETURN 'SUCCESS';

ELSE
	
	RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
	RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_sip() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_09may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;
BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_SIP
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
	FROM transactions.stg_dion_orderbook_SIP
	)
	delete FROM transactions.stg_dion_orderbook_SIP
	WHERE ctid IN (	
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

--/*--communications

insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked
)
-----------SIP
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
src.schemename as fundname,
src.amount::character varying as amount,
src.units::character varying as units,
src.orderremarks as rejection_reason,
reg.upcoming_due_date::character varying as next_due_date,
src.startdate::character varying as sip_start_date,
src.enddate::character varying as sip_end_date,
src.sipfrequency::character varying as frequency,
coalesce(src.tenure,0)::character varying as installment_number,
mad.bankname::character varying as bankname,
mad.bank_ac_number::character varying as bankacno,
'82'::character varying as sourceid,
(case 
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='FRESH'  then '3573'
when mst.trx_type_code=1 and upper(src.status)='REJECTED' and upper(src.ordertype)='FRESH' then '3559'
when mst.trx_type_code=1 and upper(src.status)='CANCELLED' and upper(src.ordertype)='CANCEL' then '3576'
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='CANCEL' then '3577'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='FRESH' then 'TRADE_CONFIRMATION_SIP_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='REJECTED' and upper(src.ordertype)='FRESH' then 'MF_SIP_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='CANCELLED' and upper(src.ordertype)='CANCEL' then 'SIP_CANCELLATION_CONFIRMATION_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='CANCEL'then 'SIP_CANCELLATION_REJECTION_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_sip src 
on dest.vendor_trx_id = src.txnid
join transactions.mf_order_summary reg
on reg.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code
join transactions.mf_mandate mad
on src.mandateid = mad.mandateid
where dest.trx_type_code= 1 
and (
coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
or upper(dest.order_type) <> upper(src.ordertype)
)
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/

------------------------------------------
---to update lead status

insert into transactions.auto_leadstatus_reject(trx_id)
select dest.trx_id
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_SIP src 
on dest.vendor_trx_id = src.txnid
where dest.trx_type_code= 1
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and dest.order_placed_by='RM'
and dest.datasource='DION';
------------------------------------------

IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_SIP)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
	SELECT dest.trx_id as txnid 
	FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_SIP src 
	ON dest.vendor_trx_id = src.txnid
	WHERE (
			COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
			OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
			OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
			OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
			OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
			OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
			OR COALESCE(dest.is_generatetoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
			OR COALESCE(dest.order_type,'')<>COALESCE(upper(src.ordertype),'')
	);
	
UPDATE transactions.mf_order_detail dest 
SET
	trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
	,modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
	,nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
	,navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
	,order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
	,tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
	,euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
	,vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
	,order_type= case when COALESCE(dest.order_type,'')<>COALESCE(upper(src.ordertype),'') then COALESCE(upper(src.ordertype),'') ELSE dest.order_type END
	,modified_date = NOW()
FROM transactions.stg_dion_orderbook_SIP src
WHERE dest.vendor_trx_id = src.txnid
and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
----------------------------------------------------------------------------
---Check Status change
CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx_status AS
SELECT dest.trx_id as txnid 
FROM transactions.mf_order_detail dest 
JOIN transactions.stg_dion_orderbook_SIP src
ON dest.vendor_trx_id = src.txnid
WHERE (COALESCE(dest.vendor_trx_status,'') <> UPPER(src.status));
----------------------------------------------------------------------------
UPDATE transactions.mf_order_detail dest 
SET
	vendor_trx_status = UPPER(src.status)
	,trx_status = trx_sts.trx_status
	,trx_status_code = sts.trx_status_code
	,inv_action = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 4)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 2)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 1) ELSE dest.inv_action END
	,inv_action_code = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN 4
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN 2
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN 1 ELSE dest.inv_action_code END
	,modified_date = NOW()
FROM transactions.stg_dion_orderbook_SIP src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and dest.trx_id in (select txnid from temp_exist_mf_trx_status);

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status ,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B -- master schema name added
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
--AND D.is_generatetoday = B.is_generatetoday
AND B.is_generatetoday = CASE WHEN D.inv_action_code <> 1 THEN false ELSE D.is_generatetoday END
AND D.consent_status_code = B.consent_status_code
--AND coalesce (D.payment_status_code,0) = coalesce (B.payment_status_code,0)
AND coalesce (B.payment_status_code,0) = CASE WHEN D.inv_action_code <> 1 THEN 0 ELSE coalesce (D.payment_status_code,0) END
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id 
AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status);

	/*
	 one time / full load 	
	UPDATE transactions.mf_order_detail org SET 
	isinname = B.isinname
	FROM transactions.mf_order_detail A 
	JOIN master.dim_mf_isin b on A.isincode=b.isincode 
	WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
	UPDATE transactions.mf_order_detail org SET 
	schemegroup = B.schemegroup
	FROM transactions.mf_order_detail A 
	JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
	WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
	UPDATE transactions.mf_order_detail org SET 
	return_type = B.return_type
	FROM transactions.mf_order_detail A 
	JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
		  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
	WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
	UPDATE transactions.mf_order_detail A 
	SET
	rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
								B.partner_code ELSE B.client_owner END,
	order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
							THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
							ELSE 'CLIENT' END::character varying
	FROM master.dim_ucc B 
	WHERE TRIM(A.ac_code) = B.priority_ac_code
	AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
	--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
	and A.trx_id > v_trx_id;
	
	update transactions.mf_order_detail a
	set consent_status_code =
		case when order_placed_by ='CLIENT' and physicalflag='D' then 0
		when order_placed_by ='CLIENT' and physicalflag='P' then 2
		when order_placed_by in ('RM','PARTNER') then 2 end,
		consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
		when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
		when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
	--where trx_id not in ( select txnid from temp_exist_mf_trx);
	where a.trx_id > v_trx_id;
	
	*/
	
----------Inserting Data into transaction History Table----------
UPDATE transactions.mf_order_detail_history A
SET valid_to = NOW(), 
	is_active = false
FROM transactions.mf_order_detail b
where a.trx_id = b.trx_id	
and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status) 
AND A.is_active = true
and (
coalesce (a.trx_final_status_code,0) <> coalesce (b.trx_final_status_code,0)
or coalesce (a.consent_status_code,0) <> coalesce (b.consent_status_code,0)	
or coalesce (a.trx_status_code,0) <> coalesce (b.trx_status_code,0)
or coalesce (a.payment_status_code,0) <> coalesce (b.payment_status_code,0)
or coalesce (a.inv_plan_status_code,0) <> coalesce (b.inv_plan_status_code,0)
); 

INSERT INTO transactions.mf_order_detail_history
(
trx_id,vendor_trx_id,ucccode,ac_code,trx_datetime,is_active,trx_type_code,trx_type,
consent_status_code,consent_status,trx_status_code,trx_status,vendor_trx_status,
payment_status_code,payment_status,inv_plan_status_code,inv_plan_status,
trx_final_status_code,final_status,mandate_id,order_remarks,trx_source,
inserted_dt,valid_from
)
		
SELECT distinct 
a.trx_id,a.vendor_trx_id,a.ucccode,a.ac_code,a.trx_datetime,true as is_active,
a.trx_type_code,a.trx_type,a.consent_status_code,a.consent_status,a.trx_status_code,
a.trx_status,a.vendor_trx_status,a.payment_status_code,A.payment_status,
a.inv_plan_status_code,a.inv_plan_status,a.trx_final_status_code,a.final_status,
a.mandate_id,A.order_remarks,A.trx_source,now() as inserted_dt,now() as valid_from		 
FROM transactions.mf_order_detail a join transactions.mf_order_detail_history b
on a.trx_id = b.trx_id 
WHERE a.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status)
and(
coalesce(a.trx_final_status_code,0) <> coalesce(b.trx_final_status_code,0)
or coalesce(a.consent_status_code,0) <> coalesce(b.consent_status_code,0)	
or coalesce(a.trx_status_code,0) <> coalesce(b.trx_status_code,0)
or coalesce(a.payment_status_code,0) <> coalesce(b.payment_status_code,0)
or coalesce(a.inv_plan_status_code,0) <> coalesce(b.inv_plan_status_code,0)
); 
	

UPDATE transactions.mf_order_detail_history 
SET 
	valid_to = '9999-12-31'::timestamp without time zone 
WHERE trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status)
AND	is_active = true 
AND valid_to IS NULL;

----------Updating Data into Summary Table----------
UPDATE transactions.mf_order_summary A SET
trx_final_status_code = B.trx_final_status_code,
final_status = B.final_status,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
WHERE A.trx_id = B.trx_id
AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status);

----------Updating Data into Order_modification Table----------
UPDATE transactions.mf_order_detail_modification org SET
trx_status =  sts.internal_status, trx_status_code = sts.trx_status_code, vendor_trx_status = UPPER(sts.vendor_status), modified_date = NOW()
--FROM transactions.mf_order_detail_modification mod
-- JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action) AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND mod.final_status <> 'Order Rejected'
AND sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
							   WHEN mod.inv_action_code = 2 THEN 5
							   WHEN mod.inv_action_code = 0 THEN 4 END;

UPDATE transactions.mf_order_detail_modification org SET
order_remarks = src.orderremarks
, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 8)
, trx_status_code = 8
, final_status = 'Order Rejected'
, trx_final_status_code = 8
, inv_plan_status_code = 7
, inv_plan_status = 'Order Rejected'
, modified_date = NOW()
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action) AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND UPPER(mod.inv_action) = 'CANCEL' AND UPPER(src.status) = 'ORDERED';

UPDATE transactions.mf_order_detail_modification A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail_modification D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
/* AND D.is_generatetoday = B.is_generatetoday */
AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id IN
(SELECT mod.trx_id FROM transactions.mf_order_detail_modification mod
 JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
 JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
 JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
 WHERE sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
								  WHEN mod.inv_action_code = 2 THEN 5
								  WHEN mod.inv_action_code = 0 THEN 4 END
); 

		
-------------------------------------------------		
-- new trx insert
	
--SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

--drop table temp_mf_trx_new

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_new AS
SELECT src.txnid FROM transactions.stg_dion_orderbook_SIP src
left join transactions.mf_order_detail destn on src.txnid = destn.vendor_trx_id
where destn.vendor_trx_id is null;

--select * from temp_mf_trx_new
--where txnid=200266

INSERT INTO transactions.mf_order_detail(
vendor_trx_id,ac_code,"user_id",isincode,trx_type,trx_datetime,trx_amt,trx_qty,datasource,
orderby,delivery_mode,mandate_id,trx_status,payment_status,modified_date,modified_by,
trx_source,created_date,nav,navdate,order_nav,order_navdate,folio_no,order_type,
physicalflag,order_remarks,tokenno,switchtokenno,vendor_exchg_refno,ucccode,pan,
euinnumber,switch_isin,internal_flag,trx_type_code,trx_status_code,is_generatetoday,
inv_type_code,inv_type,inv_action_code,inv_action,vendor_trx_status,payment_status_code,
qty_or_amt_order,mf_schcode,isinname,schemegroup)
		
SELECT 
src.txnid as vendor_trx_id,src.clientcode as ac_code,src.userid as "user_id",src.isin as isincode,
txn.trx_type as trx_type,(src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime,
case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) 
else src.amount end as trx_amt, 
coalesce(
case when coalesce(src.units,0) =0 then 
case when coalesce(src.ordernav,0)=0 then 0 
else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end 
end,0) as trx_qty,
'DION'::character varying as datasource, 
case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
src.traxmode as delivery_mode,src.mandateid as mandate_id,trx_sts.trx_status, 
case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
else dps.payment_status end payment_status,
src.lastmodifiedon as modified_date,src.lastmodifiedby as modified_by,
src.ordersource as trx_source,(src.txndate||' '||src.txntime)::timestamp without time zone as created_date,
src.nav,src.navdate,src.ordernav as order_nav,src.ordernavdate as order_navdate,src.foliono as folio_no, 
trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag,
src.orderremarks as order_remarks,src.token as tokenno,src.switchtoken as switchtokenno,
src.exchangerefno as vendor_exchg_refno,mst.ucccode,mst.pan,src.euinnumber, 
src.switchisin as switch_isin, 1 as internal_flag,trx.trx_type_code,sts.trx_status_code,
CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END as is_generatetoday,
txn.inv_type_code,inv.inv_type, 
case when trx_sts.trx_status_code=5 then 2 
when trx_sts.trx_status_code=3 then 4 else 1 end inv_action_code, 
(case when trx_sts.trx_status_code=5 then 'Pause'
when trx_sts.trx_status_code=3 then 'Cancel'
else 'Transaction' end ) ::character varying as inv_action,
UPPER(src.status) as vendor_trx_status, 
case when trim(upper(src.paymentstatus))='PAID' then 2
when trim(upper(src.paymentstatus))='UNPAID' then 1
when trim(upper(src.paymentstatus))='PROCESSING' then 1
when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
else PM.payment_status_code end payment_status_code,
case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
isin.mf_schcode,isin.isinname,sch.schemegroup
FROM transactions.stg_dion_orderbook_SIP src
LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
inner join master.dim_mf_isin isin on src.isin=isin.isincode
JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
WHERE dest.trx_id IS NULL;

UPDATE transactions.mf_order_detail A 
SET 
	display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
WHERE display_trx_id IS NULL;
			
UPDATE transactions.mf_order_detail A 
SET
	rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
								B.partner_code ELSE B.client_owner END,
	order_placed_by = CASE WHEN COALESCE(A.orderby,A.ac_code) <> A.ac_code
							THEN 
					CASE WHEN A.orderby = B.partner_code THEN 'PARTNER'
							ELSE 'RM' END
							ELSE 'CLIENT' END::character varying
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code
AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
--and A.trx_id > v_trx_id;
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);
		
UPDATE transactions.mf_order_detail org 
SET 
	return_type = B.return_type
	FROM transactions.mf_order_detail A 
	JOIN (
	SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
	FROM master.dim_mf_exchange_isin
	) B 
ON A.isincode = B.isincode AND A.tokenno = B."token"
WHERE A.trx_id = org.trx_id 
--AND org.trx_id >= v_trx_id;
and org.vendor_trx_id in (select txnid from temp_mf_trx_new);
	
----to be removed for incremental----
UPDATE transactions.mf_order_detail A 
SET consent_status_code = case 
	when inv_action_code in (2,4) and order_placed_by<>'CLIENT' then 2
	when physicalflag='P' and order_placed_by='CLIENT' then 2
	when order_placed_by<>'CLIENT' then 2 else 0 end,
	consent_status = case 
	when inv_action_code in (2,4) and order_placed_by<>'CLIENT' then 'Consent Approved'
	when physicalflag='P' and order_placed_by='CLIENT' then 'Consent Approved'
						when order_placed_by<>'CLIENT' then 'Consent Approved' else'' end,
	payment_status_code = case 
	when inv_action_code in (2,4) then 0
	when is_generatetoday=false then 0 else 2 end,
	payment_status = case 
	when inv_action_code in (2,4) then ''
	when is_generatetoday=false then '' else 'Processed' end
WHERE --A.trx_id >= v_trx_id
A.vendor_trx_id in (select txnid from temp_mf_trx_new)
--	AND order_placed_by <> 'CLIENT'
AND consent_status_code IS NULL;

UPDATE transactions.mf_order_detail A 
set is_generatetoday= case when trx_status_code in (3,5) then false 
	else is_generatetoday end
--WHERE A.trx_id >= v_trx_id;
where A.vendor_trx_id in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_detail A 
SET
	final_status = B.trx_final_status,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
JOIN master.MV_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id 
--AND A.trx_id >= v_trx_id;
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);

----------Inserting Data into transaction History Table----------
INSERT INTO transactions.mf_order_detail_history(
trx_id,vendor_trx_id,ucccode,ac_code,trx_datetime,is_active,trx_type_code,trx_type,
consent_status_code,consent_status,trx_status_code,trx_status,vendor_trx_status,
payment_status_code,payment_status,inv_plan_status_code,inv_plan_status,
trx_final_status_code,final_status,mandate_id,order_remarks,trx_source,inserted_dt,
valid_from
)
SELECT 
A.trx_id,A.vendor_trx_id,A.ucccode,A.ac_code,A.trx_datetime,true as is_active,
a.trx_type_code,A.trx_type,A.consent_status_code,A.consent_status,A.trx_status_code,
A.trx_status,A.vendor_trx_status,A.payment_status_code,A.payment_status,
a.inv_plan_status_code,a.inv_plan_status,a.trx_final_status_code,a.final_status,
a.mandate_id,A.order_remarks,A.trx_source,now() as inserted_dt,now() as valid_from
FROM transactions.mf_order_detail A 
WHERE --A.trx_id >= v_trx_id
A.vendor_trx_id in (select txnid from temp_mf_trx_new)
and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
WHERE A.trx_id = B.trx_id
);

UPDATE transactions.mf_order_detail_history 
SET 
	valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true 
AND valid_to IS NULL;
----------------------------------------------------
DROP TABLE temp_exist_mf_trx; 
DROP TABLE temp_exist_mf_trx_status;
DROP TABLE temp_mf_trx_new;
----------------------------------------------------
------------------------------------------------------------------------------------------
-- Error Transaction
--truncate table transactions.mf_order_detail_error
--DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';

DELETE FROM transactions.mf_order_detail_error A
WHERE EXISTS (SELECT B.txnid FROM transactions.stg_dion_orderbook_SIP B 
WHERE A.vendor_trx_id = B.txnid);

INSERT INTO transactions.mf_order_detail_error(
vendor_trx_id,ac_code,"user_id",isincode,trx_type,trx_datetime,trx_amt,trx_qty,datasource, 
orderby,delivery_mode,mandate_id,trx_status,payment_status,modified_date,modified_by,
trx_source,created_date,nav,navdate,order_nav,order_navdate,folio_no,order_type,physicalflag, order_remarks,
tokenno,switchtokenno,vendor_exchg_refno,ucccode,pan,euinnumber,switch_isin,internal_flag,
trx_type_code,trx_status_code,is_generatetoday,inv_type_code,inv_type,inv_action_code,
inv_action,vendor_trx_status,payment_status_code,qty_or_amt_order,mf_schcode,isinname,
schemegroup,error_message)
SELECT 
src.txnid AS vendor_trx_id,src.clientcode AS ac_code,src.userid AS "user_id", 
src.isin AS isincode,txn.trx_type AS trx_type,
(src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS trx_datetime, 
CASE 
	WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) 
	ELSE src.amount 
END AS trx_amt, 
COALESCE(
	CASE 
		WHEN COALESCE(src.units, 0) = 0 THEN 
			CASE 
				WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
				ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) 
			END 
	END, 0
) AS trx_qty,
'DION'::character varying as datasource, 
CASE 
	WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode 
	ELSE src.orderedby 
END AS orderedby,
src.traxmode AS delivery_mode,src.mandateid AS mandate_id,trx_sts.trx_status, 
CASE 
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 'Processed'
	WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
	ELSE dps.payment_status 
END AS payment_status,
src.lastmodifiedon AS modified_date,src.lastmodifiedby AS modified_by,
src.ordersource AS trx_source, 
(src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS created_date, 
src.nav,src.navdate,src.ordernav AS order_nav,src.ordernavdate AS order_navdate, 
src.foliono AS folio_no,TRIM(UPPER(src.ordertype)) AS order_type, 
COALESCE(src.physicalflag,'D') AS physicalflag,src.orderremarks AS order_remarks,
src.token AS tokenno,src.switchtoken AS switchtokenno,
src.exchangerefno AS vendor_exchg_refno,mst.ucccode,mst.pan,src.euinnumber,
src.switchisin AS switch_isin,1 AS internal_flag,trx.trx_type_code,sts.trx_status_code,
CASE 
	WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE 
	ELSE FALSE 
END AS is_generatetoday,
txn.inv_type_code,inv.inv_type,1 AS inv_action_code, 
'Transaction'::character varying AS inv_action, 
UPPER(src.status) AS vendor_trx_status,
CASE 
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 2
	WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 1
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 1
	WHEN TRIM(UPPER(COALESCE(src.paymentstatus, ''))) = '' THEN 0
	ELSE pm.payment_status_code 
END AS payment_status_code,
CASE 
	WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' 
	ELSE 'Q' 
END AS qty_or_amt_order,
isin.mf_schcode,isin.isinname,sch.schemegroup,
CONCAT(
CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END) AS error_message
FROM transactions.stg_dion_orderbook_SIP src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.map_vendor_internal_payment_status pm ON pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (
mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL
);
/*
ON CONFLICT (vendor_trx_id) 
DO UPDATE SET 
	ac_code = EXCLUDED.ac_code,
	"user_id" = EXCLUDED."user_id",
	isincode = EXCLUDED.isincode,
	trx_type = EXCLUDED.trx_type,
	trx_datetime = EXCLUDED.trx_datetime,
	trx_amt = EXCLUDED.trx_amt,
	trx_qty = EXCLUDED.trx_qty,
	datasource = EXCLUDED.datasource,
	orderby = EXCLUDED.orderby,
	delivery_mode = EXCLUDED.delivery_mode,
	mandate_id = EXCLUDED.mandate_id,
	trx_status = EXCLUDED.trx_status,
	payment_status = EXCLUDED.payment_status,
	modified_date = EXCLUDED.modified_date,
	modified_by = EXCLUDED.modified_by,
	trx_source = EXCLUDED.trx_source,
	created_date = EXCLUDED.created_date,
	nav = EXCLUDED.nav,
	navdate = EXCLUDED.navdate,
	order_nav = EXCLUDED.order_nav,
	order_navdate = EXCLUDED.order_navdate,
	folio_no = EXCLUDED.folio_no,
	order_type = EXCLUDED.order_type,
	physicalflag = EXCLUDED.physicalflag,
	order_remarks = EXCLUDED.order_remarks,
	tokenno = EXCLUDED.tokenno,
	switchtokenno = EXCLUDED.switchtokenno,
	vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
	ucccode = EXCLUDED.ucccode,
	pan = EXCLUDED.pan,
	euinnumber = EXCLUDED.euinnumber,
	switch_isin = EXCLUDED.switch_isin,
	internal_flag = EXCLUDED.internal_flag,
	trx_type_code = EXCLUDED.trx_type_code,
	trx_status_code = EXCLUDED.trx_status_code,
	is_generatetoday = EXCLUDED.is_generatetoday,
	inv_type_code = EXCLUDED.inv_type_code,
	inv_type = EXCLUDED.inv_type,
	inv_action_code = EXCLUDED.inv_action_code,
	inv_action = EXCLUDED.inv_action,
	vendor_trx_status = EXCLUDED.vendor_trx_status,
	payment_status_code = EXCLUDED.payment_status_code,
	qty_or_amt_order = EXCLUDED.qty_or_amt_order,
	mf_schcode = EXCLUDED.mf_schcode,
	isinname = EXCLUDED.isinname,
	schemegroup = EXCLUDED.schemegroup,
	error_message = EXCLUDED.error_message;
*/
---------------------------------------------------------------------------------------------------	
				
	RETURN 'SUCCESS';

ELSE
	
	RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
	RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_09may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_09may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_09may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_09may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_14jul2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_14jul2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;
BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_SIP
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
	FROM transactions.stg_dion_orderbook_SIP
	)
	delete FROM transactions.stg_dion_orderbook_SIP
	WHERE ctid IN (	
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

--/*--communications

insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked
)
-----------SIP
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
src.schemename as fundname,
src.amount::character varying as amount,
src.units::character varying as units,
src.orderremarks as rejection_reason,
reg.upcoming_due_date::character varying as next_due_date,
src.startdate::character varying as sip_start_date,
src.enddate::character varying as sip_end_date,
src.sipfrequency::character varying as frequency,
coalesce(src.tenure,0)::character varying as installment_number,
mad.bankname::character varying as bankname,
mad.bank_ac_number::character varying as bankacno,
'82'::character varying as sourceid,
(case 
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='FRESH'  then '3573'
when mst.trx_type_code=1 and upper(src.status)='REJECTED' and upper(src.ordertype)='FRESH' then '3559'
when mst.trx_type_code=1 and upper(src.status)='CANCELLED' and upper(src.ordertype)='CANCEL' then '3576'
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='CANCEL' then '3577'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='FRESH' then 'TRADE_CONFIRMATION_SIP_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='REJECTED' and upper(src.ordertype)='FRESH' then 'MF_SIP_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='CANCELLED' and upper(src.ordertype)='CANCEL' then 'SIP_CANCELLATION_CONFIRMATION_INTERNAL'
when mst.trx_type_code=1 and upper(src.status)='ORDERED' and upper(src.ordertype)='CANCEL'then 'SIP_CANCELLATION_REJECTION_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_sip src 
on dest.vendor_trx_id = src.txnid
join transactions.mf_order_summary reg
on reg.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code
and mst.category_code=261
join transactions.mf_mandate mad
on src.mandateid = mad.mandateid
where dest.trx_type_code= 1 
and (
coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
or upper(dest.order_type) <> upper(src.ordertype)
)
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/

------------------------------------------
---to update lead status

insert into transactions.auto_leadstatus_reject(trx_id)
select dest.trx_id
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_SIP src 
on dest.vendor_trx_id = src.txnid
where dest.trx_type_code= 1
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and dest.order_placed_by='RM'
and dest.datasource='DION';
------------------------------------------

IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_SIP)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
	SELECT dest.trx_id as txnid 
	FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_SIP src 
	ON dest.vendor_trx_id = src.txnid
	WHERE (
			COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
			OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
			OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
			OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
			OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
			OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
			OR COALESCE(dest.is_generatetoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
			OR COALESCE(dest.order_type,'')<>COALESCE(upper(src.ordertype),'')
	);
	
UPDATE transactions.mf_order_detail dest 
SET
	trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
	,modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
	,nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
	,navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
	,order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
	,tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
	,euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
	,vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
	,order_type= case when COALESCE(dest.order_type,'')<>COALESCE(upper(src.ordertype),'') then COALESCE(upper(src.ordertype),'') ELSE dest.order_type END
	,modified_date = NOW()
FROM transactions.stg_dion_orderbook_SIP src
WHERE dest.vendor_trx_id = src.txnid
and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
----------------------------------------------------------------------------
---Check Status change
CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx_status AS
SELECT dest.trx_id as txnid 
FROM transactions.mf_order_detail dest 
JOIN transactions.stg_dion_orderbook_SIP src
ON dest.vendor_trx_id = src.txnid
WHERE (COALESCE(dest.vendor_trx_status,'') <> UPPER(src.status));
----------------------------------------------------------------------------
UPDATE transactions.mf_order_detail dest 
SET
	vendor_trx_status = UPPER(src.status)
	,trx_status = trx_sts.trx_status
	,trx_status_code = sts.trx_status_code
	,inv_action = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 4)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 2)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 1) ELSE dest.inv_action END
	,inv_action_code = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN 4
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN 2
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN 1 ELSE dest.inv_action_code END
	,modified_date = NOW()
FROM transactions.stg_dion_orderbook_SIP src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and dest.trx_id in (select txnid from temp_exist_mf_trx_status);

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status ,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B -- master schema name added
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
--AND D.is_generatetoday = B.is_generatetoday
AND B.is_generatetoday = CASE WHEN D.inv_action_code <> 1 THEN false ELSE D.is_generatetoday END
AND D.consent_status_code = B.consent_status_code
--AND coalesce (D.payment_status_code,0) = coalesce (B.payment_status_code,0)
AND coalesce (B.payment_status_code,0) = CASE WHEN D.inv_action_code <> 1 THEN 0 ELSE coalesce (D.payment_status_code,0) END
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id 
AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status);

--To Handle eCollect
update transactions.mf_order_detail a
set 
final_status = case when a.vendor_trx_status='ORDERED' then 'Completed'
				when a.vendor_trx_status='REJECTED' then 'Order Rejected' end,
trx_final_status_code = case when a.vendor_trx_status='ORDERED' then 4
				when a.vendor_trx_status='REJECTED' then 8 end,
inv_plan_status_code = case when a.vendor_trx_status='ORDERED' then 4
				when a.vendor_trx_status='REJECTED' then 7 end,
inv_plan_status = case when a.vendor_trx_status='ORDERED' then 'Active'
				when a.vendor_trx_status='REJECTED' then 'Order Rejected' end
where a.trx_type_code=1
and	a.payment_method='eCollect' 
and a.final_status is null
and a.vendor_trx_status in ('ORDERED','REJECTED');

	/*
	 one time / full load 	
	UPDATE transactions.mf_order_detail org SET 
	isinname = B.isinname
	FROM transactions.mf_order_detail A 
	JOIN master.dim_mf_isin b on A.isincode=b.isincode 
	WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
	UPDATE transactions.mf_order_detail org SET 
	schemegroup = B.schemegroup
	FROM transactions.mf_order_detail A 
	JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
	WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
	UPDATE transactions.mf_order_detail org SET 
	return_type = B.return_type
	FROM transactions.mf_order_detail A 
	JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
		  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
	WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
	UPDATE transactions.mf_order_detail A 
	SET
	rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
								B.partner_code ELSE B.client_owner END,
	order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
							THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
							ELSE 'CLIENT' END::character varying
	FROM master.dim_ucc B 
	WHERE TRIM(A.ac_code) = B.priority_ac_code
	AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
	--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
	and A.trx_id > v_trx_id;
	
	update transactions.mf_order_detail a
	set consent_status_code =
		case when order_placed_by ='CLIENT' and physicalflag='D' then 0
		when order_placed_by ='CLIENT' and physicalflag='P' then 2
		when order_placed_by in ('RM','PARTNER') then 2 end,
		consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
		when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
		when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
	--where trx_id not in ( select txnid from temp_exist_mf_trx);
	where a.trx_id > v_trx_id;
	
	*/
	
----------Inserting Data into transaction History Table----------
UPDATE transactions.mf_order_detail_history A
SET valid_to = NOW(), 
	is_active = false
FROM transactions.mf_order_detail b
where a.trx_id = b.trx_id	
and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status) 
AND A.is_active = true
and (
coalesce (a.trx_final_status_code,0) <> coalesce (b.trx_final_status_code,0)
or coalesce (a.consent_status_code,0) <> coalesce (b.consent_status_code,0)	
or coalesce (a.trx_status_code,0) <> coalesce (b.trx_status_code,0)
or coalesce (a.payment_status_code,0) <> coalesce (b.payment_status_code,0)
or coalesce (a.inv_plan_status_code,0) <> coalesce (b.inv_plan_status_code,0)
); 

INSERT INTO transactions.mf_order_detail_history
(
trx_id,vendor_trx_id,ucccode,ac_code,trx_datetime,is_active,trx_type_code,trx_type,
consent_status_code,consent_status,trx_status_code,trx_status,vendor_trx_status,
payment_status_code,payment_status,inv_plan_status_code,inv_plan_status,
trx_final_status_code,final_status,mandate_id,order_remarks,trx_source,
inserted_dt,valid_from
)
		
SELECT distinct 
a.trx_id,a.vendor_trx_id,a.ucccode,a.ac_code,a.trx_datetime,true as is_active,
a.trx_type_code,a.trx_type,a.consent_status_code,a.consent_status,a.trx_status_code,
a.trx_status,a.vendor_trx_status,a.payment_status_code,A.payment_status,
a.inv_plan_status_code,a.inv_plan_status,a.trx_final_status_code,a.final_status,
a.mandate_id,A.order_remarks,A.trx_source,now() as inserted_dt,now() as valid_from		 
FROM transactions.mf_order_detail a join transactions.mf_order_detail_history b
on a.trx_id = b.trx_id 
WHERE a.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status)
and(
coalesce(a.trx_final_status_code,0) <> coalesce(b.trx_final_status_code,0)
or coalesce(a.consent_status_code,0) <> coalesce(b.consent_status_code,0)	
or coalesce(a.trx_status_code,0) <> coalesce(b.trx_status_code,0)
or coalesce(a.payment_status_code,0) <> coalesce(b.payment_status_code,0)
or coalesce(a.inv_plan_status_code,0) <> coalesce(b.inv_plan_status_code,0)
); 
	

UPDATE transactions.mf_order_detail_history 
SET 
	valid_to = '9999-12-31'::timestamp without time zone 
WHERE trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status)
AND	is_active = true 
AND valid_to IS NULL;

----------Updating Data into Summary Table----------
UPDATE transactions.mf_order_summary A SET
trx_final_status_code = B.trx_final_status_code,
final_status = B.final_status,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
WHERE A.trx_id = B.trx_id
AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx_status);

----------Updating Data into Order_modification Table----------
UPDATE transactions.mf_order_detail_modification org SET
trx_status =  sts.internal_status, trx_status_code = sts.trx_status_code, vendor_trx_status = UPPER(sts.vendor_status), modified_date = NOW()
--FROM transactions.mf_order_detail_modification mod
-- JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND mod.final_status <> 'Order Rejected'
AND sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
							   WHEN mod.inv_action_code = 2 THEN 5
							   WHEN mod.inv_action_code = 0 THEN 4 END;

UPDATE transactions.mf_order_detail_modification org SET
order_remarks = src.orderremarks
, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 8)
, trx_status_code = 8
, final_status = 'Order Rejected'
, trx_final_status_code = 8
, inv_plan_status_code = 7
, inv_plan_status = 'Order Rejected'
, modified_date = NOW()
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND UPPER(mod.inv_action) = 'CANCEL' AND UPPER(src.status) = 'ORDERED';

UPDATE transactions.mf_order_detail_modification A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail_modification D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
/* AND D.is_generatetoday = B.is_generatetoday */
AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id IN
(SELECT mod.trx_id FROM transactions.mf_order_detail_modification mod
 JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
 JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
 JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
 WHERE sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
								  WHEN mod.inv_action_code = 2 THEN 5
								  WHEN mod.inv_action_code = 0 THEN 4 END
); 

---update the Resume status
update transactions.mf_order_detail_modification A set
trx_final_status_code = B.trx_final_status_code,
final_status = B.final_status,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
from transactions.mf_order_detail B
where A.org_trx_id=B.trx_id
and A.inv_action_code=0
and A.final_status is null;

-------------------------------------------------		
-- new trx insert
	
--SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

--drop table temp_mf_trx_new

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_new AS
SELECT src.txnid FROM transactions.stg_dion_orderbook_SIP src
left join transactions.mf_order_detail destn on src.txnid = destn.vendor_trx_id
where destn.vendor_trx_id is null;

--select * from temp_mf_trx_new
--where txnid=200266

INSERT INTO transactions.mf_order_detail(
vendor_trx_id,ac_code,"user_id",isincode,trx_type,trx_datetime,trx_amt,trx_qty,datasource,
orderby,delivery_mode,mandate_id,trx_status,payment_status,modified_date,modified_by,
trx_source,created_date,nav,navdate,order_nav,order_navdate,folio_no,order_type,
physicalflag,order_remarks,tokenno,switchtokenno,vendor_exchg_refno,ucccode,pan,
euinnumber,switch_isin,internal_flag,trx_type_code,trx_status_code,is_generatetoday,
inv_type_code,inv_type,inv_action_code,inv_action,vendor_trx_status,payment_status_code,
qty_or_amt_order,mf_schcode,isinname,schemegroup)
		
SELECT 
src.txnid as vendor_trx_id,src.clientcode as ac_code,src.userid as "user_id",src.isin as isincode,
txn.trx_type as trx_type,(src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime,
case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) 
else src.amount end as trx_amt, 
coalesce(
case when coalesce(src.units,0) =0 then 
case when coalesce(src.ordernav,0)=0 then 0 
else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end 
end,0) as trx_qty,
'DION'::character varying as datasource, 
case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
src.traxmode as delivery_mode,src.mandateid as mandate_id,trx_sts.trx_status, 
case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
else dps.payment_status end payment_status,
src.lastmodifiedon as modified_date,src.lastmodifiedby as modified_by,
src.ordersource as trx_source,(src.txndate||' '||src.txntime)::timestamp without time zone as created_date,
src.nav,src.navdate,src.ordernav as order_nav,src.ordernavdate as order_navdate,src.foliono as folio_no, 
trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag,
src.orderremarks as order_remarks,src.token as tokenno,src.switchtoken as switchtokenno,
src.exchangerefno as vendor_exchg_refno,mst.ucccode,mst.pan,src.euinnumber, 
src.switchisin as switch_isin, 1 as internal_flag,trx.trx_type_code,sts.trx_status_code,
CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END as is_generatetoday,
txn.inv_type_code,inv.inv_type, 
case when trx_sts.trx_status_code=5 then 2 
when trx_sts.trx_status_code=3 then 4 else 1 end inv_action_code, 
(case when trx_sts.trx_status_code=5 then 'Pause'
when trx_sts.trx_status_code=3 then 'Cancel'
else 'Transaction' end ) ::character varying as inv_action,
UPPER(src.status) as vendor_trx_status, 
case when trim(upper(src.paymentstatus))='PAID' then 2
when trim(upper(src.paymentstatus))='UNPAID' then 1
when trim(upper(src.paymentstatus))='PROCESSING' then 1
when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
else PM.payment_status_code end payment_status_code,
case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
isin.mf_schcode,isin.isinname,sch.schemegroup
FROM transactions.stg_dion_orderbook_SIP src
LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
inner join master.dim_mf_isin isin on src.isin=isin.isincode
JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
WHERE dest.trx_id IS NULL;

UPDATE transactions.mf_order_detail A 
SET 
	display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
WHERE display_trx_id IS NULL;
			
UPDATE transactions.mf_order_detail A 
SET
	rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
								B.partner_code ELSE B.client_owner END,
	order_placed_by = CASE WHEN COALESCE(A.orderby,A.ac_code) <> A.ac_code
							THEN 
					CASE WHEN A.orderby = B.partner_code THEN 'PARTNER'
							ELSE 'RM' END
							ELSE 'CLIENT' END::character varying
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code
AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
--and A.trx_id > v_trx_id;
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);
		
UPDATE transactions.mf_order_detail org 
SET 
	return_type = B.return_type
	FROM transactions.mf_order_detail A 
	JOIN (
	SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
	FROM master.dim_mf_exchange_isin
	) B 
ON A.isincode = B.isincode AND A.tokenno = B."token"
WHERE A.trx_id = org.trx_id 
--AND org.trx_id >= v_trx_id;
and org.vendor_trx_id in (select txnid from temp_mf_trx_new);
	
----to be removed for incremental----
UPDATE transactions.mf_order_detail A 
SET consent_status_code = case 
	when inv_action_code in (2,4) and order_placed_by<>'CLIENT' then 2
	when physicalflag='P' and order_placed_by='CLIENT' then 2
	when order_placed_by<>'CLIENT' then 2 else 0 end,
	consent_status = case 
	when inv_action_code in (2,4) and order_placed_by<>'CLIENT' then 'Consent Approved'
	when physicalflag='P' and order_placed_by='CLIENT' then 'Consent Approved'
						when order_placed_by<>'CLIENT' then 'Consent Approved' else'' end,
	payment_status_code = case 
	when inv_action_code in (2,4) then 0
	when is_generatetoday=false then 0 else 2 end,
	payment_status = case 
	when inv_action_code in (2,4) then ''
	when is_generatetoday=false then '' else 'Processed' end
WHERE --A.trx_id >= v_trx_id
A.vendor_trx_id in (select txnid from temp_mf_trx_new)
--	AND order_placed_by <> 'CLIENT'
AND consent_status_code IS NULL;

UPDATE transactions.mf_order_detail A 
set is_generatetoday= case when trx_status_code in (3,5) then false 
	else is_generatetoday end
--WHERE A.trx_id >= v_trx_id;
where A.vendor_trx_id in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_detail A 
SET
	final_status = B.trx_final_status,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
JOIN master.MV_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id 
--AND A.trx_id >= v_trx_id;
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);

----------Inserting Data into transaction History Table----------
INSERT INTO transactions.mf_order_detail_history(
trx_id,vendor_trx_id,ucccode,ac_code,trx_datetime,is_active,trx_type_code,trx_type,
consent_status_code,consent_status,trx_status_code,trx_status,vendor_trx_status,
payment_status_code,payment_status,inv_plan_status_code,inv_plan_status,
trx_final_status_code,final_status,mandate_id,order_remarks,trx_source,inserted_dt,
valid_from
)
SELECT 
A.trx_id,A.vendor_trx_id,A.ucccode,A.ac_code,A.trx_datetime,true as is_active,
a.trx_type_code,A.trx_type,A.consent_status_code,A.consent_status,A.trx_status_code,
A.trx_status,A.vendor_trx_status,A.payment_status_code,A.payment_status,
a.inv_plan_status_code,a.inv_plan_status,a.trx_final_status_code,a.final_status,
a.mandate_id,A.order_remarks,A.trx_source,now() as inserted_dt,now() as valid_from
FROM transactions.mf_order_detail A 
WHERE --A.trx_id >= v_trx_id
A.vendor_trx_id in (select txnid from temp_mf_trx_new)
and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
WHERE A.trx_id = B.trx_id
);

UPDATE transactions.mf_order_detail_history 
SET 
	valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true 
AND valid_to IS NULL;
----------------------------------------------------
DROP TABLE temp_exist_mf_trx; 
DROP TABLE temp_exist_mf_trx_status;
DROP TABLE temp_mf_trx_new;
----------------------------------------------------
------------------------------------------------------------------------------------------
-- Error Transaction
--truncate table transactions.mf_order_detail_error
--DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';

DELETE FROM transactions.mf_order_detail_error A
WHERE EXISTS (SELECT B.txnid FROM transactions.stg_dion_orderbook_SIP B 
WHERE A.vendor_trx_id = B.txnid);

INSERT INTO transactions.mf_order_detail_error(
vendor_trx_id,ac_code,"user_id",isincode,trx_type,trx_datetime,trx_amt,trx_qty,datasource, 
orderby,delivery_mode,mandate_id,trx_status,payment_status,modified_date,modified_by,
trx_source,created_date,nav,navdate,order_nav,order_navdate,folio_no,order_type,physicalflag, order_remarks,
tokenno,switchtokenno,vendor_exchg_refno,ucccode,pan,euinnumber,switch_isin,internal_flag,
trx_type_code,trx_status_code,is_generatetoday,inv_type_code,inv_type,inv_action_code,
inv_action,vendor_trx_status,payment_status_code,qty_or_amt_order,mf_schcode,isinname,
schemegroup,error_message)
SELECT 
src.txnid AS vendor_trx_id,src.clientcode AS ac_code,src.userid AS "user_id", 
src.isin AS isincode,txn.trx_type AS trx_type,
(src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS trx_datetime, 
CASE 
	WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) 
	ELSE src.amount 
END AS trx_amt, 
COALESCE(
	CASE 
		WHEN COALESCE(src.units, 0) = 0 THEN 
			CASE 
				WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
				ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) 
			END 
	END, 0
) AS trx_qty,
'DION'::character varying as datasource, 
CASE 
	WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode 
	ELSE src.orderedby 
END AS orderedby,
src.traxmode AS delivery_mode,src.mandateid AS mandate_id,trx_sts.trx_status, 
CASE 
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 'Processed'
	WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
	ELSE dps.payment_status 
END AS payment_status,
src.lastmodifiedon AS modified_date,src.lastmodifiedby AS modified_by,
src.ordersource AS trx_source, 
(src.txndate || ' ' || src.txntime)::timestamp WITHOUT time zone AS created_date, 
src.nav,src.navdate,src.ordernav AS order_nav,src.ordernavdate AS order_navdate, 
src.foliono AS folio_no,TRIM(UPPER(src.ordertype)) AS order_type, 
COALESCE(src.physicalflag,'D') AS physicalflag,src.orderremarks AS order_remarks,
src.token AS tokenno,src.switchtoken AS switchtokenno,
src.exchangerefno AS vendor_exchg_refno,mst.ucccode,mst.pan,src.euinnumber,
src.switchisin AS switch_isin,1 AS internal_flag,trx.trx_type_code,sts.trx_status_code,
CASE 
	WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE 
	ELSE FALSE 
END AS is_generatetoday,
txn.inv_type_code,inv.inv_type,1 AS inv_action_code, 
'Transaction'::character varying AS inv_action, 
UPPER(src.status) AS vendor_trx_status,
CASE 
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 2
	WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 1
	WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 1
	WHEN TRIM(UPPER(COALESCE(src.paymentstatus, ''))) = '' THEN 0
	ELSE pm.payment_status_code 
END AS payment_status_code,
CASE 
	WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' 
	ELSE 'Q' 
END AS qty_or_amt_order,
isin.mf_schcode,isin.isinname,sch.schemegroup,
CONCAT(
CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END) AS error_message
FROM transactions.stg_dion_orderbook_SIP src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.map_vendor_internal_payment_status pm ON pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (
mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL
);
/*
ON CONFLICT (vendor_trx_id) 
DO UPDATE SET 
	ac_code = EXCLUDED.ac_code,
	"user_id" = EXCLUDED."user_id",
	isincode = EXCLUDED.isincode,
	trx_type = EXCLUDED.trx_type,
	trx_datetime = EXCLUDED.trx_datetime,
	trx_amt = EXCLUDED.trx_amt,
	trx_qty = EXCLUDED.trx_qty,
	datasource = EXCLUDED.datasource,
	orderby = EXCLUDED.orderby,
	delivery_mode = EXCLUDED.delivery_mode,
	mandate_id = EXCLUDED.mandate_id,
	trx_status = EXCLUDED.trx_status,
	payment_status = EXCLUDED.payment_status,
	modified_date = EXCLUDED.modified_date,
	modified_by = EXCLUDED.modified_by,
	trx_source = EXCLUDED.trx_source,
	created_date = EXCLUDED.created_date,
	nav = EXCLUDED.nav,
	navdate = EXCLUDED.navdate,
	order_nav = EXCLUDED.order_nav,
	order_navdate = EXCLUDED.order_navdate,
	folio_no = EXCLUDED.folio_no,
	order_type = EXCLUDED.order_type,
	physicalflag = EXCLUDED.physicalflag,
	order_remarks = EXCLUDED.order_remarks,
	tokenno = EXCLUDED.tokenno,
	switchtokenno = EXCLUDED.switchtokenno,
	vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
	ucccode = EXCLUDED.ucccode,
	pan = EXCLUDED.pan,
	euinnumber = EXCLUDED.euinnumber,
	switch_isin = EXCLUDED.switch_isin,
	internal_flag = EXCLUDED.internal_flag,
	trx_type_code = EXCLUDED.trx_type_code,
	trx_status_code = EXCLUDED.trx_status_code,
	is_generatetoday = EXCLUDED.is_generatetoday,
	inv_type_code = EXCLUDED.inv_type_code,
	inv_type = EXCLUDED.inv_type,
	inv_action_code = EXCLUDED.inv_action_code,
	inv_action = EXCLUDED.inv_action,
	vendor_trx_status = EXCLUDED.vendor_trx_status,
	payment_status_code = EXCLUDED.payment_status_code,
	qty_or_amt_order = EXCLUDED.qty_or_amt_order,
	mf_schcode = EXCLUDED.mf_schcode,
	isinname = EXCLUDED.isinname,
	schemegroup = EXCLUDED.schemegroup,
	error_message = EXCLUDED.error_message;
*/
---------------------------------------------------------------------------------------------------	
				
	RETURN 'SUCCESS';

ELSE
	
	RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
	RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_14jul2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_14jul2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_14jul2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_14jul2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_sip_bkp_14jul2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_stp();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_stp()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;

BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_STP
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
---------------------------------------------------------------------	
	----delete duplicates
	WITH ranked_rows AS (
		SELECT
		ctid, -- Include ctid for later filtering
		txnid,
		ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
		FROM transactions.stg_dion_orderbook_STP
		)
		delete FROM transactions.stg_dion_orderbook_STP
		WHERE ctid IN (	SELECT ctid		
		FROM ranked_rows
		WHERE row_num > 1
		);

--------------------------------------------------------------------
--/* communications
insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
fundname_switch,amount,units,rejection_reason,sip_start_date,
sip_end_date,frequency,no_of_installment,
sourceid,subcategoryid,subcategory,is_picked,emp_code,partner_code
)
-----------STP/SWITCH
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
dest.isinname as fundname,
isin.isinname as fundname_switch,
(case when src.amount= 0.00 then dest.trx_amt else src.amount end)::character varying as amount,
(case when src.units=0.00 then (src.nav*src.amount)::numeric(18,2) else src.units end)::character varying as units,
src.orderremarks as rejection_reason,
src.startdate::character varying as sip_start_date,
src.enddate::character varying as sip_end_date,
src.sipfrequency::character varying as frequency,
--src.tenure::character varying as no_of_installment,
(case when coalesce(src.tenure,0)=0 then su.no_of_installment 
else src.tenure end)::character varying as no_of_installment,
'82'::character varying as sourceid,
(case 
when mst.trx_type_code=2 and upper(src.status)='ORDERED' then '3569'
when mst.trx_type_code=2 and upper(src.status)='REJECTED' then '3571'
when mst.trx_type_code=2 and upper(src.status)='CANCELLED' then '3585'
when mst.trx_type_code=2 and upper(src.status)='REJECTED' then '3586'
when mst.trx_type_code=6 and upper(src.status)='ORDERED' then '3556'
when mst.trx_type_code=6 and upper(src.status)='REJECTED' then '3558'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=2 and upper(src.status)='ORDERED' then 'STP_ORDER_CONFIRMATION_INTERNAL'
when mst.trx_type_code=2 and upper(src.status)='REJECTED' then 'STP_ORDER_REJECTION_INTERNAL'
when mst.trx_type_code=2 and upper(src.status)='CANCELLED' then 'STP_CANCELLATION_CONFIRMATION_INTERNAL'
when mst.trx_type_code=2 and upper(src.status)='REJECTED' then 'STP_CANCELLATION_REJECTION_INTERNAL'
when mst.trx_type_code=6 and upper(src.status)='ORDERED' then 'SWITCH_ORDER_CONFIRMATION_INTERNAL'
when mst.trx_type_code=6 and upper(src.status)='REJECTED' then 'SWITCH_ORDER_REJECTION_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
,(case when dest.order_placed_by='RM' then coalesce(dest.created_for,dest.orderby)
when dest.order_placed_by='CLIENT' and ucc.user_type='E' then dest.rm_partner_code end)::character varying as emp_code,
(case when dest.order_placed_by='PARTNER' then ucc.partnerowner
when dest.order_placed_by='CLIENT' and ucc.user_type='P' then ucc.partnerowner end)::character varying as partner_code
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_STP src 
on dest.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code
and mst.category_code=261
join master.dim_mf_isin isin
on dest.switch_isin=isin.isincode
join master.dim_ucc ucc on ucc.ucccode= dest.ucccode
join transactions.mf_order_summary su on dest.trx_id = su.trx_id
where dest.trx_type_code in (2,6)
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/

	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_STP)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_STP src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				--OR COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'')
				--OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
				--OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				--OR COALESCE(dest.tokenno,0) <> COALESCE(src.token,0)
				OR COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0)
				--OR COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
				--OR COALESCE(dest.is_generatedtoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
				
			  );
		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		,trx_amt= (case when dest.trx_amt= 0.00 then src.amount else dest.trx_amt end)::numeric(15,4)
		,trx_qty= (case when dest.trx_qty=0.00 then (src.nav*src.amount)::numeric(15,4) else dest.trx_qty end)::numeric(15,4)
		,modified_date = NOW() at time zone 'Asia/Kolkata'
		FROM transactions.stg_dion_orderbook_STP src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
		
		----------------------------------------------------------------------------
		---Check Status change
		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx_status AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest 
		JOIN transactions.stg_dion_orderbook_STP src
		ON dest.vendor_trx_id = src.txnid
		WHERE (COALESCE(dest.vendor_trx_status,'') <> UPPER(src.status));
		----------------------------------------------------------------------------

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
	,inv_action = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 4)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 2)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 1) ELSE dest.inv_action END
	,inv_action_code = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN 4
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN 2
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN 1 ELSE dest.inv_action_code END
			, modified_date = NOW() at time zone 'Asia/Kolkata'
		FROM transactions.stg_dion_orderbook_STP src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		--AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND coalesce (B.payment_status_code,0) = CASE WHEN D.inv_action_code <> 1 THEN 0 ELSE coalesce (D.payment_status_code,0) END
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		

		/*
		 --one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
		*/
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = NOW() at time zone 'Asia/Kolkata', 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		AND A.is_active = true
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT distinct
			A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() at time zone 'Asia/Kolkata' as inserted_dt , NOW() at time zone 'Asia/Kolkata' as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 

		UPDATE transactions.mf_order_detail_history 
		SET  valid_to = '9999-12-31'::timestamp without time zone 
		WHERE trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		AND is_active = true 
		AND valid_to IS NULL;

		----------Updating Data into Summary Table----------
		UPDATE transactions.mf_order_summary A SET
		trx_final_status_code = B.trx_final_status_code,
		final_status = B.final_status,
		inv_plan_status_code = B.inv_plan_status_code,
		inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail B
		WHERE A.trx_id = B.trx_id
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

----------Updating Data into Order_modification Table----------
UPDATE transactions.mf_order_detail_modification org SET
trx_status =  sts.internal_status, trx_status_code = sts.trx_status_code, vendor_trx_status = UPPER(sts.vendor_status), 
	modified_date = NOW() at time zone 'Asia/Kolkata'
--FROM transactions.mf_order_detail_modification mod
-- JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_STP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND mod.final_status <> 'Order Rejected'
AND sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
							   WHEN mod.inv_action_code = 2 THEN 5
							   WHEN mod.inv_action_code = 0 THEN 4 END;

UPDATE transactions.mf_order_detail_modification org SET
order_remarks = src.orderremarks
, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 8)
, trx_status_code = 8
, final_status = 'Order Rejected'
, trx_final_status_code = 8
, inv_plan_status_code = 7
, inv_plan_status = 'Order Rejected'
, modified_date = NOW() at time zone 'Asia/Kolkata'
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_STP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND UPPER(mod.inv_action) = 'CANCEL' AND UPPER(src.status) = 'ORDERED';

UPDATE transactions.mf_order_detail_modification A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail_modification D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
/* AND D.is_generatetoday = B.is_generatetoday */
AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id IN
(SELECT mod.trx_id FROM transactions.mf_order_detail_modification mod
 JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
 JOIN transactions.stg_dion_orderbook_STP src ON src.txnid = mod.vendor_trx_id AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
 JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
 WHERE sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
								  WHEN mod.inv_action_code = 2 THEN 5
								  WHEN mod.inv_action_code = 0 THEN 4 END
); 

		

-------------------------------------------------		
-- new trx insert
	
		SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

		INSERT INTO transactions.mf_order_detail
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
			
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 
		case when trx_sts.trx_status_code=3 then 4 else 1 end inv_action_code,
		--1 as inv_action_code,  
		(case when trx_sts.trx_status_code=3 then 'Cancel'
		else 'Transaction' end ) ::character varying as inv_action,
		--'Transaction'::character varying as inv_action, 
			UPPER(src.status), 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup
		FROM transactions.stg_dion_orderbook_STP src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		inner join master.dim_mf_isin isin on src.isin=isin.isincode
		JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		
		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
			
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
	
		----to be removed for incremental----
	
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = case 
				when inv_action_code =4  and  order_placed_by<>'CLIENT' then 2
				when physicalflag='P' and order_placed_by='CLIENT' then 2
				when order_placed_by<>'CLIENT' then 2 else 0 end,
		consent_status = case 
				when inv_action_code =4  and  order_placed_by<>'CLIENT' then 'Consent Approved'
				when physicalflag='P' and order_placed_by='CLIENT' then 'Consent Approved'
				when order_placed_by<>'CLIENT' then 'Consent Approved' else'' end,
		payment_status_code = 0,
		payment_status = ''
		WHERE A.trx_id >= v_trx_id;

		UPDATE transactions.mf_order_detail A 
		set is_generatetoday= case when trx_status_code =3 then false 
			else is_generatetoday end
		WHERE A.trx_id >= v_trx_id;
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() at time zone 'Asia/Kolkata' as inserted_dt , NOW() at time zone 'Asia/Kolkata' as valid_from
		 FROM transactions.mf_order_detail A --
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;

------------------------------------------------------------------------------------------
---------update for missing switch details

update transactions.mf_order_detail a
set switch_mf_schcode=b.mf_schcode,
switch_grpcode=b.schemegroup ,
switchtokenno=b.token
from (
select a.isincode,a.token,b.mf_schcode,b.schemegroup 
from master.dim_mf_isin a
inner join master.dim_mf_scheme b
on a.mf_schcode=b.mf_schcode
)b
where a.switch_isin=b.isincode
and a.switch_mf_schcode is null
and a.trx_type_code in (2,6);

------------------------------------------------------------------------------------------
	-- Insert and Update for error transaction

     --DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';
	
		DELETE FROM transactions.mf_order_detail_error A
		WHERE EXISTS (SELECT B.txnid FROM  transactions.stg_dion_orderbook_STP B WHERE A.vendor_trx_id = B.txnid);

			
		INSERT INTO transactions.mf_order_detail_error (
		    vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby,
		    delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate,
		    order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks,
		    tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan,
		    euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday,
		    inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code,
		    qty_or_amt_order, mf_schcode, isinname, schemegroup, error_message
		)
		SELECT 
		    src.txnid AS vendor_trx_id, src.clientcode AS ac_code, src.userid AS "user_id", src.isin AS isincode, txn.trx_type AS trx_type,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS trx_datetime,
		    CASE 
		        WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) 
		        ELSE src.amount 
		    END AS trx_amt,
		    COALESCE(
		        CASE 
		            WHEN COALESCE(src.units, 0) = 0 THEN 
		                CASE 
		                    WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
		                    ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) 
		                END 
		        END, 
		        0
		    ) AS trx_qty,
		    'DION'::character varying, 
		    CASE WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode ELSE src.orderedby END AS orderedby,
		    src.traxmode AS delivery_mode, src.mandateid AS mandate_id, trx_sts.trx_status, 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 'Processed'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
		        ELSE dps.payment_status 
		    END AS payment_status,
		    src.lastmodifiedon AS modified_date, src.lastmodifiedby AS modified_by,
		    src.ordersource AS trx_source, (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS created_date, 
		    src.nav, src.navdate, src.ordernav AS order_nav, src.ordernavdate AS order_navdate, 
		    src.foliono AS folio_no, TRIM(UPPER(src.ordertype)) AS order_type, COALESCE(src.physicalflag, 'D') AS physicalflag,
		    src.orderremarks AS order_remarks, src.token AS tokenno, src.switchtoken AS switchtokenno,
		    src.exchangerefno AS vendor_exchg_refno, mst.ucccode, mst.pan,
		    src.euinnumber, src.switchisin AS switch_isin, 1 AS internal_flag, trx.trx_type_code, sts.trx_status_code,
		    CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END,
		    txn.inv_type_code, inv.inv_type, 1 AS inv_action_code, 'Transaction'::character varying AS inv_action, 
		    UPPER(src.status), 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 2
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 1
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 1
		        WHEN TRIM(UPPER(COALESCE(src.paymentstatus, ''))) = '' THEN 0
		        ELSE PM.payment_status_code 
		    END AS payment_status_code,
		    CASE WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' ELSE 'Q' END AS qty_or_amt_order,
		    isin.mf_schcode, 
		    isin.isinname, 
		    sch.schemegroup,
		    CONCAT(
	        CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
	        CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
	        CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
	        CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
	        CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END
	        ) AS error_message

		FROM transactions.stg_dion_orderbook_STP src
-- 		JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		LEFT JOIN master.map_vendor_internal_trx_type trx 
		    ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = TRUE
		LEFT JOIN master.trx_type txn 
		    ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = TRUE
		LEFT JOIN master.investment_type inv 
		    ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_trx_status sts 
		    ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = TRUE
		LEFT JOIN master.trx_status trx_sts 
		    ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_payment_status pm 
		    ON pm.vendor_payment_status = UPPER(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = TRUE
		LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
		LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
		LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
		WHERE mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS null
		OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS null;

	    
/*	    
	ON CONFLICT (vendor_trx_id)
	DO UPDATE SET
	    ac_code = EXCLUDED.ac_code,
	    "user_id" = EXCLUDED."user_id",
	    isincode = EXCLUDED.isincode,
	    trx_type = EXCLUDED.trx_type,
	    trx_datetime = EXCLUDED.trx_datetime,
	    trx_amt = EXCLUDED.trx_amt,
	    trx_qty = EXCLUDED.trx_qty,
	    datasource = EXCLUDED.datasource,
	    orderby = EXCLUDED.orderby,
	    delivery_mode = EXCLUDED.delivery_mode,
	    mandate_id = EXCLUDED.mandate_id,
	    trx_status = EXCLUDED.trx_status,
	    payment_status = EXCLUDED.payment_status,
	    modified_date = EXCLUDED.modified_date,
	    modified_by = EXCLUDED.modified_by,
	    trx_source = EXCLUDED.trx_source,
	    created_date = EXCLUDED.created_date,
	    nav = EXCLUDED.nav,
	    navdate = EXCLUDED.navdate,
	    order_nav = EXCLUDED.order_nav,
	    order_navdate = EXCLUDED.order_navdate,
	    folio_no = EXCLUDED.folio_no,
	    order_type = EXCLUDED.order_type,
	    physicalflag = EXCLUDED.physicalflag,
	    order_remarks = EXCLUDED.order_remarks,
	    tokenno = EXCLUDED.tokenno,
	    switchtokenno = EXCLUDED.switchtokenno,
	    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
	    ucccode = EXCLUDED.ucccode,
	    pan = EXCLUDED.pan,
	    euinnumber = EXCLUDED.euinnumber,
	    switch_isin = EXCLUDED.switch_isin,
	    internal_flag = EXCLUDED.internal_flag,
	    trx_type_code = EXCLUDED.trx_type_code,
	    trx_status_code = EXCLUDED.trx_status_code,
	    is_generatetoday = EXCLUDED.is_generatetoday,
	    inv_type_code = EXCLUDED.inv_type_code,
	    inv_type = EXCLUDED.inv_type,
	    inv_action_code = EXCLUDED.inv_action_code,
	    inv_action = EXCLUDED.inv_action,
	    vendor_trx_status = EXCLUDED.vendor_trx_status,
	    payment_status_code = EXCLUDED.payment_status_code,
	    qty_or_amt_order = EXCLUDED.qty_or_amt_order,
	    mf_schcode = EXCLUDED.mf_schcode,
	    isinname = EXCLUDED.isinname,
	    schemegroup = EXCLUDED.schemegroup,
	    error_message = EXCLUDED.error_message;
	   
*/

	
------------------------------------------------------------------------------------------	
-- Error Transaction
	/*		
		INSERT INTO transactions.mf_order_detail_error
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup, error_message)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
			
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 1 as inv_action_code, 'Transaction'::character varying as inv_action, UPPER(src.status)
		, 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup,
		CONCAT(
                CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' end,
                CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' end
            ) AS error_message
		FROM transactions.stg_dion_orderbook_STP src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
	    JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		left join master.dim_mf_isin isin on src.isin=isin.isincode
		left JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		where ( mst.priority_ac_code is null --29449 
				or  isin.isincode is null--	13517
				or isin.mf_schcode is null --2
				); 
	*/			
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_stp() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_09may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;

BEGIN
---------------------------------------------------------------------	
	----delete duplicates
	WITH ranked_rows AS (
		SELECT
		ctid, -- Include ctid for later filtering
		txnid,
		ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
		FROM transactions.stg_dion_orderbook_STP
		)
		delete FROM transactions.stg_dion_orderbook_STP
		WHERE ctid IN (		SELECT ctid		
		FROM ranked_rows
		WHERE row_num > 1
		);

	
	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_STP)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_STP src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				--OR COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'')
				--OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
				--OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				--OR COALESCE(dest.tokenno,0) <> COALESCE(src.token,0)
				OR COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0)
				--OR COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
				--OR COALESCE(dest.is_generatedtoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
				
			  );
		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		, modified_date = NOW()
		
		FROM transactions.stg_dion_orderbook_STP src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
	,inv_action = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 4)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 2)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 1) ELSE dest.inv_action END
	,inv_action_code = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN 4
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN 2
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN 1 ELSE dest.inv_action_code END
			, modified_date = NOW()
		FROM transactions.stg_dion_orderbook_STP src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		--AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND coalesce (B.payment_status_code,0) = CASE WHEN D.inv_action_code <> 1 THEN 0 ELSE coalesce (D.payment_status_code,0) END
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		

		
		 --one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	
		
		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	 
		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
		
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = NOW(), 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		AND A.is_active = true
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT distinct
			A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 

		UPDATE transactions.mf_order_detail_history 
		SET  valid_to = '9999-12-31'::timestamp without time zone 
		WHERE trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		AND is_active = true 
		AND valid_to IS NULL;

		----------Updating Data into Summary Table----------
		UPDATE transactions.mf_order_summary A SET
		trx_final_status_code = B.trx_final_status_code,
		final_status = B.final_status,
		inv_plan_status_code = B.inv_plan_status_code,
		inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail B
		WHERE A.trx_id = B.trx_id
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

----------Updating Data into Order_modification Table----------
UPDATE transactions.mf_order_detail_modification org SET
trx_status =  sts.internal_status, trx_status_code = sts.trx_status_code, vendor_trx_status = UPPER(sts.vendor_status), modified_date = NOW()
FROM transactions.mf_order_detail_modification mod
JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
WHERE org.trx_id = mod.trx_id
AND sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
							   WHEN mod.inv_action_code = 2 THEN 5
							   WHEN mod.inv_action_code = 0 THEN 4 END;

UPDATE transactions.mf_order_detail_modification A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail_modification D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
/* AND D.is_generatetoday = B.is_generatetoday */
AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id IN
(SELECT mod.trx_id FROM transactions.mf_order_detail_modification mod
 JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
 JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
 JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
 WHERE sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
								  WHEN mod.inv_action_code = 2 THEN 5
								  WHEN mod.inv_action_code = 0 THEN 4 END
); 

		

-------------------------------------------------		
-- new trx insert
	
		SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

		INSERT INTO transactions.mf_order_detail
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
			
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 
		case when trx_sts.trx_status_code=3 then 4 else 1 end inv_action_code,
		--1 as inv_action_code,  
		(case when trx_sts.trx_status_code=3 then 'Cancel'
		else 'Transaction' end ) ::character varying as inv_action,
		--'Transaction'::character varying as inv_action, 
			UPPER(src.status), 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup
		FROM transactions.stg_dion_orderbook_STP src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		inner join master.dim_mf_isin isin on src.isin=isin.isincode
		JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		
		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
			
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
	
		----to be removed for incremental----
	
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = case 
				when inv_action_code =4  and  order_placed_by<>'CLIENT' then 2
				when physicalflag='P' and order_placed_by='CLIENT' then 2
				when order_placed_by<>'CLIENT' then 2 else 0 end,
		consent_status = case 
				when inv_action_code =4  and  order_placed_by<>'CLIENT' then 'Consent Approved'
				when physicalflag='P' and order_placed_by='CLIENT' then 'Consent Approved'
				when order_placed_by<>'CLIENT' then 'Consent Approved' else'' end,
		payment_status_code = 0,
		payment_status = ''
		WHERE A.trx_id >= v_trx_id;

		UPDATE transactions.mf_order_detail A 
		set is_generatetoday= case when trx_status_code =3 then false 
			else is_generatetoday end
		WHERE A.trx_id >= v_trx_id;
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from
		 FROM transactions.mf_order_detail A --
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;
------------------------------------------------------------------------------------------
	-- Insert and Update for error transaction

     --DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';
	
		DELETE FROM transactions.mf_order_detail_error A
		WHERE EXISTS (SELECT B.txnid FROM  transactions.stg_dion_orderbook_STP B WHERE A.vendor_trx_id = B.txnid);

			
		INSERT INTO transactions.mf_order_detail_error (
		    vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby,
		    delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate,
		    order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks,
		    tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan,
		    euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday,
		    inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code,
		    qty_or_amt_order, mf_schcode, isinname, schemegroup, error_message
		)
		SELECT 
		    src.txnid AS vendor_trx_id, src.clientcode AS ac_code, src.userid AS "user_id", src.isin AS isincode, txn.trx_type AS trx_type,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS trx_datetime,
		    CASE 
		        WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) 
		        ELSE src.amount 
		    END AS trx_amt,
		    COALESCE(
		        CASE 
		            WHEN COALESCE(src.units, 0) = 0 THEN 
		                CASE 
		                    WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
		                    ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) 
		                END 
		        END, 
		        0
		    ) AS trx_qty,
		    'DION'::character varying, 
		    CASE WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode ELSE src.orderedby END AS orderedby,
		    src.traxmode AS delivery_mode, src.mandateid AS mandate_id, trx_sts.trx_status, 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 'Processed'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
		        ELSE dps.payment_status 
		    END AS payment_status,
		    src.lastmodifiedon AS modified_date, src.lastmodifiedby AS modified_by,
		    src.ordersource AS trx_source, (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS created_date, 
		    src.nav, src.navdate, src.ordernav AS order_nav, src.ordernavdate AS order_navdate, 
		    src.foliono AS folio_no, TRIM(UPPER(src.ordertype)) AS order_type, COALESCE(src.physicalflag, 'D') AS physicalflag,
		    src.orderremarks AS order_remarks, src.token AS tokenno, src.switchtoken AS switchtokenno,
		    src.exchangerefno AS vendor_exchg_refno, mst.ucccode, mst.pan,
		    src.euinnumber, src.switchisin AS switch_isin, 1 AS internal_flag, trx.trx_type_code, sts.trx_status_code,
		    CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END,
		    txn.inv_type_code, inv.inv_type, 1 AS inv_action_code, 'Transaction'::character varying AS inv_action, 
		    UPPER(src.status), 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 2
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 1
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 1
		        WHEN TRIM(UPPER(COALESCE(src.paymentstatus, ''))) = '' THEN 0
		        ELSE PM.payment_status_code 
		    END AS payment_status_code,
		    CASE WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' ELSE 'Q' END AS qty_or_amt_order,
		    isin.mf_schcode, 
		    isin.isinname, 
		    sch.schemegroup,
		    CONCAT(
	        CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
	        CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
	        CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
	        CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
	        CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END
	        ) AS error_message

		FROM transactions.stg_dion_orderbook_STP src
-- 		JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		LEFT JOIN master.map_vendor_internal_trx_type trx 
		    ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = TRUE
		LEFT JOIN master.trx_type txn 
		    ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = TRUE
		LEFT JOIN master.investment_type inv 
		    ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_trx_status sts 
		    ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = TRUE
		LEFT JOIN master.trx_status trx_sts 
		    ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_payment_status pm 
		    ON pm.vendor_payment_status = UPPER(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = TRUE
		LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
		LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
		LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
		WHERE mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS null
		OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS null;

	    
/*	    
	ON CONFLICT (vendor_trx_id)
	DO UPDATE SET
	    ac_code = EXCLUDED.ac_code,
	    "user_id" = EXCLUDED."user_id",
	    isincode = EXCLUDED.isincode,
	    trx_type = EXCLUDED.trx_type,
	    trx_datetime = EXCLUDED.trx_datetime,
	    trx_amt = EXCLUDED.trx_amt,
	    trx_qty = EXCLUDED.trx_qty,
	    datasource = EXCLUDED.datasource,
	    orderby = EXCLUDED.orderby,
	    delivery_mode = EXCLUDED.delivery_mode,
	    mandate_id = EXCLUDED.mandate_id,
	    trx_status = EXCLUDED.trx_status,
	    payment_status = EXCLUDED.payment_status,
	    modified_date = EXCLUDED.modified_date,
	    modified_by = EXCLUDED.modified_by,
	    trx_source = EXCLUDED.trx_source,
	    created_date = EXCLUDED.created_date,
	    nav = EXCLUDED.nav,
	    navdate = EXCLUDED.navdate,
	    order_nav = EXCLUDED.order_nav,
	    order_navdate = EXCLUDED.order_navdate,
	    folio_no = EXCLUDED.folio_no,
	    order_type = EXCLUDED.order_type,
	    physicalflag = EXCLUDED.physicalflag,
	    order_remarks = EXCLUDED.order_remarks,
	    tokenno = EXCLUDED.tokenno,
	    switchtokenno = EXCLUDED.switchtokenno,
	    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
	    ucccode = EXCLUDED.ucccode,
	    pan = EXCLUDED.pan,
	    euinnumber = EXCLUDED.euinnumber,
	    switch_isin = EXCLUDED.switch_isin,
	    internal_flag = EXCLUDED.internal_flag,
	    trx_type_code = EXCLUDED.trx_type_code,
	    trx_status_code = EXCLUDED.trx_status_code,
	    is_generatetoday = EXCLUDED.is_generatetoday,
	    inv_type_code = EXCLUDED.inv_type_code,
	    inv_type = EXCLUDED.inv_type,
	    inv_action_code = EXCLUDED.inv_action_code,
	    inv_action = EXCLUDED.inv_action,
	    vendor_trx_status = EXCLUDED.vendor_trx_status,
	    payment_status_code = EXCLUDED.payment_status_code,
	    qty_or_amt_order = EXCLUDED.qty_or_amt_order,
	    mf_schcode = EXCLUDED.mf_schcode,
	    isinname = EXCLUDED.isinname,
	    schemegroup = EXCLUDED.schemegroup,
	    error_message = EXCLUDED.error_message;
	   
*/

	
------------------------------------------------------------------------------------------	
-- Error Transaction
	/*		
		INSERT INTO transactions.mf_order_detail_error
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup, error_message)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
			
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 1 as inv_action_code, 'Transaction'::character varying as inv_action, UPPER(src.status)
		, 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup,
		CONCAT(
                CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' end,
                CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' end
            ) AS error_message
		FROM transactions.stg_dion_orderbook_STP src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
	    JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		left join master.dim_mf_isin isin on src.isin=isin.isincode
		left JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		where ( mst.priority_ac_code is null --29449 
				or  isin.isincode is null--	13517
				or isin.mf_schcode is null --2
				); 
	*/			
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_09may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_09may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_09may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_09may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_14jul2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_14jul2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;

BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_STP
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
---------------------------------------------------------------------	
	----delete duplicates
	WITH ranked_rows AS (
		SELECT
		ctid, -- Include ctid for later filtering
		txnid,
		ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
		FROM transactions.stg_dion_orderbook_STP
		)
		delete FROM transactions.stg_dion_orderbook_STP
		WHERE ctid IN (	SELECT ctid		
		FROM ranked_rows
		WHERE row_num > 1
		);

--------------------------------------------------------------------
--/* communications
insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
fundname_switch,amount,units,rejection_reason,sip_start_date,
sip_end_date,frequency,no_of_installment,
sourceid,subcategoryid,subcategory,is_picked
)
-----------STP/SWITCH
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
dest.isinname as fundname,
isin.isinname as fundname_switch,
(case when src.amount= 0.00 then dest.trx_amt else src.amount end)::character varying as amount,
(case when src.units=0.00 then  (src.nav*src.amount)::numeric(18,2) else src.units end)::character varying as units,
src.orderremarks as rejection_reason,
src.startdate::character varying as sip_start_date,
src.enddate::character varying as sip_end_date,
src.sipfrequency::character varying as frequency,
src.tenure::character varying as no_of_installment,
'54'::character varying as sourceid,
(case 
when mst.trx_type_code=2 and upper(src.status)='ORDERED' then '3569'
when mst.trx_type_code=2 and upper(src.status)='REJECTED' then '3571'
when mst.trx_type_code=2 and upper(src.status)='CANCELLED' then '3585'
when mst.trx_type_code=2 and upper(src.status)='REJECTED' then '3586'
when mst.trx_type_code=6 and upper(src.status)='ORDERED' then '3556'
when mst.trx_type_code=6 and upper(src.status)='REJECTED' then '3558'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=2 and upper(src.status)='ORDERED' then 'STP_ORDER_CONFIRMATION_INTERNAL'
when mst.trx_type_code=2 and upper(src.status)='REJECTED' then 'STP_ORDER_REJECTION_INTERNAL'
when mst.trx_type_code=2 and upper(src.status)='CANCELLED' then 'STP_CANCELLATION_CONFIRMATION_INTERNAL'
when mst.trx_type_code=2 and upper(src.status)='REJECTED' then 'STP_CANCELLATION_REJECTION_INTERNAL'
when mst.trx_type_code=6 and upper(src.status)='ORDERED' then 'SWITCH_ORDER_CONFIRMATION_INTERNAL'
when mst.trx_type_code=6 and upper(src.status)='REJECTED' then 'SWITCH_ORDER_REJECTION_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_STP src 
on dest.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code
and mst.category_code=261
join master.dim_mf_isin isin
on dest.switch_isin=isin.isincode
where dest.trx_type_code in (2,6)
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/

	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_STP)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_STP src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				--OR COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'')
				--OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
				--OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				--OR COALESCE(dest.tokenno,0) <> COALESCE(src.token,0)
				OR COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0)
				--OR COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
				--OR COALESCE(dest.is_generatedtoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
				
			  );
		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		, modified_date = NOW()	
		FROM transactions.stg_dion_orderbook_STP src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
		
		----------------------------------------------------------------------------
		---Check Status change
		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx_status AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest 
		JOIN transactions.stg_dion_orderbook_STP src
		ON dest.vendor_trx_id = src.txnid
		WHERE (COALESCE(dest.vendor_trx_status,'') <> UPPER(src.status));
		----------------------------------------------------------------------------

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
	,inv_action = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 4)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 2)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 1) ELSE dest.inv_action END
	,inv_action_code = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN 4
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN 2
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN 1 ELSE dest.inv_action_code END
			, modified_date = NOW()
		FROM transactions.stg_dion_orderbook_STP src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		--AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND coalesce (B.payment_status_code,0) = CASE WHEN D.inv_action_code <> 1 THEN 0 ELSE coalesce (D.payment_status_code,0) END
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		

		/*
		 --one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
		*/
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = NOW(), 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		AND A.is_active = true
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT distinct
			A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 

		UPDATE transactions.mf_order_detail_history 
		SET  valid_to = '9999-12-31'::timestamp without time zone 
		WHERE trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		AND is_active = true 
		AND valid_to IS NULL;

		----------Updating Data into Summary Table----------
		UPDATE transactions.mf_order_summary A SET
		trx_final_status_code = B.trx_final_status_code,
		final_status = B.final_status,
		inv_plan_status_code = B.inv_plan_status_code,
		inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail B
		WHERE A.trx_id = B.trx_id
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

----------Updating Data into Order_modification Table----------
UPDATE transactions.mf_order_detail_modification org SET
trx_status =  sts.internal_status, trx_status_code = sts.trx_status_code, vendor_trx_status = UPPER(sts.vendor_status), modified_date = NOW()
--FROM transactions.mf_order_detail_modification mod
-- JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_STP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND mod.final_status <> 'Order Rejected'
AND sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
							   WHEN mod.inv_action_code = 2 THEN 5
							   WHEN mod.inv_action_code = 0 THEN 4 END;

UPDATE transactions.mf_order_detail_modification org SET
order_remarks = src.orderremarks
, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 8)
, trx_status_code = 8
, final_status = 'Order Rejected'
, trx_final_status_code = 8
, inv_plan_status_code = 7
, inv_plan_status = 'Order Rejected'
, modified_date = NOW()
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_STP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND UPPER(mod.inv_action) = 'CANCEL' AND UPPER(src.status) = 'ORDERED';

UPDATE transactions.mf_order_detail_modification A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail_modification D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
/* AND D.is_generatetoday = B.is_generatetoday */
AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id IN
(SELECT mod.trx_id FROM transactions.mf_order_detail_modification mod
 JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
 JOIN transactions.stg_dion_orderbook_STP src ON src.txnid = mod.vendor_trx_id AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
 JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
 WHERE sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
								  WHEN mod.inv_action_code = 2 THEN 5
								  WHEN mod.inv_action_code = 0 THEN 4 END
); 

		

-------------------------------------------------		
-- new trx insert
	
		SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

		INSERT INTO transactions.mf_order_detail
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
			
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 
		case when trx_sts.trx_status_code=3 then 4 else 1 end inv_action_code,
		--1 as inv_action_code,  
		(case when trx_sts.trx_status_code=3 then 'Cancel'
		else 'Transaction' end ) ::character varying as inv_action,
		--'Transaction'::character varying as inv_action, 
			UPPER(src.status), 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup
		FROM transactions.stg_dion_orderbook_STP src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		inner join master.dim_mf_isin isin on src.isin=isin.isincode
		JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		
		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
			
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
	
		----to be removed for incremental----
	
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = case 
				when inv_action_code =4  and  order_placed_by<>'CLIENT' then 2
				when physicalflag='P' and order_placed_by='CLIENT' then 2
				when order_placed_by<>'CLIENT' then 2 else 0 end,
		consent_status = case 
				when inv_action_code =4  and  order_placed_by<>'CLIENT' then 'Consent Approved'
				when physicalflag='P' and order_placed_by='CLIENT' then 'Consent Approved'
				when order_placed_by<>'CLIENT' then 'Consent Approved' else'' end,
		payment_status_code = 0,
		payment_status = ''
		WHERE A.trx_id >= v_trx_id;

		UPDATE transactions.mf_order_detail A 
		set is_generatetoday= case when trx_status_code =3 then false 
			else is_generatetoday end
		WHERE A.trx_id >= v_trx_id;
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from
		 FROM transactions.mf_order_detail A --
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;

------------------------------------------------------------------------------------------
---------update for missing switch details

update transactions.mf_order_detail a
set switch_mf_schcode=b.mf_schcode,
switch_grpcode=b.schemegroup ,
switchtokenno=b.token
from (
select a.isincode,a.token,b.mf_schcode,b.schemegroup 
from master.dim_mf_isin a
inner join master.dim_mf_scheme b
on a.mf_schcode=b.mf_schcode
)b
where a.switch_isin=b.isincode
and a.switch_mf_schcode is null
and a.trx_type_code in (2,6);

------------------------------------------------------------------------------------------
	-- Insert and Update for error transaction

     --DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';
	
		DELETE FROM transactions.mf_order_detail_error A
		WHERE EXISTS (SELECT B.txnid FROM  transactions.stg_dion_orderbook_STP B WHERE A.vendor_trx_id = B.txnid);

			
		INSERT INTO transactions.mf_order_detail_error (
		    vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby,
		    delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate,
		    order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks,
		    tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan,
		    euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday,
		    inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code,
		    qty_or_amt_order, mf_schcode, isinname, schemegroup, error_message
		)
		SELECT 
		    src.txnid AS vendor_trx_id, src.clientcode AS ac_code, src.userid AS "user_id", src.isin AS isincode, txn.trx_type AS trx_type,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS trx_datetime,
		    CASE 
		        WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) 
		        ELSE src.amount 
		    END AS trx_amt,
		    COALESCE(
		        CASE 
		            WHEN COALESCE(src.units, 0) = 0 THEN 
		                CASE 
		                    WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
		                    ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) 
		                END 
		        END, 
		        0
		    ) AS trx_qty,
		    'DION'::character varying, 
		    CASE WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode ELSE src.orderedby END AS orderedby,
		    src.traxmode AS delivery_mode, src.mandateid AS mandate_id, trx_sts.trx_status, 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 'Processed'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
		        ELSE dps.payment_status 
		    END AS payment_status,
		    src.lastmodifiedon AS modified_date, src.lastmodifiedby AS modified_by,
		    src.ordersource AS trx_source, (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS created_date, 
		    src.nav, src.navdate, src.ordernav AS order_nav, src.ordernavdate AS order_navdate, 
		    src.foliono AS folio_no, TRIM(UPPER(src.ordertype)) AS order_type, COALESCE(src.physicalflag, 'D') AS physicalflag,
		    src.orderremarks AS order_remarks, src.token AS tokenno, src.switchtoken AS switchtokenno,
		    src.exchangerefno AS vendor_exchg_refno, mst.ucccode, mst.pan,
		    src.euinnumber, src.switchisin AS switch_isin, 1 AS internal_flag, trx.trx_type_code, sts.trx_status_code,
		    CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END,
		    txn.inv_type_code, inv.inv_type, 1 AS inv_action_code, 'Transaction'::character varying AS inv_action, 
		    UPPER(src.status), 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 2
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 1
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 1
		        WHEN TRIM(UPPER(COALESCE(src.paymentstatus, ''))) = '' THEN 0
		        ELSE PM.payment_status_code 
		    END AS payment_status_code,
		    CASE WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' ELSE 'Q' END AS qty_or_amt_order,
		    isin.mf_schcode, 
		    isin.isinname, 
		    sch.schemegroup,
		    CONCAT(
	        CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
	        CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
	        CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
	        CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
	        CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END
	        ) AS error_message

		FROM transactions.stg_dion_orderbook_STP src
-- 		JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		LEFT JOIN master.map_vendor_internal_trx_type trx 
		    ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = TRUE
		LEFT JOIN master.trx_type txn 
		    ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = TRUE
		LEFT JOIN master.investment_type inv 
		    ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_trx_status sts 
		    ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = TRUE
		LEFT JOIN master.trx_status trx_sts 
		    ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_payment_status pm 
		    ON pm.vendor_payment_status = UPPER(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = TRUE
		LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
		LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
		LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
		WHERE mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS null
		OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS null;

	    
/*	    
	ON CONFLICT (vendor_trx_id)
	DO UPDATE SET
	    ac_code = EXCLUDED.ac_code,
	    "user_id" = EXCLUDED."user_id",
	    isincode = EXCLUDED.isincode,
	    trx_type = EXCLUDED.trx_type,
	    trx_datetime = EXCLUDED.trx_datetime,
	    trx_amt = EXCLUDED.trx_amt,
	    trx_qty = EXCLUDED.trx_qty,
	    datasource = EXCLUDED.datasource,
	    orderby = EXCLUDED.orderby,
	    delivery_mode = EXCLUDED.delivery_mode,
	    mandate_id = EXCLUDED.mandate_id,
	    trx_status = EXCLUDED.trx_status,
	    payment_status = EXCLUDED.payment_status,
	    modified_date = EXCLUDED.modified_date,
	    modified_by = EXCLUDED.modified_by,
	    trx_source = EXCLUDED.trx_source,
	    created_date = EXCLUDED.created_date,
	    nav = EXCLUDED.nav,
	    navdate = EXCLUDED.navdate,
	    order_nav = EXCLUDED.order_nav,
	    order_navdate = EXCLUDED.order_navdate,
	    folio_no = EXCLUDED.folio_no,
	    order_type = EXCLUDED.order_type,
	    physicalflag = EXCLUDED.physicalflag,
	    order_remarks = EXCLUDED.order_remarks,
	    tokenno = EXCLUDED.tokenno,
	    switchtokenno = EXCLUDED.switchtokenno,
	    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
	    ucccode = EXCLUDED.ucccode,
	    pan = EXCLUDED.pan,
	    euinnumber = EXCLUDED.euinnumber,
	    switch_isin = EXCLUDED.switch_isin,
	    internal_flag = EXCLUDED.internal_flag,
	    trx_type_code = EXCLUDED.trx_type_code,
	    trx_status_code = EXCLUDED.trx_status_code,
	    is_generatetoday = EXCLUDED.is_generatetoday,
	    inv_type_code = EXCLUDED.inv_type_code,
	    inv_type = EXCLUDED.inv_type,
	    inv_action_code = EXCLUDED.inv_action_code,
	    inv_action = EXCLUDED.inv_action,
	    vendor_trx_status = EXCLUDED.vendor_trx_status,
	    payment_status_code = EXCLUDED.payment_status_code,
	    qty_or_amt_order = EXCLUDED.qty_or_amt_order,
	    mf_schcode = EXCLUDED.mf_schcode,
	    isinname = EXCLUDED.isinname,
	    schemegroup = EXCLUDED.schemegroup,
	    error_message = EXCLUDED.error_message;
	   
*/

	
------------------------------------------------------------------------------------------	
-- Error Transaction
	/*		
		INSERT INTO transactions.mf_order_detail_error
		(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
		 , delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
		 , order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
		 , tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
		 , euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
		 , inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
		,qty_or_amt_order, mf_schcode , --display_trx_id , 
		isinname , schemegroup, error_message)
		
		SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
		, (src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
		case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
		
		coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
			else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
			
		'DION'::character varying, 
		case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end orderedby,
		src.traxmode as delivery_mode, src.mandateid as mandate_id, trx_sts.trx_status, 
		case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
			when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
			when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
			else dps.payment_status end payment_status
		, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
		, src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
		, src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
		trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
		, src.orderremarks as order_remarks--, src.arn
		, src.token as tokenno, src.switchtoken as switchtokenno
		, src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
		, src.euinnumber, src.switchisin as switch_isin, 1 as internal_flag, trx.trx_type_code, sts.trx_status_code
		, CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
		, txn.inv_type_code, inv.inv_type, 1 as inv_action_code, 'Transaction'::character varying as inv_action, UPPER(src.status)
		, 
			case when trim(upper(src.paymentstatus))='PAID' then 2
			when trim(upper(src.paymentstatus))='UNPAID' then 1
			when trim(upper(src.paymentstatus))='PROCESSING' then 1
			when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
			else PM.payment_status_code end payment_status_code,
		case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
		isin.mf_schcode,
		--'MF'||LPAD(src.txnid ::character varying, 10, '0')::character varying as display_trx_id,
		isin.isinname,
		sch.schemegroup,
		CONCAT(
                CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' end,
                CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' end
            ) AS error_message
		FROM transactions.stg_dion_orderbook_STP src
		LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
	    JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
		JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
		JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
		JOIN master.map_vendor_internal_trx_status sts 
			ON sts.vendor_status = UPPER(src.status) 
			AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
		left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
		left join master.dim_mf_isin isin on src.isin=isin.isincode
		left JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
		where ( mst.priority_ac_code is null --29449 
				or  isin.isincode is null--	13517
				or isin.mf_schcode is null --2
				); 
	*/			
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_14jul2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_14jul2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_14jul2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_14jul2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_stp_bkp_14jul2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_swp();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_swp()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;

BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_SWP
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
SELECT
ctid, -- Include ctid for later filtering
txnid,
ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
FROM transactions.stg_dion_orderbook_SWP
)
delete FROM transactions.stg_dion_orderbook_SWP
WHERE ctid IN (	
SELECT ctid		
FROM ranked_rows
WHERE row_num > 1
);

--/* communications
insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked,emp_code,partner_code
)
-----------Redemption/SWP
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
src.schemename as fundname,
--src.amount::character varying as amount,
dest.trx_amt::character varying as amount,
src.units::character varying as units,
src.orderremarks as rejection_reason,
''::character varying as next_due_date,
src.startdate::character varying as sip_start_date,
src.enddate::character varying as sip_end_date,
src.sipfrequency::character varying as frequency,
--src.tenure::character varying as installment_number,
coalesce(su.no_of_installment,0)::character varying as installment_number,
--''::character varying as no_of_installment,
''::character varying as bankname,
''::character varying as bankacno,
'82'::character varying as sourceid,
(case 
when mst.trx_type_code=3 and upper(src.status)='ORDERED' then '3560'
when mst.trx_type_code=3 and upper(src.status)='REJECTED' then '3561'
when mst.trx_type_code=5 and upper(src.status)='ORDERED' then '3574'
when mst.trx_type_code=5 and upper(src.status)='REJECTED' then '3575'
when mst.trx_type_code=5 and upper(src.status)='CANCELLED' then '3575'
when mst.trx_type_code=3 and upper(src.status)='REJECTED' then '3588'
when mst.trx_type_code=3 and upper(src.status)='CANCELLED' then '3587'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=3 and upper(src.status)='ORDERED' then 'SWP_ORDER_CONFIRMATION_INTERNAL'
when mst.trx_type_code=3 and upper(src.status)='REJECTED' then 'SWP_ORDER_REJECTION_INTERNAL'
when mst.trx_type_code=5 and upper(src.status)='ORDERED' then 'REDEMPTION_ORDER_CONFIRMATION_INTERNAL'
when mst.trx_type_code=5 and upper(src.status)='REJECTED' then 'MF_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
when mst.trx_type_code=5 and upper(src.status)='CANCELLED' then 'MF_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
when mst.trx_type_code=3 and upper(src.status)='REJECTED' then 'SWP_CANCELLATION_REJECTION_INTERNAL'
when mst.trx_type_code=3 and upper(src.status)='CANCELLED' then 'SWP_CANCELLATION_CONFIRMATION_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
,(case when dest.order_placed_by='RM' then coalesce(dest.created_for,dest.orderby)
when dest.order_placed_by='CLIENT' and ucc.user_type='E' then dest.rm_partner_code end)::character varying as emp_code,
(case when dest.order_placed_by='PARTNER' then ucc.partnerowner
when dest.order_placed_by='CLIENT' and ucc.user_type='P' then ucc.partnerowner end)::character varying as partner_code
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_swp src 
on dest.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code
and mst.category_code=261
join master.dim_ucc ucc on ucc.ucccode= dest.ucccode
left join transactions.mf_order_summary su on dest.vendor_trx_id = su.vendor_trx_id 
where dest.trx_type_code in (3,5)
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/
	
	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_SWP)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_SWP src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				--OR COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'')
				--OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
				--OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				--OR COALESCE(dest.tokenno,0) <> COALESCE(src.token,0)
--				OR COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0)
				--OR COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
				--OR COALESCE(dest.is_generatedtoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
			  );
		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
--		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		,vendor_trx_status= CASE WHEN COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')::character varying THEN src.status::character varying ELSE dest.vendor_trx_status END
		, modified_date = (NOW() at time zone 'Asia/Kolkata')
		FROM transactions.stg_dion_orderbook_SWP src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
	,inv_action = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 ) AND sts.trx_status_code = 3 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 4)
ELSE dest.inv_action END
	,inv_action_code = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 ) AND sts.trx_status_code = 3 THEN 4
ELSE dest.inv_action_code END
			, modified_date = (NOW() at time zone 'Asia/Kolkata')
			FROM transactions.stg_dion_orderbook_SWP src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
			WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);

		----to be removed for incremental----
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = 2, consent_status = 'Consent Approved'
		WHERE A.trx_id in (select txnid from temp_exist_mf_trx)
		AND order_placed_by <> 'CLIENT' AND consent_status_code IS NULL;
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND coalesce(D.consent_status_code,0) = coalesce(B.consent_status_code,0)
		--AND coalesce(D.payment_status_code,0) = coalesce (B.payment_status_code,0)
		AND coalesce (B.payment_status_code,0) = CASE WHEN D.inv_action_code <> 1 THEN 0 ELSE coalesce (D.payment_status_code,0) END
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

		--- one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
		
		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	 
		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
		-----------------------
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = (NOW() at time zone 'Asia/Kolkata'), 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		AND A.is_active = true
		and (
		coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT distinct 
			A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			(NOW() at time zone 'Asia/Kolkata') as inserted_dt , (NOW() at time zone 'Asia/Kolkata') as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		 		

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		WHERE trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		AND is_active = true 
		AND valid_to IS NULL;
		
		----------Updating Data into Summary Table----------
		UPDATE transactions.mf_order_summary A SET
		trx_final_status_code = B.trx_final_status_code,
		final_status = B.final_status,
		inv_plan_status_code = B.inv_plan_status_code,
		inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail B
		WHERE A.trx_id = B.trx_id
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

----------Updating Data into Order_modification Table----------
UPDATE transactions.mf_order_detail_modification org SET
trx_status =  sts.internal_status, trx_status_code = sts.trx_status_code,
	vendor_trx_status = UPPER(sts.vendor_status), modified_date = (NOW() at time zone 'Asia/Kolkata')
--FROM transactions.mf_order_detail_modification mod
-- JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SWP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND mod.final_status <> 'Order Rejected'
AND sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
							   WHEN mod.inv_action_code = 2 THEN 5
							   WHEN mod.inv_action_code = 0 THEN 4 END;

UPDATE transactions.mf_order_detail_modification org SET
order_remarks = src.orderremarks
, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 8)
, trx_status_code = 8
, final_status = 'Order Rejected'
, trx_final_status_code = 8
, inv_plan_status_code = 7
, inv_plan_status = 'Order Rejected'
, modified_date = (NOW() at time zone 'Asia/Kolkata')
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SWP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND UPPER(mod.inv_action) = 'CANCEL' AND UPPER(src.status) = 'ORDERED';

UPDATE transactions.mf_order_detail_modification A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail_modification D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
/* AND D.is_generatetoday = B.is_generatetoday */
AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id IN
(SELECT mod.trx_id FROM transactions.mf_order_detail_modification mod
 JOIN temp_exist_mf_trx tmp ON tmp.txnid =  mod.org_trx_id
 JOIN transactions.stg_dion_orderbook_SWP src ON src.txnid = mod.vendor_trx_id 
AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
 JOIN master.map_vendor_internal_trx_status sts 
ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
 WHERE sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
								  WHEN mod.inv_action_code = 2 THEN 5
								  WHEN mod.inv_action_code = 0 THEN 4 END
); 

-------------------------------------------------		
-- new trx insert
	
SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

INSERT INTO transactions.mf_order_detail
(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
, delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
, order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
, tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
, euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
, inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
,qty_or_amt_order, mf_schcode,isinname , schemegroup)
		
SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
,(src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
'DION'::character varying as datasource,
case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end as orderedby,
src.traxmode as delivery_mode,src.mandateid as mandate_id,trx_sts.trx_status, 
case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
else dps.payment_status end payment_status
, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
,src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
,src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
,src.orderremarks as order_remarks--, src.arn
,src.token as tokenno, src.switchtoken as switchtokenno
,src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
,src.euinnumber, src.switchisin as switch_isin, 
1 as internal_flag, trx.trx_type_code, sts.trx_status_code
,CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END as is_generatetoday
,txn.inv_type_code, inv.inv_type,
case when trx_sts.trx_status_code=3 then 4 else 1 end inv_action_code,
--1 as inv_action_code,  
(case when trx_sts.trx_status_code=3 then 'Cancel'
else 'Transaction' end ) ::character varying as inv_action,
--'Transaction'::character varying as inv_action, 
UPPER(src.status),
case when trim(upper(src.paymentstatus))='PAID' then 2
when trim(upper(src.paymentstatus))='UNPAID' then 1
when trim(upper(src.paymentstatus))='PROCESSING' then 1
when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
else PM.payment_status_code end payment_status_code,
case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
isin.mf_schcode,isin.isinname,sch.schemegroup
FROM transactions.stg_dion_orderbook_SWP src
LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
JOIN master.map_vendor_internal_trx_status sts 
ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
inner join master.dim_mf_isin isin on src.isin=isin.isincode
JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		

		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
		
		----to be removed for incremental----
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = case 
		when inv_action_code =4  and  order_placed_by<>'CLIENT' then 2
		when physicalflag='P' and order_placed_by='CLIENT' then 2
		when order_placed_by<>'CLIENT' then 2 else 0 end,
		consent_status = case 
		when inv_action_code =4  and  order_placed_by<>'CLIENT' then 'Consent Approved'
		when physicalflag='P' and order_placed_by='CLIENT' then 'Consent Approved'
		when order_placed_by<>'CLIENT' then 'Consent Approved' else'' end,
		payment_status_code = 0,
		payment_status = ''
		WHERE A.trx_id >= v_trx_id;

		UPDATE transactions.mf_order_detail A 
		set is_generatetoday= case when trx_status_code =3 then false 
			else is_generatetoday end
		WHERE A.trx_id >= v_trx_id;
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			(NOW() at time zone 'Asia/Kolkata') as inserted_dt , (NOW() at time zone 'Asia/Kolkata') as valid_from
		 FROM transactions.mf_order_detail A --
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;
------------------------------------------------------------------------------------------
-- Error Transaction
	
		-- DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';
		DELETE FROM transactions.mf_order_detail_error A
		WHERE EXISTS (SELECT B.txnid FROM  transactions.stg_dion_orderbook_SWP B WHERE A.vendor_trx_id = B.txnid);

			
		INSERT INTO transactions.mf_order_detail_error (
		    vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby,
		    delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate,
		    order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks,
		    tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan,
		    euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday,
		    inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code,
		    qty_or_amt_order, mf_schcode, isinname, schemegroup, error_message
		)
		SELECT 
		    src.txnid AS vendor_trx_id, src.clientcode AS ac_code, src.userid AS "user_id", src.isin AS isincode, txn.trx_type AS trx_type,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS trx_datetime,
		    CASE 
		        WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) 
		        ELSE src.amount 
		    END AS trx_amt,
		    COALESCE(
		        CASE 
		            WHEN COALESCE(src.units, 0) = 0 THEN 
		                CASE 
		                    WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
		                    ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) 
		                END 
		        END, 
		        0
		    ) AS trx_qty,
		    'DION'::character varying, 
		    CASE WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode ELSE src.orderedby END AS orderedby,
		    src.traxmode AS delivery_mode, src.mandateid AS mandate_id, trx_sts.trx_status, 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 'Processed'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
		        ELSE dps.payment_status 
		    END AS payment_status,
		    src.lastmodifiedon AS modified_date, src.lastmodifiedby AS modified_by,
		    src.ordersource AS trx_source, (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS created_date, 
		    src.nav, src.navdate, src.ordernav AS order_nav, src.ordernavdate AS order_navdate, 
		    src.foliono AS folio_no, TRIM(UPPER(src.ordertype)) AS order_type, COALESCE(src.physicalflag, 'D') AS physicalflag,
		    src.orderremarks AS order_remarks, src.token AS tokenno, src.switchtoken AS switchtokenno,
		    src.exchangerefno AS vendor_exchg_refno, mst.ucccode, mst.pan,
		    src.euinnumber, src.switchisin AS switch_isin, 1 AS internal_flag, trx.trx_type_code, sts.trx_status_code,
		    CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END,
		    txn.inv_type_code, inv.inv_type, 1 AS inv_action_code, 'Transaction'::character varying AS inv_action, 
		    UPPER(src.status), 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 2
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 1
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 1
		        WHEN TRIM(UPPER(COALESCE(src.paymentstatus, ''))) = '' THEN 0
		        ELSE PM.payment_status_code 
		    END AS payment_status_code,
		    CASE WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' ELSE 'Q' END AS qty_or_amt_order,
		    isin.mf_schcode, 
		    isin.isinname, 
		    sch.schemegroup,
		    CONCAT(
	        CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
	        CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
	        CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
	        CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
	        CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END
	        ) AS error_message

		FROM transactions.stg_dion_orderbook_SWP src
-- 		JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		LEFT JOIN master.map_vendor_internal_trx_type trx 
		    ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = TRUE
		LEFT JOIN master.trx_type txn 
		    ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = TRUE
		LEFT JOIN master.investment_type inv 
		    ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_trx_status sts 
		    ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = TRUE
		LEFT JOIN master.trx_status trx_sts 
		    ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_payment_status pm 
		    ON pm.vendor_payment_status = UPPER(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = TRUE
		LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
		LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
		LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
		WHERE mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS null
		OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL;
	/*
		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    ac_code = EXCLUDED.ac_code,
		    "user_id" = EXCLUDED."user_id",
		    trx_type = EXCLUDED.trx_type,
		    trx_datetime = EXCLUDED.trx_datetime,
		    trx_amt = EXCLUDED.trx_amt,
		    trx_qty = EXCLUDED.trx_qty,
		    datasource = EXCLUDED.datasource,
		    orderby = EXCLUDED.orderby,
		    delivery_mode = EXCLUDED.delivery_mode,
		    mandate_id = EXCLUDED.mandate_id,
		    trx_status = EXCLUDED.trx_status,
		    payment_status = EXCLUDED.payment_status,
		    modified_date = EXCLUDED.modified_date,
		    modified_by = EXCLUDED.modified_by,
		    trx_source = EXCLUDED.trx_source,
		    created_date = EXCLUDED.created_date,
		    nav = EXCLUDED.nav,
		    navdate = EXCLUDED.navdate,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    folio_no = EXCLUDED.folio_no,
		    order_type = EXCLUDED.order_type,
		    physicalflag = EXCLUDED.physicalflag,
		    order_remarks = EXCLUDED.order_remarks,
		    tokenno = EXCLUDED.tokenno,
		    switchtokenno = EXCLUDED.switchtokenno,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    ucccode = EXCLUDED.ucccode,
		    pan = EXCLUDED.pan,
		    euinnumber = EXCLUDED.euinnumber,
		    switch_isin = EXCLUDED.switch_isin,
		    internal_flag = EXCLUDED.internal_flag,
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    is_generatetoday = EXCLUDED.is_generatetoday,
		    inv_type_code = EXCLUDED.inv_type_code,
		    inv_type = EXCLUDED.inv_type,
		    inv_action_code = EXCLUDED.inv_action_code,
		    inv_action = EXCLUDED.inv_action,
		    vendor_trx_status = EXCLUDED.vendor_trx_status,
		    payment_status_code = EXCLUDED.payment_status_code,
		    qty_or_amt_order = EXCLUDED.qty_or_amt_order,
		    mf_schcode = EXCLUDED.mf_schcode,
		    isinname = EXCLUDED.isinname,
		    schemegroup = EXCLUDED.schemegroup,
		    error_message = EXCLUDED.error_message;
*/
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_swp() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_09may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;

BEGIN
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
SELECT
ctid, -- Include ctid for later filtering
txnid,
ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
FROM transactions.stg_dion_orderbook_SWP
)
delete FROM transactions.stg_dion_orderbook_SWP
WHERE ctid IN (		SELECT ctid		
FROM ranked_rows
WHERE row_num > 1
);

--/* communications
insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked
)
-----------Redemption
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
src.schemename as fundname,
--src.amount::character varying as amount,
dest.trx_amt::character varying as amount,
src.units::character varying as units,
src.orderremarks as rejection_reason,
''::character varying as next_due_date,
''::character varying as sip_start_date,
''::character varying as sip_end_date,
''::character varying as frequency,
''::character varying as installment_number,
''::character varying as bankname,
''::character varying as bankacno,
'82'::character varying as sourceid,
(case 
when mst.trx_type_code=5 and upper(src.status)='ORDERED' then '3574'
when mst.trx_type_code=5 and upper(src.status)='REJECTED' then '3575'
when mst.trx_type_code=5 and upper(src.status)='CANCELLED' then '3575'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=5 and upper(src.status)='ORDERED' then 'REDEMPTION_ORDER_CONFIRMATION_INTERNAL'
when mst.trx_type_code=5 and upper(src.status)='REJECTED' then 'MF_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
when mst.trx_type_code=5 and upper(src.status)='CANCELLED' then 'MF_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_swp src 
on dest.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code
where dest.trx_type_code=5 --in (1,4,5)
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/
	
	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_SWP)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_SWP src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				--OR COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'')
				--OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
				--OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				--OR COALESCE(dest.tokenno,0) <> COALESCE(src.token,0)
--				OR COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0)
				--OR COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
				--OR COALESCE(dest.is_generatedtoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
			  );
		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
--		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		,vendor_trx_status= CASE WHEN COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')::character varying THEN src.status::character varying ELSE dest.vendor_trx_status END
		, modified_date = NOW()
		FROM transactions.stg_dion_orderbook_SWP src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);
		

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
	,inv_action = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 4)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 2)
					   WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 1) ELSE dest.inv_action END
	,inv_action_code = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 3 THEN 4
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 2 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 5 THEN 2
							WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 0 AND CASE WHEN mod.order_placed_by IN ('RM', 'PARTNER') OR (mod.order_placed_by = 'CLIENT' AND mod.physicalflag = 'P') THEN mod.consent_status_code = 2 ELSE mod.consent_status_code = 0 END) AND sts.trx_status_code = 4 THEN 1 ELSE dest.inv_action_code END
			, modified_date = NOW()
		FROM transactions.stg_dion_orderbook_SWP src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);

	
		----to be removed for incremental----
		UPDATE transactions.mf_order_detail A SET consent_status_code = 2, consent_status = 'Consent Approved'
		WHERE A.trx_id in (select txnid from temp_exist_mf_trx)
		AND order_placed_by <> 'CLIENT' AND consent_status_code IS NULL;
	
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND coalesce(D.consent_status_code,0) = coalesce(B.consent_status_code,0)
		--AND coalesce(D.payment_status_code,0) = coalesce (B.payment_status_code,0)
		AND coalesce (B.payment_status_code,0) = CASE WHEN D.inv_action_code <> 1 THEN 0 ELSE coalesce (D.payment_status_code,0) END
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

		--- one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
		
		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	 
		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
		-----------------------
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = NOW(), 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		AND A.is_active = true
		and (
		coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT distinct 
			A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		 		

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		WHERE trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		AND is_active = true 
		AND valid_to IS NULL;
		
		----------Updating Data into Summary Table----------
		UPDATE transactions.mf_order_summary A SET
		trx_final_status_code = B.trx_final_status_code,
		final_status = B.final_status,
		inv_plan_status_code = B.inv_plan_status_code,
		inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail B
		WHERE A.trx_id = B.trx_id
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

----------Updating Data into Order_modification Table----------
UPDATE transactions.mf_order_detail_modification org SET
trx_status =  sts.internal_status, trx_status_code = sts.trx_status_code, vendor_trx_status = UPPER(sts.vendor_status), modified_date = NOW()
FROM transactions.mf_order_detail_modification mod
JOIN temp_exist_mf_trx tmp ON tmp.txnid =  mod.org_trx_id
JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
WHERE org.trx_id = mod.trx_id
AND sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
							   WHEN mod.inv_action_code = 2 THEN 5
							   WHEN mod.inv_action_code = 0 THEN 4 END;

UPDATE transactions.mf_order_detail_modification A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail_modification D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
/* AND D.is_generatetoday = B.is_generatetoday */
AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id IN
(SELECT mod.trx_id FROM transactions.mf_order_detail_modification mod
 JOIN temp_exist_mf_trx tmp ON tmp.txnid =  mod.org_trx_id
 JOIN transactions.stg_dion_orderbook_SIP src ON src.txnid = mod.vendor_trx_id AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
 JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
 WHERE sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
								  WHEN mod.inv_action_code = 2 THEN 5
								  WHEN mod.inv_action_code = 0 THEN 4 END
); 

-------------------------------------------------		
-- new trx insert
	
SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

INSERT INTO transactions.mf_order_detail
(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
, delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
, order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
, tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
, euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
, inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
,qty_or_amt_order, mf_schcode,isinname , schemegroup)
		
SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
,(src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
'DION'::character varying as datasource,
case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end as orderedby,
src.traxmode as delivery_mode,src.mandateid as mandate_id,trx_sts.trx_status, 
case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
else dps.payment_status end payment_status
, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
,src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
,src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
,src.orderremarks as order_remarks--, src.arn
,src.token as tokenno, src.switchtoken as switchtokenno
,src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
,src.euinnumber, src.switchisin as switch_isin, 
1 as internal_flag, trx.trx_type_code, sts.trx_status_code
,CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END as is_generatetoday
,txn.inv_type_code, inv.inv_type,
case when trx_sts.trx_status_code=3 then 4 else 1 end inv_action_code,
--1 as inv_action_code,  
(case when trx_sts.trx_status_code=3 then 'Cancel'
else 'Transaction' end ) ::character varying as inv_action,
--'Transaction'::character varying as inv_action, 
UPPER(src.status),
case when trim(upper(src.paymentstatus))='PAID' then 2
when trim(upper(src.paymentstatus))='UNPAID' then 1
when trim(upper(src.paymentstatus))='PROCESSING' then 1
when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
else PM.payment_status_code end payment_status_code,
case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
isin.mf_schcode,isin.isinname,sch.schemegroup
FROM transactions.stg_dion_orderbook_SWP src
LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
JOIN master.map_vendor_internal_trx_status sts 
ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
inner join master.dim_mf_isin isin on src.isin=isin.isincode
JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		

		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
		
		----to be removed for incremental----
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = case 
		when inv_action_code =4  and  order_placed_by<>'CLIENT' then 2
		when physicalflag='P' and order_placed_by='CLIENT' then 2
		when order_placed_by<>'CLIENT' then 2 else 0 end,
		consent_status = case 
		when inv_action_code =4  and  order_placed_by<>'CLIENT' then 'Consent Approved'
		when physicalflag='P' and order_placed_by='CLIENT' then 'Consent Approved'
		when order_placed_by<>'CLIENT' then 'Consent Approved' else'' end,
		payment_status_code = 0,
		payment_status = ''
		WHERE A.trx_id >= v_trx_id;

		UPDATE transactions.mf_order_detail A 
		set is_generatetoday= case when trx_status_code =3 then false 
			else is_generatetoday end
		WHERE A.trx_id >= v_trx_id;
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from
		 FROM transactions.mf_order_detail A --
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;
------------------------------------------------------------------------------------------
-- Error Transaction
	
		-- DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';
		DELETE FROM transactions.mf_order_detail_error A
		WHERE EXISTS (SELECT B.txnid FROM  transactions.stg_dion_orderbook_SWP B WHERE A.vendor_trx_id = B.txnid);

			
		INSERT INTO transactions.mf_order_detail_error (
		    vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby,
		    delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate,
		    order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks,
		    tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan,
		    euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday,
		    inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code,
		    qty_or_amt_order, mf_schcode, isinname, schemegroup, error_message
		)
		SELECT 
		    src.txnid AS vendor_trx_id, src.clientcode AS ac_code, src.userid AS "user_id", src.isin AS isincode, txn.trx_type AS trx_type,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS trx_datetime,
		    CASE 
		        WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) 
		        ELSE src.amount 
		    END AS trx_amt,
		    COALESCE(
		        CASE 
		            WHEN COALESCE(src.units, 0) = 0 THEN 
		                CASE 
		                    WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
		                    ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) 
		                END 
		        END, 
		        0
		    ) AS trx_qty,
		    'DION'::character varying, 
		    CASE WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode ELSE src.orderedby END AS orderedby,
		    src.traxmode AS delivery_mode, src.mandateid AS mandate_id, trx_sts.trx_status, 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 'Processed'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
		        ELSE dps.payment_status 
		    END AS payment_status,
		    src.lastmodifiedon AS modified_date, src.lastmodifiedby AS modified_by,
		    src.ordersource AS trx_source, (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS created_date, 
		    src.nav, src.navdate, src.ordernav AS order_nav, src.ordernavdate AS order_navdate, 
		    src.foliono AS folio_no, TRIM(UPPER(src.ordertype)) AS order_type, COALESCE(src.physicalflag, 'D') AS physicalflag,
		    src.orderremarks AS order_remarks, src.token AS tokenno, src.switchtoken AS switchtokenno,
		    src.exchangerefno AS vendor_exchg_refno, mst.ucccode, mst.pan,
		    src.euinnumber, src.switchisin AS switch_isin, 1 AS internal_flag, trx.trx_type_code, sts.trx_status_code,
		    CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END,
		    txn.inv_type_code, inv.inv_type, 1 AS inv_action_code, 'Transaction'::character varying AS inv_action, 
		    UPPER(src.status), 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 2
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 1
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 1
		        WHEN TRIM(UPPER(COALESCE(src.paymentstatus, ''))) = '' THEN 0
		        ELSE PM.payment_status_code 
		    END AS payment_status_code,
		    CASE WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' ELSE 'Q' END AS qty_or_amt_order,
		    isin.mf_schcode, 
		    isin.isinname, 
		    sch.schemegroup,
		    CONCAT(
	        CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
	        CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
	        CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
	        CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
	        CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END
	        ) AS error_message

		FROM transactions.stg_dion_orderbook_SWP src
-- 		JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		LEFT JOIN master.map_vendor_internal_trx_type trx 
		    ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = TRUE
		LEFT JOIN master.trx_type txn 
		    ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = TRUE
		LEFT JOIN master.investment_type inv 
		    ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_trx_status sts 
		    ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = TRUE
		LEFT JOIN master.trx_status trx_sts 
		    ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_payment_status pm 
		    ON pm.vendor_payment_status = UPPER(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = TRUE
		LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
		LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
		LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
		WHERE mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS null
		OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL;
	/*
		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    ac_code = EXCLUDED.ac_code,
		    "user_id" = EXCLUDED."user_id",
		    trx_type = EXCLUDED.trx_type,
		    trx_datetime = EXCLUDED.trx_datetime,
		    trx_amt = EXCLUDED.trx_amt,
		    trx_qty = EXCLUDED.trx_qty,
		    datasource = EXCLUDED.datasource,
		    orderby = EXCLUDED.orderby,
		    delivery_mode = EXCLUDED.delivery_mode,
		    mandate_id = EXCLUDED.mandate_id,
		    trx_status = EXCLUDED.trx_status,
		    payment_status = EXCLUDED.payment_status,
		    modified_date = EXCLUDED.modified_date,
		    modified_by = EXCLUDED.modified_by,
		    trx_source = EXCLUDED.trx_source,
		    created_date = EXCLUDED.created_date,
		    nav = EXCLUDED.nav,
		    navdate = EXCLUDED.navdate,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    folio_no = EXCLUDED.folio_no,
		    order_type = EXCLUDED.order_type,
		    physicalflag = EXCLUDED.physicalflag,
		    order_remarks = EXCLUDED.order_remarks,
		    tokenno = EXCLUDED.tokenno,
		    switchtokenno = EXCLUDED.switchtokenno,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    ucccode = EXCLUDED.ucccode,
		    pan = EXCLUDED.pan,
		    euinnumber = EXCLUDED.euinnumber,
		    switch_isin = EXCLUDED.switch_isin,
		    internal_flag = EXCLUDED.internal_flag,
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    is_generatetoday = EXCLUDED.is_generatetoday,
		    inv_type_code = EXCLUDED.inv_type_code,
		    inv_type = EXCLUDED.inv_type,
		    inv_action_code = EXCLUDED.inv_action_code,
		    inv_action = EXCLUDED.inv_action,
		    vendor_trx_status = EXCLUDED.vendor_trx_status,
		    payment_status_code = EXCLUDED.payment_status_code,
		    qty_or_amt_order = EXCLUDED.qty_or_amt_order,
		    mf_schcode = EXCLUDED.mf_schcode,
		    isinname = EXCLUDED.isinname,
		    schemegroup = EXCLUDED.schemegroup,
		    error_message = EXCLUDED.error_message;
*/
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_09may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_09may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_09may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_09may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_14jul2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_14jul2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE v_trx_id bigint;

BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_orderbook_SWP
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
SELECT
ctid, -- Include ctid for later filtering
txnid,
ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY txntime DESC) AS row_num
FROM transactions.stg_dion_orderbook_SWP
)
delete FROM transactions.stg_dion_orderbook_SWP
WHERE ctid IN (	
SELECT ctid		
FROM ranked_rows
WHERE row_num > 1
);

--/* communications
insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,next_due_date,sip_start_date,
sip_end_date,frequency,installment_number,bankname,bankacno,
sourceid,subcategoryid,subcategory,is_picked
)
-----------Redemption/SWP
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,dest.inv_type,
dest.trx_id,dest.vendor_trx_id,dest.display_trx_id as orderid,
src.clientcode,INITCAP(src.clientname)::character varying as clientname,
src.txndate::character varying as orderdate,
dest.delivery_mode as transaction_mode,
--dest.isinname as fundname,
--dest.trx_amt as amount,
src.schemename as fundname,
--src.amount::character varying as amount,
dest.trx_amt::character varying as amount,
src.units::character varying as units,
src.orderremarks as rejection_reason,
''::character varying as next_due_date,
src.startdate::character varying as sip_start_date,
src.enddate::character varying as sip_end_date,
src.sipfrequency::character varying as frequency,
src.tenure::character varying as installment_number,
--''::character varying as no_of_installment,
''::character varying as bankname,
''::character varying as bankacno,
'54'::character varying as sourceid,
(case 
when mst.trx_type_code=3 and upper(src.status)='ORDERED' then '3560'
when mst.trx_type_code=3 and upper(src.status)='REJECTED' then '3561'
when mst.trx_type_code=5 and upper(src.status)='ORDERED' then '3574'
when mst.trx_type_code=5 and upper(src.status)='REJECTED' then '3575'
when mst.trx_type_code=5 and upper(src.status)='CANCELLED' then '3575'
when mst.trx_type_code=3 and upper(src.status)='REJECTED' then '3588'
when mst.trx_type_code=3 and upper(src.status)='CANCELLED' then '3587'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=3 and upper(src.status)='ORDERED' then 'SWP_ORDER_CONFIRMATION_INTERNAL'
when mst.trx_type_code=3 and upper(src.status)='REJECTED' then 'SWP_ORDER_REJECTION_INTERNAL'
when mst.trx_type_code=5 and upper(src.status)='ORDERED' then 'REDEMPTION_ORDER_CONFIRMATION_INTERNAL'
when mst.trx_type_code=5 and upper(src.status)='REJECTED' then 'MF_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
when mst.trx_type_code=5 and upper(src.status)='CANCELLED' then 'MF_ORDER_REJECTION_BSE_CLIENT_INTERNAL'
when mst.trx_type_code=3 and upper(src.status)='REJECTED' then 'SWP_CANCELLATION_REJECTION_INTERNAL'
when mst.trx_type_code=3 and upper(src.status)='CANCELLED' then 'SWP_CANCELLATION_CONFIRMATION_INTERNAL'
else '' end)::character varying subcategory,
false as is_picked
from transactions.mf_order_detail dest 
join transactions.stg_dion_orderbook_swp src 
on dest.vendor_trx_id = src.txnid
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code
and mst.category_code=261
where dest.trx_type_code in (3,5)
and coalesce(dest.vendor_trx_status,'') <> coalesce(src.status,'')
and upper(src.status) in ('ORDERED','REJECTED','CANCELLED')
--and dest.order_placed_by='RM'
and dest.datasource='DION';
--*/
	
	IF EXISTS(SELECT 1 FROM transactions.stg_dion_orderbook_SWP)
	THEN

		CREATE TEMP TABLE IF NOT EXISTS temp_exist_mf_trx AS
		SELECT dest.trx_id as txnid 
		FROM transactions.mf_order_detail dest JOIN transactions.stg_dion_orderbook_SWP src 
		ON dest.vendor_trx_id = src.txnid
		WHERE (
				COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone)
				OR COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')
				--OR COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'')
				--OR COALESCE(dest.nav,0) <> COALESCE(src.nav,0)
				--OR COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date)
				OR COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'')
				--OR COALESCE(dest.tokenno,0) <> COALESCE(src.token,0)
--				OR COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0)
				--OR COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'')
				OR COALESCE(dest.vendor_exchg_refno,'0') <> COALESCE(src.exchangerefno,0)::character varying
				--OR COALESCE(dest.is_generatedtoday,FALSE) <> CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END
			  );
		
		UPDATE transactions.mf_order_detail dest 
		SET
		trx_datetime = CASE WHEN COALESCE(dest.trx_datetime,'1900-01-01'::timestamp without time zone) <> COALESCE((src.txndate||' '||src.txntime)::timestamp without time zone,'1900-01-01'::timestamp without time zone) THEN (src.txndate||' '||src.txntime)::timestamp without time zone ELSE dest.trx_datetime END
		, modified_by = CASE WHEN COALESCE(dest.modified_by,'') <> COALESCE(src.lastmodifiedby,'') THEN src.lastmodifiedby ELSE dest.modified_by END
		, nav = CASE WHEN COALESCE(dest.nav,0) <> COALESCE(src.nav,0) THEN src.nav ELSE dest.nav END
		, navdate = CASE WHEN COALESCE(dest.navdate,'1900-01-01'::date) <> COALESCE(src.navdate,'1900-01-01'::date) THEN src.navdate ELSE dest.navdate END
		, order_remarks = CASE WHEN COALESCE(dest.order_remarks,'') <> COALESCE(src.orderremarks,'') THEN src.orderremarks ELSE dest.order_remarks END
		, tokenno = CASE WHEN COALESCE(dest.tokenno,0) <> COALESCE(src.token,0) THEN src.token ELSE dest.tokenno END
--		, switchtokenno = CASE WHEN COALESCE(dest.switchtokenno,0) <> COALESCE(src.switchtoken,0) THEN src.switchtoken ELSE dest.switchtokenno END
		, euinnumber = CASE WHEN COALESCE(dest.euinnumber,'') <> COALESCE(src.euinnumber,'') THEN src.euinnumber ELSE dest.euinnumber END
		, vendor_exchg_refno = CASE WHEN COALESCE(dest.vendor_exchg_refno,'') <> COALESCE(src.exchangerefno,0)::character varying THEN src.exchangerefno::character varying ELSE dest.vendor_exchg_refno END
		,vendor_trx_status= CASE WHEN COALESCE(dest.vendor_trx_status,'') <> COALESCE(src.status,'')::character varying THEN src.status::character varying ELSE dest.vendor_trx_status END
		, modified_date = NOW()
		FROM transactions.stg_dion_orderbook_SWP src
		WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);

		UPDATE transactions.mf_order_detail dest 
		SET
			vendor_trx_status = UPPER(src.status)
			, trx_status = trx_sts.trx_status
			, trx_status_code = sts.trx_status_code
	,inv_action = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 ) AND sts.trx_status_code = 3 THEN (SELECT inv.inv_action FROM master.investment_action inv WHERE inv.inv_action_code = 4)
ELSE dest.inv_action END
	,inv_action_code = CASE WHEN EXISTS (SELECT 1 FROM transactions.mf_order_detail_modification mod WHERE mod.org_trx_id = dest.trx_id AND mod.inv_action_code = 4 ) AND sts.trx_status_code = 3 THEN 4
ELSE dest.inv_action_code END
			, modified_date = NOW()
			FROM transactions.stg_dion_orderbook_SWP src
		JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
		JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
			WHERE dest.vendor_trx_id = src.txnid
		and dest.trx_id in (select txnid from temp_exist_mf_trx);

		----to be removed for incremental----
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = 2, consent_status = 'Consent Approved'
		WHERE A.trx_id in (select txnid from temp_exist_mf_trx)
		AND order_placed_by <> 'CLIENT' AND consent_status_code IS NULL;
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status ,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail D
		LEFT JOIN master.mv_map_category_status B -- master schema name added
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND coalesce(D.consent_status_code,0) = coalesce(B.consent_status_code,0)
		--AND coalesce(D.payment_status_code,0) = coalesce (B.payment_status_code,0)
		AND coalesce (B.payment_status_code,0) = CASE WHEN D.inv_action_code <> 1 THEN 0 ELSE coalesce (D.payment_status_code,0) END
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id 
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

		--- one time / full load 	
		UPDATE transactions.mf_order_detail org SET 
		isinname = B.isinname
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_isin b on A.isincode=b.isincode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
	
		
		UPDATE transactions.mf_order_detail org SET 
		schemegroup = B.schemegroup
		FROM transactions.mf_order_detail A 
		JOIN master.dim_mf_scheme b on A.mf_schcode =b.mf_schcode 
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

	 
		UPDATE transactions.mf_order_detail org SET 
		return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin) B ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);
		
		UPDATE transactions.mf_order_detail A 
		SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
									B.partner_code ELSE B.client_owner END,
		order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
			   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
			   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		--and A.trx_id not in ( select txnid from temp_exist_mf_trx);
		and A.trx_id > v_trx_id;
		
		update transactions.mf_order_detail a
		set consent_status_code =
			case when order_placed_by ='CLIENT' and physicalflag='D' then 0
			when order_placed_by ='CLIENT' and physicalflag='P' then 2
			when order_placed_by in ('RM','PARTNER') then 2 end,
			
			consent_status = case when order_placed_by ='CLIENT' and physicalflag='D' then ''
			when order_placed_by ='CLIENT' and physicalflag='P' then 'Consent Approved'
			when order_placed_by in ('RM','PARTNER') then 'Consent Approved' end
		--where trx_id not in ( select txnid from temp_exist_mf_trx);
		where a.trx_id > v_trx_id;
		
		-----------------------
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = NOW(), 
			is_active = false
		FROM transactions.mf_order_detail b
		where a.trx_id = b.trx_id	
		and A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx) 
		AND A.is_active = true
		and (
		coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		
	
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		
		SELECT distinct 
			A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from		 
		FROM transactions.mf_order_detail A join transactions.mf_order_detail_history b
		on a.trx_id = b.trx_id 
		WHERE A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		and (
			coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.consent_status_code,0)  <> coalesce (b.consent_status_code,0)	
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		or coalesce (a.inv_plan_status_code,0)  <> coalesce (b.inv_plan_status_code,0)
			); 
		 		

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		WHERE trx_id IN (SELECT txnid FROM temp_exist_mf_trx)
		AND is_active = true 
		AND valid_to IS NULL;
		
		----------Updating Data into Summary Table----------
		UPDATE transactions.mf_order_summary A SET
		trx_final_status_code = B.trx_final_status_code,
		final_status = B.final_status,
		inv_plan_status_code = B.inv_plan_status_code,
		inv_plan_status = B.inv_plan_status
		FROM transactions.mf_order_detail B
		WHERE A.trx_id = B.trx_id
		AND A.trx_id IN (SELECT txnid FROM temp_exist_mf_trx);

----------Updating Data into Order_modification Table----------
UPDATE transactions.mf_order_detail_modification org SET
trx_status =  sts.internal_status, trx_status_code = sts.trx_status_code,
	vendor_trx_status = UPPER(sts.vendor_status), modified_date = NOW()
--FROM transactions.mf_order_detail_modification mod
-- JOIN temp_exist_mf_trx_status tmp ON tmp.txnid =  mod.org_trx_id
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SWP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND mod.final_status <> 'Order Rejected'
AND sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
							   WHEN mod.inv_action_code = 2 THEN 5
							   WHEN mod.inv_action_code = 0 THEN 4 END;

UPDATE transactions.mf_order_detail_modification org SET
order_remarks = src.orderremarks
, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 8)
, trx_status_code = 8
, final_status = 'Order Rejected'
, trx_final_status_code = 8
, inv_plan_status_code = 7
, inv_plan_status = 'Order Rejected'
, modified_date = NOW()
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id, M.inv_action_code ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) mod
JOIN transactions.stg_dion_orderbook_SWP src ON src.txnid = mod.vendor_trx_id --AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
AND UPPER(src.status) <> UPPER(COALESCE(mod.vendor_trx_status,''))
WHERE mod.rn = 1 AND org.trx_id = mod.trx_id AND UPPER(mod.inv_action) = 'CANCEL' AND UPPER(src.status) = 'ORDERED';

UPDATE transactions.mf_order_detail_modification A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail_modification D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
/* AND D.is_generatetoday = B.is_generatetoday */
AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id IN
(SELECT mod.trx_id FROM transactions.mf_order_detail_modification mod
 JOIN temp_exist_mf_trx tmp ON tmp.txnid =  mod.org_trx_id
 JOIN transactions.stg_dion_orderbook_SWP src ON src.txnid = mod.vendor_trx_id 
AND UPPER(TRIM(src.ordertype)) = UPPER(mod.inv_action)
 JOIN master.map_vendor_internal_trx_status sts 
ON sts.vendor_status = UPPER(TRIM(REGEXP_REPLACE(src.status, E'\\s+', ' ', 'g'))) AND sts.category_code = 261 AND sts.isactive = true
 WHERE sts.trx_status_code = CASE WHEN mod.inv_action_code = 4 THEN 3
								  WHEN mod.inv_action_code = 2 THEN 5
								  WHEN mod.inv_action_code = 0 THEN 4 END
); 

-------------------------------------------------		
-- new trx insert
	
SELECT nextval('transactions.mf_order_detail_trx_id_seq'::regclass) INTO v_trx_id;

INSERT INTO transactions.mf_order_detail
(vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby
, delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate
, order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks
, tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan
, euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday
, inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code
,qty_or_amt_order, mf_schcode,isinname , schemegroup)
		
SELECT src.txnid as vendor_trx_id, src.clientcode as ac_code, src.userid as "user_id", src.isin as isincode, txn.trx_type as trx_type
,(src.txndate||' '||src.txntime)::timestamp without time zone as trx_datetime, 
case when coalesce(src.amount,0)=0 then (coalesce(src.units,0)*coalesce(src.ordernav,0)) else src.amount end as trx_amt, 
coalesce(case when coalesce(src.units,0) =0 then case when coalesce(src.ordernav,0)=0 then 0 
else (coalesce(src.amount,0)/coalesce(src.ordernav,0)) end end,0) as trx_qty,
'DION'::character varying as datasource,
case when coalesce(src.orderedby,'')='' then src.clientcode else src.orderedby end as orderedby,
src.traxmode as delivery_mode,src.mandateid as mandate_id,trx_sts.trx_status, 
case when trim(upper(src.paymentstatus))='PAID' then 'Processed'
when trim(upper(src.paymentstatus))='UNPAID' then 'Pending'
when trim(upper(src.paymentstatus))='PROCESSING' then 'Pending'
else dps.payment_status end payment_status
, src.lastmodifiedon as modified_date, src.lastmodifiedby as modified_by
,src.ordersource as trx_source, (src.txndate||' '||src.txntime)::timestamp without time zone as created_date, src.nav, src.navdate
,src.ordernav as order_nav, src.ordernavdate as order_navdate, src.foliono as folio_no, 
trim(upper(src.ordertype)) as order_type, coalesce (src.physicalflag,'D') as physicalflag
,src.orderremarks as order_remarks--, src.arn
,src.token as tokenno, src.switchtoken as switchtokenno
,src.exchangerefno as vendor_exchg_refno, mst.ucccode, mst.pan
,src.euinnumber, src.switchisin as switch_isin, 
1 as internal_flag, trx.trx_type_code, sts.trx_status_code
,CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END as is_generatetoday
,txn.inv_type_code, inv.inv_type,
case when trx_sts.trx_status_code=3 then 4 else 1 end inv_action_code,
--1 as inv_action_code,  
(case when trx_sts.trx_status_code=3 then 'Cancel'
else 'Transaction' end ) ::character varying as inv_action,
--'Transaction'::character varying as inv_action, 
UPPER(src.status),
case when trim(upper(src.paymentstatus))='PAID' then 2
when trim(upper(src.paymentstatus))='UNPAID' then 1
when trim(upper(src.paymentstatus))='PROCESSING' then 1
when trim(upper(coalesce(src.paymentstatus,'')))='' then 0
else PM.payment_status_code end payment_status_code,
case when coalesce(src.amount,0)<>0 then 'A' else 'Q' end as qty_or_amt_order,
isin.mf_schcode,isin.isinname,sch.schemegroup
FROM transactions.stg_dion_orderbook_SWP src
LEFT JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
JOIN master.map_vendor_internal_trx_status sts 
ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
left join master.map_vendor_internal_payment_status pm on pm.vendor_payment_status = upper(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = true
left join master.dim_payment_status dps on dps.payment_status_code = pm.payment_status_code
inner join master.dim_mf_isin isin on src.isin=isin.isincode
JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
WHERE dest.trx_id IS NULL;

		UPDATE transactions.mf_order_detail A 
		SET 
			display_trx_id = ('MF'||LPAD(trx_id::character varying, 10, '0'))::character varying 
		WHERE display_trx_id IS NULL;
				
		UPDATE transactions.mf_order_detail A 
		SET
			rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN 
										B.partner_code ELSE B.client_owner END,
										
			order_placed_by = CASE WHEN COALESCE(A.orderby, A.ac_code) <> A.ac_code
				   					THEN CASE WHEN A.orderby = B.partner_code THEN 'PARTNER' ELSE 'RM' END
				   					ELSE 'CLIENT' END::character varying
		FROM master.dim_ucc B 
		WHERE TRIM(A.ac_code) = B.priority_ac_code
		AND (A.rm_partner_code IS NULL OR A.order_placed_by IS NULL)
		and A.trx_id > v_trx_id;
		

		UPDATE transactions.mf_order_detail org 
		SET 
			return_type = B.return_type
		FROM transactions.mf_order_detail A 
		JOIN (SELECT DISTINCT "token", isincode, isinname, return_type, schemegroup
			  FROM master.dim_mf_exchange_isin
			  ) B 
		ON A.isincode = B.isincode AND A.tokenno = B."token"
		WHERE A.trx_id = org.trx_id AND org.trx_id >= v_trx_id;
		
		----to be removed for incremental----
		UPDATE transactions.mf_order_detail A 
		SET consent_status_code = case 
		when inv_action_code =4  and  order_placed_by<>'CLIENT' then 2
		when physicalflag='P' and order_placed_by='CLIENT' then 2
		when order_placed_by<>'CLIENT' then 2 else 0 end,
		consent_status = case 
		when inv_action_code =4  and  order_placed_by<>'CLIENT' then 'Consent Approved'
		when physicalflag='P' and order_placed_by='CLIENT' then 'Consent Approved'
		when order_placed_by<>'CLIENT' then 'Consent Approved' else'' end,
		payment_status_code = 0,
		payment_status = ''
		WHERE A.trx_id >= v_trx_id;

		UPDATE transactions.mf_order_detail A 
		set is_generatetoday= case when trx_status_code =3 then false 
			else is_generatetoday end
		WHERE A.trx_id >= v_trx_id;
		
		UPDATE transactions.mf_order_detail A 
		SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			
		FROM transactions.mf_order_detail D
		JOIN master.MV_map_category_status B
		ON UPPER(B.usertype) = UPPER(D.order_placed_by)
		AND D.physicalflag = B.physicalflag
		AND D.trx_type_code = B.trx_type_code
		--AND D.is_generatetoday = B.is_generatetoday
		AND COALESCE(D.consent_status_code, 0) = COALESCE(B.consent_status_code, 0)
		AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
		AND B.trx_status_code = D.trx_status_code
		AND B.inv_action_code = D.inv_action_code
		AND B.category_code = 261
		WHERE A.trx_id = D.trx_id AND A.trx_id >= v_trx_id;

		DROP TABLE temp_exist_mf_trx; 

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_detail_history
		(
			trx_id, vendor_trx_id, ucccode, ac_code, trx_datetime , is_active , trx_type_code,
			trx_type, consent_status_code, consent_status , trx_status_code, trx_status ,
			vendor_trx_status, payment_status_code , payment_status, inv_plan_status_code , inv_plan_status , 
			trx_final_status_code , final_status , mandate_id , order_remarks , trx_source , inserted_dt , valid_from
		)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_datetime , true as is_active , a.trx_type_code,
			A.trx_type, A.consent_status_code, A.consent_status , A.trx_status_code, A.trx_status ,
			A.vendor_trx_status, A.payment_status_code , A.payment_status, a.inv_plan_status_code , a.inv_plan_status , 
			a.trx_final_status_code , a.final_status , a.mandate_id , A.order_remarks , A.trx_source,  
			NOW() as inserted_dt , now() as valid_from
		 FROM transactions.mf_order_detail A --
		 WHERE A.trx_id >= v_trx_id
		 and NOT EXISTS (SELECT B.trx_id FROM transactions.mf_order_detail_history B 
							WHERE A.trx_id = B.trx_id
							);

		UPDATE transactions.mf_order_detail_history 
		SET 
			valid_to = '9999-12-31'::timestamp without time zone 
		
		WHERE is_active = true 
		AND valid_to IS NULL;
------------------------------------------------------------------------------------------
-- Error Transaction
	
		-- DELETE FROM transactions.mf_order_detail_error WHERE error_date >= NOW() - INTERVAL '7 days';
		DELETE FROM transactions.mf_order_detail_error A
		WHERE EXISTS (SELECT B.txnid FROM  transactions.stg_dion_orderbook_SWP B WHERE A.vendor_trx_id = B.txnid);

			
		INSERT INTO transactions.mf_order_detail_error (
		    vendor_trx_id, ac_code, "user_id", isincode, trx_type, trx_datetime, trx_amt, trx_qty, datasource, orderby,
		    delivery_mode, mandate_id, trx_status, payment_status, modified_date, modified_by, trx_source, created_date, nav, navdate,
		    order_nav, order_navdate, folio_no, order_type, physicalflag, order_remarks,
		    tokenno, switchtokenno, vendor_exchg_refno, ucccode, pan,
		    euinnumber, switch_isin, internal_flag, trx_type_code, trx_status_code, is_generatetoday,
		    inv_type_code, inv_type, inv_action_code, inv_action, vendor_trx_status, payment_status_code,
		    qty_or_amt_order, mf_schcode, isinname, schemegroup, error_message
		)
		SELECT 
		    src.txnid AS vendor_trx_id, src.clientcode AS ac_code, src.userid AS "user_id", src.isin AS isincode, txn.trx_type AS trx_type,
		    (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS trx_datetime,
		    CASE 
		        WHEN COALESCE(src.amount, 0) = 0 THEN (COALESCE(src.units, 0) * COALESCE(src.ordernav, 0)) 
		        ELSE src.amount 
		    END AS trx_amt,
		    COALESCE(
		        CASE 
		            WHEN COALESCE(src.units, 0) = 0 THEN 
		                CASE 
		                    WHEN COALESCE(src.ordernav, 0) = 0 THEN 0 
		                    ELSE (COALESCE(src.amount, 0) / COALESCE(src.ordernav, 0)) 
		                END 
		        END, 
		        0
		    ) AS trx_qty,
		    'DION'::character varying, 
		    CASE WHEN COALESCE(src.orderedby, '') = '' THEN src.clientcode ELSE src.orderedby END AS orderedby,
		    src.traxmode AS delivery_mode, src.mandateid AS mandate_id, trx_sts.trx_status, 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 'Processed'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 'Pending'
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 'Pending'
		        ELSE dps.payment_status 
		    END AS payment_status,
		    src.lastmodifiedon AS modified_date, src.lastmodifiedby AS modified_by,
		    src.ordersource AS trx_source, (src.txndate || ' ' || src.txntime)::timestamp WITHOUT TIME ZONE AS created_date, 
		    src.nav, src.navdate, src.ordernav AS order_nav, src.ordernavdate AS order_navdate, 
		    src.foliono AS folio_no, TRIM(UPPER(src.ordertype)) AS order_type, COALESCE(src.physicalflag, 'D') AS physicalflag,
		    src.orderremarks AS order_remarks, src.token AS tokenno, src.switchtoken AS switchtokenno,
		    src.exchangerefno AS vendor_exchg_refno, mst.ucccode, mst.pan,
		    src.euinnumber, src.switchisin AS switch_isin, 1 AS internal_flag, trx.trx_type_code, sts.trx_status_code,
		    CASE WHEN COALESCE(src.genratetoday, 'N') = 'Y' THEN TRUE ELSE FALSE END,
		    txn.inv_type_code, inv.inv_type, 1 AS inv_action_code, 'Transaction'::character varying AS inv_action, 
		    UPPER(src.status), 
		    CASE 
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PAID' THEN 2
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'UNPAID' THEN 1
		        WHEN TRIM(UPPER(src.paymentstatus)) = 'PROCESSING' THEN 1
		        WHEN TRIM(UPPER(COALESCE(src.paymentstatus, ''))) = '' THEN 0
		        ELSE PM.payment_status_code 
		    END AS payment_status_code,
		    CASE WHEN COALESCE(src.amount, 0) <> 0 THEN 'A' ELSE 'Q' END AS qty_or_amt_order,
		    isin.mf_schcode, 
		    isin.isinname, 
		    sch.schemegroup,
		    CONCAT(
	        CASE WHEN mst.ucccode IS NULL THEN 'UCC is not found; ' ELSE '' END,
	        CASE WHEN isin.isincode IS NULL THEN 'ISIN is not available in master; ' ELSE '' END,
	        CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END,
	        CASE WHEN src.txntype IS NULL THEN 'Transaction type is not available in stage; ' ELSE '' END,
	        CASE WHEN src.status IS NULL THEN 'Transaction Status is not available in stage; ' ELSE '' END
	        ) AS error_message

		FROM transactions.stg_dion_orderbook_SWP src
-- 		JOIN transactions.mf_order_detail dest ON dest.vendor_trx_id = src.txnid
		LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
		LEFT JOIN master.map_vendor_internal_trx_type trx 
		    ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = TRUE
		LEFT JOIN master.trx_type txn 
		    ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = TRUE
		LEFT JOIN master.investment_type inv 
		    ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_trx_status sts 
		    ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = TRUE
		LEFT JOIN master.trx_status trx_sts 
		    ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = TRUE
		LEFT JOIN master.map_vendor_internal_payment_status pm 
		    ON pm.vendor_payment_status = UPPER(src.paymentstatus) AND pm.category_code = 261 AND pm.isactive = TRUE
		LEFT JOIN master.dim_payment_status dps ON dps.payment_status_code = pm.payment_status_code
		LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
		LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
		WHERE mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS null
		OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL;
	/*
		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    ac_code = EXCLUDED.ac_code,
		    "user_id" = EXCLUDED."user_id",
		    trx_type = EXCLUDED.trx_type,
		    trx_datetime = EXCLUDED.trx_datetime,
		    trx_amt = EXCLUDED.trx_amt,
		    trx_qty = EXCLUDED.trx_qty,
		    datasource = EXCLUDED.datasource,
		    orderby = EXCLUDED.orderby,
		    delivery_mode = EXCLUDED.delivery_mode,
		    mandate_id = EXCLUDED.mandate_id,
		    trx_status = EXCLUDED.trx_status,
		    payment_status = EXCLUDED.payment_status,
		    modified_date = EXCLUDED.modified_date,
		    modified_by = EXCLUDED.modified_by,
		    trx_source = EXCLUDED.trx_source,
		    created_date = EXCLUDED.created_date,
		    nav = EXCLUDED.nav,
		    navdate = EXCLUDED.navdate,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    folio_no = EXCLUDED.folio_no,
		    order_type = EXCLUDED.order_type,
		    physicalflag = EXCLUDED.physicalflag,
		    order_remarks = EXCLUDED.order_remarks,
		    tokenno = EXCLUDED.tokenno,
		    switchtokenno = EXCLUDED.switchtokenno,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    ucccode = EXCLUDED.ucccode,
		    pan = EXCLUDED.pan,
		    euinnumber = EXCLUDED.euinnumber,
		    switch_isin = EXCLUDED.switch_isin,
		    internal_flag = EXCLUDED.internal_flag,
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    is_generatetoday = EXCLUDED.is_generatetoday,
		    inv_type_code = EXCLUDED.inv_type_code,
		    inv_type = EXCLUDED.inv_type,
		    inv_action_code = EXCLUDED.inv_action_code,
		    inv_action = EXCLUDED.inv_action,
		    vendor_trx_status = EXCLUDED.vendor_trx_status,
		    payment_status_code = EXCLUDED.payment_status_code,
		    qty_or_amt_order = EXCLUDED.qty_or_amt_order,
		    mf_schcode = EXCLUDED.mf_schcode,
		    isinname = EXCLUDED.isinname,
		    schemegroup = EXCLUDED.schemegroup,
		    error_message = EXCLUDED.error_message;
*/
---------------------------------------------------------------------------------------------------	
				
		RETURN 'SUCCESS';
	
	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_14jul2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_14jul2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_14jul2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_14jul2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_detail_swp_bkp_14jul2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_summary();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.stg_dion_siporder)
	THEN
	
		SELECT CASE WHEN UPPER(src.status) = 'CANCELLED' THEN true ELSE false END INTO v_iscancel FROM transactions.stg_dion_siporder src;

		CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
		SELECT destn.id FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
		WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') OR
			   COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) OR
			   COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') OR
			   TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') OR
			   COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) OR
			   COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') OR
			   COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') OR
			   COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') OR
			   COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') OR COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') OR
			   COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') OR
			   COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') OR COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) OR
			   v_iscancel <> COALESCE(destn.iscancel,false) OR COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) OR
			   COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') OR
			   COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) OR COALESCE(src.pausecount,0) <> COALESCE(destn.pausecount,0) OR
			   COALESCE(src.pausemodificationcount,0) <> COALESCE(destn.pausemodificationcount,0) OR COALESCE(src.modifycount,0) <> COALESCE(destn.modifycount,0) OR
			   COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,''));
		
		CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
		SELECT destn.id FROM transactions.mf_order_summary destn
		JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
		WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

		UPDATE transactions.mf_order_summary destn SET
		  trx_datetime =  CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
		, reg_no =  CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
		, start_date =  CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
		, end_date =  CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
		, trx_status =  CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
		, "user_id" =  CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
		, installment_paid =  CASE WHEN COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) THEN src.instalementspaid ELSE destn.installment_paid END
		, installment_pending =  CASE WHEN COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) THEN src.instalmentspending ELSE destn.installment_pending END
		, reinvestmentflag =  CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
		, nav =  CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
		, order_remarks =  CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
		, euinnumber =  CASE WHEN COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') THEN src.euinnumber ELSE destn.euinnumber END
		, cancellation_date =  CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
		, dpc =  CASE WHEN COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') THEN src.dpc ELSE destn.dpc END
		, firstordertoday =  CASE WHEN COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') THEN src.firstordertoday ELSE destn.firstordertoday END
		, childordernumber =  CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
		, tokenno =  CASE WHEN COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) THEN src.token ELSE destn.tokenno END
		, iscancel =  CASE WHEN v_iscancel <> COALESCE(destn.iscancel,false) THEN v_iscancel ELSE destn.iscancel END
		, ispaused =  CASE WHEN COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) THEN src.ispaused ELSE destn.ispaused END
		, istopup =  CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
		, vendor_exchg_refno =  CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
		, topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
		, pausecount = CASE WHEN COALESCE(src.pausecount,0) <> COALESCE(destn.pausecount,0) THEN src.pausecount ELSE destn.pausecount END
		, pausemodificationcount = CASE WHEN COALESCE(src.pausemodificationcount,0) <> COALESCE(destn.pausemodificationcount,0) THEN src.pausemodificationcount ELSE destn.pausemodificationcount END
		, modifycount = CASE WHEN COALESCE(src.modifycount,0) <> COALESCE(destn.modifycount,0) THEN src.modifycount ELSE destn.modifycount END
		, modifytype = CASE WHEN COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') THEN src.modifytype ELSE destn.modifytype END
		, mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
		, modified_date = (NOW() at time zone 'Asia/Kolkata')
		FROM transactions.stg_dion_siporder src
		WHERE src.txnid = destn.vendor_trx_id AND destn.id IN (SELECT id FROM temp_mf_trx);
	
		UPDATE transactions.mf_order_summary A SET trx_status_code = B.trx_status_code FROM master.map_vendor_internal_trx_status B 
		WHERE UPPER(A.trx_status) = UPPER(B.vendor_status) AND A.id IN (SELECT id FROM temp_mf_trx_status);
		
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_summary_history
		SET valid_to = (NOW() at time zone 'Asia/Kolkata'), is_active = false
		WHERE id IN (SELECT id FROM temp_mf_trx) AND is_active = true;
		
		INSERT INTO transactions.mf_order_summary_history
		(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
		 , trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
		 , no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
		 , previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
		SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
		 , A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
		 , A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
		 , A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, (NOW() at time zone 'Asia/Kolkata'), true
		FROM transactions.mf_order_summary A WHERE A.id IN (SELECT id FROM temp_mf_trx);

		UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

		DROP TABLE temp_mf_trx; 
		DROP TABLE temp_mf_trx_status; 
		

		INSERT INTO transactions.mf_order_summary
		(trx_datetime, order_no, vendor_trx_id, reg_no, ac_code, trx_type, trx_amt, start_date, end_date, folio_no, trx_status, orderby, isincode, frequency
		 , no_of_installment, installment_paid, installment_pending, mandate_id, iscancel, reinvestmentflag, nav, mfimfdflag, order_remarks, euinnumber--, arn
		 , rm_partner_code, cancellation_date, dpc, firstordertoday, delivery_mode, "user_id", trx_source, order_nav, order_navdate, childordernumber
		 , tokenno, mandate_amt, ispaused, istopup, vendor_exchg_refno, pausemodificationcount, topupcount, pausecount, mainsipregno, modifytype, modifycount
		 , created_date, modified_date, trx_type_code, trx_status_code, datasource, pan)
		SELECT DISTINCT (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, src.txnid, src.sipregno, src.clientcode, src.txntype, src.amount
		, src.sipstartdate, src.sipenddate, src.foliono, TRIM(UPPER(src.status)), src.orderedby, src.isin, src.frequency, src.totalinstalments, src.instalementspaid
		, src.instalmentspending, src.mandateid, v_iscancel, src.reinvestmentflag, src.nav, src.mfimfdflag, src.remarks, src.euinnumber--, src.arn
		, src.rmcode, src.sipcancellationdate, src.dpc, src.firstordertoday, src.traxmode, src.userid, src.usertype, src.ordernav, src.ordernavdate
		, src.childordernumber, src.token, src.mandateamount, src.ispaused, src.istopup, src.exchangerefnumber, src.pausemodificationcount, src.topupcount
		, src.pausecount, src.mainsipregno, src.modifytype, src.modifycount, (NOW() at time zone 'Asia/Kolkata'), (NOW() at time zone 'Asia/Kolkata')
		, (SELECT A.trx_type_code FROM master.category_trx_type A WHERE UPPER(src.txntype) = UPPER(A.vendor_trx_type))
		, (SELECT B.status_id FROM master.category_trx_status B WHERE UPPER(src.status) = UPPER(B.vendor_status))
		, 'DION'::character varying, (SELECT mst.pan FROM master.dim_customer mst WHERE mst.ac_code = src.clientcode)
		FROM transactions.stg_dion_siporder src
		LEFT JOIN transactions.mf_order_summary destn ON src.txnid = destn.vendor_trx_id
		WHERE destn.id IS NULL;
			
		UPDATE transactions.mf_order_summary A SET mf_schcode = B.mf_schcode
		FROM master.dim_mf_isin B WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

		UPDATE transactions.mf_order_summary A SET trx_id = B.trx_id, display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
		FROM transactions.mf_order_detail B WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

		UPDATE transactions.mf_order_summary A SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner ELSE B.client_owner END
		FROM master.dim_ucc B WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_summary_history
		(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
		 , trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
		 , no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
		 , previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
		SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
		 , A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
		 , A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
		 , A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, (NOW() at time zone 'Asia/Kolkata'), true
		FROM transactions.mf_order_summary A
		WHERE NOT EXISTS (SELECT * FROM transactions.mf_order_summary_history B WHERE A.id = B.id);
		
		UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

		RETURN 'SUCCESS';

	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_bkp_09may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.stg_dion_siporder)
	THEN
	
		SELECT CASE WHEN UPPER(src.status) = 'CANCELLED' THEN true ELSE false END INTO v_iscancel FROM transactions.stg_dion_siporder src;

		CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
		SELECT destn.id FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
		WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') OR
			   COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) OR
			   COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') OR
			   TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') OR
			   COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) OR
			   COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') OR
			   COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') OR
			   COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') OR
			   COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') OR COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') OR
			   COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') OR
			   COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') OR COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) OR
			   v_iscancel <> COALESCE(destn.iscancel,false) OR COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) OR
			   COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') OR
			   COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) OR COALESCE(src.pausecount,0) <> COALESCE(destn.pausecount,0) OR
			   COALESCE(src.pausemodificationcount,0) <> COALESCE(destn.pausemodificationcount,0) OR COALESCE(src.modifycount,0) <> COALESCE(destn.modifycount,0) OR
			   COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,''));
		
		CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
		SELECT destn.id FROM transactions.mf_order_summary destn
		JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
		WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

		UPDATE transactions.mf_order_summary destn SET
		  trx_datetime =  CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
		, reg_no =  CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
		, start_date =  CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
		, end_date =  CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
		, trx_status =  CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
		, "user_id" =  CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
		, installment_paid =  CASE WHEN COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) THEN src.instalementspaid ELSE destn.installment_paid END
		, installment_pending =  CASE WHEN COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) THEN src.instalmentspending ELSE destn.installment_pending END
		, reinvestmentflag =  CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
		, nav =  CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
		, order_remarks =  CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
		, euinnumber =  CASE WHEN COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') THEN src.euinnumber ELSE destn.euinnumber END
		, cancellation_date =  CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
		, dpc =  CASE WHEN COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') THEN src.dpc ELSE destn.dpc END
		, firstordertoday =  CASE WHEN COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') THEN src.firstordertoday ELSE destn.firstordertoday END
		, childordernumber =  CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
		, tokenno =  CASE WHEN COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) THEN src.token ELSE destn.tokenno END
		, iscancel =  CASE WHEN v_iscancel <> COALESCE(destn.iscancel,false) THEN v_iscancel ELSE destn.iscancel END
		, ispaused =  CASE WHEN COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) THEN src.ispaused ELSE destn.ispaused END
		, istopup =  CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
		, vendor_exchg_refno =  CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
		, topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
		, pausecount = CASE WHEN COALESCE(src.pausecount,0) <> COALESCE(destn.pausecount,0) THEN src.pausecount ELSE destn.pausecount END
		, pausemodificationcount = CASE WHEN COALESCE(src.pausemodificationcount,0) <> COALESCE(destn.pausemodificationcount,0) THEN src.pausemodificationcount ELSE destn.pausemodificationcount END
		, modifycount = CASE WHEN COALESCE(src.modifycount,0) <> COALESCE(destn.modifycount,0) THEN src.modifycount ELSE destn.modifycount END
		, modifytype = CASE WHEN COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') THEN src.modifytype ELSE destn.modifytype END
		, mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
		, modified_date = NOW()
		FROM transactions.stg_dion_siporder src
		WHERE src.txnid = destn.vendor_trx_id AND destn.id IN (SELECT id FROM temp_mf_trx);
	
		UPDATE transactions.mf_order_summary A SET trx_status_code = B.trx_status_code FROM master.map_vendor_internal_trx_status B 
		WHERE UPPER(A.trx_status) = UPPER(B.vendor_status) AND A.id IN (SELECT id FROM temp_mf_trx_status);
		
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_summary_history
		SET valid_to = NOW(), is_active = false
		WHERE id IN (SELECT id FROM temp_mf_trx) AND is_active = true;
		
		INSERT INTO transactions.mf_order_summary_history
		(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
		 , trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
		 , no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
		 , previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
		SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
		 , A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
		 , A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
		 , A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
		FROM transactions.mf_order_summary A WHERE A.id IN (SELECT id FROM temp_mf_trx);

		UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

		DROP TABLE temp_mf_trx; 
		DROP TABLE temp_mf_trx_status; 
		

		INSERT INTO transactions.mf_order_summary
		(trx_datetime, order_no, vendor_trx_id, reg_no, ac_code, trx_type, trx_amt, start_date, end_date, folio_no, trx_status, orderby, isincode, frequency
		 , no_of_installment, installment_paid, installment_pending, mandate_id, iscancel, reinvestmentflag, nav, mfimfdflag, order_remarks, euinnumber--, arn
		 , rm_partner_code, cancellation_date, dpc, firstordertoday, delivery_mode, "user_id", trx_source, order_nav, order_navdate, childordernumber
		 , tokenno, mandate_amt, ispaused, istopup, vendor_exchg_refno, pausemodificationcount, topupcount, pausecount, mainsipregno, modifytype, modifycount
		 , created_date, modified_date, trx_type_code, trx_status_code, datasource, pan)
		SELECT DISTINCT (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, src.txnid, src.sipregno, src.clientcode, src.txntype, src.amount
		, src.sipstartdate, src.sipenddate, src.foliono, TRIM(UPPER(src.status)), src.orderedby, src.isin, src.frequency, src.totalinstalments, src.instalementspaid
		, src.instalmentspending, src.mandateid, v_iscancel, src.reinvestmentflag, src.nav, src.mfimfdflag, src.remarks, src.euinnumber--, src.arn
		, src.rmcode, src.sipcancellationdate, src.dpc, src.firstordertoday, src.traxmode, src.userid, src.usertype, src.ordernav, src.ordernavdate
		, src.childordernumber, src.token, src.mandateamount, src.ispaused, src.istopup, src.exchangerefnumber, src.pausemodificationcount, src.topupcount
		, src.pausecount, src.mainsipregno, src.modifytype, src.modifycount, NOW(), NOW()
		, (SELECT A.trx_type_code FROM master.category_trx_type A WHERE UPPER(src.txntype) = UPPER(A.vendor_trx_type))
		, (SELECT B.status_id FROM master.category_trx_status B WHERE UPPER(src.status) = UPPER(B.vendor_status))
		, 'DION'::character varying, (SELECT mst.pan FROM master.dim_customer mst WHERE mst.ac_code = src.clientcode)
		FROM transactions.stg_dion_siporder src
		LEFT JOIN transactions.mf_order_summary destn ON src.txnid = destn.vendor_trx_id
		WHERE destn.id IS NULL;
			
		UPDATE transactions.mf_order_summary A SET mf_schcode = B.mf_schcode
		FROM master.dim_mf_isin B WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

		UPDATE transactions.mf_order_summary A SET trx_id = B.trx_id, display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
		FROM transactions.mf_order_detail B WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

		UPDATE transactions.mf_order_summary A SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner ELSE B.client_owner END
		FROM master.dim_ucc B WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_summary_history
		(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
		 , trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
		 , no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
		 , previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
		SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
		 , A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
		 , A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
		 , A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
		FROM transactions.mf_order_summary A
		WHERE NOT EXISTS (SELECT * FROM transactions.mf_order_summary_history B WHERE A.id = B.id);
		
		UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

		RETURN 'SUCCESS';

	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_bkp_09may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_bkp_09may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_bkp_09may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_bkp_09may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_bkp_14jul2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_bkp_14jul2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.stg_dion_siporder)
	THEN
	
		SELECT CASE WHEN UPPER(src.status) = 'CANCELLED' THEN true ELSE false END INTO v_iscancel FROM transactions.stg_dion_siporder src;

		CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
		SELECT destn.id FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
		WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') OR
			   COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) OR
			   COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') OR
			   TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') OR
			   COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) OR
			   COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') OR
			   COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') OR
			   COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') OR
			   COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') OR COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') OR
			   COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') OR
			   COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') OR COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) OR
			   v_iscancel <> COALESCE(destn.iscancel,false) OR COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) OR
			   COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') OR
			   COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) OR COALESCE(src.pausecount,0) <> COALESCE(destn.pausecount,0) OR
			   COALESCE(src.pausemodificationcount,0) <> COALESCE(destn.pausemodificationcount,0) OR COALESCE(src.modifycount,0) <> COALESCE(destn.modifycount,0) OR
			   COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,''));
		
		CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
		SELECT destn.id FROM transactions.mf_order_summary destn
		JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
		WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

		UPDATE transactions.mf_order_summary destn SET
		  trx_datetime =  CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
		, reg_no =  CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
		, start_date =  CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
		, end_date =  CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
		, trx_status =  CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
		, "user_id" =  CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
		, installment_paid =  CASE WHEN COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) THEN src.instalementspaid ELSE destn.installment_paid END
		, installment_pending =  CASE WHEN COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) THEN src.instalmentspending ELSE destn.installment_pending END
		, reinvestmentflag =  CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
		, nav =  CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
		, order_remarks =  CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
		, euinnumber =  CASE WHEN COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') THEN src.euinnumber ELSE destn.euinnumber END
		, cancellation_date =  CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
		, dpc =  CASE WHEN COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') THEN src.dpc ELSE destn.dpc END
		, firstordertoday =  CASE WHEN COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') THEN src.firstordertoday ELSE destn.firstordertoday END
		, childordernumber =  CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
		, tokenno =  CASE WHEN COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) THEN src.token ELSE destn.tokenno END
		, iscancel =  CASE WHEN v_iscancel <> COALESCE(destn.iscancel,false) THEN v_iscancel ELSE destn.iscancel END
		, ispaused =  CASE WHEN COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) THEN src.ispaused ELSE destn.ispaused END
		, istopup =  CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
		, vendor_exchg_refno =  CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
		, topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
		, pausecount = CASE WHEN COALESCE(src.pausecount,0) <> COALESCE(destn.pausecount,0) THEN src.pausecount ELSE destn.pausecount END
		, pausemodificationcount = CASE WHEN COALESCE(src.pausemodificationcount,0) <> COALESCE(destn.pausemodificationcount,0) THEN src.pausemodificationcount ELSE destn.pausemodificationcount END
		, modifycount = CASE WHEN COALESCE(src.modifycount,0) <> COALESCE(destn.modifycount,0) THEN src.modifycount ELSE destn.modifycount END
		, modifytype = CASE WHEN COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') THEN src.modifytype ELSE destn.modifytype END
		, mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
		, modified_date = NOW()
		FROM transactions.stg_dion_siporder src
		WHERE src.txnid = destn.vendor_trx_id AND destn.id IN (SELECT id FROM temp_mf_trx);
	
		UPDATE transactions.mf_order_summary A SET trx_status_code = B.trx_status_code FROM master.map_vendor_internal_trx_status B 
		WHERE UPPER(A.trx_status) = UPPER(B.vendor_status) AND A.id IN (SELECT id FROM temp_mf_trx_status);
		
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_summary_history
		SET valid_to = NOW(), is_active = false
		WHERE id IN (SELECT id FROM temp_mf_trx) AND is_active = true;
		
		INSERT INTO transactions.mf_order_summary_history
		(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
		 , trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
		 , no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
		 , previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
		SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
		 , A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
		 , A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
		 , A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
		FROM transactions.mf_order_summary A WHERE A.id IN (SELECT id FROM temp_mf_trx);

		UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

		DROP TABLE temp_mf_trx; 
		DROP TABLE temp_mf_trx_status; 
		

		INSERT INTO transactions.mf_order_summary
		(trx_datetime, order_no, vendor_trx_id, reg_no, ac_code, trx_type, trx_amt, start_date, end_date, folio_no, trx_status, orderby, isincode, frequency
		 , no_of_installment, installment_paid, installment_pending, mandate_id, iscancel, reinvestmentflag, nav, mfimfdflag, order_remarks, euinnumber--, arn
		 , rm_partner_code, cancellation_date, dpc, firstordertoday, delivery_mode, "user_id", trx_source, order_nav, order_navdate, childordernumber
		 , tokenno, mandate_amt, ispaused, istopup, vendor_exchg_refno, pausemodificationcount, topupcount, pausecount, mainsipregno, modifytype, modifycount
		 , created_date, modified_date, trx_type_code, trx_status_code, datasource, pan)
		SELECT DISTINCT (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, src.txnid, src.sipregno, src.clientcode, src.txntype, src.amount
		, src.sipstartdate, src.sipenddate, src.foliono, TRIM(UPPER(src.status)), src.orderedby, src.isin, src.frequency, src.totalinstalments, src.instalementspaid
		, src.instalmentspending, src.mandateid, v_iscancel, src.reinvestmentflag, src.nav, src.mfimfdflag, src.remarks, src.euinnumber--, src.arn
		, src.rmcode, src.sipcancellationdate, src.dpc, src.firstordertoday, src.traxmode, src.userid, src.usertype, src.ordernav, src.ordernavdate
		, src.childordernumber, src.token, src.mandateamount, src.ispaused, src.istopup, src.exchangerefnumber, src.pausemodificationcount, src.topupcount
		, src.pausecount, src.mainsipregno, src.modifytype, src.modifycount, NOW(), NOW()
		, (SELECT A.trx_type_code FROM master.category_trx_type A WHERE UPPER(src.txntype) = UPPER(A.vendor_trx_type))
		, (SELECT B.status_id FROM master.category_trx_status B WHERE UPPER(src.status) = UPPER(B.vendor_status))
		, 'DION'::character varying, (SELECT mst.pan FROM master.dim_customer mst WHERE mst.ac_code = src.clientcode)
		FROM transactions.stg_dion_siporder src
		LEFT JOIN transactions.mf_order_summary destn ON src.txnid = destn.vendor_trx_id
		WHERE destn.id IS NULL;
			
		UPDATE transactions.mf_order_summary A SET mf_schcode = B.mf_schcode
		FROM master.dim_mf_isin B WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

		UPDATE transactions.mf_order_summary A SET trx_id = B.trx_id, display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
		FROM transactions.mf_order_detail B WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

		UPDATE transactions.mf_order_summary A SET
		rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner ELSE B.client_owner END
		FROM master.dim_ucc B WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

		----------Inserting Data into transaction History Table----------
		INSERT INTO transactions.mf_order_summary_history
		(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
		 , trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
		 , no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
		 , previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
		SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
		 , A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
		 , A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
		 , A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
		FROM transactions.mf_order_summary A
		WHERE NOT EXISTS (SELECT * FROM transactions.mf_order_summary_history B WHERE A.id = B.id);
		
		UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

		RETURN 'SUCCESS';

	ELSE
		
		RETURN 'No Data in Staging Table';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_bkp_14jul2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_bkp_14jul2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_bkp_14jul2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_bkp_14jul2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_bkp_14jul2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_sip();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_sip()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
--DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;
	
BEGIN

--	select distinct status from transactions.stg_dion_siporder limit 1 
---------------------------------------------------------------------	
---------------------------------------------------------------------
update transactions.stg_dion_siporder
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY trxntime DESC) AS row_num
	FROM transactions.stg_dion_siporder
	)
	delete FROM transactions.stg_dion_siporder
	WHERE ctid IN (
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

----------------------------------------------------------------------
----Check for the case of SIP Modification

CREATE TEMP TABLE IF NOT EXISTS temp_mf_new_modify_order AS
select a.vendor_trx_id as txnid 
from transactions.mf_order_summary_modify_log a
union all
select distinct a.vendor_trx_id as txnid 
from transactions.mf_order_summary a
inner join transactions.mf_order_summary_modify_log b
on a.trx_id = b.trx_id;

----------------------------------------------------------------------
---to get Resume change
CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_resume AS
SELECT destn.trx_id FROM transactions.mf_order_summary destn 
JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
where destn.inv_plan_status_code=2 and upper(src.status)='RUNNING';

----------------------------------------------------------------------

IF EXISTS(SELECT 1 FROM transactions.stg_dion_siporder)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
	SELECT src.txnid FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
	WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') 
	OR COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) 
	OR COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') 
	OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') 
	OR TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) 
	OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') 
--		OR COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) 
--		OR COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) 
	OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'')  
	OR COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) 
	OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'')  
--		OR COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') 
	OR COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') 
--      OR COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') 
	OR COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') 
	OR COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') 
--		OR COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) 
--		OR v_iscancel <> COALESCE(destn.iscancel,false) 
	OR COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) 
	OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') 
--		OR COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') 
	OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'')
	OR TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))   
	)
	and src.txnid not in (
	select a.txnid from temp_mf_new_modify_order a
	);
	

UPDATE transactions.mf_order_summary destn SET
trx_datetime = CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
,reg_no = CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
,start_date = CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
,end_date = CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
,trx_status = CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
,"user_id" = CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
--, installment_paid = CASE WHEN COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) THEN src.instalementspaid ELSE destn.installment_paid END
--, installment_pending = CASE WHEN COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) THEN src.instalmentspending ELSE destn.installment_pending END
,reinvestmentflag = CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
,nav = CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
,order_remarks = CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
--,euinnumber = CASE WHEN COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') THEN src.euinnumber ELSE destn.euinnumber END
,cancellation_date = CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
--,dpc = CASE WHEN COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') THEN src.dpc ELSE destn.dpc END
--,firstordertoday = CASE WHEN COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') THEN src.firstordertoday ELSE destn.firstordertoday END
,childordernumber = CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
--,tokenno = CASE WHEN COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) THEN src.token ELSE destn.tokenno END
,iscancel = CASE WHEN COALESCE(destn.iscancel,false) <> CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean THEN CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean ELSE destn.iscancel END
,ispaused = CASE WHEN COALESCE(destn.ispaused,0) <> CASE WHEN (UPPER(src.status)) = 'PAUSE' THEN 1 ELSE 0 END::integer THEN CASE WHEN (UPPER(src.status)) = 'PAUSE' THEN 1 ELSE 0 END::integer ELSE destn.ispaused END
,istopup = CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
,vendor_exchg_refno = CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
--,topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
--,pausecount = CASE WHEN COALESCE(src.pausecount,0) <> COALESCE(destn.pausecount,0) THEN src.pausecount ELSE destn.pausecount END
--,pausemodificationcount = CASE WHEN COALESCE(src.pausemodificationcount,0) <> COALESCE(destn.pausemodificationcount,0) THEN src.pausemodificationcount ELSE destn.pausemodificationcount END
--,modifycount = CASE WHEN COALESCE(src.modifycount,0) <> COALESCE(destn.modifycount,0) THEN src.modifycount ELSE destn.modifycount END
--,modifytype = CASE WHEN COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') THEN src.modifytype ELSE destn.modifytype END
,mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
,modified_date = NOW() at time zone 'Asia/Kolkata'
FROM transactions.stg_dion_siporder src
WHERE src.txnid = destn.vendor_trx_id 
and src.txnid in (select txnid from temp_mf_trx);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.vendor_trx_id IN (select txnid from temp_mf_trx)
AND A.remarks IS NOT NULL
AND (UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'CANCEL' AND A.iscancel = TRUE
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'PAUSE' AND A.ispaused = 1
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'RESUME' AND A.ispaused = 0);

UPDATE transactions.mf_order_summary A SET remarks = NULL
FROM transactions.mf_order_summary main
--JOIN transactions.mf_order_detail_modification B ON main.trx_id = B.org_trx_id AND B.trx_final_status_code = 8
JOIN (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) B ON B.rn = 1 AND main.trx_id = B.org_trx_id AND B.trx_final_status_code = 8
WHERE A.id = main.id AND main.trx_id = b.org_trx_id AND A.remarks IS NOT NULL;

-----------------------------------------------------------------------------------------------
-- Handle for Pause
UPDATE transactions.mf_order_summary A SET
paused_date = B.trx_datetime::date,
no_of_installment_paused = no_of_inst_paused,
pausecount = COALESCE(A.pausecount, 0) + 1,
isresumed=false,
resumed_date=NULL,
remarks='',
upcoming_due_date=(COALESCE(A.upcoming_due_date, A.start_date) +
CASE WHEN UPPER(TRIM(A.frequency)) = 'MONTHLY' THEN( B.no_of_inst_paused+
(case when A.upcoming_due_date is null then A.installment_paid else 0 end)::int
	) || ' MONTHS'
WHEN UPPER(TRIM(A.frequency)) = 'QUARTERLY' THEN ((B.no_of_inst_paused+
(case when A.upcoming_due_date is null then A.installment_paid else 0 end)::int
) * 3) || ' MONTHS' 
WHEN UPPER(TRIM(A.frequency)) = 'DAILY' THEN ( B.no_of_inst_paused+
(case when A.upcoming_due_date is null then A.installment_paid else 0 end)::int
	) || ' DAYS' END::interval)::date
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M WHERE M.inv_action_code = 2) B
WHERE A.trx_id = B.org_trx_id AND B.rn = 1
AND A.vendor_trx_id IN (select txnid from temp_mf_trx) AND A.ispaused = 1;

------------------------------------------------------------------------------------------
-- Handle for Resume
UPDATE transactions.mf_order_summary A SET
isresumed=true,
remarks='',
resumed_date=NOW() at time zone 'Asia/Kolkata',
upcoming_due_date = (CASE WHEN UPPER(TRIM(A.frequency)) = 'MONTHLY'
						 THEN CASE WHEN EXTRACT('days' FROM A.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '1 Month'
								   ELSE TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(A.frequency)) = 'QUARTERLY'
						 THEN CASE WHEN EXTRACT('days' FROM A.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '3 Months'
								   ELSE TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(A.frequency)) = 'DAILY' THEN current_date + Interval '2 Days' END)::date
where A.trx_id in (select trx_id from temp_mf_trx_resume)
and A.ispaused=0;
-------------------------------------------------------------------------------------------

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
SELECT src.txnid FROM transactions.mf_order_summary destn
JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))
and src.txnid not in (
select a.txnid from temp_mf_new_modify_order a
);

UPDATE transactions.mf_order_summary dest 
SET
	trx_status = trx_sts.trx_status,
	trx_status_code = sts.trx_status_code,
	modified_date = NOW() at time zone 'Asia/Kolkata'
FROM transactions.stg_dion_siporder src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code 
AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and src.txnid in (select txnid from temp_mf_trx_status);

UPDATE transactions.mf_order_summary A 
SET
	final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx_status);

----------Inserting Data into transaction History Table----------
/*
UPDATE transactions.mf_order_summary_history A
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE A.vendor_trx_id = B.vendor_trx_id
--and	A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx) 
and A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status)
and is_active = true
and (
coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
or coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
or coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0)
);

INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT distinct
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A 
join transactions.mf_order_summary_history b on A.trx_id=B.trx_id
WHERE A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status)
and (
coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
or coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
or coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0)
);

UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;
*/
-------------------------------------------------		
-- new trx insert
--VACUUM ANALYZE transactions.mf_order_summary;

--drop table temp_mf_trx_new;

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_new AS
SELECT src.txnid FROM transactions.stg_dion_siporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
where destn.vendor_trx_id is null
and src.txnid not in (
select a.txnid from temp_mf_new_modify_order a
);

INSERT INTO transactions.mf_order_summary(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,
--created_date,modified_date,
trx_type_code,trx_status_code,datasource,pan
)
select distinct
(src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, 
src.txnid,src.sipregno,src.clientcode,src.txntype,src.amount,src.sipstartdate,src.sipenddate, 
src.foliono,trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when trim(upper(src.status))='CANCELLED' then true else false end as iscancel,
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,src.usertype,
src.ordernav,src.ordernavdate,src.childordernumber,src.token,src.mandateamount,
case when TRIM(UPPER(src.status))='PAUSE' then 1 else 0 end as ispaused,src.istopup,
src.exchangerefnumber,src.pausemodificationcount,src.topupcount,src.pausecount,
src.mainsipregno,src.modifytype,src.modifycount,
--now() as created_date,NOW() as modified_date,
trx.trx_type_code,sts.trx_status_code,'DION'::character varying as datasource,mst.pan
from transactions.stg_dion_siporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
join master.map_vendor_internal_trx_type trx on upper(src.txntype) = trx.vendor_trx_type 
and trx.category_code = 261 and trx.isactive = true
join master.map_vendor_internal_trx_status sts on sts.vendor_status = upper(src.status) 
and sts.category_code = 261 and sts.isactive = true 
join master.trx_status trx_sts on trx_sts.trx_status_code = sts.trx_status_code 
and trx_sts.category_code = 261 and trx_sts.isactive = true 
join master.dim_ucc mst on mst.priority_ac_code = src.clientcode
join master.dim_mf_isin isin on src.isin=isin.isincode
JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
--where destn.vendor_trx_id is null;
where src.txnid in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_summary A SET 
trx_id = B.trx_id, 
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying,
is_generatetoday = B.is_generatetoday,
trx_datetime=B.trx_datetime,
modified_date = NOW() at time zone 'Asia/Kolkata'
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id 
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);

update transactions.mf_order_summary A
set final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_summary A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

----------Inserting Data into transaction History Table----------
/*
insert into transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,
stepup_amount,stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,
paused_date,topupdate,isskip,skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,
previous_paid_date,totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,
A.istopup,A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,
A.is_generatetoday,A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,
A.vendor_trx_id,A.iscancel,A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,
A.skip_date,A.trx_type_code,A.isresumed,A.resumed_date,A.upcoming_due_date,A.previous_paid_date,
A.totalinstallmentamt_paid,A.switch_isin,A.trx_status_code,NOW(),true
FROM transactions.mf_order_summary A
left join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
--WHERE B.vendor_trx_id is null ;
where A.vendor_trx_id in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_summary_history SET
valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;
*/

------------------------------------------------------
---update installments details

update transactions.mf_order_summary a
set no_of_installment=totalinstalments,
installment_paid=instalementspaid,
installment_pending=instalmentspending
from (
select txnid,(instalementspaid+instalmentspending) as totalinstalments,
instalementspaid,instalmentspending  
from transactions.stg_dion_siporder
--where txnid=1088984
)b
where a.vendor_trx_id=b.txnid;

---------------------------------------------------------------------------------------------------------------
-- Inserting the data  intot the error table
	
--DELETE FROM transactions.mf_order_summary_error WHERE created_date >= NOW() - INTERVAL '7 days';

DELETE FROM transactions.mf_order_summary_error A
WHERE EXISTS (SELECT B.txnid FROM transactions.stg_dion_siporder B 
WHERE A.vendor_trx_id = B.txnid);

INSERT INTO transactions.mf_order_summary_error(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan,error_message
)
SELECT 
(src.sipregdate || ' ' || src.trxntime)::timestamp without time zone, 
src.siporderno, src.txnid, src.sipregno, src.clientcode, 
src.txntype, src.amount,src.sipstartdate, src.sipenddate, 
src.foliono, TRIM(UPPER(src.status)), src.orderedby, src.isin, 
src.frequency, src.totalinstalments, src.instalementspaid,
src.instalmentspending, src.mandateid, 
case when TRIM(UPPER(src.status))='CANCELLED' then true else false end as iscancel, 
src.reinvestmentflag, src.nav, src.mfimfdflag, src.remarks, src.euinnumber,
src.rmcode, src.sipcancellationdate, src.dpc, src.firstordertoday, 
src.traxmode, src.userid, src.usertype, src.ordernav, src.ordernavdate,
src.childordernumber, src.token, src.mandateamount, src.ispaused, 
src.istopup, src.exchangerefnumber, src.pausemodificationcount, 
src.topupcount,src.pausecount, src.mainsipregno, src.modifytype, 
src.modifycount, NOW() at time zone 'Asia/Kolkata' AS created_date, 
NOW() at time zone 'Asia/Kolkata' AS modified_date,
trx.trx_type_code, 
sts.trx_status_code,
'DION'::character varying as datasource,
(SELECT mst.pan FROM master.dim_customer mst WHERE mst.ac_code = src.clientcode),
CONCAT(
	CASE WHEN src.exchangerefnumber IS NULL THEN 'exchangerefnumber not available; ' ELSE '' END,
	CASE WHEN src.clientcode IS NULL THEN 'clientcode not available; ' ELSE '' END,
	CASE WHEN mst.ucccode IS NULL THEN 'UCC not available; ' ELSE '' END,
	CASE WHEN isin.isincode IS NULL THEN 'ISIN not available in mst; ' ELSE '' END,
	CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_siporder src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL);

/*		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    trx_datetime = EXCLUDED.trx_datetime,
		    order_no = EXCLUDED.order_no,
		    reg_no = EXCLUDED.reg_no,
		    ac_code = EXCLUDED.ac_code,
		    trx_type = EXCLUDED.trx_type,
		    trx_amt = EXCLUDED.trx_amt,
		    start_date = EXCLUDED.start_date,
		    end_date = EXCLUDED.end_date,
		    folio_no = EXCLUDED.folio_no,
		    trx_status = EXCLUDED.trx_status,
		    orderby = EXCLUDED.orderby,
		    isincode = EXCLUDED.isincode,
		    frequency = EXCLUDED.frequency,
		    no_of_installment = EXCLUDED.no_of_installment,
		    installment_paid = EXCLUDED.installment_paid,
		    installment_pending = EXCLUDED.installment_pending,
		    mandate_id = EXCLUDED.mandate_id,
		    iscancel = EXCLUDED.iscancel,
		    reinvestmentflag = EXCLUDED.reinvestmentflag,
		    nav = EXCLUDED.nav,
		    mfimfdflag = EXCLUDED.mfimfdflag,
		    order_remarks = EXCLUDED.order_remarks,
		    euinnumber = EXCLUDED.euinnumber,
		    rm_partner_code = EXCLUDED.rm_partner_code,
		    cancellation_date = EXCLUDED.cancellation_date,
		    dpc = EXCLUDED.dpc,
		    firstordertoday = EXCLUDED.firstordertoday,
		    delivery_mode = EXCLUDED.delivery_mode,
		    "user_id" = EXCLUDED."user_id",
		    trx_source = EXCLUDED.trx_source,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    childordernumber = EXCLUDED.childordernumber,
		    tokenno = EXCLUDED.tokenno,
		    mandate_amt = EXCLUDED.mandate_amt,
		    ispaused = EXCLUDED.ispaused,
		    istopup = EXCLUDED.istopup,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    pausemodificationcount = EXCLUDED.pausemodificationcount,
		    topupcount = EXCLUDED.topupcount,
		    pausecount = EXCLUDED.pausecount,
		    mainsipregno = EXCLUDED.mainsipregno,
		    modifytype = EXCLUDED.modifytype,
		    modifycount = EXCLUDED.modifycount,
		    created_date = NOW(),
		    modified_date = NOW(),
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    datasource = EXCLUDED.datasource,
		    pan = EXCLUDED.pan,
		    error_message = EXCLUDED.error_message;
	*/	   

UPDATE transactions.mf_order_summary_error A SET 
trx_id = B.trx_id,
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary_error A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

--------------------------------------------------------------
DROP TABLE temp_mf_trx; 
DROP TABLE temp_mf_trx_status; 
DROP TABLE temp_mf_trx_new;
DROP TABLE temp_mf_new_modify_order;
--------------------------------------------------------------

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_sip() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_09may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
--DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;
	
BEGIN

--	select distinct status from transactions.stg_dion_siporder limit 1 
---------------------------------------------------------------------	
---------------------------------------------------------------------
update transactions.stg_dion_siporder
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY trxntime DESC) AS row_num
	FROM transactions.stg_dion_siporder
	)
	delete FROM transactions.stg_dion_siporder
	WHERE ctid IN (
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

----------------------------------------------------------------------
---to get Resume change
CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_resume AS
SELECT destn.trx_id FROM transactions.mf_order_summary destn 
JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
where destn.inv_plan_status_code=2 and upper(src.status)='RUNNING';

----------------------------------------------------------------------

IF EXISTS(SELECT 1 FROM transactions.stg_dion_siporder)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
	SELECT src.txnid FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
	WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') 
	OR COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) 
	OR COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') 
	OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') 
	OR TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) 
	OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') 
--		OR COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) 
--		OR COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) 
	OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'')  
	OR COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) 
	OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'')  
--		OR COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') 
	OR COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') 
--      OR COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') 
	OR COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') 
	OR COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') 
--		OR COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) 
--		OR v_iscancel <> COALESCE(destn.iscancel,false) 
	OR COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) 
	OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') 
--		OR COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') 
	OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'')
	OR TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))   
	);

UPDATE transactions.mf_order_summary destn SET
trx_datetime = CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
,reg_no = CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
,start_date = CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
,end_date = CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
,trx_status = CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
,"user_id" = CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
--, installment_paid = CASE WHEN COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) THEN src.instalementspaid ELSE destn.installment_paid END
--, installment_pending = CASE WHEN COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) THEN src.instalmentspending ELSE destn.installment_pending END
,reinvestmentflag = CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
,nav = CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
,order_remarks = CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
--,euinnumber = CASE WHEN COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') THEN src.euinnumber ELSE destn.euinnumber END
,cancellation_date = CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
--,dpc = CASE WHEN COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') THEN src.dpc ELSE destn.dpc END
--,firstordertoday = CASE WHEN COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') THEN src.firstordertoday ELSE destn.firstordertoday END
,childordernumber = CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
--,tokenno = CASE WHEN COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) THEN src.token ELSE destn.tokenno END
,iscancel = CASE WHEN COALESCE(destn.iscancel,false) <> CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean THEN CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean ELSE destn.iscancel END
,ispaused = CASE WHEN COALESCE(destn.ispaused,0) <> CASE WHEN (UPPER(src.status)) = 'PAUSE' THEN 1 ELSE 0 END::integer THEN CASE WHEN (UPPER(src.status)) = 'PAUSE' THEN 1 ELSE 0 END::integer ELSE destn.ispaused END
,istopup = CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
,vendor_exchg_refno = CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
--,topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
--,pausecount = CASE WHEN COALESCE(src.pausecount,0) <> COALESCE(destn.pausecount,0) THEN src.pausecount ELSE destn.pausecount END
--,pausemodificationcount = CASE WHEN COALESCE(src.pausemodificationcount,0) <> COALESCE(destn.pausemodificationcount,0) THEN src.pausemodificationcount ELSE destn.pausemodificationcount END
--,modifycount = CASE WHEN COALESCE(src.modifycount,0) <> COALESCE(destn.modifycount,0) THEN src.modifycount ELSE destn.modifycount END
--,modifytype = CASE WHEN COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') THEN src.modifytype ELSE destn.modifytype END
,mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
,modified_date = NOW()
FROM transactions.stg_dion_siporder src
WHERE src.txnid = destn.vendor_trx_id 
and src.txnid in (select txnid from temp_mf_trx);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.vendor_trx_id IN (select txnid from temp_mf_trx)
AND A.remarks IS NOT NULL
AND (UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'CANCEL' AND A.iscancel = TRUE
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'PAUSE' AND A.ispaused = 1
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'RESUME' AND A.ispaused = 0);

UPDATE transactions.mf_order_summary A SET remarks = NULL
FROM transactions.mf_order_summary main
--JOIN transactions.mf_order_detail_modification B ON main.trx_id = B.org_trx_id AND B.trx_final_status_code = 8
JOIN (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) B ON B.rn = 1 AND main.trx_id = B.org_trx_id AND B.trx_final_status_code = 8
WHERE A.id = main.id AND main.trx_id = b.org_trx_id AND A.remarks IS NOT NULL;

-----------------------------------------------------------------------------------------------
-- Handle for Pause
UPDATE transactions.mf_order_summary A SET
paused_date = B.trx_datetime::date,
no_of_installment_paused = no_of_inst_paused,
pausecount = COALESCE(A.pausecount, 0) + 1,
isresumed=false,
resumed_date=NULL,
remarks='',
upcoming_due_date=(COALESCE(A.upcoming_due_date, A.start_date) +
CASE WHEN UPPER(TRIM(A.frequency)) = 'MONTHLY' THEN( B.no_of_inst_paused+
(case when A.upcoming_due_date is null then A.installment_paid else 0 end)::int
	) || ' MONTHS'
WHEN UPPER(TRIM(A.frequency)) = 'QUARTERLY' THEN ((B.no_of_inst_paused+
(case when A.upcoming_due_date is null then A.installment_paid else 0 end)::int
) * 3) || ' MONTHS' 
WHEN UPPER(TRIM(A.frequency)) = 'DAILY' THEN ( B.no_of_inst_paused+
(case when A.upcoming_due_date is null then A.installment_paid else 0 end)::int
	) || ' DAYS' END::interval)::date
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M WHERE M.inv_action_code = 2) B
WHERE A.trx_id = B.org_trx_id AND B.rn = 1
AND A.vendor_trx_id IN (select txnid from temp_mf_trx) AND A.ispaused = 1;

------------------------------------------------------------------------------------------
-- Handle for Resume
UPDATE transactions.mf_order_summary A SET
isresumed=true,
remarks='',
resumed_date=NOW() at time zone 'Asia/Kolkata',
upcoming_due_date = (CASE WHEN UPPER(TRIM(A.frequency)) = 'MONTHLY'
						 THEN CASE WHEN EXTRACT('days' FROM A.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '1 Month'
								   ELSE TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(A.frequency)) = 'QUARTERLY'
						 THEN CASE WHEN EXTRACT('days' FROM A.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '3 Months'
								   ELSE TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(A.frequency)) = 'DAILY' THEN current_date + Interval '2 Days' END)::date
where A.trx_id in (select trx_id from temp_mf_trx_resume)
and A.ispaused=0;
-------------------------------------------------------------------------------------------

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
SELECT src.txnid FROM transactions.mf_order_summary destn
JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

UPDATE transactions.mf_order_summary dest 
SET
	trx_status = trx_sts.trx_status,
	trx_status_code = sts.trx_status_code,
	modified_date = NOW()
FROM transactions.stg_dion_siporder src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code 
AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and src.txnid in (select txnid from temp_mf_trx_status);

UPDATE transactions.mf_order_summary A 
SET
	final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx_status);

----------Inserting Data into transaction History Table----------

UPDATE transactions.mf_order_summary_history A
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE A.vendor_trx_id = B.vendor_trx_id
--and	A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx) 
and A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status)
and is_active = true
and (
coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
or coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
or coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0)
);

INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT distinct
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A 
join transactions.mf_order_summary_history b on A.trx_id=B.trx_id
WHERE A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status)
and (
coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
or coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
or coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0)
);

UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

-------------------------------------------------		
-- new trx insert
--VACUUM ANALYZE transactions.mf_order_summary;

--drop table temp_mf_trx_new;

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_new AS
SELECT src.txnid FROM transactions.stg_dion_siporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
where destn.vendor_trx_id is null;

INSERT INTO transactions.mf_order_summary(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,
--created_date,modified_date,
trx_type_code,trx_status_code,datasource,pan
)
select (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, 
src.txnid,src.sipregno,src.clientcode,src.txntype,src.amount,src.sipstartdate,src.sipenddate, 
src.foliono,trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when trim(upper(src.status))='CANCELLED' then true else false end as iscancel,
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,src.usertype,
src.ordernav,src.ordernavdate,src.childordernumber,src.token,src.mandateamount,
case when TRIM(UPPER(src.status))='PAUSE' then 1 else 0 end as ispaused,src.istopup,
src.exchangerefnumber,src.pausemodificationcount,src.topupcount,src.pausecount,
src.mainsipregno,src.modifytype,src.modifycount,
--now() as created_date,NOW() as modified_date,
trx.trx_type_code,sts.trx_status_code,'DION'::character varying as datasource,mst.pan
from transactions.stg_dion_siporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
join master.map_vendor_internal_trx_type trx on upper(src.txntype) = trx.vendor_trx_type 
and trx.category_code = 261 and trx.isactive = true
join master.map_vendor_internal_trx_status sts on sts.vendor_status = upper(src.status) 
and sts.category_code = 261 and sts.isactive = true 
join master.trx_status trx_sts on trx_sts.trx_status_code = sts.trx_status_code 
and trx_sts.category_code = 261 and trx_sts.isactive = true 
join master.dim_ucc mst on mst.priority_ac_code = src.clientcode
join master.dim_mf_isin isin on src.isin=isin.isincode
JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
--where destn.vendor_trx_id is null;
where src.txnid in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_summary A SET 
trx_id = B.trx_id, 
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying,
is_generatetoday = B.is_generatetoday,
trx_datetime=B.trx_datetime,
modified_date = now()
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id 
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);

update transactions.mf_order_summary A
set final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_summary A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

----------Inserting Data into transaction History Table----------
insert into transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,
stepup_amount,stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,
paused_date,topupdate,isskip,skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,
previous_paid_date,totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,
A.istopup,A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,
A.is_generatetoday,A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,
A.vendor_trx_id,A.iscancel,A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,
A.skip_date,A.trx_type_code,A.isresumed,A.resumed_date,A.upcoming_due_date,A.previous_paid_date,
A.totalinstallmentamt_paid,A.switch_isin,A.trx_status_code,NOW(),true
FROM transactions.mf_order_summary A
left join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
--WHERE B.vendor_trx_id is null ;
where A.vendor_trx_id in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_summary_history SET
valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

---------------------------------------------------------------------------------------------------------------
-- Inserting the data  intot the error table
	
--DELETE FROM transactions.mf_order_summary_error WHERE created_date >= NOW() - INTERVAL '7 days';

DELETE FROM transactions.mf_order_summary_error A
WHERE EXISTS (SELECT B.txnid FROM transactions.stg_dion_siporder B 
WHERE A.vendor_trx_id = B.txnid);

INSERT INTO transactions.mf_order_summary_error(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan,error_message
)
SELECT 
(src.sipregdate || ' ' || src.trxntime)::timestamp without time zone, 
src.siporderno, src.txnid, src.sipregno, src.clientcode, 
src.txntype, src.amount,src.sipstartdate, src.sipenddate, 
src.foliono, TRIM(UPPER(src.status)), src.orderedby, src.isin, 
src.frequency, src.totalinstalments, src.instalementspaid,
src.instalmentspending, src.mandateid, 
case when TRIM(UPPER(src.status))='CANCELLED' then true else false end as iscancel, 
src.reinvestmentflag, src.nav, src.mfimfdflag, src.remarks, src.euinnumber,
src.rmcode, src.sipcancellationdate, src.dpc, src.firstordertoday, 
src.traxmode, src.userid, src.usertype, src.ordernav, src.ordernavdate,
src.childordernumber, src.token, src.mandateamount, src.ispaused, 
src.istopup, src.exchangerefnumber, src.pausemodificationcount, 
src.topupcount,src.pausecount, src.mainsipregno, src.modifytype, 
src.modifycount, NOW() AS created_date, NOW() AS modified_date,
trx.trx_type_code, 
sts.trx_status_code,
'DION'::character varying as datasource,
(SELECT mst.pan FROM master.dim_customer mst WHERE mst.ac_code = src.clientcode),
CONCAT(
	CASE WHEN src.exchangerefnumber IS NULL THEN 'exchangerefnumber not available; ' ELSE '' END,
	CASE WHEN src.clientcode IS NULL THEN 'clientcode not available; ' ELSE '' END,
	CASE WHEN mst.ucccode IS NULL THEN 'UCC not available; ' ELSE '' END,
	CASE WHEN isin.isincode IS NULL THEN 'ISIN not available in mst; ' ELSE '' END,
	CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_siporder src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL);

/*		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    trx_datetime = EXCLUDED.trx_datetime,
		    order_no = EXCLUDED.order_no,
		    reg_no = EXCLUDED.reg_no,
		    ac_code = EXCLUDED.ac_code,
		    trx_type = EXCLUDED.trx_type,
		    trx_amt = EXCLUDED.trx_amt,
		    start_date = EXCLUDED.start_date,
		    end_date = EXCLUDED.end_date,
		    folio_no = EXCLUDED.folio_no,
		    trx_status = EXCLUDED.trx_status,
		    orderby = EXCLUDED.orderby,
		    isincode = EXCLUDED.isincode,
		    frequency = EXCLUDED.frequency,
		    no_of_installment = EXCLUDED.no_of_installment,
		    installment_paid = EXCLUDED.installment_paid,
		    installment_pending = EXCLUDED.installment_pending,
		    mandate_id = EXCLUDED.mandate_id,
		    iscancel = EXCLUDED.iscancel,
		    reinvestmentflag = EXCLUDED.reinvestmentflag,
		    nav = EXCLUDED.nav,
		    mfimfdflag = EXCLUDED.mfimfdflag,
		    order_remarks = EXCLUDED.order_remarks,
		    euinnumber = EXCLUDED.euinnumber,
		    rm_partner_code = EXCLUDED.rm_partner_code,
		    cancellation_date = EXCLUDED.cancellation_date,
		    dpc = EXCLUDED.dpc,
		    firstordertoday = EXCLUDED.firstordertoday,
		    delivery_mode = EXCLUDED.delivery_mode,
		    "user_id" = EXCLUDED."user_id",
		    trx_source = EXCLUDED.trx_source,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    childordernumber = EXCLUDED.childordernumber,
		    tokenno = EXCLUDED.tokenno,
		    mandate_amt = EXCLUDED.mandate_amt,
		    ispaused = EXCLUDED.ispaused,
		    istopup = EXCLUDED.istopup,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    pausemodificationcount = EXCLUDED.pausemodificationcount,
		    topupcount = EXCLUDED.topupcount,
		    pausecount = EXCLUDED.pausecount,
		    mainsipregno = EXCLUDED.mainsipregno,
		    modifytype = EXCLUDED.modifytype,
		    modifycount = EXCLUDED.modifycount,
		    created_date = NOW(),
		    modified_date = NOW(),
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    datasource = EXCLUDED.datasource,
		    pan = EXCLUDED.pan,
		    error_message = EXCLUDED.error_message;
	*/	   

UPDATE transactions.mf_order_summary_error A SET 
trx_id = B.trx_id,
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary_error A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

--------------------------------------------------------------
DROP TABLE temp_mf_trx; 
DROP TABLE temp_mf_trx_status; 
DROP TABLE temp_mf_trx_new;
--------------------------------------------------------------

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_09may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_09may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_09may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_09may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_14jul2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_14jul2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
--DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;
	
BEGIN

--	select distinct status from transactions.stg_dion_siporder limit 1 
---------------------------------------------------------------------	
---------------------------------------------------------------------
update transactions.stg_dion_siporder
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY trxntime DESC) AS row_num
	FROM transactions.stg_dion_siporder
	)
	delete FROM transactions.stg_dion_siporder
	WHERE ctid IN (
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

----------------------------------------------------------------------
---to get Resume change
CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_resume AS
SELECT destn.trx_id FROM transactions.mf_order_summary destn 
JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
where destn.inv_plan_status_code=2 and upper(src.status)='RUNNING';

----------------------------------------------------------------------

IF EXISTS(SELECT 1 FROM transactions.stg_dion_siporder)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
	SELECT src.txnid FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
	WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') 
	OR COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) 
	OR COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') 
	OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') 
	OR TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) 
	OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') 
--		OR COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) 
--		OR COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) 
	OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'')  
	OR COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) 
	OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'')  
--		OR COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') 
	OR COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') 
--      OR COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') 
	OR COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') 
	OR COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') 
--		OR COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) 
--		OR v_iscancel <> COALESCE(destn.iscancel,false) 
	OR COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) 
	OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') 
--		OR COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') 
	OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'')
	OR TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))   
	);

UPDATE transactions.mf_order_summary destn SET
trx_datetime = CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
,reg_no = CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
,start_date = CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
,end_date = CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
,trx_status = CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
,"user_id" = CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
--, installment_paid = CASE WHEN COALESCE(src.instalementspaid,0) <> COALESCE(destn.installment_paid,0) THEN src.instalementspaid ELSE destn.installment_paid END
--, installment_pending = CASE WHEN COALESCE(src.instalmentspending,0) <> COALESCE(destn.installment_pending,0) THEN src.instalmentspending ELSE destn.installment_pending END
,reinvestmentflag = CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
,nav = CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
,order_remarks = CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
--,euinnumber = CASE WHEN COALESCE(src.euinnumber,'') <> COALESCE(destn.euinnumber,'') THEN src.euinnumber ELSE destn.euinnumber END
,cancellation_date = CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
--,dpc = CASE WHEN COALESCE(src.dpc,'Y') <> COALESCE(destn.dpc,'Y') THEN src.dpc ELSE destn.dpc END
--,firstordertoday = CASE WHEN COALESCE(src.firstordertoday,'N') <> COALESCE(destn.firstordertoday,'N') THEN src.firstordertoday ELSE destn.firstordertoday END
,childordernumber = CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
--,tokenno = CASE WHEN COALESCE(src.token,0) <> COALESCE(destn.tokenno,0) THEN src.token ELSE destn.tokenno END
,iscancel = CASE WHEN COALESCE(destn.iscancel,false) <> CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean THEN CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean ELSE destn.iscancel END
,ispaused = CASE WHEN COALESCE(destn.ispaused,0) <> CASE WHEN (UPPER(src.status)) = 'PAUSE' THEN 1 ELSE 0 END::integer THEN CASE WHEN (UPPER(src.status)) = 'PAUSE' THEN 1 ELSE 0 END::integer ELSE destn.ispaused END
,istopup = CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
,vendor_exchg_refno = CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
--,topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
--,pausecount = CASE WHEN COALESCE(src.pausecount,0) <> COALESCE(destn.pausecount,0) THEN src.pausecount ELSE destn.pausecount END
--,pausemodificationcount = CASE WHEN COALESCE(src.pausemodificationcount,0) <> COALESCE(destn.pausemodificationcount,0) THEN src.pausemodificationcount ELSE destn.pausemodificationcount END
--,modifycount = CASE WHEN COALESCE(src.modifycount,0) <> COALESCE(destn.modifycount,0) THEN src.modifycount ELSE destn.modifycount END
--,modifytype = CASE WHEN COALESCE(src.modifytype,'') <> COALESCE(destn.modifytype,'') THEN src.modifytype ELSE destn.modifytype END
,mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
,modified_date = NOW()
FROM transactions.stg_dion_siporder src
WHERE src.txnid = destn.vendor_trx_id 
and src.txnid in (select txnid from temp_mf_trx);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.vendor_trx_id IN (select txnid from temp_mf_trx)
AND A.remarks IS NOT NULL
AND (UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'CANCEL' AND A.iscancel = TRUE
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'PAUSE' AND A.ispaused = 1
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'RESUME' AND A.ispaused = 0);

UPDATE transactions.mf_order_summary A SET remarks = NULL
FROM transactions.mf_order_summary main
--JOIN transactions.mf_order_detail_modification B ON main.trx_id = B.org_trx_id AND B.trx_final_status_code = 8
JOIN (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M) B ON B.rn = 1 AND main.trx_id = B.org_trx_id AND B.trx_final_status_code = 8
WHERE A.id = main.id AND main.trx_id = b.org_trx_id AND A.remarks IS NOT NULL;

-----------------------------------------------------------------------------------------------
-- Handle for Pause
UPDATE transactions.mf_order_summary A SET
paused_date = B.trx_datetime::date,
no_of_installment_paused = no_of_inst_paused,
pausecount = COALESCE(A.pausecount, 0) + 1,
isresumed=false,
resumed_date=NULL,
remarks='',
upcoming_due_date=(COALESCE(A.upcoming_due_date, A.start_date) +
CASE WHEN UPPER(TRIM(A.frequency)) = 'MONTHLY' THEN( B.no_of_inst_paused+
(case when A.upcoming_due_date is null then A.installment_paid else 0 end)::int
	) || ' MONTHS'
WHEN UPPER(TRIM(A.frequency)) = 'QUARTERLY' THEN ((B.no_of_inst_paused+
(case when A.upcoming_due_date is null then A.installment_paid else 0 end)::int
) * 3) || ' MONTHS' 
WHEN UPPER(TRIM(A.frequency)) = 'DAILY' THEN ( B.no_of_inst_paused+
(case when A.upcoming_due_date is null then A.installment_paid else 0 end)::int
	) || ' DAYS' END::interval)::date
FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY M.org_trx_id ORDER BY M.trx_id DESC) as rn
	  FROM transactions.mf_order_detail_modification M WHERE M.inv_action_code = 2) B
WHERE A.trx_id = B.org_trx_id AND B.rn = 1
AND A.vendor_trx_id IN (select txnid from temp_mf_trx) AND A.ispaused = 1;

------------------------------------------------------------------------------------------
-- Handle for Resume
UPDATE transactions.mf_order_summary A SET
isresumed=true,
remarks='',
resumed_date=NOW() at time zone 'Asia/Kolkata',
upcoming_due_date = (CASE WHEN UPPER(TRIM(A.frequency)) = 'MONTHLY'
						 THEN CASE WHEN EXTRACT('days' FROM A.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '1 Month'
								   ELSE TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(A.frequency)) = 'QUARTERLY'
						 THEN CASE WHEN EXTRACT('days' FROM A.start_date) <= EXTRACT('days' FROM current_date)
								   THEN TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') + Interval '3 Months'
								   ELSE TO_DATE((EXTRACT('days' FROM A.start_date) || '-' || TO_CHAR(CURRENT_DATE, 'MM-YYYY')), 'DD-MM-YYYY') END
						 WHEN UPPER(TRIM(A.frequency)) = 'DAILY' THEN current_date + Interval '2 Days' END)::date
where A.trx_id in (select trx_id from temp_mf_trx_resume)
and A.ispaused=0;
-------------------------------------------------------------------------------------------

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
SELECT src.txnid FROM transactions.mf_order_summary destn
JOIN transactions.stg_dion_siporder src ON src.txnid = destn.vendor_trx_id
WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

UPDATE transactions.mf_order_summary dest 
SET
	trx_status = trx_sts.trx_status,
	trx_status_code = sts.trx_status_code,
	modified_date = NOW()
FROM transactions.stg_dion_siporder src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code 
AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and src.txnid in (select txnid from temp_mf_trx_status);

UPDATE transactions.mf_order_summary A 
SET
	final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx_status);

----------Inserting Data into transaction History Table----------

UPDATE transactions.mf_order_summary_history A
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE A.vendor_trx_id = B.vendor_trx_id
--and	A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx) 
and A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status)
and is_active = true
and (
coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
or coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
or coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0)
);

INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT distinct
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A 
join transactions.mf_order_summary_history b on A.trx_id=B.trx_id
WHERE A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status)
and (
coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
or coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
or coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0)
);

UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

-------------------------------------------------		
-- new trx insert
--VACUUM ANALYZE transactions.mf_order_summary;

--drop table temp_mf_trx_new;

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_new AS
SELECT src.txnid FROM transactions.stg_dion_siporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
where destn.vendor_trx_id is null;

INSERT INTO transactions.mf_order_summary(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,
--created_date,modified_date,
trx_type_code,trx_status_code,datasource,pan
)
select (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, 
src.txnid,src.sipregno,src.clientcode,src.txntype,src.amount,src.sipstartdate,src.sipenddate, 
src.foliono,trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when trim(upper(src.status))='CANCELLED' then true else false end as iscancel,
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,src.usertype,
src.ordernav,src.ordernavdate,src.childordernumber,src.token,src.mandateamount,
case when TRIM(UPPER(src.status))='PAUSE' then 1 else 0 end as ispaused,src.istopup,
src.exchangerefnumber,src.pausemodificationcount,src.topupcount,src.pausecount,
src.mainsipregno,src.modifytype,src.modifycount,
--now() as created_date,NOW() as modified_date,
trx.trx_type_code,sts.trx_status_code,'DION'::character varying as datasource,mst.pan
from transactions.stg_dion_siporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
join master.map_vendor_internal_trx_type trx on upper(src.txntype) = trx.vendor_trx_type 
and trx.category_code = 261 and trx.isactive = true
join master.map_vendor_internal_trx_status sts on sts.vendor_status = upper(src.status) 
and sts.category_code = 261 and sts.isactive = true 
join master.trx_status trx_sts on trx_sts.trx_status_code = sts.trx_status_code 
and trx_sts.category_code = 261 and trx_sts.isactive = true 
join master.dim_ucc mst on mst.priority_ac_code = src.clientcode
join master.dim_mf_isin isin on src.isin=isin.isincode
JOIN master.dim_mf_scheme sch on isin.mf_schcode = sch.mf_schcode
--where destn.vendor_trx_id is null;
where src.txnid in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_summary A SET 
trx_id = B.trx_id, 
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying,
is_generatetoday = B.is_generatetoday,
trx_datetime=B.trx_datetime,
modified_date = now()
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id 
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);

update transactions.mf_order_summary A
set final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_summary A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

----------Inserting Data into transaction History Table----------
insert into transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,
stepup_amount,stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,
paused_date,topupdate,isskip,skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,
previous_paid_date,totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,
A.istopup,A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,
A.is_generatetoday,A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,
A.vendor_trx_id,A.iscancel,A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,
A.skip_date,A.trx_type_code,A.isresumed,A.resumed_date,A.upcoming_due_date,A.previous_paid_date,
A.totalinstallmentamt_paid,A.switch_isin,A.trx_status_code,NOW(),true
FROM transactions.mf_order_summary A
left join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
--WHERE B.vendor_trx_id is null ;
where A.vendor_trx_id in (select txnid from temp_mf_trx_new);

UPDATE transactions.mf_order_summary_history SET
valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

---------------------------------------------------------------------------------------------------------------
-- Inserting the data  intot the error table
	
--DELETE FROM transactions.mf_order_summary_error WHERE created_date >= NOW() - INTERVAL '7 days';

DELETE FROM transactions.mf_order_summary_error A
WHERE EXISTS (SELECT B.txnid FROM transactions.stg_dion_siporder B 
WHERE A.vendor_trx_id = B.txnid);

INSERT INTO transactions.mf_order_summary_error(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan,error_message
)
SELECT 
(src.sipregdate || ' ' || src.trxntime)::timestamp without time zone, 
src.siporderno, src.txnid, src.sipregno, src.clientcode, 
src.txntype, src.amount,src.sipstartdate, src.sipenddate, 
src.foliono, TRIM(UPPER(src.status)), src.orderedby, src.isin, 
src.frequency, src.totalinstalments, src.instalementspaid,
src.instalmentspending, src.mandateid, 
case when TRIM(UPPER(src.status))='CANCELLED' then true else false end as iscancel, 
src.reinvestmentflag, src.nav, src.mfimfdflag, src.remarks, src.euinnumber,
src.rmcode, src.sipcancellationdate, src.dpc, src.firstordertoday, 
src.traxmode, src.userid, src.usertype, src.ordernav, src.ordernavdate,
src.childordernumber, src.token, src.mandateamount, src.ispaused, 
src.istopup, src.exchangerefnumber, src.pausemodificationcount, 
src.topupcount,src.pausecount, src.mainsipregno, src.modifytype, 
src.modifycount, NOW() AS created_date, NOW() AS modified_date,
trx.trx_type_code, 
sts.trx_status_code,
'DION'::character varying as datasource,
(SELECT mst.pan FROM master.dim_customer mst WHERE mst.ac_code = src.clientcode),
CONCAT(
	CASE WHEN src.exchangerefnumber IS NULL THEN 'exchangerefnumber not available; ' ELSE '' END,
	CASE WHEN src.clientcode IS NULL THEN 'clientcode not available; ' ELSE '' END,
	CASE WHEN mst.ucccode IS NULL THEN 'UCC not available; ' ELSE '' END,
	CASE WHEN isin.isincode IS NULL THEN 'ISIN not available in mst; ' ELSE '' END,
	CASE WHEN isin.mf_schcode IS NULL THEN 'MF Scheme Code is not available in master; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_siporder src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL);

/*		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    trx_datetime = EXCLUDED.trx_datetime,
		    order_no = EXCLUDED.order_no,
		    reg_no = EXCLUDED.reg_no,
		    ac_code = EXCLUDED.ac_code,
		    trx_type = EXCLUDED.trx_type,
		    trx_amt = EXCLUDED.trx_amt,
		    start_date = EXCLUDED.start_date,
		    end_date = EXCLUDED.end_date,
		    folio_no = EXCLUDED.folio_no,
		    trx_status = EXCLUDED.trx_status,
		    orderby = EXCLUDED.orderby,
		    isincode = EXCLUDED.isincode,
		    frequency = EXCLUDED.frequency,
		    no_of_installment = EXCLUDED.no_of_installment,
		    installment_paid = EXCLUDED.installment_paid,
		    installment_pending = EXCLUDED.installment_pending,
		    mandate_id = EXCLUDED.mandate_id,
		    iscancel = EXCLUDED.iscancel,
		    reinvestmentflag = EXCLUDED.reinvestmentflag,
		    nav = EXCLUDED.nav,
		    mfimfdflag = EXCLUDED.mfimfdflag,
		    order_remarks = EXCLUDED.order_remarks,
		    euinnumber = EXCLUDED.euinnumber,
		    rm_partner_code = EXCLUDED.rm_partner_code,
		    cancellation_date = EXCLUDED.cancellation_date,
		    dpc = EXCLUDED.dpc,
		    firstordertoday = EXCLUDED.firstordertoday,
		    delivery_mode = EXCLUDED.delivery_mode,
		    "user_id" = EXCLUDED."user_id",
		    trx_source = EXCLUDED.trx_source,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    childordernumber = EXCLUDED.childordernumber,
		    tokenno = EXCLUDED.tokenno,
		    mandate_amt = EXCLUDED.mandate_amt,
		    ispaused = EXCLUDED.ispaused,
		    istopup = EXCLUDED.istopup,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    pausemodificationcount = EXCLUDED.pausemodificationcount,
		    topupcount = EXCLUDED.topupcount,
		    pausecount = EXCLUDED.pausecount,
		    mainsipregno = EXCLUDED.mainsipregno,
		    modifytype = EXCLUDED.modifytype,
		    modifycount = EXCLUDED.modifycount,
		    created_date = NOW(),
		    modified_date = NOW(),
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    datasource = EXCLUDED.datasource,
		    pan = EXCLUDED.pan,
		    error_message = EXCLUDED.error_message;
	*/	   

UPDATE transactions.mf_order_summary_error A SET 
trx_id = B.trx_id,
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary_error A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

--------------------------------------------------------------
DROP TABLE temp_mf_trx; 
DROP TABLE temp_mf_trx_status; 
DROP TABLE temp_mf_trx_new;
--------------------------------------------------------------

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_14jul2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_14jul2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_14jul2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_14jul2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_sip_bkp_14jul2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_stp();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_stp()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
--DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;
	
BEGIN

--	select distinct status from transactions.stg_dion_stporder limit 1 
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY trxntime DESC) AS row_num
	FROM transactions.stg_dion_stporder
	)
	delete FROM transactions.stg_dion_stporder
	WHERE ctid IN (
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

IF EXISTS(SELECT 1 FROM transactions.stg_dion_stporder)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
	SELECT src.txnid FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_stporder src ON src.txnid = destn.vendor_trx_id
	WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') 
	OR COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) 
	OR COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') 
	OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') 
	OR TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) 
	OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') 
	OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'')  
	OR COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) 
	OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'')  
	OR COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') 
	OR COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') 
	OR COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) 
	OR COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) 
	OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') 
	OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'')
	OR TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))   
	);

UPDATE transactions.mf_order_summary destn SET
trx_datetime = CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
,reg_no = CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
,start_date = CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
,end_date = CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
,trx_status = CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
,"user_id" = CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
,reinvestmentflag = CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
,nav = CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
,order_remarks = CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
,cancellation_date = CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
,childordernumber = CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
,iscancel = CASE WHEN COALESCE(destn.iscancel,false) <> CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean THEN CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean ELSE destn.iscancel END
,istopup = CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
,vendor_exchg_refno = CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
,topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
,mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
,modified_date = (NOW() at time zone 'Asia/Kolkata')
FROM transactions.stg_dion_stporder src
WHERE src.txnid = destn.vendor_trx_id 
and src.txnid in (select txnid from temp_mf_trx);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.vendor_trx_id IN (select txnid from temp_mf_trx)
AND A.remarks IS NOT NULL
AND (UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'CANCEL' AND A.iscancel = TRUE
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'PAUSE' AND A.ispaused = 1
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'RESUME' AND A.ispaused = 0);

-------------------------------------------------------------------------------------------

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
SELECT src.txnid FROM transactions.mf_order_summary destn
JOIN transactions.stg_dion_stporder src ON src.txnid = destn.vendor_trx_id
WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

UPDATE transactions.mf_order_summary dest 
SET
	trx_status = trx_sts.trx_status,
	trx_status_code = sts.trx_status_code,
	modified_date = (NOW() at time zone 'Asia/Kolkata')
FROM transactions.stg_dion_stporder src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code 
AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and src.txnid in (select txnid from temp_mf_trx_status);

UPDATE transactions.mf_order_summary A 
SET
	final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx);

----------Inserting Data into transaction History Table----------
/*

UPDATE transactions.mf_order_summary_history A
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE A.vendor_trx_id = B.vendor_trx_id
and	A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx) 
and is_active = true
and coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
and coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
and coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0);

INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,trx_final_status_code,final_status,inv_plan_status_code,inv_plan_status
FROM transactions.mf_order_summary A 
WHERE A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status);

UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

*/
-------------------------------------------------		
-- new trx insert
--VACUUM ANALYZE transactions.mf_order_summary;

INSERT INTO transactions.mf_order_summary(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan
)
select (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, 
src.txnid,src.sipregno,src.clientcode,src.txntype,src.amount,src.sipstartdate,src.sipenddate, 
src.foliono,trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments::int as totalinstalments,src.instalementspaid::int as instalementspaid,
src.instalmentspending,src.mandateid, 
case when trim(upper(src.status))='CANCELLED' then true else false end as iscancel,
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,src.usertype,
src.ordernav,src.ordernavdate,src.childordernumber,src.token,src.mandateamount,
case when TRIM(UPPER(src.status))='PAUSE' then 1 else 0 end as ispaused,src.istopup,
src.exchangerefnumber,src.pausemodificationcount,src.topupcount,src.pausecount,
src.mainsipregno,src.modifytype,src.modifycount,(NOW() at time zone 'Asia/Kolkata'),
(NOW() at time zone 'Asia/Kolkata'),trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan
from transactions.stg_dion_stporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
join master.map_vendor_internal_trx_type trx on upper(src.txntype) = trx.vendor_trx_type 
and trx.category_code = 261 and trx.isactive = true
join master.map_vendor_internal_trx_status sts on sts.vendor_status = upper(src.status) 
and sts.category_code = 261 and sts.isactive = true 
join master.trx_status trx_sts on trx_sts.trx_status_code = sts.trx_status_code 
and trx_sts.category_code = 261 and trx_sts.isactive = true 
join master.dim_ucc mst on mst.priority_ac_code = src.clientcode
where destn.vendor_trx_id is null;

update transactions.mf_order_summary A
set final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from transactions.stg_dion_stporder);

UPDATE transactions.mf_order_summary A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary A SET 
trx_id = B.trx_id, 
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

----------Inserting Data into transaction History Table----------
/*
insert into transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,
stepup_amount,stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,
paused_date,topupdate,isskip,skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,
previous_paid_date,totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,
A.istopup,A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,
A.is_generatetoday,A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,
A.vendor_trx_id,A.iscancel,A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,
A.skip_date,A.trx_type_code,A.isresumed,A.resumed_date,A.upcoming_due_date,A.previous_paid_date,
A.totalinstallmentamt_paid,A.switch_isin,A.trx_status_code,NOW(),true
FROM transactions.mf_order_summary A
join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
WHERE B.vendor_trx_id is null ;

UPDATE transactions.mf_order_summary_history SET
valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;
*/

---------------------------------------------------------------------------------------------------------------
-- Inserting the data  intot the error table
	
DELETE FROM transactions.mf_order_summary_error 
WHERE created_date >= (NOW() at time zone 'Asia/Kolkata') - INTERVAL '7 days';

INSERT INTO transactions.mf_order_summary_error(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,
--no_of_installment,installment_paid,
installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan,error_message
)
select
(src.sipregdate || ' ' || src.trxntime)::timestamp without time zone, 
src.siporderno,src.txnid,src.sipregno,src.clientcode,src.txntype,
src.amount,src.sipstartdate,src.sipenddate,src.foliono,
trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
--src.totalinstalments::int as totalinstalments,src.instalementspaid::int as instalementspaid,
src.instalmentspending,src.mandateid, 
case when TRIM(UPPER(src.status))='CANCELLED' then true else false end as iscancel, 
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,
src.usertype,src.ordernav,src.ordernavdate,src.childordernumber,src.token,
src.mandateamount,src.ispaused,src.istopup,src.exchangerefnumber,
src.pausemodificationcount,src.topupcount,src.pausecount,src.mainsipregno,src.modifytype, 
src.modifycount,(NOW() at time zone 'Asia/Kolkata') as created_date,
(NOW() at time zone 'Asia/Kolkata') as modified_date,trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan,
CONCAT(
	CASE WHEN src.exchangerefnumber IS NULL THEN 'exchangerefnumber not available; ' ELSE '' END,
	CASE WHEN src.clientcode IS NULL THEN 'clientcode not available; ' ELSE '' END,
	CASE WHEN mst.ucccode IS NULL THEN 'UCC not available; ' ELSE '' END,
	CASE WHEN isin.isincode IS NULL THEN 'ISIN not available in mst; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_stporder src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL);

/*		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    trx_datetime = EXCLUDED.trx_datetime,
		    order_no = EXCLUDED.order_no,
		    reg_no = EXCLUDED.reg_no,
		    ac_code = EXCLUDED.ac_code,
		    trx_type = EXCLUDED.trx_type,
		    trx_amt = EXCLUDED.trx_amt,
		    start_date = EXCLUDED.start_date,
		    end_date = EXCLUDED.end_date,
		    folio_no = EXCLUDED.folio_no,
		    trx_status = EXCLUDED.trx_status,
		    orderby = EXCLUDED.orderby,
		    isincode = EXCLUDED.isincode,
		    frequency = EXCLUDED.frequency,
		    no_of_installment = EXCLUDED.no_of_installment,
		    installment_paid = EXCLUDED.installment_paid,
		    installment_pending = EXCLUDED.installment_pending,
		    mandate_id = EXCLUDED.mandate_id,
		    iscancel = EXCLUDED.iscancel,
		    reinvestmentflag = EXCLUDED.reinvestmentflag,
		    nav = EXCLUDED.nav,
		    mfimfdflag = EXCLUDED.mfimfdflag,
		    order_remarks = EXCLUDED.order_remarks,
		    euinnumber = EXCLUDED.euinnumber,
		    rm_partner_code = EXCLUDED.rm_partner_code,
		    cancellation_date = EXCLUDED.cancellation_date,
		    dpc = EXCLUDED.dpc,
		    firstordertoday = EXCLUDED.firstordertoday,
		    delivery_mode = EXCLUDED.delivery_mode,
		    "user_id" = EXCLUDED."user_id",
		    trx_source = EXCLUDED.trx_source,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    childordernumber = EXCLUDED.childordernumber,
		    tokenno = EXCLUDED.tokenno,
		    mandate_amt = EXCLUDED.mandate_amt,
		    ispaused = EXCLUDED.ispaused,
		    istopup = EXCLUDED.istopup,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    pausemodificationcount = EXCLUDED.pausemodificationcount,
		    topupcount = EXCLUDED.topupcount,
		    pausecount = EXCLUDED.pausecount,
		    mainsipregno = EXCLUDED.mainsipregno,
		    modifytype = EXCLUDED.modifytype,
		    modifycount = EXCLUDED.modifycount,
		    created_date = NOW(),
		    modified_date = NOW(),
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    datasource = EXCLUDED.datasource,
		    pan = EXCLUDED.pan,
		    error_message = EXCLUDED.error_message;
	*/	   

UPDATE transactions.mf_order_summary_error A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary_error A SET 
trx_id = B.trx_id,
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary_error A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

--------------------------------------------------------------
DROP TABLE temp_mf_trx; 
DROP TABLE temp_mf_trx_status; 
--------------------------------------------------------------

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_stp() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_stp() TO cmotswrite;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_stp_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_stp_bkp_09may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
--DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;
	
BEGIN

--	select distinct status from transactions.stg_dion_stporder limit 1 
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY trxntime DESC) AS row_num
	FROM transactions.stg_dion_stporder
	)
	delete FROM transactions.stg_dion_stporder
	WHERE ctid IN (
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

IF EXISTS(SELECT 1 FROM transactions.stg_dion_stporder)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
	SELECT src.txnid FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_stporder src ON src.txnid = destn.vendor_trx_id
	WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') 
	OR COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) 
	OR COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') 
	OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') 
	OR TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) 
	OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') 
	OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'')  
	OR COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) 
	OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'')  
	OR COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') 
	OR COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') 
	OR COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) 
	OR COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) 
	OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') 
	OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'')
	OR TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))   
	);

UPDATE transactions.mf_order_summary destn SET
trx_datetime = CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
,reg_no = CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
,start_date = CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
,end_date = CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
,trx_status = CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
,"user_id" = CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
,reinvestmentflag = CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
,nav = CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
,order_remarks = CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
,cancellation_date = CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
,childordernumber = CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
,iscancel = CASE WHEN COALESCE(destn.iscancel,false) <> CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean THEN CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean ELSE destn.iscancel END
,istopup = CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
,vendor_exchg_refno = CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
,topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
,mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
,modified_date = NOW()
FROM transactions.stg_dion_stporder src
WHERE src.txnid = destn.vendor_trx_id 
and src.txnid in (select txnid from temp_mf_trx);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.vendor_trx_id IN (select txnid from temp_mf_trx)
AND A.remarks IS NOT NULL
AND (UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'CANCEL' AND A.iscancel = TRUE
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'PAUSE' AND A.ispaused = 1
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'RESUME' AND A.ispaused = 0);

-------------------------------------------------------------------------------------------

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
SELECT src.txnid FROM transactions.mf_order_summary destn
JOIN transactions.stg_dion_stporder src ON src.txnid = destn.vendor_trx_id
WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

UPDATE transactions.mf_order_summary dest 
SET
	trx_status = trx_sts.trx_status,
	trx_status_code = sts.trx_status_code,
	modified_date = NOW()
FROM transactions.stg_dion_stporder src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code 
AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and src.txnid in (select txnid from temp_mf_trx_status);

UPDATE transactions.mf_order_summary A 
SET
	final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx);

----------Inserting Data into transaction History Table----------

UPDATE transactions.mf_order_summary_history A
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE A.vendor_trx_id = B.vendor_trx_id
and	A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx) 
and is_active = true
and coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
and coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
and coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0);

INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,trx_final_status_code,final_status,inv_plan_status_code,inv_plan_status
FROM transactions.mf_order_summary A 
WHERE A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status);

UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

-------------------------------------------------		
-- new trx insert
--VACUUM ANALYZE transactions.mf_order_summary;

INSERT INTO transactions.mf_order_summary(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan
)
select (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, 
src.txnid,src.sipregno,src.clientcode,src.txntype,src.amount,src.sipstartdate,src.sipenddate, 
src.foliono,trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when trim(upper(src.status))='CANCELLED' then true else false end as iscancel,
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,src.usertype,
src.ordernav,src.ordernavdate,src.childordernumber,src.token,src.mandateamount,
case when TRIM(UPPER(src.status))='PAUSE' then 1 else 0 end as ispaused,src.istopup,
src.exchangerefnumber,src.pausemodificationcount,src.topupcount,src.pausecount,
src.mainsipregno,src.modifytype,src.modifycount,NOW(),NOW(),trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan
from transactions.stg_dion_stporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
join master.map_vendor_internal_trx_type trx on upper(src.txntype) = trx.vendor_trx_type 
and trx.category_code = 261 and trx.isactive = true
join master.map_vendor_internal_trx_status sts on sts.vendor_status = upper(src.status) 
and sts.category_code = 261 and sts.isactive = true 
join master.trx_status trx_sts on trx_sts.trx_status_code = sts.trx_status_code 
and trx_sts.category_code = 261 and trx_sts.isactive = true 
join master.dim_ucc mst on mst.priority_ac_code = src.clientcode
where destn.vendor_trx_id is null;

update transactions.mf_order_summary A
set final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from transactions.stg_dion_stporder);

UPDATE transactions.mf_order_summary A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary A SET 
trx_id = B.trx_id, 
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

----------Inserting Data into transaction History Table----------

insert into transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,
stepup_amount,stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,
paused_date,topupdate,isskip,skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,
previous_paid_date,totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,
A.istopup,A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,
A.is_generatetoday,A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,
A.vendor_trx_id,A.iscancel,A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,
A.skip_date,A.trx_type_code,A.isresumed,A.resumed_date,A.upcoming_due_date,A.previous_paid_date,
A.totalinstallmentamt_paid,A.switch_isin,A.trx_status_code,NOW(),true
FROM transactions.mf_order_summary A
join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
WHERE B.vendor_trx_id is null ;

UPDATE transactions.mf_order_summary_history SET
valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

---------------------------------------------------------------------------------------------------------------
-- Inserting the data  intot the error table
	
DELETE FROM transactions.mf_order_summary_error WHERE created_date >= NOW() - INTERVAL '7 days';

INSERT INTO transactions.mf_order_summary_error(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan,error_message
)
select
(src.sipregdate || ' ' || src.trxntime)::timestamp without time zone, 
src.siporderno,src.txnid,src.sipregno,src.clientcode,src.txntype,
src.amount,src.sipstartdate,src.sipenddate,src.foliono,
trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when TRIM(UPPER(src.status))='CANCELLED' then true else false end as iscancel, 
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,
src.usertype,src.ordernav,src.ordernavdate,src.childordernumber,src.token,
src.mandateamount,src.ispaused,src.istopup,src.exchangerefnumber,
src.pausemodificationcount,src.topupcount,src.pausecount,src.mainsipregno,src.modifytype, 
src.modifycount,NOW() as created_date,NOW() as modified_date,trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan,
CONCAT(
	CASE WHEN src.exchangerefnumber IS NULL THEN 'exchangerefnumber not available; ' ELSE '' END,
	CASE WHEN src.clientcode IS NULL THEN 'clientcode not available; ' ELSE '' END,
	CASE WHEN mst.ucccode IS NULL THEN 'UCC not available; ' ELSE '' END,
	CASE WHEN isin.isincode IS NULL THEN 'ISIN not available in mst; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_stporder src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL);

/*		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    trx_datetime = EXCLUDED.trx_datetime,
		    order_no = EXCLUDED.order_no,
		    reg_no = EXCLUDED.reg_no,
		    ac_code = EXCLUDED.ac_code,
		    trx_type = EXCLUDED.trx_type,
		    trx_amt = EXCLUDED.trx_amt,
		    start_date = EXCLUDED.start_date,
		    end_date = EXCLUDED.end_date,
		    folio_no = EXCLUDED.folio_no,
		    trx_status = EXCLUDED.trx_status,
		    orderby = EXCLUDED.orderby,
		    isincode = EXCLUDED.isincode,
		    frequency = EXCLUDED.frequency,
		    no_of_installment = EXCLUDED.no_of_installment,
		    installment_paid = EXCLUDED.installment_paid,
		    installment_pending = EXCLUDED.installment_pending,
		    mandate_id = EXCLUDED.mandate_id,
		    iscancel = EXCLUDED.iscancel,
		    reinvestmentflag = EXCLUDED.reinvestmentflag,
		    nav = EXCLUDED.nav,
		    mfimfdflag = EXCLUDED.mfimfdflag,
		    order_remarks = EXCLUDED.order_remarks,
		    euinnumber = EXCLUDED.euinnumber,
		    rm_partner_code = EXCLUDED.rm_partner_code,
		    cancellation_date = EXCLUDED.cancellation_date,
		    dpc = EXCLUDED.dpc,
		    firstordertoday = EXCLUDED.firstordertoday,
		    delivery_mode = EXCLUDED.delivery_mode,
		    "user_id" = EXCLUDED."user_id",
		    trx_source = EXCLUDED.trx_source,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    childordernumber = EXCLUDED.childordernumber,
		    tokenno = EXCLUDED.tokenno,
		    mandate_amt = EXCLUDED.mandate_amt,
		    ispaused = EXCLUDED.ispaused,
		    istopup = EXCLUDED.istopup,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    pausemodificationcount = EXCLUDED.pausemodificationcount,
		    topupcount = EXCLUDED.topupcount,
		    pausecount = EXCLUDED.pausecount,
		    mainsipregno = EXCLUDED.mainsipregno,
		    modifytype = EXCLUDED.modifytype,
		    modifycount = EXCLUDED.modifycount,
		    created_date = NOW(),
		    modified_date = NOW(),
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    datasource = EXCLUDED.datasource,
		    pan = EXCLUDED.pan,
		    error_message = EXCLUDED.error_message;
	*/	   

UPDATE transactions.mf_order_summary_error A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary_error A SET 
trx_id = B.trx_id,
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary_error A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

--------------------------------------------------------------
DROP TABLE temp_mf_trx; 
DROP TABLE temp_mf_trx_status; 
--------------------------------------------------------------

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_stp_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_stp_bkp_09may2025() TO cmotswrite;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_stp_bkp_14jul2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_stp_bkp_14jul2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
--DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;
	
BEGIN

--	select distinct status from transactions.stg_dion_stporder limit 1 
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY trxntime DESC) AS row_num
	FROM transactions.stg_dion_stporder
	)
	delete FROM transactions.stg_dion_stporder
	WHERE ctid IN (
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

IF EXISTS(SELECT 1 FROM transactions.stg_dion_stporder)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
	SELECT src.txnid FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_stporder src ON src.txnid = destn.vendor_trx_id
	WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') 
	OR COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) 
	OR COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') 
	OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') 
	OR TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) 
	OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') 
	OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'')  
	OR COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) 
	OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'')  
	OR COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') 
	OR COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') 
	OR COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) 
	OR COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) 
	OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') 
	OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'')
	OR TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))   
	);

UPDATE transactions.mf_order_summary destn SET
trx_datetime = CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
,reg_no = CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
,start_date = CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
,end_date = CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
,trx_status = CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
,"user_id" = CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
,reinvestmentflag = CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
,nav = CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
,order_remarks = CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
,cancellation_date = CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
,childordernumber = CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
,iscancel = CASE WHEN COALESCE(destn.iscancel,false) <> CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean THEN CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean ELSE destn.iscancel END
,istopup = CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
,vendor_exchg_refno = CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
,topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
,mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
,modified_date = NOW()
FROM transactions.stg_dion_stporder src
WHERE src.txnid = destn.vendor_trx_id 
and src.txnid in (select txnid from temp_mf_trx);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.vendor_trx_id IN (select txnid from temp_mf_trx)
AND A.remarks IS NOT NULL
AND (UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'CANCEL' AND A.iscancel = TRUE
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'PAUSE' AND A.ispaused = 1
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'RESUME' AND A.ispaused = 0);

-------------------------------------------------------------------------------------------

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
SELECT src.txnid FROM transactions.mf_order_summary destn
JOIN transactions.stg_dion_stporder src ON src.txnid = destn.vendor_trx_id
WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

UPDATE transactions.mf_order_summary dest 
SET
	trx_status = trx_sts.trx_status,
	trx_status_code = sts.trx_status_code,
	modified_date = NOW()
FROM transactions.stg_dion_stporder src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code 
AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and src.txnid in (select txnid from temp_mf_trx_status);

UPDATE transactions.mf_order_summary A 
SET
	final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx);

----------Inserting Data into transaction History Table----------

UPDATE transactions.mf_order_summary_history A
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE A.vendor_trx_id = B.vendor_trx_id
and	A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx) 
and is_active = true
and coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
and coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
and coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0);

INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,trx_final_status_code,final_status,inv_plan_status_code,inv_plan_status
FROM transactions.mf_order_summary A 
WHERE A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status);

UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

-------------------------------------------------		
-- new trx insert
--VACUUM ANALYZE transactions.mf_order_summary;

INSERT INTO transactions.mf_order_summary(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan
)
select (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, 
src.txnid,src.sipregno,src.clientcode,src.txntype,src.amount,src.sipstartdate,src.sipenddate, 
src.foliono,trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when trim(upper(src.status))='CANCELLED' then true else false end as iscancel,
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,src.usertype,
src.ordernav,src.ordernavdate,src.childordernumber,src.token,src.mandateamount,
case when TRIM(UPPER(src.status))='PAUSE' then 1 else 0 end as ispaused,src.istopup,
src.exchangerefnumber,src.pausemodificationcount,src.topupcount,src.pausecount,
src.mainsipregno,src.modifytype,src.modifycount,NOW(),NOW(),trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan
from transactions.stg_dion_stporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
join master.map_vendor_internal_trx_type trx on upper(src.txntype) = trx.vendor_trx_type 
and trx.category_code = 261 and trx.isactive = true
join master.map_vendor_internal_trx_status sts on sts.vendor_status = upper(src.status) 
and sts.category_code = 261 and sts.isactive = true 
join master.trx_status trx_sts on trx_sts.trx_status_code = sts.trx_status_code 
and trx_sts.category_code = 261 and trx_sts.isactive = true 
join master.dim_ucc mst on mst.priority_ac_code = src.clientcode
where destn.vendor_trx_id is null;

update transactions.mf_order_summary A
set final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from transactions.stg_dion_stporder);

UPDATE transactions.mf_order_summary A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary A SET 
trx_id = B.trx_id, 
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

----------Inserting Data into transaction History Table----------

insert into transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,
stepup_amount,stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,
paused_date,topupdate,isskip,skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,
previous_paid_date,totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,
A.istopup,A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,
A.is_generatetoday,A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,
A.vendor_trx_id,A.iscancel,A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,
A.skip_date,A.trx_type_code,A.isresumed,A.resumed_date,A.upcoming_due_date,A.previous_paid_date,
A.totalinstallmentamt_paid,A.switch_isin,A.trx_status_code,NOW(),true
FROM transactions.mf_order_summary A
join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
WHERE B.vendor_trx_id is null ;

UPDATE transactions.mf_order_summary_history SET
valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

---------------------------------------------------------------------------------------------------------------
-- Inserting the data  intot the error table
	
DELETE FROM transactions.mf_order_summary_error WHERE created_date >= NOW() - INTERVAL '7 days';

INSERT INTO transactions.mf_order_summary_error(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan,error_message
)
select
(src.sipregdate || ' ' || src.trxntime)::timestamp without time zone, 
src.siporderno,src.txnid,src.sipregno,src.clientcode,src.txntype,
src.amount,src.sipstartdate,src.sipenddate,src.foliono,
trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when TRIM(UPPER(src.status))='CANCELLED' then true else false end as iscancel, 
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,
src.usertype,src.ordernav,src.ordernavdate,src.childordernumber,src.token,
src.mandateamount,src.ispaused,src.istopup,src.exchangerefnumber,
src.pausemodificationcount,src.topupcount,src.pausecount,src.mainsipregno,src.modifytype, 
src.modifycount,NOW() as created_date,NOW() as modified_date,trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan,
CONCAT(
	CASE WHEN src.exchangerefnumber IS NULL THEN 'exchangerefnumber not available; ' ELSE '' END,
	CASE WHEN src.clientcode IS NULL THEN 'clientcode not available; ' ELSE '' END,
	CASE WHEN mst.ucccode IS NULL THEN 'UCC not available; ' ELSE '' END,
	CASE WHEN isin.isincode IS NULL THEN 'ISIN not available in mst; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_stporder src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL);

/*		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    trx_datetime = EXCLUDED.trx_datetime,
		    order_no = EXCLUDED.order_no,
		    reg_no = EXCLUDED.reg_no,
		    ac_code = EXCLUDED.ac_code,
		    trx_type = EXCLUDED.trx_type,
		    trx_amt = EXCLUDED.trx_amt,
		    start_date = EXCLUDED.start_date,
		    end_date = EXCLUDED.end_date,
		    folio_no = EXCLUDED.folio_no,
		    trx_status = EXCLUDED.trx_status,
		    orderby = EXCLUDED.orderby,
		    isincode = EXCLUDED.isincode,
		    frequency = EXCLUDED.frequency,
		    no_of_installment = EXCLUDED.no_of_installment,
		    installment_paid = EXCLUDED.installment_paid,
		    installment_pending = EXCLUDED.installment_pending,
		    mandate_id = EXCLUDED.mandate_id,
		    iscancel = EXCLUDED.iscancel,
		    reinvestmentflag = EXCLUDED.reinvestmentflag,
		    nav = EXCLUDED.nav,
		    mfimfdflag = EXCLUDED.mfimfdflag,
		    order_remarks = EXCLUDED.order_remarks,
		    euinnumber = EXCLUDED.euinnumber,
		    rm_partner_code = EXCLUDED.rm_partner_code,
		    cancellation_date = EXCLUDED.cancellation_date,
		    dpc = EXCLUDED.dpc,
		    firstordertoday = EXCLUDED.firstordertoday,
		    delivery_mode = EXCLUDED.delivery_mode,
		    "user_id" = EXCLUDED."user_id",
		    trx_source = EXCLUDED.trx_source,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    childordernumber = EXCLUDED.childordernumber,
		    tokenno = EXCLUDED.tokenno,
		    mandate_amt = EXCLUDED.mandate_amt,
		    ispaused = EXCLUDED.ispaused,
		    istopup = EXCLUDED.istopup,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    pausemodificationcount = EXCLUDED.pausemodificationcount,
		    topupcount = EXCLUDED.topupcount,
		    pausecount = EXCLUDED.pausecount,
		    mainsipregno = EXCLUDED.mainsipregno,
		    modifytype = EXCLUDED.modifytype,
		    modifycount = EXCLUDED.modifycount,
		    created_date = NOW(),
		    modified_date = NOW(),
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    datasource = EXCLUDED.datasource,
		    pan = EXCLUDED.pan,
		    error_message = EXCLUDED.error_message;
	*/	   

UPDATE transactions.mf_order_summary_error A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary_error A SET 
trx_id = B.trx_id,
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary_error A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

--------------------------------------------------------------
DROP TABLE temp_mf_trx; 
DROP TABLE temp_mf_trx_status; 
--------------------------------------------------------------

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_stp_bkp_14jul2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_stp_bkp_14jul2025() TO cmotswrite;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_swp();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_swp()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
--DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;
	
BEGIN

--	select distinct status from transactions.stg_dion_swporder limit 1 
---------------------------------------------------------------------	
---------------------------------------------------------------------
update transactions.stg_dion_swporder
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY trxntime DESC) AS row_num
	FROM transactions.stg_dion_swporder
	)
	delete FROM transactions.stg_dion_swporder
	WHERE ctid IN (
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

IF EXISTS(SELECT 1 FROM transactions.stg_dion_swporder)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
	SELECT src.txnid FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_swporder src ON src.txnid = destn.vendor_trx_id
	WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') 
	OR COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) 
	OR COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') 
	OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') 
	OR TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) 
	OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') 
	OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'')  
	OR COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) 
	OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'')  
	OR COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') 
	OR COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') 
	OR COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) 
	OR COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) 
	OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') 
	OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'')
	OR TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))   
	);

UPDATE transactions.mf_order_summary destn 
SET
trx_datetime = CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
,reg_no = CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
,start_date = CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
,end_date = CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
,trx_status = CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
,"user_id" = CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
,reinvestmentflag = CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
,nav = CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
,order_remarks = CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
,cancellation_date = CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
,childordernumber = CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
,iscancel = CASE WHEN COALESCE(destn.iscancel,false) <> CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean THEN CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean ELSE destn.iscancel END
,istopup = CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
,vendor_exchg_refno = CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
,topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
,mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
,modified_date = (NOW() at time zone 'Asia/Kolkata')
FROM transactions.stg_dion_swporder src
WHERE src.txnid = destn.vendor_trx_id 
and src.txnid in (select txnid from temp_mf_trx);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.vendor_trx_id IN (select txnid from temp_mf_trx)
AND A.remarks IS NOT NULL
AND (UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'CANCEL' AND A.iscancel = TRUE
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'PAUSE' AND A.ispaused = 1
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'RESUME' AND A.ispaused = 0);

-------------------------------------------------------------------------------------------

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
SELECT src.txnid FROM transactions.mf_order_summary destn
JOIN transactions.stg_dion_swporder src ON src.txnid = destn.vendor_trx_id
WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

UPDATE transactions.mf_order_summary dest 
SET
	trx_status = trx_sts.trx_status,
	trx_status_code = sts.trx_status_code,
	modified_date = (NOW() at time zone 'Asia/Kolkata')
FROM transactions.stg_dion_swporder src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code 
AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and src.txnid in (select txnid from temp_mf_trx_status);

UPDATE transactions.mf_order_summary A 
SET
	final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx);

----------Inserting Data into transaction History Table----------
/*
UPDATE transactions.mf_order_summary_history A
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE A.vendor_trx_id = B.vendor_trx_id
--and A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status) 
and is_active = true and
(coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
 OR coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
 OR coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0));

INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
from transactions.mf_order_summary A 
--WHERE A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status);
join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
where coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
OR coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
OR coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0);

UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;
*/

-------------------------------------------------		
-- new trx insert
--VACUUM ANALYZE transactions.mf_order_summary;

INSERT INTO transactions.mf_order_summary(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan
)
select (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, 
src.txnid,src.sipregno,src.clientcode,src.txntype,src.amount,src.sipstartdate,src.sipenddate, 
src.foliono,trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments::int as totalinstalments,src.instalementspaid::int as instalementspaid,
src.instalmentspending,src.mandateid, 
case when trim(upper(src.status))='CANCELLED' then true else false end as iscancel,
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,src.usertype,
src.ordernav,src.ordernavdate,src.childordernumber,src.token,src.mandateamount,
case when TRIM(UPPER(src.status))='PAUSE' then 1 else 0 end as ispaused,src.istopup,
src.exchangerefnumber,src.pausemodificationcount,src.topupcount,src.pausecount,
src.mainsipregno,src.modifytype,src.modifycount,(NOW() at time zone 'Asia/Kolkata'),
(NOW() at time zone 'Asia/Kolkata'),trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan
from transactions.stg_dion_swporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
join master.map_vendor_internal_trx_type trx on upper(src.txntype) = trx.vendor_trx_type 
and trx.category_code = 261 and trx.isactive = true
join master.map_vendor_internal_trx_status sts on sts.vendor_status = upper(src.status) 
and sts.category_code = 261 and sts.isactive = true 
join master.trx_status trx_sts on trx_sts.trx_status_code = sts.trx_status_code 
and trx_sts.category_code = 261 and trx_sts.isactive = true 
join master.dim_ucc mst on mst.priority_ac_code = src.clientcode
where destn.vendor_trx_id is null;

update transactions.mf_order_summary A
set final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from transactions.stg_dion_swporder);

UPDATE transactions.mf_order_summary A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary A SET 
trx_id = B.trx_id, 
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

----------Inserting Data into transaction History Table----------
/*
insert into transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,
stepup_amount,stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,
paused_date,topupdate,isskip,skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,
previous_paid_date,totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,
A.istopup,A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,
A.is_generatetoday,A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,
A.vendor_trx_id,A.iscancel,A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,
A.skip_date,A.trx_type_code,A.isresumed,A.resumed_date,A.upcoming_due_date,A.previous_paid_date,
A.totalinstallmentamt_paid,A.switch_isin,A.trx_status_code,NOW(),true
FROM transactions.mf_order_summary A
join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
WHERE B.vendor_trx_id is null ;

UPDATE transactions.mf_order_summary_history SET
valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;
*/

---------------------------------------------------------------------------------------------------------------
-- Inserting the data  intot the error table
	
DELETE FROM transactions.mf_order_summary_error 
WHERE created_date >= (NOW() at time zone 'Asia/Kolkata') - INTERVAL '7 days';

INSERT INTO transactions.mf_order_summary_error(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan,error_message
)
select
(src.sipregdate || ' ' || src.trxntime)::timestamp without time zone, 
src.siporderno,src.txnid,src.sipregno,src.clientcode,src.txntype,
src.amount,src.sipstartdate,src.sipenddate,src.foliono,
trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments::int as totalinstalments,src.instalementspaid::int as instalementspaid,
src.instalmentspending,src.mandateid, 
case when TRIM(UPPER(src.status))='CANCELLED' then true else false end as iscancel, 
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,
src.usertype,src.ordernav,src.ordernavdate,src.childordernumber,src.token,
src.mandateamount,src.ispaused,src.istopup,src.exchangerefnumber,
src.pausemodificationcount,src.topupcount,src.pausecount,src.mainsipregno,src.modifytype, 
src.modifycount,(NOW() at time zone 'Asia/Kolkata') as created_date,
(NOW() at time zone 'Asia/Kolkata') as modified_date,trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan,
CONCAT(
	CASE WHEN src.exchangerefnumber IS NULL THEN 'exchangerefnumber not available; ' ELSE '' END,
	CASE WHEN src.clientcode IS NULL THEN 'clientcode not available; ' ELSE '' END,
	CASE WHEN mst.ucccode IS NULL THEN 'UCC not available; ' ELSE '' END,
	CASE WHEN isin.isincode IS NULL THEN 'ISIN not available in mst; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_swporder src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL);

/*		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    trx_datetime = EXCLUDED.trx_datetime,
		    order_no = EXCLUDED.order_no,
		    reg_no = EXCLUDED.reg_no,
		    ac_code = EXCLUDED.ac_code,
		    trx_type = EXCLUDED.trx_type,
		    trx_amt = EXCLUDED.trx_amt,
		    start_date = EXCLUDED.start_date,
		    end_date = EXCLUDED.end_date,
		    folio_no = EXCLUDED.folio_no,
		    trx_status = EXCLUDED.trx_status,
		    orderby = EXCLUDED.orderby,
		    isincode = EXCLUDED.isincode,
		    frequency = EXCLUDED.frequency,
		    no_of_installment = EXCLUDED.no_of_installment,
		    installment_paid = EXCLUDED.installment_paid,
		    installment_pending = EXCLUDED.installment_pending,
		    mandate_id = EXCLUDED.mandate_id,
		    iscancel = EXCLUDED.iscancel,
		    reinvestmentflag = EXCLUDED.reinvestmentflag,
		    nav = EXCLUDED.nav,
		    mfimfdflag = EXCLUDED.mfimfdflag,
		    order_remarks = EXCLUDED.order_remarks,
		    euinnumber = EXCLUDED.euinnumber,
		    rm_partner_code = EXCLUDED.rm_partner_code,
		    cancellation_date = EXCLUDED.cancellation_date,
		    dpc = EXCLUDED.dpc,
		    firstordertoday = EXCLUDED.firstordertoday,
		    delivery_mode = EXCLUDED.delivery_mode,
		    "user_id" = EXCLUDED."user_id",
		    trx_source = EXCLUDED.trx_source,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    childordernumber = EXCLUDED.childordernumber,
		    tokenno = EXCLUDED.tokenno,
		    mandate_amt = EXCLUDED.mandate_amt,
		    ispaused = EXCLUDED.ispaused,
		    istopup = EXCLUDED.istopup,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    pausemodificationcount = EXCLUDED.pausemodificationcount,
		    topupcount = EXCLUDED.topupcount,
		    pausecount = EXCLUDED.pausecount,
		    mainsipregno = EXCLUDED.mainsipregno,
		    modifytype = EXCLUDED.modifytype,
		    modifycount = EXCLUDED.modifycount,
		    created_date = NOW(),
		    modified_date = NOW(),
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    datasource = EXCLUDED.datasource,
		    pan = EXCLUDED.pan,
		    error_message = EXCLUDED.error_message;
	*/	   

UPDATE transactions.mf_order_summary_error A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary_error A SET 
trx_id = B.trx_id,
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary_error A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

--------------------------------------------------------------
DROP TABLE temp_mf_trx; 
DROP TABLE temp_mf_trx_status; 
--------------------------------------------------------------

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_swp() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_09may2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_09may2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
--DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;
	
BEGIN

--	select distinct status from transactions.stg_dion_swporder limit 1 
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY trxntime DESC) AS row_num
	FROM transactions.stg_dion_swporder
	)
	delete FROM transactions.stg_dion_swporder
	WHERE ctid IN (
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

IF EXISTS(SELECT 1 FROM transactions.stg_dion_swporder)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
	SELECT src.txnid FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_swporder src ON src.txnid = destn.vendor_trx_id
	WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') 
	OR COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) 
	OR COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') 
	OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') 
	OR TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) 
	OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') 
	OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'')  
	OR COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) 
	OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'')  
	OR COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') 
	OR COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') 
	OR COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) 
	OR COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) 
	OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') 
	OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'')
	OR TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))   
	);

UPDATE transactions.mf_order_summary destn 
SET
trx_datetime = CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
,reg_no = CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
,start_date = CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
,end_date = CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
,trx_status = CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
,"user_id" = CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
,reinvestmentflag = CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
,nav = CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
,order_remarks = CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
,cancellation_date = CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
,childordernumber = CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
,iscancel = CASE WHEN COALESCE(destn.iscancel,false) <> CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean THEN CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean ELSE destn.iscancel END
,istopup = CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
,vendor_exchg_refno = CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
,topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
,mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
,modified_date = NOW()
FROM transactions.stg_dion_swporder src
WHERE src.txnid = destn.vendor_trx_id 
and src.txnid in (select txnid from temp_mf_trx);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.vendor_trx_id IN (select txnid from temp_mf_trx)
AND A.remarks IS NOT NULL
AND (UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'CANCEL' AND A.iscancel = TRUE
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'PAUSE' AND A.ispaused = 1
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'RESUME' AND A.ispaused = 0);

-------------------------------------------------------------------------------------------

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
SELECT src.txnid FROM transactions.mf_order_summary destn
JOIN transactions.stg_dion_swporder src ON src.txnid = destn.vendor_trx_id
WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

UPDATE transactions.mf_order_summary dest 
SET
	trx_status = trx_sts.trx_status,
	trx_status_code = sts.trx_status_code,
	modified_date = NOW()
FROM transactions.stg_dion_swporder src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code 
AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and src.txnid in (select txnid from temp_mf_trx_status);

UPDATE transactions.mf_order_summary A 
SET
	final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx);

----------Inserting Data into transaction History Table----------

UPDATE transactions.mf_order_summary_history A
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE A.vendor_trx_id = B.vendor_trx_id
--and A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status) 
and is_active = true and
(coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
 OR coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
 OR coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0));

INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
from transactions.mf_order_summary A 
--WHERE A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status);
join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
where coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
OR coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
OR coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0);

UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

-------------------------------------------------		
-- new trx insert
--VACUUM ANALYZE transactions.mf_order_summary;

INSERT INTO transactions.mf_order_summary(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan
)
select (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, 
src.txnid,src.sipregno,src.clientcode,src.txntype,src.amount,src.sipstartdate,src.sipenddate, 
src.foliono,trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when trim(upper(src.status))='CANCELLED' then true else false end as iscancel,
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,src.usertype,
src.ordernav,src.ordernavdate,src.childordernumber,src.token,src.mandateamount,
case when TRIM(UPPER(src.status))='PAUSE' then 1 else 0 end as ispaused,src.istopup,
src.exchangerefnumber,src.pausemodificationcount,src.topupcount,src.pausecount,
src.mainsipregno,src.modifytype,src.modifycount,NOW(),NOW(),trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan
from transactions.stg_dion_swporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
join master.map_vendor_internal_trx_type trx on upper(src.txntype) = trx.vendor_trx_type 
and trx.category_code = 261 and trx.isactive = true
join master.map_vendor_internal_trx_status sts on sts.vendor_status = upper(src.status) 
and sts.category_code = 261 and sts.isactive = true 
join master.trx_status trx_sts on trx_sts.trx_status_code = sts.trx_status_code 
and trx_sts.category_code = 261 and trx_sts.isactive = true 
join master.dim_ucc mst on mst.priority_ac_code = src.clientcode
where destn.vendor_trx_id is null;

update transactions.mf_order_summary A
set final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from transactions.stg_dion_swporder);

UPDATE transactions.mf_order_summary A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary A SET 
trx_id = B.trx_id, 
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

----------Inserting Data into transaction History Table----------

insert into transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,
stepup_amount,stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,
paused_date,topupdate,isskip,skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,
previous_paid_date,totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,
A.istopup,A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,
A.is_generatetoday,A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,
A.vendor_trx_id,A.iscancel,A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,
A.skip_date,A.trx_type_code,A.isresumed,A.resumed_date,A.upcoming_due_date,A.previous_paid_date,
A.totalinstallmentamt_paid,A.switch_isin,A.trx_status_code,NOW(),true
FROM transactions.mf_order_summary A
join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
WHERE B.vendor_trx_id is null ;

UPDATE transactions.mf_order_summary_history SET
valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

---------------------------------------------------------------------------------------------------------------
-- Inserting the data  intot the error table
	
DELETE FROM transactions.mf_order_summary_error WHERE created_date >= NOW() - INTERVAL '7 days';

INSERT INTO transactions.mf_order_summary_error(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan,error_message
)
select
(src.sipregdate || ' ' || src.trxntime)::timestamp without time zone, 
src.siporderno,src.txnid,src.sipregno,src.clientcode,src.txntype,
src.amount,src.sipstartdate,src.sipenddate,src.foliono,
trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when TRIM(UPPER(src.status))='CANCELLED' then true else false end as iscancel, 
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,
src.usertype,src.ordernav,src.ordernavdate,src.childordernumber,src.token,
src.mandateamount,src.ispaused,src.istopup,src.exchangerefnumber,
src.pausemodificationcount,src.topupcount,src.pausecount,src.mainsipregno,src.modifytype, 
src.modifycount,NOW() as created_date,NOW() as modified_date,trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan,
CONCAT(
	CASE WHEN src.exchangerefnumber IS NULL THEN 'exchangerefnumber not available; ' ELSE '' END,
	CASE WHEN src.clientcode IS NULL THEN 'clientcode not available; ' ELSE '' END,
	CASE WHEN mst.ucccode IS NULL THEN 'UCC not available; ' ELSE '' END,
	CASE WHEN isin.isincode IS NULL THEN 'ISIN not available in mst; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_swporder src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL);

/*		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    trx_datetime = EXCLUDED.trx_datetime,
		    order_no = EXCLUDED.order_no,
		    reg_no = EXCLUDED.reg_no,
		    ac_code = EXCLUDED.ac_code,
		    trx_type = EXCLUDED.trx_type,
		    trx_amt = EXCLUDED.trx_amt,
		    start_date = EXCLUDED.start_date,
		    end_date = EXCLUDED.end_date,
		    folio_no = EXCLUDED.folio_no,
		    trx_status = EXCLUDED.trx_status,
		    orderby = EXCLUDED.orderby,
		    isincode = EXCLUDED.isincode,
		    frequency = EXCLUDED.frequency,
		    no_of_installment = EXCLUDED.no_of_installment,
		    installment_paid = EXCLUDED.installment_paid,
		    installment_pending = EXCLUDED.installment_pending,
		    mandate_id = EXCLUDED.mandate_id,
		    iscancel = EXCLUDED.iscancel,
		    reinvestmentflag = EXCLUDED.reinvestmentflag,
		    nav = EXCLUDED.nav,
		    mfimfdflag = EXCLUDED.mfimfdflag,
		    order_remarks = EXCLUDED.order_remarks,
		    euinnumber = EXCLUDED.euinnumber,
		    rm_partner_code = EXCLUDED.rm_partner_code,
		    cancellation_date = EXCLUDED.cancellation_date,
		    dpc = EXCLUDED.dpc,
		    firstordertoday = EXCLUDED.firstordertoday,
		    delivery_mode = EXCLUDED.delivery_mode,
		    "user_id" = EXCLUDED."user_id",
		    trx_source = EXCLUDED.trx_source,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    childordernumber = EXCLUDED.childordernumber,
		    tokenno = EXCLUDED.tokenno,
		    mandate_amt = EXCLUDED.mandate_amt,
		    ispaused = EXCLUDED.ispaused,
		    istopup = EXCLUDED.istopup,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    pausemodificationcount = EXCLUDED.pausemodificationcount,
		    topupcount = EXCLUDED.topupcount,
		    pausecount = EXCLUDED.pausecount,
		    mainsipregno = EXCLUDED.mainsipregno,
		    modifytype = EXCLUDED.modifytype,
		    modifycount = EXCLUDED.modifycount,
		    created_date = NOW(),
		    modified_date = NOW(),
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    datasource = EXCLUDED.datasource,
		    pan = EXCLUDED.pan,
		    error_message = EXCLUDED.error_message;
	*/	   

UPDATE transactions.mf_order_summary_error A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary_error A SET 
trx_id = B.trx_id,
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary_error A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

--------------------------------------------------------------
DROP TABLE temp_mf_trx; 
DROP TABLE temp_mf_trx_status; 
--------------------------------------------------------------

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_09may2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_09may2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_09may2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_09may2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_09may2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_14jul2025();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_14jul2025()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

--DECLARE v_trx_id bigint;
--DECLARE v_iscancel boolean;
--DECLARE v_trx_status_id bigint;
	
BEGIN

--	select distinct status from transactions.stg_dion_swporder limit 1 
---------------------------------------------------------------------	
---------------------------------------------------------------------
update transactions.stg_dion_swporder
set	status=regexp_replace(status, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	
----delete duplicates
WITH ranked_rows AS (
	SELECT
	ctid, -- Include ctid for later filtering
	txnid,
	ROW_NUMBER() OVER (PARTITION BY txnid ORDER BY trxntime DESC) AS row_num
	FROM transactions.stg_dion_swporder
	)
	delete FROM transactions.stg_dion_swporder
	WHERE ctid IN (
	SELECT ctid	FROM ranked_rows
	WHERE row_num > 1
	);

IF EXISTS(SELECT 1 FROM transactions.stg_dion_swporder)
THEN
	CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx AS
	SELECT src.txnid FROM transactions.mf_order_summary destn JOIN transactions.stg_dion_swporder src ON src.txnid = destn.vendor_trx_id
	WHERE (COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') 
	OR COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) 
	OR COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') 
	OR COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') 
	OR TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) 
	OR COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') 
	OR COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'')  
	OR COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) 
	OR COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'')  
	OR COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') 
	OR COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') 
	OR COALESCE(src.ispaused,0) <> COALESCE(destn.ispaused,0) 
	OR COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) 
	OR COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') 
	OR COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'')
	OR TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status))   
	);

UPDATE transactions.mf_order_summary destn 
SET
trx_datetime = CASE WHEN COALESCE((src.sipregdate||' '||src.trxntime)::timestamp without time zone,'1900-01-01') <> COALESCE(destn.trx_datetime,'1900-01-01') THEN (src.sipregdate||' '||src.trxntime)::timestamp without time zone ELSE destn.trx_datetime END
,reg_no = CASE WHEN COALESCE(src.sipregno,0) <> COALESCE(destn.reg_no,0) THEN src.sipregno ELSE destn.reg_no END
,start_date = CASE WHEN COALESCE(src.sipstartdate,'1900-01-01') <> COALESCE(destn.start_date,'1900-01-01') THEN src.sipstartdate ELSE destn.start_date END
,end_date = CASE WHEN COALESCE(src.sipenddate,'1900-01-01') <> COALESCE(destn.end_date,'1900-01-01') THEN src.sipenddate ELSE destn.end_date END
,trx_status = CASE WHEN TRIM(UPPER(COALESCE(src.status,''))) <> TRIM(UPPER(COALESCE(destn.trx_status,''))) THEN TRIM(UPPER(src.status)) ELSE TRIM(UPPER(destn.trx_status)) END
,"user_id" = CASE WHEN COALESCE(src.orderedby,'') <> COALESCE(destn."user_id",'') THEN src.orderedby ELSE destn."user_id" END
,reinvestmentflag = CASE WHEN COALESCE(src.reinvestmentflag,'') <> COALESCE(destn.reinvestmentflag,'') THEN src.reinvestmentflag ELSE destn.reinvestmentflag END
,nav = CASE WHEN COALESCE(src.nav,0.0) <> COALESCE(destn.nav,0.0) THEN src.nav ELSE destn.nav END
,order_remarks = CASE WHEN COALESCE(src.remarks,'') <> COALESCE(destn.order_remarks,'') THEN src.remarks ELSE destn.order_remarks END
,cancellation_date = CASE WHEN COALESCE(src.sipcancellationdate,'1900-01-01') <> COALESCE(destn.cancellation_date,'1900-01-01') THEN src.sipcancellationdate ELSE destn.cancellation_date END
,childordernumber = CASE WHEN COALESCE(src.childordernumber,'') <> COALESCE(destn.childordernumber,'') THEN src.childordernumber ELSE destn.childordernumber END
,iscancel = CASE WHEN COALESCE(destn.iscancel,false) <> CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean THEN CASE WHEN (UPPER(src.status)) = 'CANCELLED' THEN TRUE ELSE FALSE END::boolean ELSE destn.iscancel END
,istopup = CASE WHEN COALESCE(src.istopup,0) <> COALESCE(destn.istopup,0) THEN src.istopup ELSE destn.istopup END
,vendor_exchg_refno = CASE WHEN COALESCE(src.exchangerefnumber,'') <> COALESCE(destn.vendor_exchg_refno,'') THEN src.exchangerefnumber ELSE destn.vendor_exchg_refno END
,topupcount = CASE WHEN COALESCE(src.topupcount,0) <> COALESCE(destn.topupcount,0) THEN src.topupcount ELSE destn.topupcount END
,mainsipregno = CASE WHEN COALESCE(src.mainsipregno,'') <> COALESCE(destn.mainsipregno,'') THEN src.mainsipregno ELSE destn.mainsipregno END
,modified_date = NOW()
FROM transactions.stg_dion_swporder src
WHERE src.txnid = destn.vendor_trx_id 
and src.txnid in (select txnid from temp_mf_trx);

UPDATE transactions.mf_order_summary A SET remarks = NULL
WHERE A.vendor_trx_id IN (select txnid from temp_mf_trx)
AND A.remarks IS NOT NULL
AND (UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'CANCEL' AND A.iscancel = TRUE
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'PAUSE' AND A.ispaused = 1
	 OR UPPER(TRIM(REPLACE(A.remarks,' Request in Progress',''))) = 'RESUME' AND A.ispaused = 0);

-------------------------------------------------------------------------------------------

CREATE TEMP TABLE IF NOT EXISTS temp_mf_trx_status AS
SELECT src.txnid FROM transactions.mf_order_summary destn
JOIN transactions.stg_dion_swporder src ON src.txnid = destn.vendor_trx_id
WHERE TRIM(UPPER(src.status)) <> TRIM(UPPER(destn.trx_status));

UPDATE transactions.mf_order_summary dest 
SET
	trx_status = trx_sts.trx_status,
	trx_status_code = sts.trx_status_code,
	modified_date = NOW()
FROM transactions.stg_dion_swporder src
JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) 
AND sts.category_code = 261 AND sts.isactive = true
JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code 
AND trx_sts.category_code = 261 AND trx_sts.isactive = true
WHERE dest.vendor_trx_id = src.txnid
and src.txnid in (select txnid from temp_mf_trx_status);

UPDATE transactions.mf_order_summary A 
SET
	final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from temp_mf_trx);

----------Inserting Data into transaction History Table----------

UPDATE transactions.mf_order_summary_history A
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE A.vendor_trx_id = B.vendor_trx_id
--and A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status) 
and is_active = true and
(coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
 OR coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
 OR coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0));

INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
from transactions.mf_order_summary A 
--WHERE A.vendor_trx_id IN (SELECT txnid FROM temp_mf_trx_status);
join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
where coalesce(a.trx_final_status_code,0)<>coalesce(b.trx_final_status_code,0)
OR coalesce(a.trx_status_code,0)<>coalesce(b.trx_status_code,0)
OR coalesce(a.inv_plan_status_code,0)<>coalesce(b.inv_plan_status_code,0);

UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

-------------------------------------------------		
-- new trx insert
--VACUUM ANALYZE transactions.mf_order_summary;

INSERT INTO transactions.mf_order_summary(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan
)
select (src.sipregdate||' '||src.trxntime)::timestamp without time zone, src.siporderno, 
src.txnid,src.sipregno,src.clientcode,src.txntype,src.amount,src.sipstartdate,src.sipenddate, 
src.foliono,trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when trim(upper(src.status))='CANCELLED' then true else false end as iscancel,
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,src.usertype,
src.ordernav,src.ordernavdate,src.childordernumber,src.token,src.mandateamount,
case when TRIM(UPPER(src.status))='PAUSE' then 1 else 0 end as ispaused,src.istopup,
src.exchangerefnumber,src.pausemodificationcount,src.topupcount,src.pausecount,
src.mainsipregno,src.modifytype,src.modifycount,NOW(),NOW(),trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan
from transactions.stg_dion_swporder src
left join transactions.mf_order_summary destn on src.txnid = destn.vendor_trx_id
join master.map_vendor_internal_trx_type trx on upper(src.txntype) = trx.vendor_trx_type 
and trx.category_code = 261 and trx.isactive = true
join master.map_vendor_internal_trx_status sts on sts.vendor_status = upper(src.status) 
and sts.category_code = 261 and sts.isactive = true 
join master.trx_status trx_sts on trx_sts.trx_status_code = sts.trx_status_code 
and trx_sts.category_code = 261 and trx_sts.isactive = true 
join master.dim_ucc mst on mst.priority_ac_code = src.clientcode
where destn.vendor_trx_id is null;

update transactions.mf_order_summary A
set final_status = B.final_status ,
	trx_final_status_code = B.trx_final_status_code,
	inv_plan_status_code = B.inv_plan_status_code,
	inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail B
where A.vendor_trx_id = B.vendor_trx_id
and A.vendor_trx_id in (select txnid from transactions.stg_dion_swporder);

UPDATE transactions.mf_order_summary A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary A SET 
trx_id = B.trx_id, 
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

----------Inserting Data into transaction History Table----------

insert into transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,
stepup_amount,stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,
paused_date,topupdate,isskip,skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,
previous_paid_date,totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active)
select 
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,
A.istopup,A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,
A.is_generatetoday,A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,
A.vendor_trx_id,A.iscancel,A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,
A.skip_date,A.trx_type_code,A.isresumed,A.resumed_date,A.upcoming_due_date,A.previous_paid_date,
A.totalinstallmentamt_paid,A.switch_isin,A.trx_status_code,NOW(),true
FROM transactions.mf_order_summary A
join transactions.mf_order_summary_history B on A.vendor_trx_id = B.vendor_trx_id
WHERE B.vendor_trx_id is null ;

UPDATE transactions.mf_order_summary_history SET
valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

---------------------------------------------------------------------------------------------------------------
-- Inserting the data  intot the error table
	
DELETE FROM transactions.mf_order_summary_error WHERE created_date >= NOW() - INTERVAL '7 days';

INSERT INTO transactions.mf_order_summary_error(
trx_datetime,order_no,vendor_trx_id,reg_no,ac_code,trx_type,trx_amt,start_date,end_date,folio_no,
trx_status,orderby,isincode,frequency,no_of_installment,installment_paid,installment_pending,
mandate_id,iscancel,reinvestmentflag,nav,mfimfdflag,order_remarks,euinnumber,rm_partner_code,
cancellation_date,dpc,firstordertoday,delivery_mode,"user_id",trx_source,order_nav,order_navdate,
childordernumber,tokenno,mandate_amt,ispaused,istopup,vendor_exchg_refno,pausemodificationcount,
topupcount,pausecount,mainsipregno,modifytype,modifycount,created_date,modified_date,trx_type_code,
trx_status_code,datasource,pan,error_message
)
select
(src.sipregdate || ' ' || src.trxntime)::timestamp without time zone, 
src.siporderno,src.txnid,src.sipregno,src.clientcode,src.txntype,
src.amount,src.sipstartdate,src.sipenddate,src.foliono,
trim(upper(src.status)) as status,src.orderedby,src.isin,src.frequency,
src.totalinstalments,src.instalementspaid,src.instalmentspending,src.mandateid, 
case when TRIM(UPPER(src.status))='CANCELLED' then true else false end as iscancel, 
src.reinvestmentflag,src.nav,src.mfimfdflag,src.remarks,src.euinnumber,src.rmcode,
src.sipcancellationdate,src.dpc,src.firstordertoday,src.traxmode,src.userid,
src.usertype,src.ordernav,src.ordernavdate,src.childordernumber,src.token,
src.mandateamount,src.ispaused,src.istopup,src.exchangerefnumber,
src.pausemodificationcount,src.topupcount,src.pausecount,src.mainsipregno,src.modifytype, 
src.modifycount,NOW() as created_date,NOW() as modified_date,trx.trx_type_code,
sts.trx_status_code,'DION'::character varying as datasource,mst.pan,
CONCAT(
	CASE WHEN src.exchangerefnumber IS NULL THEN 'exchangerefnumber not available; ' ELSE '' END,
	CASE WHEN src.clientcode IS NULL THEN 'clientcode not available; ' ELSE '' END,
	CASE WHEN mst.ucccode IS NULL THEN 'UCC not available; ' ELSE '' END,
	CASE WHEN isin.isincode IS NULL THEN 'ISIN not available in mst; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_swporder src
LEFT JOIN master.dim_ucc mst ON mst.priority_ac_code = src.clientcode
LEFT JOIN master.map_vendor_internal_trx_type trx ON UPPER(src.txntype) = trx.vendor_trx_type AND trx.category_code = 261 AND trx.isactive = true
LEFT JOIN master.trx_type txn ON txn.trx_type_code = trx.trx_type_code AND txn.category_code = 261 AND txn.isactive = true
LEFT JOIN master.investment_type inv ON inv.inv_type_code = txn.inv_type_code AND inv.category_code = 261 AND inv.isactive = true
LEFT JOIN master.map_vendor_internal_trx_status sts ON sts.vendor_status = UPPER(src.status) AND sts.category_code = 261 AND sts.isactive = true
LEFT JOIN master.trx_status trx_sts ON trx_sts.trx_status_code = sts.trx_status_code AND trx_sts.category_code = 261 AND trx_sts.isactive = true
LEFT JOIN master.dim_mf_isin isin ON src.isin = isin.isincode
LEFT JOIN master.dim_mf_scheme sch ON isin.mf_schcode = sch.mf_schcode
WHERE (mst.priority_ac_code IS NULL OR isin.isincode IS NULL OR isin.mf_schcode IS NULL
OR mst.ucccode IS NULL OR src.txntype IS NULL OR src.status IS NULL);

/*		ON CONFLICT (vendor_trx_id) DO UPDATE
		SET 
		    trx_datetime = EXCLUDED.trx_datetime,
		    order_no = EXCLUDED.order_no,
		    reg_no = EXCLUDED.reg_no,
		    ac_code = EXCLUDED.ac_code,
		    trx_type = EXCLUDED.trx_type,
		    trx_amt = EXCLUDED.trx_amt,
		    start_date = EXCLUDED.start_date,
		    end_date = EXCLUDED.end_date,
		    folio_no = EXCLUDED.folio_no,
		    trx_status = EXCLUDED.trx_status,
		    orderby = EXCLUDED.orderby,
		    isincode = EXCLUDED.isincode,
		    frequency = EXCLUDED.frequency,
		    no_of_installment = EXCLUDED.no_of_installment,
		    installment_paid = EXCLUDED.installment_paid,
		    installment_pending = EXCLUDED.installment_pending,
		    mandate_id = EXCLUDED.mandate_id,
		    iscancel = EXCLUDED.iscancel,
		    reinvestmentflag = EXCLUDED.reinvestmentflag,
		    nav = EXCLUDED.nav,
		    mfimfdflag = EXCLUDED.mfimfdflag,
		    order_remarks = EXCLUDED.order_remarks,
		    euinnumber = EXCLUDED.euinnumber,
		    rm_partner_code = EXCLUDED.rm_partner_code,
		    cancellation_date = EXCLUDED.cancellation_date,
		    dpc = EXCLUDED.dpc,
		    firstordertoday = EXCLUDED.firstordertoday,
		    delivery_mode = EXCLUDED.delivery_mode,
		    "user_id" = EXCLUDED."user_id",
		    trx_source = EXCLUDED.trx_source,
		    order_nav = EXCLUDED.order_nav,
		    order_navdate = EXCLUDED.order_navdate,
		    childordernumber = EXCLUDED.childordernumber,
		    tokenno = EXCLUDED.tokenno,
		    mandate_amt = EXCLUDED.mandate_amt,
		    ispaused = EXCLUDED.ispaused,
		    istopup = EXCLUDED.istopup,
		    vendor_exchg_refno = EXCLUDED.vendor_exchg_refno,
		    pausemodificationcount = EXCLUDED.pausemodificationcount,
		    topupcount = EXCLUDED.topupcount,
		    pausecount = EXCLUDED.pausecount,
		    mainsipregno = EXCLUDED.mainsipregno,
		    modifytype = EXCLUDED.modifytype,
		    modifycount = EXCLUDED.modifycount,
		    created_date = NOW(),
		    modified_date = NOW(),
		    trx_type_code = EXCLUDED.trx_type_code,
		    trx_status_code = EXCLUDED.trx_status_code,
		    datasource = EXCLUDED.datasource,
		    pan = EXCLUDED.pan,
		    error_message = EXCLUDED.error_message;
	*/	   

UPDATE transactions.mf_order_summary_error A SET 
mf_schcode = B.mf_schcode
FROM master.dim_mf_isin B 
WHERE A.isincode = B.isincode AND A.mf_schcode IS NULL;

UPDATE transactions.mf_order_summary_error A SET 
trx_id = B.trx_id,
display_trx_id = ('MF'||LPAD(B.trx_id::character varying, 10, '0'))::character varying
FROM transactions.mf_order_detail B 
WHERE A.vendor_trx_id = B.vendor_trx_id AND A.trx_id IS NULL;

UPDATE transactions.mf_order_summary_error A SET
rm_partner_code = CASE WHEN COALESCE(B.partnerowner,'') <> '' THEN B.partnerowner 
	ELSE B.client_owner END
FROM master.dim_ucc B 
WHERE TRIM(A.ac_code) = B.priority_ac_code AND A.rm_partner_code IS NULL;

--------------------------------------------------------------
DROP TABLE temp_mf_trx; 
DROP TABLE temp_mf_trx_status; 
--------------------------------------------------------------

RETURN 'SUCCESS';

ELSE

RETURN 'No Data in Staging Table';

END IF;
	
EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_14jul2025() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_14jul2025() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_14jul2025() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_14jul2025() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_order_summary_swp_bkp_14jul2025() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_mf_subsequent_order();

CREATE OR REPLACE FUNCTION transactions.fn_post_mf_subsequent_order()
 RETURNS text
 LANGUAGE plpgsql
AS $function$

BEGIN

---------------------------------------------------------------------
update transactions.stg_dion_sipsubsequentorder
set	txntype=regexp_replace(txntype, '[^A-Za-z0-9]', '', 'g');
---------------------------------------------------------------------	

IF EXISTS(SELECT 1 FROM transactions.stg_dion_sipsubsequentorder)
THEN

UPDATE transactions.stg_dion_sipsubsequentorder A 
SET intrefno = B.vendor_trx_id 
FROM transactions.mf_order_summary B
WHERE A.sipregno = B.reg_no AND A.intrefno IS NULL;

--  DELETE FROM transactions.mf_subsequent_order_error WHERE modified_date >= NOW() - INTERVAL '7 days';

INSERT INTO transactions.mf_subsequent_order_error
(order_no,ac_code,trx_type,trx_type_code,orderdate,amount,reg_date,status,
orderedby,sysrefno,isincode,mandate_id,reg_no,remarks,paymentrejection,
vendor_trx_id,created_date,modified_date,data_source,error_message)
SELECT 
src.siporderno, src.clientcode, src.txntype,
vi.trx_type_code,src.orderdate::date AS orderdate,
src.amount,src.sipregdate::date AS reg_date,
src.status,src.orderedby,src.sysrefno,src.isin,src.mandateid,
src.sipregno,src.remarks,src.paymentrejection,src.intrefno, 
(to_char(now(),'YYYY-MM-DD HH24:MI:SS'))::timestamp without time zone AS created_date,
(to_char(now(),'YYYY-MM-DD HH24:MI:SS'))::timestamp without time zone AS modified_date,	
'DION':: Character Varying as data_source,
CONCAT( 
CASE WHEN src.sipregdate IS NULL THEN 'sipregdate is NULL; ' ELSE '' END,
CASE WHEN src.sipregno IS NULL THEN 'sipregno is NULL; ' ELSE '' END,
CASE WHEN src.orderdate IS NULL THEN 'orderdate is NULL; ' ELSE '' END,
CASE WHEN du.priority_ac_code IS NULL THEN 'priority_ac_code is NULL; ' ELSE '' END,
CASE WHEN src.clientcode IS NULL THEN 'clientcode is NULL; ' ELSE '' END
) AS error_message
FROM transactions.stg_dion_sipsubsequentorder src
join master.dim_mf_isin isin on src.isin =isin.isincode
join master.dim_ucc du on du.priority_ac_code =src.clientcode
join master.map_vendor_internal_trx_type vi on vi.vendor_trx_type = TRIM(src.txntype)
where src.sipregno is null or src.sipregdate is null or src.orderdate is null or src.clientcode is null or du.priority_ac_code is null;
/*
ON CONFLICT (order_no, vendor_trx_id, reg_no, orderdate) DO UPDATE  
SET 
	ac_code = EXCLUDED.ac_code,
	trx_type = EXCLUDED.trx_type,
	trx_type_code = EXCLUDED.trx_type_code,
	amount = EXCLUDED.amount,
	reg_date = EXCLUDED.reg_date,
	status = EXCLUDED.status,
	orderedby = EXCLUDED.orderedby,
	sysrefno = EXCLUDED.sysrefno,
	isincode = EXCLUDED.isincode,
	mandate_id = EXCLUDED.mandate_id,
	remarks = EXCLUDED.remarks,
	paymentrejection = EXCLUDED.paymentrejection,
	created_date = NOW(),
	modified_date = NOW(), 
	data_source = EXCLUDED.data_source,
	error_message = EXCLUDED.error_message;   
*/

TRUNCATE TABLE transactions.mf_subsequent_order RESTART IDENTITY;

insert into transactions.mf_subsequent_order(
isincode,order_no,reg_no,vendor_trx_id,ac_code,
trx_type_code,trx_type,orderdate,amount,reg_date,
status,orderedby,sysrefno,mandate_id,remarks,
paymentrejection,created_date,modified_date,data_source)

select 
src.isin,src.siporderno as order_no,src.sipregno as reg_no,
coalesce(b.vendor_trx_id,0) as vendor_trx_id,
src.clientcode as ac_code,
vi.trx_type_code,trim(src.txntype) as trx_type,
src.orderdate::date as orderdate,amount,
src.sipregdate::date as reg_date,
src.status,src.orderedby,src.sysrefno,
src.mandateid,src.remarks,src.paymentrejection,
--date_trunc('second',now()) as created_date, 
--date_trunc('second',now()) as modified_date,
(to_char(now(), 'YYYY-MM-DD HH24:MI:SS'))::timestamp without time zone AS created_date,
(to_char(now(), 'YYYY-MM-DD HH24:MI:SS'))::timestamp without time zone AS modified_date,	
'DION':: Character Varying as data_source
from transactions.stg_dion_sipsubsequentorder src
left join transactions.mf_order_summary b
on src.sipregno = b.reg_no
join master.dim_ucc du on du.priority_ac_code =src.clientcode
join master.dim_mf_isin isin on src.isin =isin.isincode
join master.map_vendor_internal_trx_type vi on vi.vendor_trx_type = trim(src.txntype)
--where src.sipregno=59755988
--where src.sipregno is not null and src.sipregdate is not null and src.orderdate is not null and src.clientcode is not null
order by src.orderdate::date;

--/* commuication
----------SIP Installment
insert into transactions.communication_mailer_mst(
producttype,ordertype,inv_type,trx_id,vendor_trx_id,orderid,
clientcode,clientname,orderdate,transaction_mode,fundname,
amount,units,rejection_reason,installment_number,
sourceid,subcategoryid,subcategory,is_picked
)
-----------Installment
select  
'Mutual Fund'::character varying as producttype,
mst.trx_type as ordertype,det.inv_type,
src.trx_id,src.vendor_trx_id,src.display_trx_id as orderid,
dest.ac_code as clientcode,
INITCAP(ucc.acname)::character varying as clientname,
dest.orderdate::character varying as orderdate,
det.delivery_mode as transaction_mode,
det.isinname as fundname,
det.trx_amt::character varying as amount,
det.trx_qty::character varying as units,
(case when upper(dest.status)='VALID' then ''
when upper(dest.status)='INVALID' then dest.remarks
else '' end)::character varying as rejection_reason,
subsequent.cnt::character varying as installment_number,
'82'::character varying as sourceid,
(case 
when mst.trx_type_code=1 and upper(dest.status)='VALID' then '3578'
when mst.trx_type_code=1 and upper(dest.status)='INVALID' then '3579'
else '' end)::character varying as subcategoryid,
(case 
when mst.trx_type_code=1 and upper(dest.status)='VALID' then 'SUBSEQUENT_SIP_CONFIRMED_INTERNAL'
when mst.trx_type_code=1 and upper(dest.status)='INVALID' then 'SUBSEQUENT_SIP_REJECTED_INTERNAL'	
else '' end)::character varying subcategory,
false as is_picked
from transactions.mf_subsequent_order dest
join master.trx_type mst
on dest.trx_type_code = mst.trx_type_code and mst.category_code=261
join transactions.mf_order_summary src on src.reg_no= dest.reg_no
join master.dim_ucc ucc on ucc.priority_ac_code = dest.ac_code
join transactions.mf_order_detail det on dest.vendor_trx_id  = det.vendor_trx_id
join (
	select a.reg_no,count(1) as cnt 
	from transactions.mf_subsequent_order a
	where a.trx_type_code=1 
	and a.orderedby='Exchange Triggered'
	and upper(a.status) in ('VALID','INVALID')
	and a.data_source='DION'
	group by reg_no
)subsequent
on dest.reg_no=subsequent.reg_no
where dest.trx_type_code=1 
and dest.orderedby='Exchange Triggered'
--and dest.orderdate='2025-02-18'
and dest.orderdate =CURRENT_DATE - INTERVAL '1 day'
and upper(dest.status) in ('VALID','INVALID')
and dest.data_source='DION';
--*/

------------------------------------------------------
----Update Installment Count Status
UPDATE transactions.mf_order_summary AS a
SET totalinstallment_paid = b.cnt,
	installment_paid=b.cnt
FROM (
    SELECT reg_no, COUNT(*) AS cnt
    FROM transactions.mf_subsequent_order
    GROUP BY reg_no
) b
WHERE a.reg_no = b.reg_no
AND a.vendor_trx_id IS NOT NULL;
-----------------------------------------------------------------
----update SWP installment 
update transactions.mf_order_summary a
set totalinstallmentamt_paid=b.totalinstallmentamt_paid
from
(
	select a.trx_id,a.reg_no,(a.trx_amt*b.install_cnt)::int as totalinstallmentamt_paid
	from transactions.mf_order_summary a
	join (
		select sipregno,count(1)::int as install_cnt 
		from transactions.stg_dion_sipsubsequentorder
		where trim(txntype)='SWP'
		and status='VALID'
		group by sipregno
	)b
	on a.reg_no = b.sipregno
)b
where a.trx_id=b.trx_id;
-----------------------------------------------------------------

	RETURN 'SUCCESS';
ELSE
	RETURN 'No Data in Staging Table';
END IF;

EXCEPTION
WHEN OTHERS THEN
	BEGIN
		RETURN 'Failure Error :- '||CAST(SQLERRM as VARCHAR(4000));
	END;  

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_mf_subsequent_order() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_subsequent_order() TO public;
GRANT ALL ON FUNCTION transactions.fn_post_mf_subsequent_order() TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_mf_subsequent_order() TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_mf_subsequent_order() TO cmotsread;

-- DROP FUNCTION transactions.fn_post_otp(_int8, varchar, varchar, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_post_otp(v_trx_id bigint[], v_sms_otp_code character varying DEFAULT NULL::character varying, v_email_otp_code character varying DEFAULT NULL::character varying, v_whatsapp_otp_code character varying DEFAULT NULL::character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying, ac_code character varying, ac_name character varying, email character varying, mobileno character varying, order_expiry timestamp without time zone, client_trx_type character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_otp_id bigint;
DECLARE result_row RECORD;
DECLARE v_order_placed_by character varying;

BEGIN

--v_order_placed_by := (select distinct A.order_placed_by from transactions.mf_order_detail A where A.trx_id=ANY($1));

IF v_inv_action_code = 1 THEN
    SELECT DISTINCT
        CASE 
            WHEN a.order_placed_by IN ('PARTNER', 'RM') THEN 'RM'
            ELSE 'CLIENT'
        END::VARCHAR
    INTO v_order_placed_by
    FROM transactions.mf_order_detail a
    WHERE a.trx_id = ANY(v_trx_id);
ELSE
    SELECT DISTINCT
        CASE 
            WHEN a.order_placed_by IN ('PARTNER', 'RM') THEN 'RM'
            ELSE 'CLIENT'
        END::VARCHAR
    INTO v_order_placed_by
    FROM transactions.mf_order_detail_modification a
    WHERE a.trx_id = ANY(v_trx_id);
END IF;
	
RAISE NOTICE 'Order placed by: %', v_order_placed_by;

IF(v_order_placed_by<>'CLIENT')
THEN

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date
				AND A.consent_status = (SELECT B.consent_status FROM master.dim_consent_status B WHERE B.consent_status_code = 1))
	THEN
		
		FOR result_row IN (SELECT UNNEST(v_trx_id) _id)
		LOOP
			
			SELECT nextval('transactions.otp_otp_id_seq'::regclass) INTO v_otp_id;
				
			INSERT INTO	transactions.otp
			(otp_id, sms_otp_code, email_otp_code, whatsapp_otp_code, opt_sent_datetime, otp_expire_datetime, otp_verfied_flg, client_email_id, client_mobile)
			SELECT v_otp_id, v_sms_otp_code, v_email_otp_code, v_whatsapp_otp_code, NOW() at time zone 'Asia/Kolkata', (NOW() at time zone 'Asia/Kolkata' + Interval '2 Minutes'), 0
			, (SELECT DISTINCT C.client_email_id FROM transactions.order_consent C WHERE C.trx_id = result_row._id AND NOW() at time zone 'Asia/Kolkata' < C.consent_expire_date AND C.otp_id IS NULL)
			, (SELECT DISTINCT C.client_mobile FROM transactions.order_consent C WHERE C.trx_id = result_row._id AND NOW() at time zone 'Asia/Kolkata' < C.consent_expire_date AND C.otp_id IS NULL);
			
			UPDATE transactions.order_consent A SET otp_id = v_otp_id, retry_count = CASE WHEN A.otp_id IS NULL THEN 0 ELSE A.retry_count+1 END
			WHERE A.trx_id = result_row._id AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date
			AND A.consent_status = (SELECT D.consent_status FROM master.dim_consent_status D WHERE D.consent_status_code = 1)
			AND A.inv_action_code = v_inv_action_code;
		
		END LOOP;
		
		IF (v_inv_action_code = 1)
		THEN
		
			RETURN QUERY
			SELECT DISTINCT A.trx_id, 'SUCCESS'::character varying as status, ('OTP genrated successfully')::character varying as remarks
			, B.ac_code, 
			C.acname ac_name, 
	--		C.email, 
	--		C.mobileno, 
			coalesce(B.email,C.email)::character varying as email,
			coalesce(B.mobileno,C.mobileno)::character varying as mobileno,
			A.consent_expire_date as order_expiry, 'Demat'::character varying as client_trx_type
			FROM transactions.order_consent A 
			INNER JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.inv_action_code = 1
			INNER JOIN master.dim_ucc C ON B.ac_code = C.priority_ac_code
			WHERE A.trx_id = ANY($1);
		
		ELSE

			RETURN QUERY
			SELECT DISTINCT A.trx_id, 'SUCCESS'::character varying as status, ('OTP genrated successfully')::character varying as remarks
			, B.ac_code, C.acname ac_name, C.email, C.mobileno, A.consent_expire_date as order_expiry, 'Demat'::character varying as client_trx_type
			FROM transactions.order_consent A 
			INNER JOIN transactions.mf_order_detail_modification B ON A.trx_id = B.trx_id 
			AND A.inv_action_code <> 1
			INNER JOIN master.dim_ucc C ON B.ac_code = C.priority_ac_code
			WHERE A.trx_id = ANY($1);
		
		END IF;
		
	ELSE
	
		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, 'FAILURE'::character varying as status, 'No Valid Consent for provided Transaction'::character varying as remarks
		, null::character varying as ac_code, null::character varying as ac_name, null::character varying as email
		, null::character varying as mobileno, null::timestamp without time zone as order_expiry, 'Demat'::character varying as client_trx_type;
		
	END IF;
END IF;

IF(v_order_placed_by='CLIENT')
THEN

		IF (v_inv_action_code = 1)
		THEN

				SELECT nextval('transactions.otp_otp_id_seq'::regclass) INTO v_otp_id;
				
			INSERT INTO	transactions.otp
			(otp_id, sms_otp_code, email_otp_code, whatsapp_otp_code, opt_sent_datetime, 
			otp_expire_datetime, otp_verfied_flg, client_email_id, client_mobile,trx_id,inv_action_code)
			SELECT v_otp_id, v_sms_otp_code, v_email_otp_code, v_whatsapp_otp_code, NOW() at time zone 'Asia/Kolkata', 
			(NOW() at time zone 'Asia/Kolkata' + Interval '2 Minutes'), 0,
			coalesce(A.email,C.email)::character varying as email,
			coalesce(A.mobileno,C.mobileno)::character varying as mobileno,A.trx_id,v_inv_action_code
			from transactions.mf_order_detail A 
			INNER JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = ANY($1);
		
		
			RETURN QUERY
			SELECT DISTINCT A.trx_id, 'SUCCESS'::character varying as status, ('OTP genrated successfully')::character varying as remarks
			,A.ac_code, 
			C.acname ac_name, 
			coalesce(A.email,C.email)::character varying as email,
			coalesce(A.mobileno,C.mobileno)::character varying as mobileno,
			NULL::timestamp without time zone as order_expiry, A.delivery_mode as client_trx_type
			from transactions.mf_order_detail A 
			INNER JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = ANY($1);
		
		ELSE

			SELECT nextval('transactions.otp_otp_id_seq'::regclass) INTO v_otp_id;
				
			INSERT INTO	transactions.otp
			(otp_id, sms_otp_code, email_otp_code, whatsapp_otp_code, opt_sent_datetime, 
			otp_expire_datetime, otp_verfied_flg, client_email_id, client_mobile,trx_id,inv_action_code)
			SELECT v_otp_id, v_sms_otp_code, v_email_otp_code, v_whatsapp_otp_code, NOW() at time zone 'Asia/Kolkata', 
			(NOW() at time zone 'Asia/Kolkata' + Interval '2 Minutes'), 0,
			coalesce(A.email,C.email)::character varying as email,
			coalesce(A.mobileno,C.mobileno)::character varying as mobileno,A.trx_id,v_inv_action_code
			from transactions.mf_order_detail_modification A 
			INNER JOIN master.dim_ucc C ON A.ac_code = C.priority_ac_code
			WHERE A.trx_id = ANY($1);
		

			RETURN QUERY
			SELECT DISTINCT B.trx_id, 'SUCCESS'::character varying as status, ('OTP genrated successfully')::character varying as remarks
			, B.ac_code, C.acname ac_name, 
		--	C.email, C.mobileno,
			coalesce(A.email,C.email)::character varying as email,
			coalesce(A.mobileno,C.mobileno)::character varying as mobileno,
			NULL::timestamp without time zone as order_expiry, A.delivery_mode as client_trx_type
			FROM transactions.mf_order_detail A 
			INNER JOIN transactions.mf_order_detail_modification B ON A.trx_id = B.org_trx_id 
			AND B.inv_action_code <> 1
			INNER JOIN master.dim_ucc C ON B.ac_code = C.priority_ac_code
			WHERE B.trx_id = ANY($1);
		
		END IF;
		
	ELSE
	
		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, 'FAILURE'::character varying as status, 'No Valid Consent for provided Transaction'::character varying as remarks
		, null::character varying as ac_code, null::character varying as ac_name, null::character varying as email
		, null::character varying as mobileno, null::timestamp without time zone as order_expiry, 'Physical'::character varying as client_trx_type;
		
	
END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_otp(_int8, varchar, varchar, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_otp(_int8, varchar, varchar, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_post_otp(_int8, varchar, varchar, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_otp(_int8, varchar, varchar, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_otp(_int8, varchar, varchar, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_post_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_post_otp_bkp_09may2025(v_trx_id bigint[], v_sms_otp_code character varying DEFAULT NULL::character varying, v_email_otp_code character varying DEFAULT NULL::character varying, v_whatsapp_otp_code character varying DEFAULT NULL::character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying, ac_code character varying, ac_name character varying, email character varying, mobileno character varying, order_expiry timestamp without time zone, client_trx_type character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_otp_id bigint;
DECLARE result_row RECORD;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code AND NOW() < A.consent_expire_date
				AND A.consent_status = (SELECT B.consent_status FROM master.dim_consent_status B WHERE B.consent_status_code = 1))
	THEN
		
		FOR result_row IN (SELECT UNNEST(v_trx_id) _id)
		LOOP
			
			SELECT nextval('transactions.otp_otp_id_seq'::regclass) INTO v_otp_id;
				
			INSERT INTO	transactions.otp
			(otp_id, sms_otp_code, email_otp_code, whatsapp_otp_code, opt_sent_datetime, otp_expire_datetime, otp_verfied_flg, client_email_id, client_mobile)
			SELECT v_otp_id, v_sms_otp_code, v_email_otp_code, v_whatsapp_otp_code, NOW(), NOW() + Interval '2 Minutes', 0
			, (SELECT DISTINCT C.client_email_id FROM transactions.order_consent C WHERE C.trx_id = result_row._id AND NOW() < C.consent_expire_date AND C.otp_id IS NULL)
			, (SELECT DISTINCT C.client_mobile FROM transactions.order_consent C WHERE C.trx_id = result_row._id AND NOW() < C.consent_expire_date AND C.otp_id IS NULL);
			
			UPDATE transactions.order_consent A SET otp_id = v_otp_id, retry_count = CASE WHEN A.otp_id IS NULL THEN 0 ELSE A.retry_count+1 END
			WHERE A.trx_id = result_row._id AND NOW() < A.consent_expire_date
			AND A.consent_status = (SELECT D.consent_status FROM master.dim_consent_status D WHERE D.consent_status_code = 1)
			AND A.inv_action_code = v_inv_action_code;
		
		END LOOP;
		
		IF (v_inv_action_code = 1)
		THEN
		
			RETURN QUERY
			SELECT DISTINCT A.trx_id, 'SUCCESS'::character varying as status, ('OTP genrated successfully')::character varying as remarks
			, B.ac_code, C.acname ac_name, C.email, C.mobileno, A.consent_expire_date as order_expiry, 'Demat'::character varying as client_trx_type
			FROM transactions.order_consent A 
			INNER JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.inv_action_code = 1
			INNER JOIN master.dim_ucc C ON B.ac_code = C.priority_ac_code
			WHERE A.trx_id = ANY($1);
		
		ELSE

			RETURN QUERY
			SELECT DISTINCT A.trx_id, 'SUCCESS'::character varying as status, ('OTP genrated successfully')::character varying as remarks
			, B.ac_code, C.acname ac_name, C.email, C.mobileno, A.consent_expire_date as order_expiry, 'Demat'::character varying as client_trx_type
			FROM transactions.order_consent A 
			INNER JOIN transactions.mf_order_detail_modification B ON A.trx_id = B.trx_id AND A.inv_action_code <> 1
			INNER JOIN master.dim_ucc C ON B.ac_code = C.priority_ac_code
			WHERE A.trx_id = ANY($1);
		
		END IF;
		
	ELSE
	
		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, 'FAILURE'::character varying as status, 'No Valid Consent for provided Transaction'::character varying as remarks
		, null::character varying as ac_code, null::character varying as ac_name, null::character varying as email
		, null::character varying as mobileno, null::timestamp without time zone as order_expiry, 'Demat'::character varying as client_trx_type;
		
	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_post_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_post_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_post_otp_bkp_23jul2025(v_trx_id bigint[], v_sms_otp_code character varying DEFAULT NULL::character varying, v_email_otp_code character varying DEFAULT NULL::character varying, v_whatsapp_otp_code character varying DEFAULT NULL::character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, status character varying, remarks character varying, ac_code character varying, ac_name character varying, email character varying, mobileno character varying, order_expiry timestamp without time zone, client_trx_type character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_otp_id bigint;
DECLARE result_row RECORD;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code AND NOW() < A.consent_expire_date
				AND A.consent_status = (SELECT B.consent_status FROM master.dim_consent_status B WHERE B.consent_status_code = 1))
	THEN
		
		FOR result_row IN (SELECT UNNEST(v_trx_id) _id)
		LOOP
			
			SELECT nextval('transactions.otp_otp_id_seq'::regclass) INTO v_otp_id;
				
			INSERT INTO	transactions.otp
			(otp_id, sms_otp_code, email_otp_code, whatsapp_otp_code, opt_sent_datetime, otp_expire_datetime, otp_verfied_flg, client_email_id, client_mobile)
			SELECT v_otp_id, v_sms_otp_code, v_email_otp_code, v_whatsapp_otp_code, NOW(), NOW() + Interval '2 Minutes', 0
			, (SELECT DISTINCT C.client_email_id FROM transactions.order_consent C WHERE C.trx_id = result_row._id AND NOW() < C.consent_expire_date AND C.otp_id IS NULL)
			, (SELECT DISTINCT C.client_mobile FROM transactions.order_consent C WHERE C.trx_id = result_row._id AND NOW() < C.consent_expire_date AND C.otp_id IS NULL);
			
			UPDATE transactions.order_consent A SET otp_id = v_otp_id, retry_count = CASE WHEN A.otp_id IS NULL THEN 0 ELSE A.retry_count+1 END
			WHERE A.trx_id = result_row._id AND NOW() < A.consent_expire_date
			AND A.consent_status = (SELECT D.consent_status FROM master.dim_consent_status D WHERE D.consent_status_code = 1)
			AND A.inv_action_code = v_inv_action_code;
		
		END LOOP;
		
		IF (v_inv_action_code = 1)
		THEN
		
			RETURN QUERY
			SELECT DISTINCT A.trx_id, 'SUCCESS'::character varying as status, ('OTP genrated successfully')::character varying as remarks
			, B.ac_code, C.acname ac_name, 
	--		C.email, 
	--		C.mobileno, 
			coalesce(B.email,C.email)::character varying as email,
			coalesce(B.mobileno,C.mobileno)::character varying as mobileno,
			A.consent_expire_date as order_expiry, 'Demat'::character varying as client_trx_type
			FROM transactions.order_consent A 
			INNER JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.inv_action_code = 1
			INNER JOIN master.dim_ucc C ON B.ac_code = C.priority_ac_code
			WHERE A.trx_id = ANY($1);
		
		ELSE

			RETURN QUERY
			SELECT DISTINCT A.trx_id, 'SUCCESS'::character varying as status, ('OTP genrated successfully')::character varying as remarks
			, B.ac_code, C.acname ac_name, C.email, C.mobileno, A.consent_expire_date as order_expiry,
			'Demat'::character varying as client_trx_type
			FROM transactions.order_consent A 
			INNER JOIN transactions.mf_order_detail_modification B ON A.trx_id = B.trx_id 
			AND A.inv_action_code <> 1
			INNER JOIN master.dim_ucc C ON B.ac_code = C.priority_ac_code
			WHERE A.trx_id = ANY($1);
		
		END IF;
		
	ELSE
	
		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, 'FAILURE'::character varying as status, 'No Valid Consent for provided Transaction'::character varying as remarks
		, null::character varying as ac_code, null::character varying as ac_name, null::character varying as email
		, null::character varying as mobileno, null::timestamp without time zone as order_expiry, 'Demat'::character varying as client_trx_type;
		
	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_post_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_post_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_post_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_post_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_reject_mf_consent(_int8, int4, int4);

CREATE OR REPLACE FUNCTION transactions.fn_reject_mf_consent(v_trx_id bigint[], v_category_code integer, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, consent_id character varying, remarks character varying, order_type character varying, trx_type character varying, trx_amt numeric, frequency character varying, isinname character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, product_name character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_consent_id bigint;
DECLARE result_row RECORD;
DECLARE v_consent_status character varying;
DECLARE v_order_placed_by character varying;

BEGIN

IF v_inv_action_code = 1 THEN
    SELECT DISTINCT
        CASE 
            WHEN a.order_placed_by IN ('PARTNER', 'RM') THEN 'RM'
            ELSE 'CLIENT'
        END::VARCHAR
    INTO v_order_placed_by
    FROM transactions.mf_order_detail a
    WHERE a.trx_id = ANY(v_trx_id);
ELSE
    SELECT DISTINCT
        CASE 
            WHEN a.order_placed_by IN ('PARTNER', 'RM') THEN 'RM'
            ELSE 'CLIENT'
        END::VARCHAR
    INTO v_order_placed_by
    FROM transactions.mf_order_detail_modification a
    WHERE a.trx_id = ANY(v_trx_id);
END IF;

RAISE NOTICE 'Order placed by: %', v_order_placed_by;

SELECT A.consent_status INTO v_consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 3;

IF v_order_placed_by<>'CLIENT'
THEN
	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code AND A.inv_action_code = v_inv_action_code
			  AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date AND UPPER(A.consent_status) <> UPPER(v_consent_status) AND UPPER(A.consent_status) <> 'CONSENT APPROVED')
	THEN
		UPDATE transactions.order_consent A 
		SET consent_status = v_consent_status, 
		consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata'
		WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code 
		AND A.inv_action_code = v_inv_action_code 
		AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date 
		AND UPPER(A.consent_status) <> 'CONSENT REJECTED';

		IF(v_inv_action_code = 1)
		THEN
			----------Updating Consent Status into Main transaction Table----------
			UPDATE transactions.mf_order_detail A 
			SET consent_status = v_consent_status
			, consent_status_code = (SELECT A.consent_status_code FROM master.dim_consent_status A
									 WHERE A.category_code = '261' AND UPPER(A.consent_status) = UPPER(v_consent_status))
			, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata', 
			modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) 
			AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and consent_status_code=1;

			UPDATE transactions.mf_order_detail A SET
			final_status = 'Consent Rejected',
			trx_final_status_code = 6,
			trx_status='Order Rejected',
			trx_status_code = 8
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			-- /* Final status is rejected and type is transaction
			UPDATE transactions.mf_order_detail A SET
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and trx_final_status_code=6 and inv_action_code=1 
			and trx_type_code<>4;

			UPDATE transactions.mf_order_detail A SET
			inv_plan_status_code = 4,
			inv_plan_status = 'Active'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and trx_final_status_code=6 and inv_action_code<>1
			and trx_type_code<>4;

			update transactions.mf_order_summary a
			set
			final_status = B.final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status,
			trx_type_code=b.trx_type_code,
			trx_status_Code=b.trx_status_Code,
			trx_status=b.trx_status
			from transactions.mf_order_detail b
			where a.trx_id = B.trx_id
			and A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			----------Inserting Data into transaction History Table----------
		
			UPDATE transactions.mf_order_detail_history A SET valid_to = NOW() at time zone 'Asia/Kolkata', is_active = false
			WHERE a.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.is_active = true;

			INSERT INTO transactions.mf_order_detail_history
			(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
			 , vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
			,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
			SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
			, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, 
			NOW() at time zone 'Asia/Kolkata', true,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
			 FROM transactions.mf_order_detail A
			 WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

			RETURN QUERY
			SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
			, ('Consent Rejected sucessfully for trx_id ')::character varying as remarks
			, B.order_type, B.trx_type, B.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
			, D.ucccode, B.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, cat.category_name as product_name 
			FROM transactions.order_consent A
			INNER JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id
			LEFT JOIN transactions.mf_order_summary E ON A.trx_id = E.trx_id
			inner JOIN master.dim_ucc D ON B.ac_code = D.priority_ac_code
			inner JOIN master.dim_mf_isin mst ON B.isincode = mst.isincode
			inner JOIN master.mv_category cat ON A.category_code = cat.category_code
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.category_code = v_category_code
			GROUP BY A.trx_id, ('Consent Rejected sucessfully for trx_id ')::character varying, B.order_type, B.trx_type, B.trx_amt, E.frequency, mst.isinname, D.ucccode, B.ac_code, D.acname
			, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name;
			
		ELSE
		
			----------Updating Modification Stage Table----------

			UPDATE transactions.mf_order_detail_modification A SET
			consent_status = v_consent_status
			, consent_status_code = (SELECT A.consent_status_code FROM master.dim_consent_status A
									 WHERE A.category_code = '261' AND UPPER(A.consent_status) = UPPER(v_consent_status))
			, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata'
			, modified_date = NOW() at time zone 'Asia/Kolkata',
			final_status = 'Consent Rejected',
			trx_final_status_code = 6,
			trx_status='Order Rejected',
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected',
			trx_status_code = 8
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1);

			UPDATE transactions.mf_order_summary A SET remarks = NULL
			WHERE A.trx_id IN (SELECT B.org_trx_id FROM transactions.mf_order_detail_modification B WHERE B.trx_id IN
								(SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
							  );

			RETURN QUERY
			SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
			, ('Consent Rejected sucessfully for trx_id ')::character varying as remarks
			, UPPER(st.inv_action)::character varying as order_type, 
			case when upper(st.trx_type) in ('SIP','XSIP') then 'XSIP' else st.trx_type end trx_type,
			st.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
			, D.ucccode, st.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, cat.category_name as product_name 
			FROM transactions.order_consent A
			INNER JOIN transactions.mf_order_detail_modification st ON A.trx_id = st.trx_id
			LEFT JOIN transactions.mf_order_summary E ON st.org_trx_id = E.trx_id
			inner JOIN master.dim_ucc D ON st.ac_code = D.priority_ac_code
			inner JOIN master.dim_mf_isin mst ON st.isincode = mst.isincode
			inner JOIN master.mv_category cat ON A.category_code = cat.category_code
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
			AND A.category_code = v_category_code
			GROUP BY A.trx_id, ('Consent Rejected sucessfully for trx_id ')::character varying, UPPER(st.inv_action)::character varying, st.trx_type, st.trx_amt, E.frequency, mst.isinname, D.ucccode, st.ac_code, D.acname
			, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name;

		END IF;
		
	ELSE

		RETURN QUERY
		SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
		, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying as remarks
		, B.order_type, 
		case when upper(B.trx_type) in ('SIP','XSIP') then 'XSIP' else B.trx_type end trx_type,
		B.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
		, D.ucccode, B.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
		, cat.category_name as product_name FROM transactions.order_consent A
		INNER JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id
		LEFT JOIN transactions.mf_order_summary E ON A.trx_id = E.trx_id
		inner JOIN master.dim_ucc D ON B.ac_code = D.priority_ac_code
		inner JOIN master.dim_mf_isin mst ON B.isincode = mst.isincode
		inner JOIN master.mv_category cat ON A.category_code = cat.category_code
		WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code =1)
		AND A.category_code = v_category_code
		GROUP BY A.trx_id, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying, B.order_type, B.trx_type, B.trx_amt, E.frequency, mst.isinname, D.ucccode, B.ac_code, D.acname
		, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name
		UNION
		SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
		, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying as remarks
		, UPPER(st.inv_action)::character varying as order_type, 
		case when upper(st.trx_type) in ('SIP','XSIP') then 'XSIP' else st.trx_type end trx_type,
		st.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
		, D.ucccode, st.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
		, cat.category_name as product_name FROM transactions.order_consent A
		INNER JOIN transactions.mf_order_detail_modification st ON A.trx_id = st.trx_id
		LEFT JOIN transactions.mf_order_summary E ON A.trx_id = E.trx_id
		inner JOIN master.dim_ucc D ON st.ac_code = D.priority_ac_code
		inner JOIN master.dim_mf_isin mst ON st.isincode = mst.isincode
		inner JOIN master.mv_category cat ON A.category_code = cat.category_code
		WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
		AND A.category_code = v_category_code
		GROUP BY A.trx_id, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying, UPPER(st.inv_action)::character varying, st.trx_type, st.trx_amt, E.frequency, mst.isinname, D.ucccode, st.ac_code, D.acname
		, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name;
	END IF;

ELSIF v_order_placed_by='CLIENT'
THEN
	IF v_inv_action_code=1
	THEN
		----------Updating Consent Status into Main transaction Table----------
			UPDATE transactions.mf_order_detail A 
			SET consent_status = v_consent_status
			, consent_status_code = (SELECT A.consent_status_code FROM master.dim_consent_status A
									 WHERE A.category_code = '261' AND UPPER(A.consent_status) = UPPER(v_consent_status))
			,modified_date = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and consent_status_code=1;

			UPDATE transactions.mf_order_detail A SET
			final_status = 'Consent Rejected',
			trx_final_status_code = 6,
			trx_status='Order Rejected',
			trx_status_code = 8
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			-- /* Final status is rejected and type is transaction
			UPDATE transactions.mf_order_detail A SET
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and trx_final_status_code=6 and inv_action_code=1 
			and trx_type_code<>4;

			UPDATE transactions.mf_order_detail A SET
			inv_plan_status_code = 4,
			inv_plan_status = 'Active'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and trx_final_status_code=6 and inv_action_code<>1
			and trx_type_code<>4;

			update transactions.mf_order_summary a
			set
			final_status = B.final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status,
			trx_type_code=b.trx_type_code,
			trx_status_Code=b.trx_status_Code,
			trx_status=b.trx_status
			from transactions.mf_order_detail b
			where a.trx_id = B.trx_id
			and A.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			----------Inserting Data into transaction History Table----------
			UPDATE transactions.mf_order_detail_history A 
			SET valid_to = NOW() at time zone 'Asia/Kolkata', is_active = false
			WHERE a.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.is_active = true;

			INSERT INTO transactions.mf_order_detail_history
			(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
			 , vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
			,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
			SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
			, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, 
			NOW() at time zone 'Asia/Kolkata', true,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
			 FROM transactions.mf_order_detail A
			 WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

			RETURN QUERY
			SELECT DISTINCT A.trx_id, ''::character varying as consent_id
			, ('Consent Rejected sucessfully for trx_id ')::character varying as remarks
			, B.order_type, B.trx_type, B.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
			, D.ucccode, B.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, cat.category_name as product_name 
			FROM transactions.otp A
			inner join transactions.mf_order_detail B on A.trx_id = B.trx_id
			left JOIN transactions.mf_order_summary E ON B.trx_id = E.trx_id
			inner JOIN master.dim_ucc D ON B.ac_code = D.priority_ac_code
			inner JOIN master.dim_mf_isin mst ON B.isincode = mst.isincode
			inner JOIN master.mv_category cat ON A.category_code = cat.category_code
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.category_code = v_category_code;
	ELSE
			----------Updating Modification Stage Table----------
			UPDATE transactions.mf_order_detail_modification A SET
			consent_status = v_consent_status
			, consent_status_code = (SELECT A.consent_status_code FROM master.dim_consent_status A
									 WHERE A.category_code = '261' AND UPPER(A.consent_status) = UPPER(v_consent_status))
			, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata', 
			modified_date = NOW() at time zone 'Asia/Kolkata',
			final_status = 'Consent Rejected',
			trx_final_status_code = 6,
			trx_status='Order Rejected',
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected',
			trx_status_code = 8
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1);

			UPDATE transactions.mf_order_summary A SET remarks = NULL
			WHERE A.trx_id IN (SELECT B.org_trx_id FROM transactions.mf_order_detail_modification B 
								WHERE B.trx_id IN (SELECT C.trx_id FROM transactions.otp C 
													WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code 
													AND C.inv_action_code <> 1)
							  );

			RETURN QUERY
			SELECT DISTINCT A.trx_id,''::character varying as consent_id
			, ('Consent Rejected sucessfully for trx_id ')::character varying as remarks
			, UPPER(st.inv_action)::character varying as order_type, 
			case when upper(st.trx_type) in ('SIP','XSIP') then 'XSIP' else st.trx_type end trx_type,
			st.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
			, D.ucccode, st.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
			, CASE WHEN COALESCE(D.partner_code,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, cat.category_name as product_name 
			FROM transactions.otp A
			INNER JOIN transactions.mf_order_detail_modification st ON A.trx_id = st.trx_id
			LEFT JOIN transactions.mf_order_summary E ON st.org_trx_id = E.trx_id
			inner JOIN master.dim_ucc D ON st.ac_code = D.priority_ac_code
			inner JOIN master.dim_mf_isin mst ON st.isincode = mst.isincode
			inner JOIN master.mv_category cat ON A.category_code = cat.category_code
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
			AND A.category_code = v_category_code;
	END IF;
END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_reject_mf_consent(_int8, int4, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent(_int8, int4, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent(_int8, int4, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent(_int8, int4, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent(_int8, int4, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_reject_mf_consent_bkp_09may2025(_int8, int4, int4);

CREATE OR REPLACE FUNCTION transactions.fn_reject_mf_consent_bkp_09may2025(v_trx_id bigint[], v_category_code integer, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, consent_id character varying, remarks character varying, order_type character varying, trx_type character varying, trx_amt numeric, frequency character varying, isinname character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, product_name character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_consent_id bigint;
DECLARE result_row RECORD;
DECLARE v_consent_status character varying;

BEGIN

SELECT A.consent_status INTO v_consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 3;

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code AND A.inv_action_code = v_inv_action_code
			  AND NOW() < A.consent_expire_date AND UPPER(A.consent_status) <> UPPER(v_consent_status) AND UPPER(A.consent_status) <> 'CONSENT APPROVED')
	THEN
		
		UPDATE transactions.order_consent A 
		SET consent_status = v_consent_status, consent_approval_reject_datetime = NOW()
		WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code 
		AND A.inv_action_code = v_inv_action_code AND NOW() < A.consent_expire_date 
		AND UPPER(A.consent_status) <> 'CONSENT REJECTED';

		IF(v_inv_action_code = 1)
		THEN
		
			----------Updating Consent Status into Main transaction Table----------
			UPDATE transactions.mf_order_detail A 
			SET consent_status = v_consent_status
			, consent_status_code = (SELECT A.consent_status_code FROM master.dim_consent_status A
									 WHERE A.category_code = '261' AND UPPER(A.consent_status) = UPPER(v_consent_status))
			, consent_approval_reject_datetime = NOW(), modified_date = NOW()
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and consent_status_code=1;

			UPDATE transactions.mf_order_detail A SET
			final_status = 'Consent Rejected',
			trx_final_status_code = 6,
			trx_status='Order Rejected',
			trx_status_code = 8
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			-- /* Final status is rejected and type is transaction
			UPDATE transactions.mf_order_detail A SET
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and trx_final_status_code=6 and inv_action_code=1 
			and trx_type_code<>4;

			UPDATE transactions.mf_order_detail A SET
			inv_plan_status_code = 4,
			inv_plan_status = 'Active'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and trx_final_status_code=6 and inv_action_code<>1
			and trx_type_code<>4;

			update transactions.mf_order_summary a
			set
			final_status = B.final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status,
			trx_type_code=b.trx_type_code,
			trx_status_Code=b.trx_status_Code,
			trx_status=b.trx_status
			from transactions.mf_order_detail b
			where a.trx_id = B.trx_id
			and A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			----------Inserting Data into transaction History Table----------
			
			UPDATE transactions.mf_order_detail_history A SET valid_to = NOW(), is_active = false
			WHERE a.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.is_active = true;

			INSERT INTO transactions.mf_order_detail_history
			(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
			 , vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
			,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
			SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
			, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
			,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
			 FROM transactions.mf_order_detail A
			 WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

			----------Inserting Data into Summary transaction History Table----------
			
			UPDATE transactions.mf_order_summary_history A SET valid_to = NOW(), is_active = false
			WHERE a.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.is_active = true;
			
			INSERT INTO transactions.mf_order_summary_history
			(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
			, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
			, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
			, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
			SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
			, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
			, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
			, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
			FROM transactions.mf_order_summary A
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
			
			RETURN QUERY
			SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
			, ('Consent Rejected sucessfully for trx_id ')::character varying as remarks
			, B.order_type, B.trx_type, B.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
			, D.ucccode, B.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, cat.category_name as product_name FROM transactions.order_consent A
			INNER JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id
			LEFT JOIN transactions.mf_order_summary E ON A.trx_id = E.trx_id
			inner JOIN master.dim_ucc D ON B.ac_code = D.priority_ac_code
			inner JOIN master.dim_mf_isin mst ON B.isincode = mst.isincode
			inner JOIN master.mv_category cat ON A.category_code = cat.category_code
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.category_code = v_category_code
			GROUP BY A.trx_id, ('Consent Rejected sucessfully for trx_id ')::character varying, B.order_type, B.trx_type, B.trx_amt, E.frequency, mst.isinname, D.ucccode, B.ac_code, D.acname
			, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name;
			
		ELSE
		
			----------Updating Modification Stage Table----------

			UPDATE transactions.mf_order_detail_modification A SET
			consent_status = v_consent_status
			, consent_status_code = (SELECT A.consent_status_code FROM master.dim_consent_status A
									 WHERE A.category_code = '261' AND UPPER(A.consent_status) = UPPER(v_consent_status))
			, consent_approval_reject_datetime = NOW(), modified_date = NOW(),
			final_status = 'Consent Rejected',
			trx_final_status_code = 6,
			trx_status='Order Rejected',
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected',
			trx_status_code = 8
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1);

			UPDATE transactions.mf_order_summary A SET remarks = NULL
			WHERE A.trx_id IN (SELECT B.org_trx_id FROM transactions.mf_order_detail_modification B WHERE B.trx_id IN
								(SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
							  );

			RETURN QUERY
			SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
			, ('Consent Rejected sucessfully for trx_id ')::character varying as remarks
			, UPPER(st.inv_action)::character varying as order_type, st.trx_type, st.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
			, D.ucccode, st.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, cat.category_name as product_name FROM transactions.order_consent A
			INNER JOIN transactions.mf_order_detail_modification st ON A.trx_id = st.trx_id
			LEFT JOIN transactions.mf_order_summary E ON st.org_trx_id = E.trx_id
			inner JOIN master.dim_ucc D ON st.ac_code = D.priority_ac_code
			inner JOIN master.dim_mf_isin mst ON st.isincode = mst.isincode
			inner JOIN master.mv_category cat ON A.category_code = cat.category_code
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
			AND A.category_code = v_category_code
			GROUP BY A.trx_id, ('Consent Rejected sucessfully for trx_id ')::character varying, UPPER(st.inv_action)::character varying, st.trx_type, st.trx_amt, E.frequency, mst.isinname, D.ucccode, st.ac_code, D.acname
			, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name;

		END IF;
		
	ELSE

		RETURN QUERY
		SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
		, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying as remarks
		, B.order_type, B.trx_type, B.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
		, D.ucccode, B.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
		, cat.category_name as product_name FROM transactions.order_consent A
		INNER JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id
		LEFT JOIN transactions.mf_order_summary E ON A.trx_id = E.trx_id
		inner JOIN master.dim_ucc D ON B.ac_code = D.priority_ac_code
		inner JOIN master.dim_mf_isin mst ON B.isincode = mst.isincode
		inner JOIN master.mv_category cat ON A.category_code = cat.category_code
		WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code =1)
		AND A.category_code = v_category_code
		GROUP BY A.trx_id, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying, B.order_type, B.trx_type, B.trx_amt, E.frequency, mst.isinname, D.ucccode, B.ac_code, D.acname
		, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name
		UNION
		SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
		, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying as remarks
		, UPPER(st.inv_action)::character varying as order_type, st.trx_type, st.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
		, D.ucccode, st.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
		, cat.category_name as product_name FROM transactions.order_consent A
		INNER JOIN transactions.mf_order_detail_modification st ON A.trx_id = st.trx_id
		LEFT JOIN transactions.mf_order_summary E ON A.trx_id = E.trx_id
		inner JOIN master.dim_ucc D ON st.ac_code = D.priority_ac_code
		inner JOIN master.dim_mf_isin mst ON st.isincode = mst.isincode
		inner JOIN master.mv_category cat ON A.category_code = cat.category_code
		WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
		AND A.category_code = v_category_code
		GROUP BY A.trx_id, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying, UPPER(st.inv_action)::character varying, st.trx_type, st.trx_amt, E.frequency, mst.isinname, D.ucccode, st.ac_code, D.acname
		, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name;

	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_reject_mf_consent_bkp_09may2025(_int8, int4, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent_bkp_09may2025(_int8, int4, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent_bkp_09may2025(_int8, int4, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent_bkp_09may2025(_int8, int4, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent_bkp_09may2025(_int8, int4, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_reject_mf_consent_bkp_23jul2025(_int8, int4, int4);

CREATE OR REPLACE FUNCTION transactions.fn_reject_mf_consent_bkp_23jul2025(v_trx_id bigint[], v_category_code integer, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, consent_id character varying, remarks character varying, order_type character varying, trx_type character varying, trx_amt numeric, frequency character varying, isinname character varying, ucccode character varying, ac_code character varying, ac_name character varying, client_mobile character varying, client_email character varying, rm_name character varying, rm_mobile character varying, rm_email character varying, rm_partner_flag character varying, product_name character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE v_consent_id bigint;
DECLARE result_row RECORD;
DECLARE v_consent_status character varying;

BEGIN

SELECT A.consent_status INTO v_consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 3;

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code AND A.inv_action_code = v_inv_action_code
			  AND NOW() < A.consent_expire_date AND UPPER(A.consent_status) <> UPPER(v_consent_status) AND UPPER(A.consent_status) <> 'CONSENT APPROVED')
	THEN
		
		UPDATE transactions.order_consent A 
		SET consent_status = v_consent_status, consent_approval_reject_datetime = NOW()
		WHERE A.trx_id = ANY($1) AND A.category_code = v_category_code 
		AND A.inv_action_code = v_inv_action_code AND NOW() < A.consent_expire_date 
		AND UPPER(A.consent_status) <> 'CONSENT REJECTED';

		IF(v_inv_action_code = 1)
		THEN
		
			----------Updating Consent Status into Main transaction Table----------
			UPDATE transactions.mf_order_detail A 
			SET consent_status = v_consent_status
			, consent_status_code = (SELECT A.consent_status_code FROM master.dim_consent_status A
									 WHERE A.category_code = '261' AND UPPER(A.consent_status) = UPPER(v_consent_status))
			, consent_approval_reject_datetime = NOW(), modified_date = NOW()
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and consent_status_code=1;

			UPDATE transactions.mf_order_detail A SET
			final_status = 'Consent Rejected',
			trx_final_status_code = 6,
			trx_status='Order Rejected',
			trx_status_code = 8
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			-- /* Final status is rejected and type is transaction
			UPDATE transactions.mf_order_detail A SET
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and trx_final_status_code=6 and inv_action_code=1 
			and trx_type_code<>4;

			UPDATE transactions.mf_order_detail A SET
			inv_plan_status_code = 4,
			inv_plan_status = 'Active'
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			and trx_final_status_code=6 and inv_action_code<>1
			and trx_type_code<>4;

			update transactions.mf_order_summary a
			set
			final_status = B.final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status,
			trx_type_code=b.trx_type_code,
			trx_status_Code=b.trx_status_Code,
			trx_status=b.trx_status
			from transactions.mf_order_detail b
			where a.trx_id = B.trx_id
			and A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			----------Inserting Data into transaction History Table----------
			
			UPDATE transactions.mf_order_detail_history A SET valid_to = NOW(), is_active = false
			WHERE a.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.is_active = true;

			INSERT INTO transactions.mf_order_detail_history
			(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
			 , vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
			,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
			SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
			, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
			,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
			 FROM transactions.mf_order_detail A
			 WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

			----------Inserting Data into Summary transaction History Table----------
			
			UPDATE transactions.mf_order_summary_history A SET valid_to = NOW(), is_active = false
			WHERE a.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.is_active = true;
			
			INSERT INTO transactions.mf_order_summary_history
			(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
			, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
			, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
			, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
			SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
			, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
			, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
			, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
			FROM transactions.mf_order_summary A
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1);

			UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
			
			RETURN QUERY
			SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
			, ('Consent Rejected sucessfully for trx_id ')::character varying as remarks
			, B.order_type, B.trx_type, B.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
			, D.ucccode, B.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, cat.category_name as product_name FROM transactions.order_consent A
			INNER JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id
			LEFT JOIN transactions.mf_order_summary E ON A.trx_id = E.trx_id
			inner JOIN master.dim_ucc D ON B.ac_code = D.priority_ac_code
			inner JOIN master.dim_mf_isin mst ON B.isincode = mst.isincode
			inner JOIN master.mv_category cat ON A.category_code = cat.category_code
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code = 1)
			AND A.category_code = v_category_code
			GROUP BY A.trx_id, ('Consent Rejected sucessfully for trx_id ')::character varying, B.order_type, B.trx_type, B.trx_amt, E.frequency, mst.isinname, D.ucccode, B.ac_code, D.acname
			, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name;
			
		ELSE
		
			----------Updating Modification Stage Table----------

			UPDATE transactions.mf_order_detail_modification A SET
			consent_status = v_consent_status
			, consent_status_code = (SELECT A.consent_status_code FROM master.dim_consent_status A
									 WHERE A.category_code = '261' AND UPPER(A.consent_status) = UPPER(v_consent_status))
			, consent_approval_reject_datetime = NOW(), modified_date = NOW(),
			final_status = 'Consent Rejected',
			trx_final_status_code = 6,
			trx_status='Order Rejected',
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected',
			trx_status_code = 8
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1);

			UPDATE transactions.mf_order_summary A SET remarks = NULL
			WHERE A.trx_id IN (SELECT B.org_trx_id FROM transactions.mf_order_detail_modification B WHERE B.trx_id IN
								(SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
							  );

			RETURN QUERY
			SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
			, ('Consent Rejected sucessfully for trx_id ')::character varying as remarks
			, UPPER(st.inv_action)::character varying as order_type, 
			case when upper(st.trx_type) in ('SIP','XSIP') then 'XSIP' else st.trx_type end trx_type,
			st.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
			, D.ucccode, st.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
			, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
			, cat.category_name as product_name FROM transactions.order_consent A
			INNER JOIN transactions.mf_order_detail_modification st ON A.trx_id = st.trx_id
			LEFT JOIN transactions.mf_order_summary E ON st.org_trx_id = E.trx_id
			inner JOIN master.dim_ucc D ON st.ac_code = D.priority_ac_code
			inner JOIN master.dim_mf_isin mst ON st.isincode = mst.isincode
			inner JOIN master.mv_category cat ON A.category_code = cat.category_code
			WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
			AND A.category_code = v_category_code
			GROUP BY A.trx_id, ('Consent Rejected sucessfully for trx_id ')::character varying, UPPER(st.inv_action)::character varying, st.trx_type, st.trx_amt, E.frequency, mst.isinname, D.ucccode, st.ac_code, D.acname
			, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name;

		END IF;
		
	ELSE

		RETURN QUERY
		SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
		, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying as remarks
		, B.order_type, 
		case when upper(B.trx_type) in ('SIP','XSIP') then 'XSIP' else B.trx_type end trx_type,
		B.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
		, D.ucccode, B.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
		, cat.category_name as product_name FROM transactions.order_consent A
		INNER JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id
		LEFT JOIN transactions.mf_order_summary E ON A.trx_id = E.trx_id
		inner JOIN master.dim_ucc D ON B.ac_code = D.priority_ac_code
		inner JOIN master.dim_mf_isin mst ON B.isincode = mst.isincode
		inner JOIN master.mv_category cat ON A.category_code = cat.category_code
		WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code =1)
		AND A.category_code = v_category_code
		GROUP BY A.trx_id, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying, B.order_type, B.trx_type, B.trx_amt, E.frequency, mst.isinname, D.ucccode, B.ac_code, D.acname
		, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name
		UNION
		SELECT DISTINCT A.trx_id, STRING_AGG(A.consent_id, ',')::character varying as consent_id
		, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying as remarks
		, UPPER(st.inv_action)::character varying as order_type, 
		case when upper(st.trx_type) in ('SIP','XSIP') then 'XSIP' else st.trx_type end trx_type,
		st.trx_amt, E.frequency, INITCAP(mst.isinname)::character varying isinname
		, D.ucccode, st.ac_code, D.acname as ac_name, D.mobileno as client_mobile, D.email as client_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_name ELSE D.client_owner_name END as rm_name
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_mobile ELSE D.rm_mobile END as rm_mobile
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN D.partner_email ELSE D.rm_email END as rm_email
		, CASE WHEN COALESCE(D.partnerowner,'') <> '' THEN 'PARTNER' ELSE 'RM' END::character varying as rm_partner_flag
		, cat.category_name as product_name FROM transactions.order_consent A
		INNER JOIN transactions.mf_order_detail_modification st ON A.trx_id = st.trx_id
		LEFT JOIN transactions.mf_order_summary E ON A.trx_id = E.trx_id
		inner JOIN master.dim_ucc D ON st.ac_code = D.priority_ac_code
		inner JOIN master.dim_mf_isin mst ON st.isincode = mst.isincode
		inner JOIN master.mv_category cat ON A.category_code = cat.category_code
		WHERE A.trx_id IN (SELECT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.category_code = v_category_code AND C.inv_action_code <> 1)
		AND A.category_code = v_category_code
		GROUP BY A.trx_id, ('Consent status cannot be Rejected as the current status is "'||A.consent_status||'"')::character varying, UPPER(st.inv_action)::character varying, st.trx_type, st.trx_amt, E.frequency, mst.isinname, D.ucccode, st.ac_code, D.acname
		, D.mobileno, D.email, D.partnerowner, D.partner_name, D.client_owner_name, D.partner_mobile, D.rm_mobile, D.partner_email, D.rm_email, cat.category_name;

	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_reject_mf_consent_bkp_23jul2025(_int8, int4, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent_bkp_23jul2025(_int8, int4, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent_bkp_23jul2025(_int8, int4, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent_bkp_23jul2025(_int8, int4, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_reject_mf_consent_bkp_23jul2025(_int8, int4, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_com_mailer_mst(varchar, int8);

CREATE OR REPLACE FUNCTION transactions.fn_update_com_mailer_mst(v_subcategory character varying, v_comid bigint)
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

UPDATE transactions.communication_mailer_mst
SET
is_picked=true
where subcategoryid=v_subcategory
and comid in (v_comid)
and is_picked=false;

-- Return the status
	RETURN QUERY 
	SELECT 'Success'::character varying AS status;

EXCEPTION
    WHEN OTHERS THEN
        -- Log error if needed
        RETURN QUERY 
        SELECT 'Failure'::character varying AS status;
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_com_mailer_mst(varchar, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_com_mailer_mst(varchar, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_com_mailer_mst(varchar, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_com_mailer_mst(varchar, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_com_mailer_mst(varchar, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_communication_log_details(int4, int4, bool, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_communication_log_details(v_srno integer, v_is_sent integer DEFAULT 0, v_is_picked boolean DEFAULT false, v_sent_comm character varying DEFAULT NULL::character varying)
 RETURNS text
 LANGUAGE plpgsql
AS $function$

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.communication_log_details A WHERE A.srno = v_srno
			  AND (A.is_sent <> v_is_sent OR A.is_picked <> v_ispicked OR (v_sent_comm IS NOT NULL AND COALESCE(A.sent_communication,'') <> v_sent_comm)) )
	THEN
		
		UPDATE transactions.communication_log_details A SET
		is_sent = CASE WHEN A.is_sent <> v_is_sent THEN v_is_sent ELSE A.is_sent END,
		is_picked = CASE WHEN A.is_picked <> v_ispicked THEN v_ispicked ELSE A.is_picked END,
		sent_communication = CASE WHEN v_sent_comm IS NOT NULL AND COALESCE(A.sent_communication,'') <> v_sent_comm THEN v_sent_comm ELSE A.sent_communication END,
		modified_date = NOW()
		WHERE A.srno = v_srno
		AND (A.is_sent <> v_is_sent
			 OR A.is_picked <> v_ispicked
			 OR (v_sent_comm IS NOT NULL AND COALESCE(A.sent_communication,'') <> v_sent_comm));
			  
		RETURN 'SUCCESS';

	ELSE
		
		RETURN 'No Update Required as there is no change';
	
	END IF;
	
	EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			
			RETURN 'FAILURE Error :- '||CAST(SQLERRM as VARCHAR(4000));

        END;  
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_communication_log_details(int4, int4, bool, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_communication_log_details(int4, int4, bool, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_communication_log_details(int4, int4, bool, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_communication_log_details(int4, int4, bool, varchar) TO cmotsread;
GRANT ALL ON FUNCTION transactions.fn_update_communication_log_details(int4, int4, bool, varchar) TO appadmin;

-- DROP FUNCTION transactions.fn_update_leadid(int8, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_leadid(v_trx_id bigint, v_lead_id character varying)
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF EXISTS (
        SELECT 1
        FROM transactions.mf_order_detail
        WHERE trx_id = v_trx_id
    ) THEN

	update transactions.mf_order_detail
	set lead_id=v_lead_id
	where trx_id = v_trx_id;
	
	RETURN QUERY
	SELECT 'SUCCESS'::character varying as status;
	
    ELSE
	
       SELECT 'FAILURE'::character varying as status;
    
	END IF; 
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_leadid(int8, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_leadid(int8, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_leadid(int8, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_leadid(int8, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_leadid(int8, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mandate_status(varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mandate_status(v_logintype character varying, v_ac_code character varying, v_mandateid character varying)
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

		-- Update staging table if exists
	IF EXISTS (
		SELECT 1 FROM transactions.stg_mf_mandate WHERE mandateid = v_mandateid
	) THEN
		UPDATE transactions.stg_mf_mandate
		SET status = 'UNDER PROCESSING'
		WHERE mandateid = v_mandateid;

	RETURN QUERY SELECT 'SUCCESS'::character varying;

	END IF;

	-- Update main mandate table if exists
	IF EXISTS (
		SELECT 1 FROM transactions.mf_mandate WHERE mandateid = v_mandateid
	) THEN
		UPDATE transactions.mf_mandate
		SET status = 'UNDER PROCESSING'
		WHERE mandateid = v_mandateid;

		RETURN QUERY SELECT 'SUCCESS'::character varying;
	ELSE
		RETURN QUERY SELECT 'FAILURE'::character varying;
	END IF;
	
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mandate_status(varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mandate_status(varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mandate_status(varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mandate_status(varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mandate_status(varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_challan_details(varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_challan_details(v_payment_trxid character varying, v_deposit_challanno character varying, v_deposit_challanremarks character varying)
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF EXISTS (
	SELECT 1
	FROM transactions.mf_order_detail
	WHERE created_date::date >= (now()::date - INTERVAL '10 days')::date
	AND trx_type_code = 4
	AND upper(payment_method) = 'CHEQUE'
	AND payment_trxid = v_payment_trxid
	AND deposit_challanno IS NULL
) 
THEN

	update transactions.mf_order_detail
	set deposit_challanno=v_deposit_challanno,
	deposit_challanremarks=v_deposit_challanremarks
	WHERE created_date::date >= (now()::date - INTERVAL '10 days')::date
	AND trx_type_code = 4
	AND upper(payment_method) = 'CHEQUE'
	AND payment_trxid = v_payment_trxid
	AND deposit_challanno IS NULL;  
	
	RETURN QUERY
	SELECT 'SUCCESS'::character varying as status;

ELSE
	SELECT 'No Record Found'::character varying as status;
END IF; 
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_challan_details(varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_challan_details(varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_challan_details(varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_challan_details(varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_challan_details(varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_cheque_details(varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_cheque_details(v_payment_trxid character varying, v_collectionentry_groupid character varying, v_collectionentry_remarks character varying)
 RETURNS TABLE(status character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

IF EXISTS (
	SELECT 1
	FROM transactions.mf_order_detail
	WHERE created_date::date >= (now()::date - INTERVAL '10 days')::date
	AND trx_type_code = 4
	AND upper(payment_method) = 'CHEQUE'
	AND payment_trxid = v_payment_trxid
	AND collectionentry_groupid is null
) 
THEN

	update transactions.mf_order_detail
	set collectionentry_groupid=v_collectionentry_groupid,
	collectionentry_remarks=v_collectionentry_remarks
	WHERE created_date::date >= (now()::date - INTERVAL '10 days')::date
	AND trx_type_code = 4
	AND upper(payment_method) = 'CHEQUE'
	AND collectionentry_groupid is null
	AND payment_trxid = v_payment_trxid;  
	
	RETURN QUERY
	SELECT 'SUCCESS'::character varying as status;

ELSE
	SELECT 'No Record Found'::character varying as status;
END IF; 
END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_cheque_details(varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_cheque_details(varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_cheque_details(varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_cheque_details(varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_cheque_details(varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_modification_transactions(int8, bool, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_modification_transactions(v_trx_id bigint, v_is_rejected boolean, v_res character varying, v_remarks character varying)
 RETURNS TABLE(trx_id bigint, status character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_trx_id AND A.internal_flag = 0)
	THEN

		IF (v_is_rejected = true)
		THEN

			UPDATE transactions.mf_order_detail_modification A
			SET internal_flag = 1
			, vendor_res = v_res
			, order_remarks = v_remarks
			, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 8)
			, trx_status_code = 8
			, sent_to_vendor_datetime = (NOW() at time zone 'Asia/Kolkata')
			, modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = 'Order Rejected'
			, trx_final_status_code = 8
			, inv_plan_status_code = 7
			, inv_plan_status = 'Order Rejected'
			WHERE A.trx_id = v_trx_id;

			-----Update remarks for modification order after rejecion 
			update transactions.mf_order_summary A SET
			remarks=NULL
			where A.trx_id in (select a.org_trx_id from transactions.mf_order_detail_modification a
			where a.trx_id=v_trx_id);
				
			RETURN QUERY
			SELECT B.trx_id, 'SUCCESS'::character varying as status FROM transactions.mf_order_detail_modification B WHERE B.trx_id = v_trx_id;
		
		ELSE

			UPDATE transactions.mf_order_detail_modification A SET
			internal_flag = 1
			, vendor_res = v_res
			, order_remarks = v_remarks
			/* , trx_status =  CASE WHEN A.inv_action_code = 4 THEN (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 3)
								 WHEN A.inv_action_code = 2 THEN (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 5)
								 WHEN A.inv_action_code = 0 THEN (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 4) END			
			, trx_status_code = CASE WHEN A.inv_action_code = 4 THEN 3 WHEN A.inv_action_code = 2 THEN 5 WHEN A.inv_action_code = 0 THEN 4 END */
			, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 6)			
			, trx_status_code = 6
			, sent_to_vendor_datetime = (NOW() at time zone 'Asia/Kolkata')
			, modified_date = (NOW() at time zone 'Asia/Kolkata')
			WHERE A.trx_id = v_trx_id;

			/* UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id; */

			RETURN QUERY
			SELECT B.trx_id, 'SUCCESS'::character varying as status FROM transactions.mf_order_detail_modification B WHERE B.trx_id = v_trx_id;
			
		END IF;
		
	ELSE

		RETURN QUERY
		SELECT v_trx_id, 'FAILURE'::character varying as status;

	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_modification_transactions(int8, bool, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_modification_transactions(int8, bool, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_modification_transactions(int8, bool, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_modification_transactions(int8, bool, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_modification_transactions(int8, bool, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_modification_transactions_bkp_09may2025(int8, bool, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_modification_transactions_bkp_09may2025(v_trx_id bigint, v_is_rejected boolean, v_res character varying, v_remarks character varying)
 RETURNS TABLE(trx_id bigint, status character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail_modification A WHERE A.trx_id = v_trx_id AND A.internal_flag = 0)
	THEN

		IF (v_is_rejected = true)
		THEN

			UPDATE transactions.mf_order_detail_modification A
			SET internal_flag = 1
			, vendor_res = v_res
			, order_remarks = v_remarks
			, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 8)
			, trx_status_code = 8
			, sent_to_vendor_datetime = NOW()
			, modified_date = NOW()
			WHERE A.trx_id = v_trx_id;

			UPDATE transactions.mf_order_detail_modification A SET
			final_status = 'Order Rejected'
			, trx_final_status_code = 8
			, inv_plan_status_code = 7
			, inv_plan_status = 'Order Rejected'
			WHERE A.trx_id = v_trx_id;

			-----Update remarks for modification order after rejecion 
			update transactions.mf_order_summary A SET
			remarks=NULL
			where A.trx_id in (select org_trx_id from transactions.mf_order_detail_modification
			where trx_id=v_trx_id);
				
			RETURN QUERY
			SELECT B.trx_id, 'SUCCESS'::character varying as status FROM transactions.mf_order_detail_modification B WHERE B.trx_id = v_trx_id;
		
		ELSE

			UPDATE transactions.mf_order_detail_modification A SET
			internal_flag = 1
			, vendor_res = v_res
			, order_remarks = v_remarks
			/* , trx_status =  CASE WHEN A.inv_action_code = 4 THEN (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 3)
								 WHEN A.inv_action_code = 2 THEN (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 5)
								 WHEN A.inv_action_code = 0 THEN (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 4) END			
			, trx_status_code = CASE WHEN A.inv_action_code = 4 THEN 3 WHEN A.inv_action_code = 2 THEN 5 WHEN A.inv_action_code = 0 THEN 4 END */
			, trx_status = (SELECT S.trx_status FROM master.trx_status S WHERE S.category_code = 261 AND S.trx_status_code = 6)			
			, trx_status_code = 6
			, sent_to_vendor_datetime = NOW()
			, modified_date = NOW()
			WHERE A.trx_id = v_trx_id;

			/* UPDATE transactions.mf_order_detail_modification A SET
			final_status = B.trx_final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status
			FROM transactions.mf_order_detail_modification D
			LEFT JOIN master.mv_map_category_status B
			ON UPPER(B.usertype) = UPPER(D.order_placed_by)
			AND D.physicalflag = B.physicalflag
			AND D.trx_type_code = B.trx_type_code
			/* AND D.is_generatetoday = B.is_generatetoday */
			AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
			AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
			AND B.trx_status_code = D.trx_status_code
			AND B.inv_action_code = D.inv_action_code
			AND B.category_code = 261
			WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id; */

			RETURN QUERY
			SELECT B.trx_id, 'SUCCESS'::character varying as status FROM transactions.mf_order_detail_modification B WHERE B.trx_id = v_trx_id;
			
		END IF;
		
	ELSE

		RETURN QUERY
		SELECT v_trx_id, 'FAILURE'::character varying as status;

	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_modification_transactions_bkp_09may2025(int8, bool, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_modification_transactions_bkp_09may2025(int8, bool, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_modification_transactions_bkp_09may2025(int8, bool, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_modification_transactions_bkp_09may2025(int8, bool, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_modification_transactions_bkp_09may2025(int8, bool, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_order_cancel(varchar, int4, int8);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_order_cancel(v_logintype character varying, v_inv_action_code integer, v_trx_id bigint)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF v_inv_action_code = 1
	THEN

		---------------Order Book
		UPDATE transactions.mf_order_detail
		SET trx_status_code = 3,
			trx_status = 'Order Cancelled',
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected',
			trx_final_status_code = 2,
			final_status = 'Order Rejected',
			order_remarks = CASE 
								WHEN v_logintype = 'RM' THEN 'Order Cancelled by RM'
								WHEN v_logintype = 'PARTNER' THEN 'Order Cancelled by Partner'
								WHEN v_logintype = 'CLIENT' THEN 'Order Cancelled by Client'
							END
		WHERE trx_id = v_trx_id
		AND inv_action_code = v_inv_action_code
		AND vendor_trx_id IS NULL;

		----------Insert Data into transaction History Table----------
		update transactions.mf_order_detail_history
		set 
			valid_to = (NOW() at time zone 'Asia/Kolkata'),
			is_active = false
		WHERE trx_id = v_trx_id;

		insert into transactions.mf_order_detail_history(
		trx_id,vendor_trx_id,ucccode,ac_code,trx_datetime,is_active,trx_type_code,trx_type,
		consent_status_code,consent_status,trx_status_code,trx_status,vendor_trx_status,
		payment_status_code,payment_status,inv_plan_status_code,inv_plan_status, 
		trx_final_status_code,final_status,mandate_id,order_remarks,trx_source,inserted_dt,valid_from
		)

		select distinct
		A.trx_id,A.vendor_trx_id,A.ucccode,A.ac_code,A.trx_datetime,true as is_active,a.trx_type_code,
		A.trx_type,A.consent_status_code,A.consent_status,A.trx_status_code,A.trx_status,A.vendor_trx_status, 
		A.payment_status_code,A.payment_status,a.inv_plan_status_code,a.inv_plan_status,A.trx_final_status_code,
		A.final_status,A.mandate_id,A.order_remarks,A.trx_source,(NOW() at time zone 'Asia/Kolkata') as inserted_dt,
		(NOW() at time zone 'Asia/Kolkata') as valid_from		 
		from transactions.mf_order_detail A 
		join transactions.mf_order_detail_history b on a.trx_id = b.trx_id 
		where A.trx_id = v_trx_id
		and (
		coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		); 

		update transactions.mf_order_detail_history 
		set 
		valid_to = '9999-12-31'::timestamp without time zone 
		where trx_id = v_trx_id
		and	is_active = true 
		and valid_to is null;

		---------------Order Summary Book
		UPDATE transactions.mf_order_summary A
		SET 
			trx_status_code=B.trx_status_code,
			trx_status=B.trx_status,
			final_status = B.final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status,
			order_remarks=B.order_remarks
		FROM transactions.mf_order_detail B
		where A.trx_id=B.trx_id
		and A.trx_id = v_trx_id
		AND B.inv_action_code = v_inv_action_code
		AND B.vendor_trx_id IS NULL;

/*
-- Update transactions.mf_order_summary_history
UPDATE transactions.mf_order_summary_history a
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE a.trx_id =v_trx_id
and is_active = true;

-------insert reject entry in History summary 
INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT distinct
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A 
join transactions.mf_order_summary_history b on A.trx_id=B.trx_id
WHERE A.trx_id =v_trx_id;

-- Update valid_to for active records
UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;
*/
-----------------------------------------------------------

		RETURN 'SUCCESS';
	------
	ELSE
		---------------Order modification Book
		UPDATE transactions.mf_order_detail_modification
		SET trx_status_code = 3,
			trx_status = 'Order Cancelled',
			trx_final_status_code = 2,
			final_status = 'Order Rejected',
			order_remarks = CASE 
								WHEN v_logintype = 'RM' THEN 'Order Cancelled by RM'
								WHEN v_logintype = 'PARTNER' THEN 'Order Cancelled by Partner'
								WHEN v_logintype = 'CLIENT' THEN 'Order Cancelled by Client'
							END
		WHERE trx_id = v_trx_id
		AND inv_action_code = v_inv_action_code;
	--	AND vendor_trx_id IS NULL;

	UPDATE transactions.mf_order_summary A SET remarks = ''
WHERE A.trx_id IN (SELECT DISTINCT M.org_trx_id FROM transactions.mf_order_detail_modification M
				 WHERE M.trx_id =v_trx_id)
AND coalesce(A.remarks,'')<> '';

				RETURN 'SUCCESS';
	END IF;
	------------------
	EXCEPTION
		WHEN OTHERS THEN
			RETURN 'Failure Error :- ' || CAST(SQLERRM AS VARCHAR(4000));
	------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_order_cancel(varchar, int4, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_order_cancel(varchar, int4, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_order_cancel(varchar, int4, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_order_cancel(varchar, int4, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_order_cancel(varchar, int4, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_order_cancel_bkp_09may2025(varchar, int4, int8);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_order_cancel_bkp_09may2025(v_logintype character varying, v_inv_action_code integer, v_trx_id bigint)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF v_inv_action_code = 1
	THEN

		---------------Order Book
		UPDATE transactions.mf_order_detail
		SET trx_status_code = 3,
			trx_status = 'Order Cancelled',
			inv_plan_status_code = 7,
			inv_plan_status = 'Order Rejected',
			trx_final_status_code = 2,
			final_status = 'Order Rejected',
			order_remarks = CASE 
								WHEN v_logintype = 'RM' THEN 'Order Cancelled by RM'
								WHEN v_logintype = 'PARTNER' THEN 'Order Cancelled by Partner'
								WHEN v_logintype = 'CLIENT' THEN 'Order Cancelled by Client'
							END
		WHERE trx_id = v_trx_id
		AND inv_action_code = v_inv_action_code
		AND vendor_trx_id IS NULL;

		----------Insert Data into transaction History Table----------
		update transactions.mf_order_detail_history
		set 
			valid_to = NOW(),
			is_active = false
		WHERE trx_id = v_trx_id;

		insert into transactions.mf_order_detail_history(
		trx_id,vendor_trx_id,ucccode,ac_code,trx_datetime,is_active,trx_type_code,trx_type,
		consent_status_code,consent_status,trx_status_code,trx_status,vendor_trx_status,
		payment_status_code,payment_status,inv_plan_status_code,inv_plan_status, 
		trx_final_status_code,final_status,mandate_id,order_remarks,trx_source,inserted_dt,valid_from
		)

		select distinct
		A.trx_id,A.vendor_trx_id,A.ucccode,A.ac_code,A.trx_datetime,true as is_active,a.trx_type_code,
		A.trx_type,A.consent_status_code,A.consent_status,A.trx_status_code,A.trx_status,A.vendor_trx_status, 
		A.payment_status_code,A.payment_status,a.inv_plan_status_code,a.inv_plan_status,A.trx_final_status_code,
		A.final_status,A.mandate_id,A.order_remarks,A.trx_source,NOW() as inserted_dt,Now() as valid_from		 
		from transactions.mf_order_detail A 
		join transactions.mf_order_detail_history b on a.trx_id = b.trx_id 
		where A.trx_id = v_trx_id
		and (
		coalesce (a.trx_final_status_code,0)  <> coalesce (b.trx_final_status_code,0)
		or coalesce (a.trx_status_code,0)  <> coalesce (b.trx_status_code,0)
		); 

		update transactions.mf_order_detail_history 
		set 
		valid_to = '9999-12-31'::timestamp without time zone 
		where trx_id = v_trx_id
		and	is_active = true 
		and valid_to is null;

		---------------Order Summary Book
		UPDATE transactions.mf_order_summary A
		SET 
			trx_status_code=B.trx_status_code,
			trx_status=B.trx_status,
			final_status = B.final_status,
			trx_final_status_code = B.trx_final_status_code,
			inv_plan_status_code = B.inv_plan_status_code,
			inv_plan_status = B.inv_plan_status,
			order_remarks=B.order_remarks
		FROM transactions.mf_order_detail B
		where A.trx_id=B.trx_id
		and A.trx_id = v_trx_id
		AND B.inv_action_code = v_inv_action_code
		AND B.vendor_trx_id IS NULL;

-- Update transactions.mf_order_summary_history
UPDATE transactions.mf_order_summary_history a
	SET valid_to = NOW(),is_active = false
FROM transactions.mf_order_summary b
WHERE a.trx_id =v_trx_id
and is_active = true;

-------insert reject entry in History summary 
INSERT INTO transactions.mf_order_summary_history(
id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,valid_from,is_active,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status)
SELECT distinct
A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,NOW(),true,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_summary A 
join transactions.mf_order_summary_history b on A.trx_id=B.trx_id
WHERE A.trx_id =v_trx_id;

-- Update valid_to for active records
UPDATE transactions.mf_order_summary_history 
SET valid_to = '9999-12-31'::timestamp without time zone 
WHERE is_active = true AND valid_to IS NULL;

-----------------------------------------------------------

		RETURN 'SUCCESS';
	------
	ELSE
		---------------Order modification Book
		UPDATE transactions.mf_order_detail_modification
		SET trx_status_code = 3,
			trx_status = 'Order Cancelled',
			trx_final_status_code = 2,
			final_status = 'Order Rejected',
			order_remarks = CASE 
								WHEN v_logintype = 'RM' THEN 'Order Cancelled by RM'
								WHEN v_logintype = 'PARTNER' THEN 'Order Cancelled by Partner'
								WHEN v_logintype = 'CLIENT' THEN 'Order Cancelled by Client'
							END
		WHERE trx_id = v_trx_id
		AND inv_action_code = v_inv_action_code;
	--	AND vendor_trx_id IS NULL;

				RETURN 'SUCCESS';
	END IF;
	------------------
	EXCEPTION
		WHEN OTHERS THEN
			RETURN 'Failure Error :- ' || CAST(SQLERRM AS VARCHAR(4000));
	------------------

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_order_cancel_bkp_09may2025(varchar, int4, int8) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_order_cancel_bkp_09may2025(varchar, int4, int8) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_order_cancel_bkp_09may2025(varchar, int4, int8) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_order_cancel_bkp_09may2025(varchar, int4, int8) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_order_cancel_bkp_09may2025(varchar, int4, int8) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_sync_status(int4, varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_sync_status(p_syncid integer, p_ucccode character varying, p_status character varying, p_source character varying, p_initiated_by character varying)
 RETURNS TABLE(syncid integer, status character varying)
 LANGUAGE plpgsql
AS $function$
declare 
	v_last_reqid int;
	v_status varchar:= 'failed';
begin
	if (p_syncid = 0)
	then
		
		update transactions.mf_sync_history sync
		set status  = 'Consent Expired',
			--sync_start_datetime = current_timestamp at TIME ZONE'Asia/Kolkata',
			sync_end_datetime = current_timestamp at TIME ZONE'Asia/Kolkata'
		where sync.ucccode = p_ucccode
		and sync.status <> 'Completed';
	
		insert into transactions.mf_sync_history 
		(ucccode , sync_start_datetime , sync_end_datetime , status , "source" , initiated_by)
		values(
				p_ucccode , 
				current_timestamp at TIME ZONE'Asia/Kolkata',  
				current_timestamp at TIME ZONE'Asia/Kolkata',
				p_status ,
				p_source ,
				p_initiated_by
				)
		returning id into v_last_reqid;
		p_syncid := v_last_reqid;
		v_status:= 	'success';
		
		insert into transactions.mf_sync_history_log 
		(sync_id , ucccode , sync_start_datetime , sync_end_datetime , status , "source" , initiated_by)
		
		select p_syncid as sync_id ,
				p_ucccode as ucccode , 
				current_timestamp at TIME ZONE'Asia/Kolkata' as sync_start_datetime,  
				current_timestamp at TIME ZONE'Asia/Kolkata' as sync_end_datetime,
				p_status as status,
				p_source as source,
				p_initiated_by as initiated_by;
			
		return query
		select p_syncid as syncid ,
				v_status as status ;	
	
	else
		
		update transactions.mf_sync_history sync
		set status  = p_status ,
			sync_start_datetime = current_timestamp at TIME ZONE'Asia/Kolkata',
			sync_end_datetime = current_timestamp at TIME ZONE'Asia/Kolkata'
		where sync.id = p_syncid;
		
		insert into transactions.mf_sync_history_log 
		(sync_id , ucccode , sync_start_datetime , sync_end_datetime , status , "source" , initiated_by)
		
		select p_syncid as sync_id ,
				p_ucccode as ucccode , 
				current_timestamp at TIME ZONE'Asia/Kolkata' as sync_start_datetime,  
				current_timestamp at TIME ZONE'Asia/Kolkata' as sync_end_datetime,
				p_status as status,
				p_source as source,
				p_initiated_by as initiated_by;
		
		v_status:= 	'success';
	
		return query
		select p_syncid as syncid ,
		 		v_status as status ;		
	
	end if;


end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_sync_status(int4, varchar, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_sync_status(int4, varchar, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_sync_status(int4, varchar, varchar, varchar, varchar) TO cmotswrite;

-- DROP FUNCTION transactions.fn_update_mf_transactions_payment_details(int8, varchar, varchar, varchar, varchar, varchar, varchar, varchar, date);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_transactions_payment_details(v_trx_id bigint, v_payment_trxid character varying DEFAULT NULL::character varying, v_payment_status character varying DEFAULT NULL::character varying, v_payment_method character varying DEFAULT NULL::character varying, v_bank_code character varying DEFAULT NULL::character varying, v_bank_name character varying DEFAULT NULL::character varying, v_bank_ac_number character varying DEFAULT NULL::character varying, v_cheque_number character varying DEFAULT NULL::character varying, v_cheque_date date DEFAULT NULL::date)
 RETURNS TABLE(token bigint, isinino character varying, units numeric, amount numeric, reinvestmentflag character varying, requestedby character varying, ordertype character varying, txntype character varying, euinflag character varying, euinnumber character varying, clientcode character varying, dpc character varying, ordersource character varying, schemeplan character varying, display_trx_id character varying, physicalflag character varying, start_date date, end_date date, tenure integer, frequency character varying, is_generatetoday boolean, mandate_id character varying, folio_no character varying, vendor_req character varying, trx_id bigint, status character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

----------Updating Payment Data into Main transaction Table----------
UPDATE transactions.mf_order_detail A SET
payment_trxid = v_payment_trxid
, payment_status = v_payment_status
, payment_status_code = (SELECT A.payment_status_code FROM master.dim_payment_status A WHERE UPPER(A.payment_status) = UPPER(v_payment_status))
, payment_method = v_payment_method
, bank_code = v_bank_code
, bank_name = v_bank_name
, bank_ac_number = v_bank_ac_number
, modified_date = NOW() at time zone 'Asia/Kolkata'
, cheque_number= v_cheque_number
, cheque_date= v_cheque_date
WHERE A.trx_id = v_trx_id;
/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
	 WHEN C.is_generatetoday = FALSE THEN ''
	 WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
*/
If (trim(Upper(v_payment_method))<>'ECOLLECT')
	then
UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
else
UPDATE transactions.mf_order_detail A SET
payment_status_code='1',
payment_status='Pending',
final_status ='Order In Progress',
trx_final_status_code = 5,
inv_plan_status_code = case when trx_type_code=1 then 6 else NULL::Integer end,
inv_plan_status = case when trx_type_code=1 then 'Order in Progress' else '' end 
WHERE A.trx_id = v_trx_id and trim(Upper(v_payment_method))='ECOLLECT';
end If;

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail_history A
			  JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.is_active = true
			  WHERE A.trx_id = v_trx_id AND (A.trx_final_status_code <> B.trx_final_status_code 
		OR A.payment_status_code <> B.payment_status_code))
	THEN

		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = NOW() at time zone 'Asia/Kolkata', is_active = false 
		WHERE A.trx_id = v_trx_id AND A.is_active = true;

		INSERT INTO transactions.mf_order_detail_history
		(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
		, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
		,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
		, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, 
		NOW() at time zone 'Asia/Kolkata', true
		,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
		FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id ;

		UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

	END IF;
	
RETURN QUERY
SELECT DISTINCT A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
,A.trx_id,
(case when upper(a.payment_method)=upper('Ecollect') and A.vendor_trx_id is not null then 'FAILURE' else 'SUCCESS' end)::character varying as status
FROM transactions.mf_order_detail A
LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
WHERE A.trx_id = v_trx_id;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_transactions_payment_details(int8, varchar, varchar, varchar, varchar, varchar, varchar, varchar, date) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details(int8, varchar, varchar, varchar, varchar, varchar, varchar, varchar, date) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details(int8, varchar, varchar, varchar, varchar, varchar, varchar, varchar, date) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details(int8, varchar, varchar, varchar, varchar, varchar, varchar, varchar, date) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details(int8, varchar, varchar, varchar, varchar, varchar, varchar, varchar, date) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_09may2025(int8, varchar, varchar, varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_09may2025(v_trx_id bigint, v_payment_trxid character varying DEFAULT NULL::character varying, v_payment_status character varying DEFAULT NULL::character varying, v_payment_method character varying DEFAULT NULL::character varying, v_bank_code character varying DEFAULT NULL::character varying, v_bank_name character varying DEFAULT NULL::character varying, v_bank_ac_number character varying DEFAULT NULL::character varying)
 RETURNS TABLE(token bigint, isinino character varying, units numeric, amount numeric, reinvestmentflag character varying, requestedby character varying, ordertype character varying, txntype character varying, euinflag character varying, euinnumber character varying, clientcode character varying, dpc character varying, ordersource character varying, schemeplan character varying, display_trx_id character varying, physicalflag character varying, start_date date, end_date date, tenure integer, frequency character varying, is_generatetoday boolean, mandate_id character varying, folio_no character varying, vendor_req character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

----------Updating Payment Data into Main transaction Table----------
UPDATE transactions.mf_order_detail SET
payment_trxid = v_payment_trxid
, payment_status = v_payment_status
, payment_status_code = (SELECT A.payment_status_code FROM master.dim_payment_status A WHERE UPPER(A.payment_status) = UPPER(v_payment_status))
, payment_method = v_payment_method
, bank_code = v_bank_code
, bank_name = v_bank_name
, bank_ac_number = v_bank_ac_number
, modified_date = NOW()
WHERE trx_id = v_trx_id;
/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
	 WHEN C.is_generatetoday = FALSE THEN ''
	 WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
*/

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail_history A
			  JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.is_active = true
			  WHERE A.trx_id = v_trx_id AND (A.trx_final_status_code <> B.trx_final_status_code OR A.payment_status_code <> B.payment_status_code))
	THEN
	
		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history SET valid_to = NOW(), is_active = false WHERE trx_id = v_trx_id AND is_active = true;

		INSERT INTO transactions.mf_order_detail_history
		(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
		, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
		,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
		, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
		,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
		FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id ;

		UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
	
	END IF;
	
RETURN QUERY
SELECT DISTINCT A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
FROM transactions.mf_order_detail A
LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
WHERE A.trx_id = v_trx_id;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_09may2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_09may2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_09may2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_09may2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_09may2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_14jul2025(int8, varchar, varchar, varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_14jul2025(v_trx_id bigint, v_payment_trxid character varying DEFAULT NULL::character varying, v_payment_status character varying DEFAULT NULL::character varying, v_payment_method character varying DEFAULT NULL::character varying, v_bank_code character varying DEFAULT NULL::character varying, v_bank_name character varying DEFAULT NULL::character varying, v_bank_ac_number character varying DEFAULT NULL::character varying)
 RETURNS TABLE(token bigint, isinino character varying, units numeric, amount numeric, reinvestmentflag character varying, requestedby character varying, ordertype character varying, txntype character varying, euinflag character varying, euinnumber character varying, clientcode character varying, dpc character varying, ordersource character varying, schemeplan character varying, display_trx_id character varying, physicalflag character varying, start_date date, end_date date, tenure integer, frequency character varying, is_generatetoday boolean, mandate_id character varying, folio_no character varying, vendor_req character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

----------Updating Payment Data into Main transaction Table----------
UPDATE transactions.mf_order_detail SET
payment_trxid = v_payment_trxid
, payment_status = v_payment_status
, payment_status_code = (SELECT A.payment_status_code FROM master.dim_payment_status A WHERE UPPER(A.payment_status) = UPPER(v_payment_status))
, payment_method = v_payment_method
, bank_code = v_bank_code
, bank_name = v_bank_name
, bank_ac_number = v_bank_ac_number
, modified_date = NOW()
WHERE trx_id = v_trx_id;
/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
	 WHEN C.is_generatetoday = FALSE THEN ''
	 WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
*/
If (trim(Upper(v_payment_method))<>'ECOLLECT')
	then
UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
else
UPDATE transactions.mf_order_detail A SET
payment_status_code='1',
payment_status='Pending',
final_status ='Order In Progress',
trx_final_status_code = 5,
inv_plan_status_code = case when trx_type_code=1 then 6 else NULL::Integer end,
inv_plan_status = case when trx_type_code=1 then 'Order in Progress' else '' end 
WHERE A.trx_id = v_trx_id and trim(Upper(v_payment_method))='ECOLLECT';
end If;

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail_history A
			  JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.is_active = true
			  WHERE A.trx_id = v_trx_id AND (A.trx_final_status_code <> B.trx_final_status_code OR A.payment_status_code <> B.payment_status_code))
	THEN

		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history SET valid_to = NOW(), is_active = false WHERE trx_id = v_trx_id AND is_active = true;

		INSERT INTO transactions.mf_order_detail_history
		(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
		, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
		,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
		, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
		,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
		FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id ;

		UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

	END IF;
	
RETURN QUERY
SELECT DISTINCT A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
FROM transactions.mf_order_detail A
LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
WHERE A.trx_id = v_trx_id;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_14jul2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_14jul2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_14jul2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_14jul2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_details_bkp_14jul2025(int8, varchar, varchar, varchar, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_transactions_payment_status(int8, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_transactions_payment_status(v_trx_id bigint, v_payment_trxid character varying DEFAULT NULL::character varying, v_payment_status character varying DEFAULT NULL::character varying, v_remarks character varying DEFAULT NULL::character varying)
 RETURNS TABLE(status character varying, remarks character varying, token bigint, isinino character varying, units numeric, amount numeric, reinvestmentflag character varying, requestedby character varying, ordertype character varying, txntype character varying, euinflag character varying, euinnumber character varying, clientcode character varying, dpc character varying, ordersource character varying, schemeplan character varying, display_trx_id character varying, physicalflag character varying, start_date date, end_date date, tenure integer, frequency character varying, is_generatetoday boolean, mandate_id character varying, folio_no character varying, vendor_req character varying, client_name character varying, consent_expire_date timestamp without time zone, payment_initiated_date timestamp without time zone, trx_id bigint)
 LANGUAGE plpgsql
AS $function$

BEGIN

	
IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id AND COALESCE(A.trx_final_status_code, 0) <> 2
	AND A.trx_status_code = 7 AND A.payment_status <> v_payment_status AND COALESCE(A.payment_status_code, 0) <> 2)
THEN

	----------Updating Payment Data into Main transaction Table----------
	UPDATE transactions.mf_order_detail A SET
	payment_trxid = v_payment_trxid
	, payment_status = v_payment_status
	, payment_status_code = (SELECT A.payment_status_code FROM master.dim_payment_status A 
	WHERE UPPER(A.payment_status) = UPPER(v_payment_status))
	, payment_remarks = v_remarks
	, modified_date = (NOW() at time zone 'Asia/Kolkata')
	WHERE A.trx_id = v_trx_id;
/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
	 WHEN C.is_generatetoday = FALSE THEN ''
	 WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
*/

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

update transactions.mf_order_summary a SET
final_status = b.final_status,
trx_final_status_code = b.trx_final_status_code,
inv_plan_status_code = b.inv_plan_status_code,
inv_plan_status = b.inv_plan_status,
trx_type_code=b.trx_type_code
from transactions.mf_order_detail b
where a.trx_id = b.trx_id and b.trx_id=v_trx_id;

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail_history A
			  JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.is_active = true
			  WHERE A.trx_id = v_trx_id AND (A.trx_final_status_code <> B.trx_final_status_code OR A.payment_status_code <> B.payment_status_code))
	THEN

		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history A
		SET valid_to = (NOW() at time zone 'Asia/Kolkata'), 
		is_active = false WHERE A.trx_id = v_trx_id AND A.is_active = true;

		INSERT INTO transactions.mf_order_detail_history
		(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
		 , vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
		,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
		 , A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, 
		(NOW() at time zone 'Asia/Kolkata'), true
		,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
		 FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id ;

		UPDATE transactions.mf_order_detail_history SET 
		valid_to = '9999-12-31'::timestamp without time zone 
		WHERE is_active = true AND valid_to IS NULL;

	END IF;
	
	RETURN QUERY
	SELECT DISTINCT 'SUCCESS'::character varying as status, ('Payment '|| v_payment_status ||' successful')::character varying as remarks
	, A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
	, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
	, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
	, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
	, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
	, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
	, (SELECT ucc.acname as client_name from master.dim_ucc ucc WHERE ucc.priority_ac_code = A.ac_code), D.consent_expire_date
	, COALESCE((SELECT DATE_TRUNC('second', H.inserted_dt) FROM transactions.mf_order_detail_history H WHERE H.trx_id = v_trx_id AND H.trx_final_status_code = 3 ORDER BY 1 DESC LIMIT 1)
				,DATE_TRUNC('second', A.created_date))
		,A.trx_id
	FROM transactions.mf_order_detail A
	LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
	LEFT JOIN transactions.order_consent D ON A.trx_id = D.trx_id
	WHERE A.trx_id = v_trx_id;

ELSE

	RETURN QUERY
	SELECT DISTINCT 'FAILURE'::character varying as status, 'Payment cannot be updated with same status'::character varying as remarks
	, A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
	, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
	, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
	, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
	, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
	, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
	, (SELECT ucc.acname as client_name from master.dim_ucc ucc WHERE ucc.priority_ac_code = A.ac_code), D.consent_expire_date
	, COALESCE((SELECT DATE_TRUNC('second', H.inserted_dt) FROM transactions.mf_order_detail_history H WHERE H.trx_id = v_trx_id AND H.trx_final_status_code = 3 ORDER BY 1 DESC LIMIT 1)
				,DATE_TRUNC('second', A.created_date))
	,A.trx_id
	FROM transactions.mf_order_detail A
	LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
	LEFT JOIN transactions.order_consent D ON A.trx_id = D.trx_id
	WHERE A.trx_id = v_trx_id;

END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_transactions_payment_status(int8, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status(int8, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status(int8, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status(int8, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status(int8, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_05sept2025(int8, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_05sept2025(v_trx_id bigint, v_payment_trxid character varying DEFAULT NULL::character varying, v_payment_status character varying DEFAULT NULL::character varying, v_remarks character varying DEFAULT NULL::character varying)
 RETURNS TABLE(status character varying, remarks character varying, token bigint, isinino character varying, units numeric, amount numeric, reinvestmentflag character varying, requestedby character varying, ordertype character varying, txntype character varying, euinflag character varying, euinnumber character varying, clientcode character varying, dpc character varying, ordersource character varying, schemeplan character varying, display_trx_id character varying, physicalflag character varying, start_date date, end_date date, tenure integer, frequency character varying, is_generatetoday boolean, mandate_id character varying, folio_no character varying, vendor_req character varying, client_name character varying, consent_expire_date timestamp without time zone, payment_initiated_date timestamp without time zone)
 LANGUAGE plpgsql
AS $function$

BEGIN

	
IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id AND COALESCE(A.trx_final_status_code, 0) <> 2
	AND A.trx_status_code = 7 AND A.payment_status <> v_payment_status AND COALESCE(A.payment_status_code, 0) <> 2)
THEN

	----------Updating Payment Data into Main transaction Table----------
	UPDATE transactions.mf_order_detail SET
	payment_trxid = v_payment_trxid
	, payment_status = v_payment_status
	, payment_status_code = (SELECT A.payment_status_code FROM master.dim_payment_status A 
	WHERE UPPER(A.payment_status) = UPPER(v_payment_status))
	, payment_remarks = v_remarks
	, modified_date = (NOW() at time zone 'Asia/Kolkata')
	WHERE trx_id = v_trx_id;
/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
	 WHEN C.is_generatetoday = FALSE THEN ''
	 WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
*/

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

update transactions.mf_order_summary a SET
final_status = B.final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
trx_type_code=b.trx_type_code
from transactions.mf_order_detail b
where a.trx_id = B.trx_id and b.trx_id=v_trx_id;

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail_history A
			  JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.is_active = true
			  WHERE A.trx_id = v_trx_id AND (A.trx_final_status_code <> B.trx_final_status_code OR A.payment_status_code <> B.payment_status_code))
	THEN

		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history 
		SET valid_to = (NOW() at time zone 'Asia/Kolkata'), is_active = false WHERE trx_id = v_trx_id AND is_active = true;

		INSERT INTO transactions.mf_order_detail_history
		(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
		 , vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
		,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
		 , A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, 
		(NOW() at time zone 'Asia/Kolkata'), true
		,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
		 FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id ;

		UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

/*
		UPDATE transactions.mf_order_summary_history SET valid_to = NOW(), is_active = false WHERE trx_id = v_trx_id AND is_active = true;

		INSERT INTO transactions.mf_order_summary_history(id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
		created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
		stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
		isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
		totalinstallmentamt_paid,switch_isin,trx_status_code,trx_final_status_code,	final_status,inv_plan_status_code,inv_plan_status,valid_from,is_active)
		SELECT distinct A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
		A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
		A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
		A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
		A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
		A.trx_status_code,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status,NOW(),true
		 FROM transactions.mf_order_summary A WHERE A.trx_id = v_trx_id;

		UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
*/

	END IF;
	
	RETURN QUERY
	SELECT DISTINCT 'SUCCESS'::character varying as status, ('Payment '|| v_payment_status ||' successful')::character varying as remarks
	, A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
	, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
	, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
	, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
	, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
	, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
	, (SELECT ucc.acname as client_name from master.dim_ucc ucc WHERE ucc.priority_ac_code = A.ac_code), D.consent_expire_date
	, COALESCE((SELECT DATE_TRUNC('second', H.inserted_dt) FROM transactions.mf_order_detail_history H WHERE H.trx_id = v_trx_id AND H.trx_final_status_code = 3 ORDER BY 1 DESC LIMIT 1)
				,DATE_TRUNC('second', A.created_date))
	FROM transactions.mf_order_detail A
	LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
	LEFT JOIN transactions.order_consent D ON A.trx_id = D.trx_id
	WHERE A.trx_id = v_trx_id;

ELSE

	RETURN QUERY
	SELECT DISTINCT 'FAILURE'::character varying as status, 'Payment cannot be updated with same status'::character varying as remarks
	, A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
	, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
	, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
	, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
	, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
	, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
	, (SELECT ucc.acname as client_name from master.dim_ucc ucc WHERE ucc.priority_ac_code = A.ac_code), D.consent_expire_date
	, COALESCE((SELECT DATE_TRUNC('second', H.inserted_dt) FROM transactions.mf_order_detail_history H WHERE H.trx_id = v_trx_id AND H.trx_final_status_code = 3 ORDER BY 1 DESC LIMIT 1)
				,DATE_TRUNC('second', A.created_date))
	FROM transactions.mf_order_detail A
	LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
	LEFT JOIN transactions.order_consent D ON A.trx_id = D.trx_id
	WHERE A.trx_id = v_trx_id;

END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_05sept2025(int8, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_05sept2025(int8, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_05sept2025(int8, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_05sept2025(int8, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_05sept2025(int8, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_09may2025(int8, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_09may2025(v_trx_id bigint, v_payment_trxid character varying DEFAULT NULL::character varying, v_payment_status character varying DEFAULT NULL::character varying, v_remarks character varying DEFAULT NULL::character varying)
 RETURNS TABLE(status character varying, remarks character varying, token bigint, isinino character varying, units numeric, amount numeric, reinvestmentflag character varying, requestedby character varying, ordertype character varying, txntype character varying, euinflag character varying, euinnumber character varying, clientcode character varying, dpc character varying, ordersource character varying, schemeplan character varying, display_trx_id character varying, physicalflag character varying, start_date date, end_date date, tenure integer, frequency character varying, is_generatetoday boolean, mandate_id character varying, folio_no character varying, vendor_req character varying, client_name character varying, consent_expire_date timestamp without time zone, payment_initiated_date timestamp without time zone)
 LANGUAGE plpgsql
AS $function$

BEGIN

	
IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id AND COALESCE(A.trx_final_status_code, 0) <> 2
	AND A.trx_status_code = 7 AND A.payment_status <> v_payment_status AND COALESCE(A.payment_status_code, 0) <> 2)
THEN

	----------Updating Payment Data into Main transaction Table----------
	UPDATE transactions.mf_order_detail SET
	payment_trxid = v_payment_trxid
	, payment_status = v_payment_status
	, payment_status_code = (SELECT A.payment_status_code FROM master.dim_payment_status A 
	WHERE UPPER(A.payment_status) = UPPER(v_payment_status))
	, payment_remarks = v_remarks
	, modified_date = NOW()
	WHERE trx_id = v_trx_id;
/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
	 WHEN C.is_generatetoday = FALSE THEN ''
	 WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
*/

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

update transactions.mf_order_summary a SET
final_status = B.final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
trx_type_code=b.trx_type_code
from transactions.mf_order_detail b
where a.trx_id = B.trx_id and b.trx_id=v_trx_id;

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail_history A
			  JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.is_active = true
			  WHERE A.trx_id = v_trx_id AND (A.trx_final_status_code <> B.trx_final_status_code OR A.payment_status_code <> B.payment_status_code))
	THEN

		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history SET valid_to = NOW(), is_active = false WHERE trx_id = v_trx_id AND is_active = true;

		INSERT INTO transactions.mf_order_detail_history
		(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
		 , vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
		,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
		 , A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
		,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
		 FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id ;

		UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
				
		UPDATE transactions.mf_order_summary_history SET valid_to = NOW(), is_active = false WHERE trx_id = v_trx_id AND is_active = true;

		INSERT INTO transactions.mf_order_summary_history(id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
		created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
		stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
		isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
		totalinstallmentamt_paid,switch_isin,trx_status_code,trx_final_status_code,	final_status,inv_plan_status_code,inv_plan_status,valid_from,is_active)
		SELECT distinct A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
		A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
		A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
		A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
		A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
		A.trx_status_code,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status,NOW(),true
		 FROM transactions.mf_order_summary A WHERE A.trx_id = v_trx_id;

		UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

	END IF;
	
	RETURN QUERY
	SELECT DISTINCT 'SUCCESS'::character varying as status, ('Payment '|| v_payment_status ||' successful')::character varying as remarks
	, A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
	, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
	, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
	, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
	, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
	, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
	, (SELECT ucc.acname as client_name from master.dim_ucc ucc WHERE ucc.priority_ac_code = A.ac_code), D.consent_expire_date
	, COALESCE((SELECT DATE_TRUNC('second', H.inserted_dt) FROM transactions.mf_order_detail_history H WHERE H.trx_id = v_trx_id AND H.trx_final_status_code = 3 ORDER BY 1 DESC LIMIT 1)
				,DATE_TRUNC('second', A.created_date))
	FROM transactions.mf_order_detail A
	LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
	LEFT JOIN transactions.order_consent D ON A.trx_id = D.trx_id
	WHERE A.trx_id = v_trx_id;

ELSE

	RETURN QUERY
	SELECT DISTINCT 'FAILURE'::character varying as status, 'Payment cannot be updated with same status'::character varying as remarks
	, A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
	, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
	, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
	, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
	, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
	, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
	, (SELECT ucc.acname as client_name from master.dim_ucc ucc WHERE ucc.priority_ac_code = A.ac_code), D.consent_expire_date
	, COALESCE((SELECT DATE_TRUNC('second', H.inserted_dt) FROM transactions.mf_order_detail_history H WHERE H.trx_id = v_trx_id AND H.trx_final_status_code = 3 ORDER BY 1 DESC LIMIT 1)
				,DATE_TRUNC('second', A.created_date))
	FROM transactions.mf_order_detail A
	LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
	LEFT JOIN transactions.order_consent D ON A.trx_id = D.trx_id
	WHERE A.trx_id = v_trx_id;

END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_09may2025(int8, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_09may2025(int8, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_09may2025(int8, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_09may2025(int8, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_09may2025(int8, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_10sept2025(int8, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_10sept2025(v_trx_id bigint, v_payment_trxid character varying DEFAULT NULL::character varying, v_payment_status character varying DEFAULT NULL::character varying, v_remarks character varying DEFAULT NULL::character varying)
 RETURNS TABLE(status character varying, remarks character varying, token bigint, isinino character varying, units numeric, amount numeric, reinvestmentflag character varying, requestedby character varying, ordertype character varying, txntype character varying, euinflag character varying, euinnumber character varying, clientcode character varying, dpc character varying, ordersource character varying, schemeplan character varying, display_trx_id character varying, physicalflag character varying, start_date date, end_date date, tenure integer, frequency character varying, is_generatetoday boolean, mandate_id character varying, folio_no character varying, vendor_req character varying, client_name character varying, consent_expire_date timestamp without time zone, payment_initiated_date timestamp without time zone)
 LANGUAGE plpgsql
AS $function$

BEGIN

	
IF EXISTS(SELECT 1 FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id AND COALESCE(A.trx_final_status_code, 0) <> 2
	AND A.trx_status_code = 7 AND A.payment_status <> v_payment_status AND COALESCE(A.payment_status_code, 0) <> 2)
THEN

	----------Updating Payment Data into Main transaction Table----------
	UPDATE transactions.mf_order_detail SET
	payment_trxid = v_payment_trxid
	, payment_status = v_payment_status
	, payment_status_code = (SELECT A.payment_status_code FROM master.dim_payment_status A 
	WHERE UPPER(A.payment_status) = UPPER(v_payment_status))
	, payment_remarks = v_remarks
	, modified_date = (NOW() at time zone 'Asia/Kolkata')
	WHERE trx_id = v_trx_id;
/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
	 WHEN C.is_generatetoday = FALSE THEN ''
	 WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
*/

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

update transactions.mf_order_summary a SET
final_status = B.final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
trx_type_code=b.trx_type_code
from transactions.mf_order_detail b
where a.trx_id = B.trx_id and b.trx_id=v_trx_id;

	IF EXISTS(SELECT 1 FROM transactions.mf_order_detail_history A
			  JOIN transactions.mf_order_detail B ON A.trx_id = B.trx_id AND A.is_active = true
			  WHERE A.trx_id = v_trx_id AND (A.trx_final_status_code <> B.trx_final_status_code OR A.payment_status_code <> B.payment_status_code))
	THEN

		----------Inserting Data into transaction History Table----------
		UPDATE transactions.mf_order_detail_history 
		SET valid_to = (NOW() at time zone 'Asia/Kolkata'), is_active = false WHERE trx_id = v_trx_id AND is_active = true;

		INSERT INTO transactions.mf_order_detail_history
		(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
		 , vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
		,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
		SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
		 , A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, 
		(NOW() at time zone 'Asia/Kolkata'), true
		,A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
		 FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id ;

		UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

/*
		UPDATE transactions.mf_order_summary_history SET valid_to = NOW(), is_active = false WHERE trx_id = v_trx_id AND is_active = true;

		INSERT INTO transactions.mf_order_summary_history(id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
		created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
		stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
		isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
		totalinstallmentamt_paid,switch_isin,trx_status_code,trx_final_status_code,	final_status,inv_plan_status_code,inv_plan_status,valid_from,is_active)
		SELECT distinct A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
		A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
		A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
		A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
		A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
		A.trx_status_code,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status,NOW(),true
		 FROM transactions.mf_order_summary A WHERE A.trx_id = v_trx_id;

		UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
*/

	END IF;
	
	RETURN QUERY
	SELECT DISTINCT 'SUCCESS'::character varying as status, ('Payment '|| v_payment_status ||' successful')::character varying as remarks
	, A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
	, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
	, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
	, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
	, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
	, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
	, (SELECT ucc.acname as client_name from master.dim_ucc ucc WHERE ucc.priority_ac_code = A.ac_code), D.consent_expire_date
	, COALESCE((SELECT DATE_TRUNC('second', H.inserted_dt) FROM transactions.mf_order_detail_history H WHERE H.trx_id = v_trx_id AND H.trx_final_status_code = 3 ORDER BY 1 DESC LIMIT 1)
				,DATE_TRUNC('second', A.created_date))
	FROM transactions.mf_order_detail A
	LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
	LEFT JOIN transactions.order_consent D ON A.trx_id = D.trx_id
	WHERE A.trx_id = v_trx_id;

ELSE

	RETURN QUERY
	SELECT DISTINCT 'FAILURE'::character varying as status, 'Payment cannot be updated with same status'::character varying as remarks
	, A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
	, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
	, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
	, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
	, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
	, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
	, (SELECT ucc.acname as client_name from master.dim_ucc ucc WHERE ucc.priority_ac_code = A.ac_code), D.consent_expire_date
	, COALESCE((SELECT DATE_TRUNC('second', H.inserted_dt) FROM transactions.mf_order_detail_history H WHERE H.trx_id = v_trx_id AND H.trx_final_status_code = 3 ORDER BY 1 DESC LIMIT 1)
				,DATE_TRUNC('second', A.created_date))
	FROM transactions.mf_order_detail A
	LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
	LEFT JOIN transactions.order_consent D ON A.trx_id = D.trx_id
	WHERE A.trx_id = v_trx_id;

END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_10sept2025(int8, varchar, varchar, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_10sept2025(int8, varchar, varchar, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_10sept2025(int8, varchar, varchar, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_10sept2025(int8, varchar, varchar, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_payment_status_bkp_10sept2025(int8, varchar, varchar, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_transactions_vendorid(int8, int8, varchar, bool, bool, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_transactions_vendorid(v_trx_id bigint, v_vendor_trx_id bigint DEFAULT NULL::bigint, v_remarks character varying DEFAULT NULL::character varying, v_is_resent boolean DEFAULT false, v_is_rejected boolean DEFAULT false, v_rej_remarks character varying DEFAULT NULL::character varying)
 RETURNS TABLE(token bigint, isinino character varying, units numeric, amount numeric, reinvestmentflag character varying, requestedby character varying, ordertype character varying, txntype character varying, euinflag character varying, euinnumber character varying, clientcode character varying, dpc character varying, ordersource character varying, schemeplan character varying, display_trx_id character varying, physicalflag character varying, start_date date, end_date date, tenure integer, frequency character varying, is_generatetoday boolean, mandate_id character varying, folio_no character varying, vendor_req character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

IF (v_vendor_trx_id IS NOT NULL)
THEN

----------Updating Vendor Trx ID into Main transaction Table----------
UPDATE transactions.mf_order_detail
SET vendor_trx_id = v_vendor_trx_id
, internal_flag = 1
, vendor_res = v_remarks
, trx_retry_count = CASE WHEN v_is_resent = FALSE THEN 0 ELSE trx_retry_count+1 END
, sent_to_vendor_datetime = NOW() at time zone 'Asia/Kolkata'
, modified_date = NOW() at time zone 'Asia/Kolkata'
WHERE trx_id = v_trx_id;

UPDATE transactions.mf_order_summary SET vendor_trx_id = v_vendor_trx_id, 
modified_date = NOW() at time zone 'Asia/Kolkata' WHERE trx_id = v_trx_id;

UPDATE transactions.mf_order_detail_history SET vendor_trx_id = v_vendor_trx_id WHERE trx_id = v_trx_id;

--UPDATE transactions.mf_order_summary_history SET vendor_trx_id = v_vendor_trx_id WHERE trx_id = v_trx_id;

RETURN QUERY
SELECT DISTINCT A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
FROM transactions.mf_order_detail A
LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
WHERE A.trx_id = v_trx_id;

ELSE

UPDATE transactions.mf_order_detail
SET vendor_res = v_remarks
, trx_retry_count = CASE WHEN v_is_resent = FALSE THEN 0 ELSE trx_retry_count+1 END
, sent_to_vendor_datetime = NOW() at time zone 'Asia/Kolkata'
, modified_date = NOW() at time zone 'Asia/Kolkata'
WHERE trx_id = v_trx_id;

IF (v_is_rejected = TRUE)
THEN

/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
		 WHEN C.is_generatetoday = FALSE THEN ''
		 WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
*/

-- UPDATE transactions.mf_order_detail A SET
-- final_status = B.trx_final_status,
-- trx_final_status_code = B.trx_final_status_code,
-- inv_plan_status_code = B.inv_plan_status_code,
-- inv_plan_status = B.inv_plan_status
-- FROM transactions.mf_order_detail D
-- LEFT JOIN master.mv_map_category_status B
-- ON UPPER(B.usertype) = UPPER(D.order_placed_by)
-- AND D.physicalflag = B.physicalflag
-- AND D.trx_type_code = B.trx_type_code
-- AND D.is_generatetoday = B.is_generatetoday
-- AND D.consent_status_code = B.consent_status_code
-- AND D.payment_status_code = B.payment_status_code
-- AND B.trx_status_code = D.trx_status_code
-- AND B.inv_action_code = D.inv_action_code
-- AND B.category_code = 261
-- WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

UPDATE transactions.mf_order_detail
SET order_remarks = v_rej_remarks
, trx_status = (SELECT trx_status FROM master.trx_status WHERE category_code = 261 AND isactive = true AND trx_status_code = 8)
, trx_status_code = 8
, vendor_trx_status = (SELECT vendor_status FROM master.map_vendor_internal_trx_status WHERE category_code = 261 AND isactive = true AND trx_status_code = 8 AND id = 11)
WHERE trx_id = v_trx_id;

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

-------------
--To Handle eCollect
update transactions.mf_order_detail a
set 
trx_final_status_code = 2,
final_status = 'Order Rejected',
inv_plan_status_code = case when a.trx_type_code=1 then 7 else null end,
inv_plan_status = case when a.trx_type_code=1 then 'REJECTED' else null end
where a.trx_type_code in (1,4)
and	a.payment_method='eCollect' 
and a.final_status is null
and a.vendor_trx_status ='REJECTED'
AND A.trx_id = v_trx_id;

----------Inserting Data into transaction History Table----------
UPDATE transactions.mf_order_detail_history SET valid_to = NOW() at time zone 'Asia/Kolkata', is_active = false
WHERE trx_id = v_trx_id AND is_active = true;

INSERT INTO transactions.mf_order_detail_history
(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source,
vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active,
final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks,
A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code
, NOW() at time zone 'Asia/Kolkata', true,
A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;
 
UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

UPDATE transactions.mf_order_summary
SET order_remarks = v_rej_remarks
, trx_status = (SELECT trx_status FROM master.trx_status WHERE category_code = 261 AND isactive = true AND trx_status_code = 8)
, trx_status_code = 8
, modified_date = NOW() at time zone 'Asia/Kolkata'
WHERE trx_id = v_trx_id;

update transactions.mf_order_summary a SET
final_status = B.final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
trx_type_code=b.trx_type_code
from transactions.mf_order_detail b
where a.trx_id = B.trx_id and b.trx_id=v_trx_id;

----------Inserting Data into transaction History Table----------
/*
UPDATE transactions.mf_order_summary_history SET valid_to = NOW(), is_active = false
WHERE trx_id = v_trx_id AND is_active = true;

INSERT INTO transactions.mf_order_summary_history(id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status,valid_from,is_active)
SELECT distinct A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status,NOW(),true
 FROM transactions.mf_order_summary A WHERE A.trx_id = v_trx_id;

UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

*/
END IF;

RETURN QUERY
SELECT DISTINCT A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
FROM transactions.mf_order_detail A
LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
WHERE A.trx_id = v_trx_id;		

END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_transactions_vendorid(int8, int8, varchar, bool, bool, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_vendorid(int8, int8, varchar, bool, bool, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_vendorid(int8, int8, varchar, bool, bool, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_vendorid(int8, int8, varchar, bool, bool, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_vendorid(int8, int8, varchar, bool, bool, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_mf_transactions_vendorid_bkp_09may2025(int8, int8, varchar, bool, bool, varchar);

CREATE OR REPLACE FUNCTION transactions.fn_update_mf_transactions_vendorid_bkp_09may2025(v_trx_id bigint, v_vendor_trx_id bigint DEFAULT NULL::bigint, v_remarks character varying DEFAULT NULL::character varying, v_is_resent boolean DEFAULT false, v_is_rejected boolean DEFAULT false, v_rej_remarks character varying DEFAULT NULL::character varying)
 RETURNS TABLE(token bigint, isinino character varying, units numeric, amount numeric, reinvestmentflag character varying, requestedby character varying, ordertype character varying, txntype character varying, euinflag character varying, euinnumber character varying, clientcode character varying, dpc character varying, ordersource character varying, schemeplan character varying, display_trx_id character varying, physicalflag character varying, start_date date, end_date date, tenure integer, frequency character varying, is_generatetoday boolean, mandate_id character varying, folio_no character varying, vendor_req character varying)
 LANGUAGE plpgsql
AS $function$

BEGIN

IF (v_vendor_trx_id IS NOT NULL)
THEN

----------Updating Vendor Trx ID into Main transaction Table----------
UPDATE transactions.mf_order_detail
SET vendor_trx_id = v_vendor_trx_id
, internal_flag = 1
, vendor_res = v_remarks
, trx_retry_count = CASE WHEN v_is_resent = FALSE THEN 0 ELSE trx_retry_count+1 END
, sent_to_vendor_datetime = NOW()
, modified_date = NOW()
WHERE trx_id = v_trx_id;

UPDATE transactions.mf_order_summary SET vendor_trx_id = v_vendor_trx_id, modified_date = NOW() WHERE trx_id = v_trx_id;

UPDATE transactions.mf_order_detail_history SET vendor_trx_id = v_vendor_trx_id WHERE trx_id = v_trx_id;

UPDATE transactions.mf_order_summary_history SET vendor_trx_id = v_vendor_trx_id WHERE trx_id = v_trx_id;

RETURN QUERY
SELECT DISTINCT A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
FROM transactions.mf_order_detail A
LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
WHERE A.trx_id = v_trx_id;

ELSE

UPDATE transactions.mf_order_detail
SET vendor_res = v_remarks
, trx_retry_count = CASE WHEN v_is_resent = FALSE THEN 0 ELSE trx_retry_count+1 END
, sent_to_vendor_datetime = NOW()
, modified_date = NOW()
WHERE trx_id = v_trx_id;

IF (v_is_rejected = TRUE)
THEN

/*
UPDATE transactions.mf_order_detail A SET
final_status = B.final_status,
final_status_id = B.final_status_id FROM transactions.mf_order_detail D
LEFT JOIN transactions.mf_order_summary C ON D.trx_id = C.trx_id
LEFT JOIN master.category_final_status B ON
UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag AND D.trx_type_code = B.trx_type
AND CASE WHEN C.is_generatetoday IS NULL THEN ''
		 WHEN C.is_generatetoday = FALSE THEN ''
		 WHEN C.is_generatetoday = TRUE THEN 'Y' END = COALESCE(B.generatetoday,'')
AND D.consent_status_code = B.consent_status_code
AND COALESCE(D.payment_status_code, 0) = COALESCE(B.payment_status_code, 0)
AND COALESCE(B.order_status_id,0) = COALESCE(D.trx_status_code,0) AND B.isactive = 1
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;
*/

-- UPDATE transactions.mf_order_detail A SET
-- final_status = B.trx_final_status,
-- trx_final_status_code = B.trx_final_status_code,
-- inv_plan_status_code = B.inv_plan_status_code,
-- inv_plan_status = B.inv_plan_status
-- FROM transactions.mf_order_detail D
-- LEFT JOIN master.mv_map_category_status B
-- ON UPPER(B.usertype) = UPPER(D.order_placed_by)
-- AND D.physicalflag = B.physicalflag
-- AND D.trx_type_code = B.trx_type_code
-- AND D.is_generatetoday = B.is_generatetoday
-- AND D.consent_status_code = B.consent_status_code
-- AND D.payment_status_code = B.payment_status_code
-- AND B.trx_status_code = D.trx_status_code
-- AND B.inv_action_code = D.inv_action_code
-- AND B.category_code = 261
-- WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

UPDATE transactions.mf_order_detail
SET order_remarks = v_rej_remarks
, trx_status = (SELECT trx_status FROM master.trx_status WHERE category_code = 261 AND isactive = true AND trx_status_code = 8)
, trx_status_code = 8
, vendor_trx_status = (SELECT vendor_status FROM master.map_vendor_internal_trx_status WHERE category_code = 261 AND isactive = true AND trx_status_code = 8 AND id = 11)
WHERE trx_id = v_trx_id;

UPDATE transactions.mf_order_detail A SET
final_status = B.trx_final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status
FROM transactions.mf_order_detail D
LEFT JOIN master.mv_map_category_status B
ON UPPER(B.usertype) = UPPER(D.order_placed_by)
AND D.physicalflag = B.physicalflag
AND D.trx_type_code = B.trx_type_code
AND D.is_generatetoday = B.is_generatetoday
AND D.consent_status_code = B.consent_status_code
AND D.payment_status_code = B.payment_status_code
AND B.trx_status_code = D.trx_status_code
AND B.inv_action_code = D.inv_action_code
AND B.category_code = 261
WHERE A.trx_id = D.trx_id AND A.trx_id = v_trx_id;

----------Inserting Data into transaction History Table----------
UPDATE transactions.mf_order_detail_history SET valid_to = NOW(), is_active = false
WHERE trx_id = v_trx_id AND is_active = true;

INSERT INTO transactions.mf_order_detail_history
(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source,
vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active,
final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks,
A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true,
A.final_status,A.trx_final_status_code,A.inv_plan_status_code,A.inv_plan_status
FROM transactions.mf_order_detail A WHERE A.trx_id = v_trx_id;
 
UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

UPDATE transactions.mf_order_summary
SET order_remarks = v_rej_remarks
, trx_status = (SELECT trx_status FROM master.trx_status WHERE category_code = 261 AND isactive = true AND trx_status_code = 8)
, trx_status_code = 8
, modified_date = NOW()
WHERE trx_id = v_trx_id;

update transactions.mf_order_summary a SET
final_status = B.final_status,
trx_final_status_code = B.trx_final_status_code,
inv_plan_status_code = B.inv_plan_status_code,
inv_plan_status = B.inv_plan_status,
trx_type_code=b.trx_type_code
from transactions.mf_order_detail b
where a.trx_id = B.trx_id and b.trx_id=v_trx_id;

----------Inserting Data into transaction History Table----------
UPDATE transactions.mf_order_summary_history SET valid_to = NOW(), is_active = false
WHERE trx_id = v_trx_id AND is_active = true;

INSERT INTO transactions.mf_order_summary_history(id,order_no,trx_id,reg_no,trx_type,trx_status,mandate_id,trx_source,ispaused,istopup,modifycount,
created_date,trx_datetime,start_day,trx_qty,installment_type,is_generatetoday,stepup_type,stepup_amount,
stepup_percent,stepup_start_date,vendor_trx_id,iscancel,no_of_installment_paused,paused_date,topupdate,
isskip, skip_date,trx_type_code,isresumed,resumed_date,upcoming_due_date,previous_paid_date,
totalinstallmentamt_paid,switch_isin,trx_status_code,trx_final_status_code,
final_status,inv_plan_status_code,inv_plan_status,valid_from,is_active)
SELECT distinct A.id,A.order_no,A.trx_id,A.reg_no,A.trx_type,A.trx_status,A.mandate_id,A.trx_source,A.ispaused,A.istopup,
A.modifycount,A.created_date,A.trx_datetime,A.start_day,A.trx_qty,A.installment_type,A.is_generatetoday,
A.stepup_type,A.stepup_amount,A.stepup_percent,A.stepup_start_date,A.vendor_trx_id,A.iscancel,
A.no_of_installment_paused,A.paused_date,A.topupdate,A.isskip,A.skip_date,A.trx_type_code,A.isresumed,
A.resumed_date,A.upcoming_due_date,A.previous_paid_date,A.totalinstallmentamt_paid,A.switch_isin,
A.trx_status_code,A.trx_final_status_code,A.final_status,A.inv_plan_status_code,A.inv_plan_status,NOW(),true
 FROM transactions.mf_order_summary A WHERE A.trx_id = v_trx_id;

UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

END IF;

RETURN QUERY
SELECT DISTINCT A.tokenno as "token", A.isincode AS isinino, A.trx_qty as units, A.trx_amt as amount
, B.reinvestmentflag, A.orderby as requestedby, A.order_type as ordertype, A.trx_type as txntype
, CASE WHEN A.euinnumber IS NOT NULL THEN 'Y' ELSE 'N' END::character varying euinflag
, A.euinnumber, A.ac_code as clientcode, COALESCE(B.dpc,'N') dpc, A.trx_source as ordersource
, A.return_type as schemeplan, A.display_trx_id, A.physicalflag
, B.start_date, B.end_date, B.no_of_installment as tenure, B.frequency, B.is_generatetoday, B.mandate_id, A.folio_no, A.vendor_req
FROM transactions.mf_order_detail A
LEFT JOIN transactions.mf_order_summary B ON A.trx_id = B.trx_id
WHERE A.trx_id = v_trx_id;		

END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_mf_transactions_vendorid_bkp_09may2025(int8, int8, varchar, bool, bool, varchar) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_vendorid_bkp_09may2025(int8, int8, varchar, bool, bool, varchar) TO public;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_vendorid_bkp_09may2025(int8, int8, varchar, bool, bool, varchar) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_vendorid_bkp_09may2025(int8, int8, varchar, bool, bool, varchar) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_update_mf_transactions_vendorid_bkp_09may2025(int8, int8, varchar, bool, bool, varchar) TO cmotsread;

-- DROP FUNCTION transactions.fn_update_status_mf_holding_external();

CREATE OR REPLACE FUNCTION transactions.fn_update_status_mf_holding_external()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
begin 

Update transactions.mf_client_holdings_external ext
	set isexternal = false ,
		arn_transfer_status = 'Completed',
		updated_date = current_timestamp at TIME ZONE'Asia/Kolkata'
	from transactions.mv_client_holding mf
	where ext.ucccode  = mf.ucccode 
	and ext.isin = mf.isincode 
	and ext.folio = mf.foliono  
	and coalesce (arn_transfer_status,'') = 'In Progress';

update transactions.mf_client_holdings_external mche 
set arn_transfer_status = 'Expired'
where arn_transfer_status = 'In Progress'
and cast (CURRENT_DATE as date )- cast (updated_date as date ) > 30;
	
end;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_update_status_mf_holding_external() OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_update_status_mf_holding_external() TO public;
GRANT ALL ON FUNCTION transactions.fn_update_status_mf_holding_external() TO cmotswrite;

-- DROP FUNCTION transactions.fn_verify_otp(_int8, varchar, varchar, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_verify_otp(v_trx_id bigint[], v_email_otp_code character varying, v_sms_otp_code character varying, v_whatsapp_otp_code character varying DEFAULT NULL::character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, client_code character varying, status character varying, remarks character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE result_row RECORD;
DECLARE v_order_placed_by character varying;

BEGIN

IF v_inv_action_code = 1 THEN
    SELECT DISTINCT
        CASE 
            WHEN a.order_placed_by IN ('PARTNER', 'RM') THEN 'RM'
            ELSE 'CLIENT'
        END::VARCHAR
    INTO v_order_placed_by
    FROM transactions.mf_order_detail a
    WHERE a.trx_id = ANY(v_trx_id);
ELSE
    SELECT DISTINCT
        CASE 
            WHEN a.order_placed_by IN ('PARTNER', 'RM') THEN 'RM'
            ELSE 'CLIENT'
        END::VARCHAR
    INTO v_order_placed_by
    FROM transactions.mf_order_detail_modification a
    WHERE a.trx_id = ANY(v_trx_id);
END IF;

--v_order_placed_by := (select distinct A.order_placed_by from transactions.mf_order_detail A where A.trx_id=ANY($1));

IF(v_order_placed_by<>'CLIENT')
THEN
	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.inv_action_code = v_inv_action_code AND A.trx_id = ANY($1) AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date
				AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE A.category_code = '261' AND consent_status_code = 1) AND A.otp_id IS NOT NULL
			 )
		THEN

		IF EXISTS(SELECT 1 FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
				  AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
				  WHERE B.trx_id = ANY($1) AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL)
				  AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code, '')
				  AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code, '')
				  AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code, '')
				 )
		THEN

			UPDATE transactions.otp A SET otp_verfied_flg = 1
			WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
			AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B WHERE B.trx_id = ANY($1)
			AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL)
			AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code, '')
			AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code, '')
			AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code, '');

			UPDATE transactions.order_consent A SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 2)
			, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata'
			WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date AND A.otp_id IS NOT NULL;

			IF(v_inv_action_code = 1)
			THEN
			
				UPDATE transactions.mf_order_detail A 
				SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_status_code = 2
				, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata'
				, modified_date = NOW() at time zone 'Asia/Kolkata'
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_detail A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status,
				payment_status_code = case when A.trx_type_code = 4 then 1
										   when A.trx_type_code = 1 and A.is_generatetoday = true then 1 else 0 end,
				payment_status = case when A.trx_type_code = 4 then 'Pending'
									  when A.trx_type_code = 1 and A.is_generatetoday = true then 'Pending' else null end
				FROM transactions.mf_order_detail D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				AND D.is_generatetoday = B.is_generatetoday
				AND D.consent_status_code = B.consent_status_code
				AND D.payment_status_code = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1)
				and A.consent_status_code=2 ;

				update transactions.mf_order_summary a set
				final_status = B.final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status,
				trx_type_code=b.trx_type_code,
				trx_status_Code=b.trx_status_Code
				from transactions.mf_order_detail b
				WHERE A.trx_id = b.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1)
				and b.consent_status_code=2 ;

				----------Inserting Data into transaction History Table----------

				UPDATE transactions.mf_order_detail_history A 
				SET valid_to = NOW() at time zone 'Asia/Kolkata', is_active = false
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1)
				AND A.is_active = true;

				INSERT INTO transactions.mf_order_detail_history
				(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
				, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
				,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
				SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
				, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code
				, NOW() at time zone 'Asia/Kolkata', true
				, A.final_status, A.trx_final_status_code, A.inv_plan_status_code, A.inv_plan_status
				FROM transactions.mf_order_detail A
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

				----------Inserting Data into Summary transaction History Table----------
/*
				UPDATE transactions.mf_order_summary_history A SET valid_to = NOW(), is_active = false
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.inv_action_code = 1) AND A.is_active = true;
				
				INSERT INTO transactions.mf_order_summary_history
				(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
				, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
				, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
				, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
				SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
				, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
				, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
				, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
				FROM transactions.mf_order_summary A
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = '261' AND C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;
*/
				RETURN QUERY
				SELECT A.trx_id, C.ac_code, 'SUCCESS'::character varying as status, 'OTP Verified successfully'::character varying as remarks
				FROM transactions.order_consent A JOIN transactions.otp B ON A.otp_id = B.otp_id
				JOIN transactions.mf_order_detail C ON A.trx_id = C.trx_id
				WHERE A.category_code = 261 AND A.trx_id = ANY($1) AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date AND B.otp_verfied_flg = 1
				and A.consent_type = 1 AND A.inv_action_code = v_inv_action_code;

			ELSE

				----------Updating Data in Modification Stage Table----------

				UPDATE transactions.mf_order_detail_modification A 
				SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_status_code = 2
				, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata'
				, modified_date = NOW() at time zone 'Asia/Kolkata'
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code <> 1);

				UPDATE transactions.mf_order_detail_modification A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status
				FROM transactions.mf_order_detail_modification D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				/* AND D.is_generatetoday = B.is_generatetoday */
				AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
				AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.inv_action_code <> 1);
				
					IF (v_inv_action_code = 0)
					THEN

						UPDATE transactions.mf_order_detail_modification A SET
						trx_final_status_code = 5,
						final_status = 'Order In Progress',
						inv_plan_status_code = 2,
						inv_plan_status = 'Pause'
						WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code;
					
					END IF;

				RETURN QUERY
				SELECT A.trx_id, C.ac_code, 'SUCCESS'::character varying as status, 'OTP Verified successfully'::character varying as remarks
				FROM transactions.order_consent A JOIN transactions.otp B ON A.otp_id = B.otp_id
				JOIN transactions.mf_order_detail_modification C ON A.trx_id = C.trx_id
				WHERE A.category_code = 261 AND A.trx_id = ANY($1) AND NOW() at time zone 'Asia/Kolkata' < A.consent_expire_date AND B.otp_verfied_flg = 1
				and A.consent_type = 1 AND A.inv_action_code = v_inv_action_code;

			END IF;
			
		ELSE

			RETURN QUERY
			SELECT DISTINCT A.trx_id, ''::character varying ac_code, 'FAILURE'::character varying as status
			, CASE WHEN (SELECT A.otp_verfied_flg FROM transactions.otp A WHERE NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
										 )
						) = 1 THEN ('OTP Verification already completed')::character varying
				   WHEN (SELECT A.otp_expire_datetime FROM transactions.otp A WHERE A.otp_verfied_flg = 0
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
										 )
						) < NOW() at time zone 'Asia/Kolkata' THEN ('OTP Expired, Please re-generate the OTP')::character varying
				   WHEN (SELECT COALESCE(A.email_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL and B.consent_type=1
										 )
						 AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'')
						 AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
						) <> COALESCE(v_email_otp_code,'') THEN ('OTP Verification Failed as Email code not matching')::character varying
				   WHEN (SELECT COALESCE(A.sms_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
										 )
						 AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
						 AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
						) <> COALESCE(v_sms_otp_code,'') THEN ('OTP Verification Failed as SMS code not matching')::character varying
				   WHEN (SELECT COALESCE(A.whatsapp_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL
										  and B.consent_type=1
										 )
						 AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
						 AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'')
						) <> COALESCE(v_whatsapp_otp_code,'') THEN ('OTP Verification Failed as WhatsApp code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') <> COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') <> COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL
												 and B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as WhatsApp and Email code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') <> COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') <> COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
												 AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as SMS and Email code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') <> COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') <> COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
												 AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as SMS and WhatsApp code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') <> COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') <> COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
												 AND NOW() at time zone 'Asia/Kolkata' < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as Email, SMS and WhatsApp codes are not matching')::character varying END
				    FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code;								

			END IF;

		ELSE

		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, ''::character varying, 'FAILURE'::character varying as status,'No Valid Consent for provided Transaction'::character varying as remarks;

	END IF;
END IF;

IF(v_order_placed_by='CLIENT')
THEN

IF EXISTS(SELECT 1 FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
				  AND A.trx_id = ANY($1) and A.inv_action_code=v_inv_action_code 
	and A.email_otp_code=v_email_otp_code
				 )
		THEN

	UPDATE transactions.otp A SET otp_verfied_flg = 1
	WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
	AND A.trx_id = ANY($1) and A.inv_action_code=v_inv_action_code
	and A.email_otp_code=v_email_otp_code;

	IF(v_inv_action_code = 1)
			THEN
				UPDATE transactions.mf_order_detail A 
				SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_status_code = 2
				, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata'
				, modified_date = NOW() at time zone 'Asia/Kolkata'
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_detail A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status,
				payment_status_code = case when A.trx_type_code = 4 then 1
										   when A.trx_type_code = 1 and A.is_generatetoday = true then 1 else 0 end,
				payment_status = case when A.trx_type_code = 4 then 'Pending'
									  when A.trx_type_code = 1 and A.is_generatetoday = true then 'Pending' else null end
				FROM transactions.mf_order_detail D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				AND D.is_generatetoday = B.is_generatetoday
				AND D.consent_status_code = B.consent_status_code
				AND D.payment_status_code = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.inv_action_code = 1)
				and A.consent_status_code=2 ;

				update transactions.mf_order_summary a set
				final_status = B.final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status,
				trx_type_code=b.trx_type_code,
				trx_status_Code=b.trx_status_Code
				from transactions.mf_order_detail b
				WHERE A.trx_id = b.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.inv_action_code = 1)
				and b.consent_status_code=2 ;

				----------Inserting Data into transaction History Table----------

				UPDATE transactions.mf_order_detail_history A 
				SET valid_to = NOW() at time zone 'Asia/Kolkata', is_active = false
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.inv_action_code = 1)
				AND A.is_active = true;

				INSERT INTO transactions.mf_order_detail_history
				(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
				, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
				,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
				SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
				, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code
				, NOW() at time zone 'Asia/Kolkata', true
				, A.final_status, A.trx_final_status_code, A.inv_plan_status_code, A.inv_plan_status
				FROM transactions.mf_order_detail A
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

				RETURN QUERY
				SELECT distinct A.trx_id, C.ac_code, 'SUCCESS'::character varying as status, 'OTP Verified successfully'::character varying as remarks
				FROM transactions.otp A
				JOIN transactions.mf_order_detail C ON A.trx_id = C.trx_id
				WHERE A.trx_id = ANY($1) AND A.otp_verfied_flg = 1
				and A.inv_action_code = v_inv_action_code;

			ELSE

				----------Updating Data in Modification Stage Table----------

				UPDATE transactions.mf_order_detail_modification A 
				SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_status_code = 2
				, consent_approval_reject_datetime = NOW() at time zone 'Asia/Kolkata'
				, modified_date = NOW() at time zone 'Asia/Kolkata'
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.otp C WHERE  C.trx_id = ANY($1) AND C.inv_action_code <> 1);

				UPDATE transactions.mf_order_detail_modification A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status
				FROM transactions.mf_order_detail_modification D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				/* AND D.is_generatetoday = B.is_generatetoday */
				AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
				AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.otp C WHERE C.trx_id = ANY($1) AND C.inv_action_code <> 1);
				
					IF (v_inv_action_code = 0)
					THEN

						UPDATE transactions.mf_order_detail_modification A SET
						trx_final_status_code = 5,
						final_status = 'Order In Progress',
						inv_plan_status_code = 2,
						inv_plan_status = 'Pause'
						WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code;
					
					END IF;

				RETURN QUERY
				SELECT C.trx_id, C.ac_code, 'SUCCESS'::character varying as status, 'OTP Verified successfully'::character varying as remarks
				FROM transactions.otp B 
				JOIN transactions.mf_order_detail_modification C ON B.trx_id = C.trx_id
				WHERE  b.trx_id = ANY($1) AND B.otp_verfied_flg = 1
				and b.inv_action_code = v_inv_action_code;

			END IF;
			
		ELSE

			RETURN QUERY
			SELECT DISTINCT A.trx_id, ''::character varying ac_code, 'FAILURE'::character varying as status
			, CASE WHEN (SELECT A.otp_verfied_flg FROM transactions.otp A WHERE NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
						 AND  A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code
						) = 1 THEN ('OTP Verification already completed')::character varying
				   WHEN (SELECT A.otp_expire_datetime FROM transactions.otp A WHERE A.otp_verfied_flg = 0
						 AND A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code
						) < NOW() at time zone 'Asia/Kolkata' THEN ('OTP Expired, Please re-generate the OTP')::character varying
				   WHEN (SELECT COALESCE(A.email_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() at time zone 'Asia/Kolkata' < A.otp_expire_datetime
						 AND A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code
						 AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'')
						 AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
						) <> COALESCE(v_email_otp_code,'') THEN ('OTP Verification Failed as Email code not matching')::character varying END
				   FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code;								
			END IF;

		ELSE

		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, ''::character varying, 'FAILURE'::character varying as status,'No Valid Consent for provided Transaction'::character varying as remarks;

END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_verify_otp(_int8, varchar, varchar, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_verify_otp(_int8, varchar, varchar, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_verify_otp(_int8, varchar, varchar, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_verify_otp(_int8, varchar, varchar, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_verify_otp(_int8, varchar, varchar, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_verify_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_verify_otp_bkp_09may2025(v_trx_id bigint[], v_email_otp_code character varying, v_sms_otp_code character varying, v_whatsapp_otp_code character varying DEFAULT NULL::character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, client_code character varying, status character varying, remarks character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE result_row RECORD;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.inv_action_code = v_inv_action_code AND A.trx_id = ANY($1) AND NOW() < A.consent_expire_date
				AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE A.category_code = '261' AND consent_status_code = 1) AND A.otp_id IS NOT NULL
			 )
		THEN

		IF EXISTS(SELECT 1 FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
				  AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
				  WHERE B.trx_id = ANY($1) AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL)
				  AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code, '')
				  AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code, '')
				  AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code, '')
				 )
		THEN

			UPDATE transactions.otp A SET otp_verfied_flg = 1
			WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
			AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B WHERE B.trx_id = ANY($1)
			AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL)
			AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code, '')
			AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code, '')
			AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code, '');

			UPDATE transactions.order_consent A SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 2)
			, consent_approval_reject_datetime = NOW()
			WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code AND NOW() < A.consent_expire_date AND A.otp_id IS NOT NULL;

			IF(v_inv_action_code = 1)
			THEN
			
				UPDATE transactions.mf_order_detail A 
				SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_status_code = 2
				, consent_approval_reject_datetime = NOW(), modified_date = NOW()
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_detail A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status,
				payment_status_code = case when A.trx_type_code = 4 then 1
										   when A.trx_type_code = 1 and A.is_generatetoday = true then 1 else 0 end,
				payment_status = case when A.trx_type_code = 4 then 'Pending'
									  when A.trx_type_code = 1 and A.is_generatetoday = true then 'Pending' else null end
				FROM transactions.mf_order_detail D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				AND D.is_generatetoday = B.is_generatetoday
				AND D.consent_status_code = B.consent_status_code
				AND D.payment_status_code = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1)
				and A.consent_status_code=2 ;

				update transactions.mf_order_summary a set
				final_status = B.final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status,
				trx_type_code=b.trx_type_code,
				trx_status_Code=b.trx_status_Code
				from transactions.mf_order_detail b
				WHERE A.trx_id = b.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1)
				and b.consent_status_code=2 ;

				----------Inserting Data into transaction History Table----------

				UPDATE transactions.mf_order_detail_history A SET valid_to = NOW(), is_active = false
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1)
				AND A.is_active = true;

				INSERT INTO transactions.mf_order_detail_history
				(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
				, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
				,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
				SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
				, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
				, A.final_status, A.trx_final_status_code, A.inv_plan_status_code, A.inv_plan_status
				FROM transactions.mf_order_detail A
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

				----------Inserting Data into Summary transaction History Table----------

				UPDATE transactions.mf_order_summary_history A SET valid_to = NOW(), is_active = false
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.inv_action_code = 1) AND A.is_active = true;
				
				INSERT INTO transactions.mf_order_summary_history
				(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
				, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
				, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
				, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
				SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
				, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
				, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
				, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
				FROM transactions.mf_order_summary A
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = '261' AND C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

				RETURN QUERY
				SELECT A.trx_id, C.ac_code, 'SUCCESS'::character varying as status, 'OTP Verified successfully'::character varying as remarks
				FROM transactions.order_consent A JOIN transactions.otp B ON A.otp_id = B.otp_id
				JOIN transactions.mf_order_detail C ON A.trx_id = C.trx_id
				WHERE A.category_code = 261 AND A.trx_id = ANY($1) AND NOW() < A.consent_expire_date AND B.otp_verfied_flg = 1
				and A.consent_type = 1 AND A.inv_action_code = v_inv_action_code;

			ELSE

				----------Updating Data in Modification Stage Table----------

				UPDATE transactions.mf_order_detail_modification A 
				SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_status_code = 2
				, consent_approval_reject_datetime = NOW(), modified_date = NOW()
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code <> 1);

				UPDATE transactions.mf_order_detail_modification A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status
				FROM transactions.mf_order_detail_modification D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				/* AND D.is_generatetoday = B.is_generatetoday */
				AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
				AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.inv_action_code <> 1);

					IF (v_inv_action_code = 0)
					THEN

						UPDATE transactions.mf_order_detail_modification A SET
						trx_final_status_code = 5,
						final_status = 'Order In Progress',
						inv_plan_status_code = 2,
						inv_plan_status = 'Pause'
						WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code;
					
					END IF;

				RETURN QUERY
				SELECT A.trx_id, C.ac_code, 'SUCCESS'::character varying as status, 'OTP Verified successfully'::character varying as remarks
				FROM transactions.order_consent A JOIN transactions.otp B ON A.otp_id = B.otp_id
				JOIN transactions.mf_order_detail_modification C ON A.trx_id = C.trx_id
				WHERE A.category_code = 261 AND A.trx_id = ANY($1) AND NOW() < A.consent_expire_date AND B.otp_verfied_flg = 1
				and A.consent_type = 1 AND A.inv_action_code = v_inv_action_code;

			END IF;
			
		ELSE

			RETURN QUERY
			SELECT DISTINCT A.trx_id, ''::character varying ac_code, 'FAILURE'::character varying as status
			, CASE WHEN (SELECT A.otp_verfied_flg FROM transactions.otp A WHERE NOW() < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
										 )
						) = 1 THEN ('OTP Verification already completed')::character varying
				   WHEN (SELECT A.otp_expire_datetime FROM transactions.otp A WHERE A.otp_verfied_flg = 0
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
										 )
						) < NOW() THEN ('OTP Expired, Please re-generate the OTP')::character varying
				   WHEN (SELECT COALESCE(A.email_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL and B.consent_type=1
										 )
						 AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'')
						 AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
						) <> COALESCE(v_email_otp_code,'') THEN ('OTP Verification Failed as Email code not matching')::character varying
				   WHEN (SELECT COALESCE(A.sms_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
										 )
						 AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
						 AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
						) <> COALESCE(v_sms_otp_code,'') THEN ('OTP Verification Failed as SMS code not matching')::character varying
				   WHEN (SELECT COALESCE(A.whatsapp_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL
										  and B.consent_type=1
										 )
						 AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
						 AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'')
						) <> COALESCE(v_whatsapp_otp_code,'') THEN ('OTP Verification Failed as WhatsApp code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') <> COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') <> COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL
												 and B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as WhatsApp and Email code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') <> COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') <> COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
												 AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as SMS and Email code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') <> COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') <> COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
												 AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as SMS and WhatsApp code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') <> COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') <> COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
												 AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as Email, SMS and WhatsApp codes are not matching')::character varying END
				    FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code;								

			END IF;

		ELSE

		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, ''::character varying, 'FAILURE'::character varying as status,'No Valid Consent for provided Transaction'::character varying as remarks;

	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_verify_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_verify_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_verify_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_verify_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_verify_otp_bkp_09may2025(_int8, varchar, varchar, varchar, int4) TO cmotsread;

-- DROP FUNCTION transactions.fn_verify_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4);

CREATE OR REPLACE FUNCTION transactions.fn_verify_otp_bkp_23jul2025(v_trx_id bigint[], v_email_otp_code character varying, v_sms_otp_code character varying, v_whatsapp_otp_code character varying DEFAULT NULL::character varying, v_inv_action_code integer DEFAULT 1)
 RETURNS TABLE(trx_id bigint, client_code character varying, status character varying, remarks character varying)
 LANGUAGE plpgsql
AS $function$

DECLARE result_row RECORD;

BEGIN

	IF EXISTS(SELECT 1 FROM transactions.order_consent A WHERE A.category_code = 261 AND A.inv_action_code = v_inv_action_code AND A.trx_id = ANY($1) AND NOW() < A.consent_expire_date
				AND A.consent_status = (SELECT consent_status FROM master.dim_consent_status WHERE A.category_code = '261' AND consent_status_code = 1) AND A.otp_id IS NOT NULL
			 )
		THEN

		IF EXISTS(SELECT 1 FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
				  AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
				  WHERE B.trx_id = ANY($1) AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL)
				  AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code, '')
				  AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code, '')
				  AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code, '')
				 )
		THEN

			UPDATE transactions.otp A SET otp_verfied_flg = 1
			WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
			AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B WHERE B.trx_id = ANY($1)
			AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL)
			AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code, '')
			AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code, '')
			AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code, '');

			UPDATE transactions.order_consent A SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.consent_status_code = 2)
			, consent_approval_reject_datetime = NOW()
			WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code AND NOW() < A.consent_expire_date AND A.otp_id IS NOT NULL;

			IF(v_inv_action_code = 1)
			THEN
			
				UPDATE transactions.mf_order_detail A 
				SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_status_code = 2
				, consent_approval_reject_datetime = NOW(), modified_date = NOW()
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_detail A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status,
				payment_status_code = case when A.trx_type_code = 4 then 1
										   when A.trx_type_code = 1 and A.is_generatetoday = true then 1 else 0 end,
				payment_status = case when A.trx_type_code = 4 then 'Pending'
									  when A.trx_type_code = 1 and A.is_generatetoday = true then 'Pending' else null end
				FROM transactions.mf_order_detail D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				AND D.is_generatetoday = B.is_generatetoday
				AND D.consent_status_code = B.consent_status_code
				AND D.payment_status_code = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1)
				and A.consent_status_code=2 ;

				update transactions.mf_order_summary a set
				final_status = B.final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status,
				trx_type_code=b.trx_type_code,
				trx_status_Code=b.trx_status_Code
				from transactions.mf_order_detail b
				WHERE A.trx_id = b.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1)
				and b.consent_status_code=2 ;

				----------Inserting Data into transaction History Table----------

				UPDATE transactions.mf_order_detail_history A SET valid_to = NOW(), is_active = false
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1)
				AND A.is_active = true;

				INSERT INTO transactions.mf_order_detail_history
				(trx_id, vendor_trx_id, ucccode, ac_code, trx_type, trx_datetime, mandate_id, trx_status, payment_status, order_remarks, trx_source
				, vendor_trx_status, trx_type_code, trx_status_code, consent_status, consent_status_code, payment_status_code, valid_from, is_active
				,final_status,trx_final_status_code,inv_plan_status_code,inv_plan_status)
				SELECT A.trx_id, A.vendor_trx_id, A.ucccode, A.ac_code, A.trx_type, A.trx_datetime, A.mandate_id, A.trx_status, A.payment_status, A.order_remarks
				, A.trx_source, A.vendor_trx_status, A.trx_type_code, A.trx_status_code, A.consent_status, A.consent_status_code, A.payment_status_code, NOW(), true
				, A.final_status, A.trx_final_status_code, A.inv_plan_status_code, A.inv_plan_status
				FROM transactions.mf_order_detail A
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_detail_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

				----------Inserting Data into Summary transaction History Table----------

				UPDATE transactions.mf_order_summary_history A SET valid_to = NOW(), is_active = false
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.inv_action_code = 1) AND A.is_active = true;
				
				INSERT INTO transactions.mf_order_summary_history
				(id, order_no, trx_id, reg_no, trx_type, trx_status, mandate_id, trx_source, ispaused, istopup, modifycount, created_date, trx_datetime, start_day
				, trx_qty, installment_type, is_generatetoday, stepup_type, stepup_amount, stepup_percent, stepup_start_date, vendor_trx_id, iscancel
				, no_of_installment_paused, paused_date, topupdate, isskip, skip_date, trx_type_code, isresumed, resumed_date, upcoming_due_date
				, previous_paid_date, totalinstallmentamt_paid, switch_isin, trx_status_code, valid_from, is_active)
				SELECT A.id, A.order_no, A.trx_id, A.reg_no, A.trx_type, A.trx_status, A.mandate_id, A.trx_source, A.ispaused, A.istopup, A.modifycount, A.created_date, A.trx_datetime
				, A.start_day, A.trx_qty, A.installment_type, A.is_generatetoday, A.stepup_type, A.stepup_amount, A.stepup_percent, A.stepup_start_date, A.vendor_trx_id, A.iscancel
				, A.no_of_installment_paused, A.paused_date, A.topupdate, A.isskip, A.skip_date, A.trx_type_code, A.isresumed, A.resumed_date, A.upcoming_due_date
				, A.previous_paid_date, A.totalinstallmentamt_paid, A.switch_isin, A.trx_status_code, NOW(), true
				FROM transactions.mf_order_summary A
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = '261' AND C.trx_id = ANY($1) AND C.inv_action_code = 1);

				UPDATE transactions.mf_order_summary_history SET valid_to = '9999-12-31'::timestamp without time zone WHERE is_active = true AND valid_to IS NULL;

				RETURN QUERY
				SELECT A.trx_id, C.ac_code, 'SUCCESS'::character varying as status, 'OTP Verified successfully'::character varying as remarks
				FROM transactions.order_consent A JOIN transactions.otp B ON A.otp_id = B.otp_id
				JOIN transactions.mf_order_detail C ON A.trx_id = C.trx_id
				WHERE A.category_code = 261 AND A.trx_id = ANY($1) AND NOW() < A.consent_expire_date AND B.otp_verfied_flg = 1
				and A.consent_type = 1 AND A.inv_action_code = v_inv_action_code;

			ELSE

				----------Updating Data in Modification Stage Table----------

				UPDATE transactions.mf_order_detail_modification A 
				SET consent_status = (SELECT DISTINCT A.consent_status FROM master.dim_consent_status A WHERE A.category_code = '261' AND A.consent_status_code = 2)
				, consent_status_code = 2
				, consent_approval_reject_datetime = NOW(), modified_date = NOW()
				WHERE A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.category_code = 261 AND C.trx_id = ANY($1) AND C.inv_action_code <> 1);

				UPDATE transactions.mf_order_detail_modification A SET
				final_status = B.trx_final_status,
				trx_final_status_code = B.trx_final_status_code,
				inv_plan_status_code = B.inv_plan_status_code,
				inv_plan_status = B.inv_plan_status
				FROM transactions.mf_order_detail_modification D
				LEFT JOIN master.mv_map_category_status B
				ON UPPER(B.usertype) = UPPER(D.order_placed_by)
				AND D.physicalflag = B.physicalflag
				AND D.trx_type_code = B.trx_type_code
				/* AND D.is_generatetoday = B.is_generatetoday */
				AND COALESCE(D.consent_status_code, 0) = B.consent_status_code
				AND COALESCE(D.payment_status_code, 0) = B.payment_status_code
				AND B.trx_status_code = D.trx_status_code
				AND B.inv_action_code = D.inv_action_code
				AND B.category_code = 261
				WHERE A.trx_id = D.trx_id
				AND A.trx_id IN (SELECT DISTINCT C.trx_id FROM transactions.order_consent C WHERE C.trx_id = ANY($1) AND C.inv_action_code <> 1);
				
					IF (v_inv_action_code = 0)
					THEN

						UPDATE transactions.mf_order_detail_modification A SET
						trx_final_status_code = 5,
						final_status = 'Order In Progress',
						inv_plan_status_code = 2,
						inv_plan_status = 'Pause'
						WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code;
					
					END IF;

				RETURN QUERY
				SELECT A.trx_id, C.ac_code, 'SUCCESS'::character varying as status, 'OTP Verified successfully'::character varying as remarks
				FROM transactions.order_consent A JOIN transactions.otp B ON A.otp_id = B.otp_id
				JOIN transactions.mf_order_detail_modification C ON A.trx_id = C.trx_id
				WHERE A.category_code = 261 AND A.trx_id = ANY($1) AND NOW() < A.consent_expire_date AND B.otp_verfied_flg = 1
				and A.consent_type = 1 AND A.inv_action_code = v_inv_action_code;

			END IF;
			
		ELSE

			RETURN QUERY
			SELECT DISTINCT A.trx_id, ''::character varying ac_code, 'FAILURE'::character varying as status
			, CASE WHEN (SELECT A.otp_verfied_flg FROM transactions.otp A WHERE NOW() < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
										 )
						) = 1 THEN ('OTP Verification already completed')::character varying
				   WHEN (SELECT A.otp_expire_datetime FROM transactions.otp A WHERE A.otp_verfied_flg = 0
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
										 )
						) < NOW() THEN ('OTP Expired, Please re-generate the OTP')::character varying
				   WHEN (SELECT COALESCE(A.email_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL and B.consent_type=1
										 )
						 AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'')
						 AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
						) <> COALESCE(v_email_otp_code,'') THEN ('OTP Verification Failed as Email code not matching')::character varying
				   WHEN (SELECT COALESCE(A.sms_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
										  AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
										 )
						 AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
						 AND COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
						) <> COALESCE(v_sms_otp_code,'') THEN ('OTP Verification Failed as SMS code not matching')::character varying
				   WHEN (SELECT COALESCE(A.whatsapp_otp_code, '') FROM transactions.otp A WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
						 AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
										  WHERE B.trx_id = ANY($1) AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL
										  and B.consent_type=1
										 )
						 AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
						 AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'')
						) <> COALESCE(v_whatsapp_otp_code,'') THEN ('OTP Verification Failed as WhatsApp code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') <> COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') <> COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') = COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL
												 and B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as WhatsApp and Email code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') = COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') <> COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') <> COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
												 AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as SMS and Email code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') <> COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') <> COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
												 AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as SMS and WhatsApp code not matching')::character varying
				   WHEN EXISTS (SELECT COALESCE(A.whatsapp_otp_code, '') <> COALESCE(v_whatsapp_otp_code,'')
								AND COALESCE(A.email_otp_code, '') = COALESCE(v_email_otp_code,'')
								AND COALESCE(A.sms_otp_code, '') <> COALESCE(v_sms_otp_code,'') FROM transactions.otp A
								WHERE A.otp_verfied_flg = 0 AND NOW() < A.otp_expire_datetime
								AND A.otp_id IN (SELECT B.otp_id FROM transactions.order_consent B
												 WHERE B.trx_id = ANY($1) AND B.inv_action_code = v_inv_action_code
												 AND NOW() < B.consent_expire_date AND B.otp_id IS NOT NULL AND B.consent_type=1
												)
							   ) THEN ('OTP Verification Failed as Email, SMS and WhatsApp codes are not matching')::character varying END
				    FROM transactions.order_consent A WHERE A.trx_id = ANY($1) AND A.inv_action_code = v_inv_action_code;								

			END IF;

		ELSE

		RETURN QUERY
		SELECT UNNEST(v_trx_id) trx_id, ''::character varying, 'FAILURE'::character varying as status,'No Valid Consent for provided Transaction'::character varying as remarks;

	END IF;

END;
$function$
;

-- Permissions

ALTER FUNCTION transactions.fn_verify_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) OWNER TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_verify_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) TO public;
GRANT ALL ON FUNCTION transactions.fn_verify_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) TO cmotswrite;
GRANT ALL ON FUNCTION transactions.fn_verify_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) TO appadmin;
GRANT ALL ON FUNCTION transactions.fn_verify_otp_bkp_23jul2025(_int8, varchar, varchar, varchar, int4) TO cmotsread;


-- Permissions

GRANT ALL ON SCHEMA transactions TO cmotswrite;
GRANT USAGE ON SCHEMA transactions TO appadmin;
GRANT USAGE ON SCHEMA transactions TO cmotsread;
